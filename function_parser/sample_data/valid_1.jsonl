{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bench\/Main.hs","language":"haskell","identifier":"fib","parameters":"1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fib 1 = 1","function_tokens":["fib","1","=","1"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bench\/Main.hs#L9-L9","hash_key":"knupfer\/chronos:bench\/Main.hs","hash_val":48994,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"insert","parameters":"tree node","argument_list":"","return_statement":"","docstring":"Insert a node into a NodeTree","docstring_summary":"Insert a node into a NodeTree","docstring_tokens":["Insert","a","node","into","a","NodeTree"],"function":"insert tree node = if applyAt tree (nodeId node) needsSplit\n                   -- Split the tree before inserting, when it makes sense\n                   then let splitTree = split tree . nodeId $ node\n                        in insert splitTree node\n                   -- Insert the node\n                   else modifyAt tree (nodeId node) doInsert\n\n    where needsSplit depth valid (nodes, _) =\n            let maxDepth = (length . toByteStruct . nodeId $ node) - 1\n            in  -- A new node will be inserted\n                node `notElem` map fst nodes &&\n                -- The bucket is full\n                length nodes >= 7 &&\n                -- The bucket may be split\n                (depth < 5 || valid) && depth <= maxDepth\n\n          doInsert _ _ b@(nodes, cache)\n            -- Refresh an already existing node\n            | node `elem` map fst nodes = refresh node b\n            -- Simply insert the node, if the bucket isn't full\n            | length nodes < 7 = Bucket ((node, 0):nodes, cache)\n            -- Move the node to the first spot, if it's already cached\n            | node `elem` cache = Bucket (nodes, node : L.delete node cache)\n            -- Cache the node and drop older ones, if necessary\n            | otherwise = Bucket (nodes, node : take 4 cache)\n\n-- | Split the KBucket the specified id would reside in into two and return a\n--   Split NodeTreeElem","function_tokens":["insert","tree","node","=","if","applyAt","tree","(","nodeId","node",")","needsSplit","-- Split the tree before inserting, when it makes sense","then","let","splitTree","=","split","tree",".","nodeId","$","node","in","insert","splitTree","node","-- Insert the node","else","modifyAt","tree","(","nodeId","node",")","doInsert","where","needsSplit","depth","valid","(","nodes",",","_",")","=","let","maxDepth","=","(","length",".","toByteStruct",".","nodeId","$","node",")","-","1","in","-- A new node will be inserted","node","`","notElem","`","map","fst","nodes","&&","-- The bucket is full","length","nodes",">=","7","&&","-- The bucket may be split","(","depth","<","5","||","valid",")","&&","depth","<=","maxDepth","doInsert","_","_","b","@","(","nodes",",","cache",")","-- Refresh an already existing node","|","node","`","elem","`","map","fst","nodes","=","refresh","node","b","-- Simply insert the node, if the bucket isn't full","|","length","nodes","<","7","=","Bucket","(","(","node",",","0",")",":","nodes",",","cache",")","-- Move the node to the first spot, if it's already cached","|","node","`","elem","`","cache","=","Bucket","(","nodes",",","node",":","L","delete","node","cache",")","-- Cache the node and drop older ones, if necessary","|","otherwise","=","Bucket","(","nodes",",","node",":","take","4","cache",")","-- | Split the KBucket the specified id would reside in into two and return a","--   Split NodeTreeElem"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L141-L169","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"library","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"library = maybeToList $ fst . Cabal.ignoreConditions <$>\n        Cabal.condLibrary packageDescription","function_tokens":["library","=","maybeToList","$","fst",".","Cabal","ignoreConditions","<$>","Cabal","condLibrary","packageDescription"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L54-L55","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = ReaderC (\\ r -> mfix (runReader r . f))","function_tokens":["mfix","f","=","ReaderC","(","\\","r","->","mfix","(","runReader","r",".","f",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L83-L83","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"fromRows","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from rows","docstring_summary":"O(m*n) Create matrix from rows","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","rows"],"function":"fromRows = MG.fromRows","function_tokens":["fromRows","=","MG","fromRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L160-L160","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L424-L424","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"step","parameters":"i u","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"step i u = do\n                        GM.unsafeWrite v ((cr + i `div` c) * n' + i `mod` c + cc) u\n                        return (i+1)","function_tokens":["step","i","u","=","do","GM","unsafeWrite","v","(","(","cr","+","i","`","div","`","c",")","*","n'","+","i","`","mod","`","c","+","cc",")","u","return","(","i","+","1",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L256-L259","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val n           = maybe (Int64 $ fromIntegral n) Int32 (fitInt n)","function_tokens":["val","n","=","maybe","(","Int64","$","fromIntegral","n",")","Int32","(","fitInt","n",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L368-L368","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ReaderC u *> ReaderC v = ReaderC $ \\ r -> u r *> v r","function_tokens":["ReaderC","u","*>","ReaderC","v","=","ReaderC","$","\\","r","->","u","r","*>","v","r"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L61-L61","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/State\/Labelled.hs","language":"haskell","identifier":"modify","parameters":"f","argument_list":"","return_statement":"","docstring":"Replace the state value with the result of applying a function to the current state value. This is strict in the new state.  @ 'modify' f = 'get' '>>=' ('put' . f '$!') @  @since 1.0.2.0","docstring_summary":"Replace the state value with the result of applying a function to the current state value. This is strict in the new state.","docstring_tokens":["Replace","the","state","value","with","the","result","of","applying","a","function","to","the","current","state","value",".","This","is","strict","in","the","new","state","."],"function":"modify f = runUnderLabel @label (S.modify f)","function_tokens":["modify","f","=","runUnderLabel","@","label","(","S","modify","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/State\/Labelled.hs#L71-L71","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/State\/Labelled.hs","hash_val":51637,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"n'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n' = j' - j + 1","function_tokens":["n'","=","j'","-","j","+","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L204-L204","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L316-L316","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"f","parameters":"va vb a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f va vb a = runSplineT va a >>= \\case\n          Left c -> fr c vb a\n          Right (b1, va1) -> runSplineT vb a >>= \\case\n            Left d -> return $ Right (b1, SplineT $ fl d va1)\n            Right (b2, vb1) -> return $ Right (apnd b1 b2, SplineT $ f va1 vb1)\n\n-- | Capture the spline's last output value and tuple it with the\n-- spline's result. This is helpful when you want to sample the last\n-- output value in order to determine the next spline to sequence.\n--\n-- The tupled value is returned in as a 'Maybe b' since it is not\n-- guaranteed that an output value is produced before a Spline concludes.\n--\n-- >>> :{\n-- let\n--   s :: MonadIO m => SplineT () Int m String\n--   s = do\n--     (mayX, boomStr) <-\n--       capture\n--         $ do\n--           step 0\n--           step 1\n--           step 2\n--           return \"boom\"\n--     -- x is 2, but 'capture' can't be sure of that\n--     maybe\n--       (return \"Failure\")\n--       ( (>> return boomStr)\n--         . step\n--         . (+1)\n--       )\n--       mayX\n-- in\n--   testVarOver (outputStream s 666) [(),(),(),()]\n-- >>> :}\n-- 0\n-- 1\n-- 2\n-- 3","function_tokens":["f","va","vb","a","=","runSplineT","va","a",">>=","\\","case","Left","c","->","fr","c","vb","a","Right","(","b1",",","va1",")","->","runSplineT","vb","a",">>=","\\","case","Left","d","->","return","$","Right","(","b1",",","SplineT","$","fl","d","va1",")","Right","(","b2",",","vb1",")","->","return","$","Right","(","apnd","b1","b2",",","SplineT","$","f","va1","vb1",")","-- | Capture the spline's last output value and tuple it with the","-- spline's result. This is helpful when you want to sample the last","-- output value in order to determine the next spline to sequence.","--","-- The tupled value is returned in as a 'Maybe b' since it is not","-- guaranteed that an output value is produced before a Spline concludes.","--","-- >>> :{","-- let","--   s :: MonadIO m => SplineT () Int m String","--   s = do","--     (mayX, boomStr) <-","--       capture","--         $ do","--           step 0","--           step 1","--           step 2","--           return \"boom\"","--     -- x is 2, but 'capture' can't be sure of that","--     maybe","--       (return \"Failure\")","--       ( (>> return boomStr)","--         . step","--         . (+1)","--       )","--       mayX","-- in","--   testVarOver (outputStream s 666) [(),(),(),()]","-- >>> :}","-- 0","-- 1","-- 2","-- 3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L305-L344","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _           = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L311-L311","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith = MG.zipWith","function_tokens":["zipWith","=","MG","zipWith"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L261-L261","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(UTC x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (UTC x) = Just x","function_tokens":["cast'","(","UTC","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L325-L325","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"toRegistration","parameters":"(Answer sig)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toRegistration (Answer sig)  = case rType . command $ sig of\n            Nothing -> Nothing\n            Just rt -> Just (RR [rt] (origin sig))\n    where origin sig = nodeId . source $ sig\n\n          rType :: Command i a -> Maybe (ReplyType i)\n          rType  PONG               = Just  R_PONG\n          rType (RETURN_VALUE id _) = Just (R_RETURN_VALUE id)\n          rType (RETURN_NODES id _) = Just (R_RETURN_NODES id)\n          rType _ = Nothing\n\n-- | Compare wether two ReplyRegistrations match","function_tokens":["toRegistration","(","Answer","sig",")","=","case","rType",".","command","$","sig","of","Nothing","->","Nothing","Just","rt","->","Just","(","RR","[","rt","]","(","origin","sig",")",")","where","origin","sig","=","nodeId",".","source","$","sig","rType","::","Command","i","a","->","Maybe","(","ReplyType","i",")","rType","PONG","=","Just","R_PONG","rType","(","RETURN_VALUE","id","_",")","=","Just","(","R_RETURN_VALUE","id",")","rType","(","RETURN_NODES","id","_",")","=","Just","(","R_RETURN_NODES","id",")","rType","_","=","Nothing","-- | Compare wether two ReplyRegistrations match"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L51-L63","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"create","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"create = MG.create","function_tokens":["create","=","MG","create"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L394-L394","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"izipWith3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith3 = MG.izipWith3","function_tokens":["izipWith3","=","MG","izipWith3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L291-L291","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Except.hs","language":"haskell","identifier":"show","parameters":"NoCabalFiles","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show NoCabalFiles = \"no cabal files were found in .  We tried to run `hpack` and\/or `stack query` and still don't see a cabal file. Is this directory really a Haskell project?\"","function_tokens":["show","NoCabalFiles","=","\"no cabal files were found in .  We tried to run `hpack` and\/or `stack query` and still don't see a cabal file. Is this directory really a Haskell project?\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Except.hs#L26-L26","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Except.hs","hash_val":50331,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"unMaybe","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unMaybe = undefined","function_tokens":["unMaybe","=","undefined"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L237-L237","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fresh\/Strict.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx","function_tokens":["alg","hdl","sig","ctx","=","FreshC","$","case","sig","of","L","Fresh","->","state","$","\\","i","->","(","i","+","1",",","i","<$","ctx",")","R","other","->","alg","(","runFreshC",".","hdl",")","(","R","other",")","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fresh\/Strict.hs#L63-L66","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fresh\/Strict.hs","hash_val":46850,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"izipWith","parameters":"f m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith f m1 m2\n    | MG.dim m1 \/= MG.dim m2 = error \"izipWith: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.izipWith f' (MG.flatten m1) $ MG.flatten m2\n  where\n    c = MG.cols m1\n    f' i = f (i `divMod` c)","function_tokens":["izipWith","f","m1","m2","|","MG","dim","m1","\/=","MG","dim","m2","=","error","\"izipWith: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","izipWith","f'","(","MG","flatten","m1",")","$","MG","flatten","m2","where","c","=","MG","cols","m1","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L390-L397","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L253-L253","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"ssortToSort","parameters":"(SArraySort i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ssortToSort (SArraySort i e) = ArraySort (ssortToSort i) (ssortToSort e)","function_tokens":["ssortToSort","(","SArraySort","i","e",")","=","ArraySort","(","ssortToSort","i",")","(","ssortToSort","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L75-L75","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"mapM","parameters":"f m@(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM f m@(Matrix r c _ _ _) = liftM (MG.fromVector (r,c)) $ G.mapM f $ MG.flatten m","function_tokens":["mapM","f","m","@","(","Matrix","r","c","_","_","_",")","=","liftM","(","MG","fromVector","(","r",",","c",")",")","$","G","mapM","f","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L294-L294","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int32 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int32 x) = Just x","function_tokens":["cast'","(","Int32","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L355-L355","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"convert","parameters":"(Matrix r c tda offset vec)","argument_list":"","return_statement":"","docstring":"-- | construct upper triangular matrix from vector upperTriangular :: (Num a, G.Vector v a) => Int -> v a -> Matrix v a upperTriangular n vec = O(m*n) Convert different matrix type","docstring_summary":"-- | construct upper triangular matrix from vector upperTriangular :: (Num a, G.Vector v a) => Int -> v a -> Matrix v a upperTriangular n vec = O(m*n) Convert different matrix type","docstring_tokens":["--","|","construct","upper","triangular","matrix","from","vector","upperTriangular","::","(","Num","a","G",".","Vector","v","a",")","=",">","Int","-",">","v","a","-",">","Matrix","v","a","upperTriangular","n","vec","=","O","(","m","*","n",")","Convert","different","matrix","type"],"function":"convert (Matrix r c tda offset vec) = Matrix r c tda offset . G.convert $ vec","function_tokens":["convert","(","Matrix","r","c","tda","offset","vec",")","=","Matrix","r","c","tda","offset",".","G","convert","$","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L191-L191","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"doInsert","parameters":"_ _ b@(nodes, cache)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doInsert _ _ b@(nodes, cache)\n            -- Refresh an already existing node\n            | node `elem` map fst nodes = refresh node b\n            -- Simply insert the node, if the bucket isn't full\n            | length nodes < 7 = Bucket ((node, 0):nodes, cache)\n            -- Move the node to the first spot, if it's already cached\n            | node `elem` cache = Bucket (nodes, node : L.delete node cache)\n            -- Cache the node and drop older ones, if necessary\n            | otherwise = Bucket (nodes, node : take 4 cache)","function_tokens":["doInsert","_","_","b","@","(","nodes",",","cache",")","-- Refresh an already existing node","|","node","`","elem","`","map","fst","nodes","=","refresh","node","b","-- Simply insert the node, if the bucket isn't full","|","length","nodes","<","7","=","Bucket","(","(","node",",","0",")",":","nodes",",","cache",")","-- Move the node to the first spot, if it's already cached","|","node","`","elem","`","cache","=","Bucket","(","nodes",",","node",":","L","delete","node","cache",")","-- Cache the node and drop older ones, if necessary","|","otherwise","=","Bucket","(","nodes",",","node",":","take","4","cache",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L157-L165","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unsafeTakeRow","parameters":"(Matrix _ c tda offset vec) i","argument_list":"","return_statement":"","docstring":"O(1) Extract a row.","docstring_summary":"O(1) Extract a row.","docstring_tokens":["O","(","1",")","Extract","a","row","."],"function":"unsafeTakeRow (Matrix _ c tda offset vec) i = G.slice i' c vec\n      where\n        i' = offset + i * tda","function_tokens":["unsafeTakeRow","(","Matrix","_","c","tda","offset","vec",")","i","=","G","slice","i'","c","vec","where","i'","=","offset","+","i","*","tda"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L154-L157","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"newElems","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newElems     = go idStruct targetStruct 0 True elem","function_tokens":["newElems","=","go","idStruct","targetStruct","0","True","elem"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L41-L41","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWith6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith6 = MG.zipWith6","function_tokens":["zipWith6","=","MG","zipWith6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L282-L282","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"izipWith5","parameters":"f m1 m2 m3 m4 m5","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith5 f m1 m2 m3 m4 m5\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 ||\n      MG.dim m4 \/= MG.dim m5 = error \"izipWith5: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.izipWith5 f' (MG.flatten m1) (MG.flatten m2)\n                  (MG.flatten m3) (MG.flatten m4) $ MG.flatten m5\n  where\n    c = MG.cols m1\n    f' i = f (i `divMod` c)","function_tokens":["izipWith5","f","m1","m2","m3","m4","m5","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","||","MG","dim","m4","\/=","MG","dim","m5","=","error","\"izipWith5: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","izipWith5","f'","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","(","MG","flatten","m4",")","$","MG","flatten","m5","where","c","=","MG","cols","m1","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L431-L442","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"gatherBuildInfos","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"gatherBuildInfos = map Cabal.libBuildInfo library <>\n                         map Cabal.libBuildInfo subLibraries <>\n                         map Cabal.buildInfo executables <>\n                         map Cabal.testBuildInfo testSuites <>\n                         map Cabal.benchmarkBuildInfo benchmarks","function_tokens":["gatherBuildInfos","=","map","Cabal","libBuildInfo","library","<>","map","Cabal","libBuildInfo","subLibraries","<>","map","Cabal","buildInfo","executables","<>","map","Cabal","testBuildInfo","testSuites","<>","map","Cabal","benchmarkBuildInfo","benchmarks"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L74-L78","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(left, right) = splitBucket i f ns","function_tokens":["(","left",",","right",")","=","splitBucket","i","f","ns"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L182-L182","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"dim","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim = MG.dim","function_tokens":["dim","=","MG","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L117-L117","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(UTC x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (UTC x) = Just (utcTimeToPOSIXSeconds x)","function_tokens":["cast'","(","UTC","x",")","=","Just","(","utcTimeToPOSIXSeconds","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L330-L330","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"race","parameters":"f sa0 sb0","argument_list":"","return_statement":"","docstring":"Run two splines in parallel, combining their output. Return the result of the spline that concludes first. If they conclude at the same time the result is taken from the left spline.  >>> :{ let s1 = pure \"route \"   `_untilEvent` (1 >>> after 2) s2 = pure 666     `_untilEvent` (1 >>> after 3) s = do winner <- race (\\l r -> l ++ show r) s1 s2 step $ show winner v = outputStream s \"\" in testVarOver v [(),(),()] >>> :} \"route 666\" \"Left 2\" \"Left 2\"","docstring_summary":"Run two splines in parallel, combining their output. Return the result of the spline that concludes first. If they conclude at the same time the result is taken from the left spline.  >>> :{ let s1 = pure \"route \"   `_untilEvent` (1 >>> after 2) s2 = pure 666     `_untilEvent` (1 >>> after 3) s = do winner <- race (\\l r -> l ++ show r) s1 s2 step $ show winner v = outputStream s \"\" in testVarOver v [(),(),()] >>> :} \"route 666\" \"Left 2\" \"Left 2\"","docstring_tokens":["Run","two","splines","in","parallel","combining","their","output",".","Return","the","result","of","the","spline","that","concludes","first",".","If","they","conclude","at","the","same","time","the","result","is","taken","from","the","left","spline",".",">>>",":","{","let","s1","=","pure","route","_untilEvent","(","1",">>>","after","2",")","s2","=","pure","666","_untilEvent","(","1",">>>","after","3",")","s","=","do","winner","<","-","race","(","\\","l","r","-",">","l","++","show","r",")","s1","s2","step","$","show","winner","v","=","outputStream","s","in","testVarOver","v","[","()","()","()","]",">>>",":","}","route","666","Left","2","Left","2"],"function":"race f sa0 sb0 = SplineT (g sa0 sb0)\n  where g sa sb i = runSplineT sa i >>= \\case\n          Left d -> return $ Left $ Left d\n          Right (a, sa1) -> runSplineT sb i >>= \\case\n            Left e -> return $ Left $ Right e\n            Right (b, sb1) -> return $ Right (f a b, SplineT $ g sa1 sb1)\n\n-- | Run many splines in parallel, combining their output with 'mappend'.\n-- Returns the result of the spline that concludes first. If any conclude at the\n-- same time the leftmost result will be returned.\n--\n-- >>> :{\n-- let ss = [ pure \"hey \"   `_untilEvent` (1 >>> after 5)\n--          , pure \"there\"  `_untilEvent` (1 >>> after 3)\n--          , pure \"!\"      `_untilEvent` (1 >>> after 2)\n--          ]\n--     s = do winner <- raceAny ss\n--            step $ show winner\n--     v = outputStream s \"\"\n-- in testVarOver v [(),()]\n-- >>> :}\n-- \"hey there!\"\n-- \"2\"","function_tokens":["race","f","sa0","sb0","=","SplineT","(","g","sa0","sb0",")","where","g","sa","sb","i","=","runSplineT","sa","i",">>=","\\","case","Left","d","->","return","$","Left","$","Left","d","Right","(","a",",","sa1",")","->","runSplineT","sb","i",">>=","\\","case","Left","e","->","return","$","Left","$","Right","e","Right","(","b",",","sb1",")","->","return","$","Right","(","f","a","b",",","SplineT","$","g","sa1","sb1",")","-- | Run many splines in parallel, combining their output with 'mappend'.","-- Returns the result of the spline that concludes first. If any conclude at the","-- same time the leftmost result will be returned.","--","-- >>> :{","-- let ss = [ pure \"hey \"   `_untilEvent` (1 >>> after 5)","--          , pure \"there\"  `_untilEvent` (1 >>> after 3)","--          , pure \"!\"      `_untilEvent` (1 >>> after 2)","--          ]","--     s = do winner <- raceAny ss","--            step $ show winner","--     v = outputStream s \"\"","-- in testVarOver v [(),()]","-- >>> :}","-- \"hey there!\"","-- \"2\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L244-L267","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"prettyChange","parameters":"l (CBlock n _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyChange l (CBlock n _) = show l ++ \"-\" ++ show (l + n) ++ \" replace lines\"","function_tokens":["prettyChange","l","(","CBlock","n","_",")","=","show","l","++","\"-\"","++","show","(","l","+","n",")","++","\" replace lines\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L60-L60","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int64 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int64 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int64","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L245-L245","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = MG.cols m1","function_tokens":["c","=","MG","cols","m1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L408-L408","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Sym (Symbol x))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Sym (Symbol x)) = Just x","function_tokens":["cast'","(","Sym","(","Symbol","x",")",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L258-L258","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"renderLogMessage","parameters":"","argument_list":"","return_statement":"","docstring":"Render a structured log message as a string.","docstring_summary":"Render a structured log message as a string.","docstring_tokens":["Render","a","structured","log","message","as","a","string","."],"function":"renderLogMessage = \\case\n  Debug message -> \"[debug] \" ++ message\n  Info  message -> \"[info] \"  ++ message\n\n-- The application: it logs two messages, then quits.","function_tokens":["renderLogMessage","=","\\","case","Debug","message","->","\"[debug] \"","++","message","Info","message","->","\"[info] \"","++","message","-- The application: it logs two messages, then quits."],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L52-L57","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _          = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L390-L390","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' = Just","function_tokens":["cast'","=","Just"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L282-L282","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int64 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int64 x) = Just x","function_tokens":["cast'","(","Int64","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L362-L362","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"f","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f _ _ = L.find (idMatches id) . map fst . fst","function_tokens":["f","_","_","=","L","find","(","idMatches","id",")",".","map","fst",".","fst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L105-L105","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"go","parameters":"acc (b : bs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go acc (b : bs) =\n        let ints = [blockStart b .. blockEnd b] in\n        if any (`IS.member` acc) ints\n            then True\n            else go (IS.union acc $ IS.fromList ints) bs","function_tokens":["go","acc","(","b",":","bs",")","=","let","ints","=","[","blockStart","b","..","blockEnd","b","]","in","if","any","(","`","IS","member","`","acc",")","ints","then","True","else","go","(","IS","union","acc","$","IS","fromList","ints",")","bs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L75-L79","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"moveBlock","parameters":"offset (Block start end)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"moveBlock offset (Block start end) = Block (start + offset) (end + offset)","function_tokens":["moveBlock","offset","(","Block","start","end",")","=","Block","(","start","+","offset",")","(","end","+","offset",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L55-L55","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val            = Bool","function_tokens":["val","=","Bool"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L319-L319","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"testSuites","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"testSuites = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condTestSuites packageDescription","function_tokens":["testSuites","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condTestSuites","packageDescription"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L66-L67","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val            = Uuid","function_tokens":["val","=","Uuid"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L299-L299","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = StateC $ \\ k s -> mfix (runState (curry pure) s . f . snd) >>= uncurry k","function_tokens":["mfix","f","=","StateC","$","\\","k","s","->","mfix","(","runState","(","curry","pure",")","s",".","f",".","snd",")",">>=","uncurry","k"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L111-L111","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"setEachBody","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setEachBody = setBodies . fmap","function_tokens":["setEachBody","=","setBodies",".","fmap"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L43-L43","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"tr","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix transpose","docstring_summary":"O(m*n) Matrix transpose","docstring_tokens":["O","(","m","*","n",")","Matrix","transpose"],"function":"tr = MG.tr","function_tokens":["tr","=","MG","tr"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L189-L189","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(x, _ : y) = splitAt i doc","function_tokens":["(","x",",","_",":","y",")","=","splitAt","i","doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L128-L128","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"splitBucket","parameters":"i f (n:ns)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"splitBucket i f (n:ns) = let bs = toByteStruct . nodeId . f $ n\n                                       bit = bs !! i\n                                       (left, right) = splitBucket i f ns\n                                   in if bit\n                                      then (left, n:right)\n                                      else (n:left, right)","function_tokens":["splitBucket","i","f","(","n",":","ns",")","=","let","bs","=","toByteStruct",".","nodeId",".","f","$","n","bit","=","bs","!!","i","(","left",",","right",")","=","splitBucket","i","f","ns","in","if","bit","then","(","left",",","n",":","right",")","else","(","n",":","left",",","right",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L180-L185","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"conflicts","parameters":"(Edits edits)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"conflicts (Edits edits) = M.toAscList edits >>= uncurry checkChanges\n  where\n    checkChanges _ [] = []\n    checkChanges i (CInsert _ : cs) = checkChanges i cs\n    checkChanges i (c1@(CBlock _ _) : c2 : _) = [Conflict i c1 i c2]\n    checkChanges i [c1@(CBlock n _)] = do\n        i' <- [i + 1 .. i + n - 1]\n        case M.lookup i' edits of\n            Just (c2 : _) -> [Conflict i c1 i' c2]\n            _             -> []\n    checkChanges i (c1@(CLine xstart xend _) : c2@(CLine ystart _ _) : cs)\n        | xstart == ystart = [Conflict i c1 i c2]\n        | xend > ystart    = [Conflict i c1 i c2]\n        | otherwise        = checkChanges i (c2 : cs)\n    checkChanges _ (CLine _ _ _ : _) = []\n\n\n--------------------------------------------------------------------------------","function_tokens":["conflicts","(","Edits","edits",")","=","M","toAscList","edits",">>=","uncurry","checkChanges","where","checkChanges","_","[","]","=","[","]","checkChanges","i","(","CInsert","_",":","cs",")","=","checkChanges","i","cs","checkChanges","i","(","c1","@","(","CBlock","_","_",")",":","c2",":","_",")","=","[","Conflict","i","c1","i","c2","]","checkChanges","i","[","c1","@","(","CBlock","n","_",")","]","=","do","i'","<-","[","i","+","1","..","i","+","n","-","1","]","case","M","lookup","i'","edits","of","Just","(","c2",":","_",")","->","[","Conflict","i","c1","i'","c2","]","_","->","[","]","checkChanges","i","(","c1","@","(","CLine","xstart","xend","_",")",":","c2","@","(","CLine","ystart","_","_",")",":","cs",")","|","xstart","==","ystart","=","[","Conflict","i","c1","i","c2","]","|","xend",">","ystart","=","[","Conflict","i","c1","i","c2","]","|","otherwise","=","checkChanges","i","(","c2",":","cs",")","checkChanges","_","(","CLine","_","_","_",":","_",")","=","[","]","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L150-L168","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"whileProc","parameters":"ve","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"whileProc ve = SplineT $ runVarT ve >=> return . \\case\n  (Just b, ve1) -> Right (b, whileProc ve1)\n  (Nothing,  _) -> Left ()\n\n-- | Create a spline from a stream and an event stream. The spline\n-- uses the stream's values as its own output values. The spline will run until\n-- the event stream produces an event, at that point the last known output\n-- value and the event value are tupled and returned as the spline's result.","function_tokens":["whileProc","ve","=","SplineT","$","runVarT","ve",">=>","return",".","\\","case","(","Just","b",",","ve1",")","->","Right","(","b",",","whileProc","ve1",")","(","Nothing",",","_",")","->","Left","(",")","-- | Create a spline from a stream and an event stream. The spline","-- uses the stream's values as its own output values. The spline will run until","-- the event stream produces an event, at that point the last known output","-- value and the event value are tupled and returned as the spline's result."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L195-L203","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"toRegistration","parameters":"Closed","argument_list":"","return_statement":"","docstring":"Convert a Signal into its ReplyRegistration representation","docstring_summary":"Convert a Signal into its ReplyRegistration representation","docstring_tokens":["Convert","a","Signal","into","its","ReplyRegistration","representation"],"function":"toRegistration Closed        = Nothing","function_tokens":["toRegistration","Closed","=","Nothing"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L49-L49","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"takeRow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeRow = MG.takeRow","function_tokens":["takeRow","=","MG","takeRow"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L132-L132","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"adjustInput","parameters":"vf0 s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"adjustInput vf0 s = SplineT $ g vf0 s\n  where g vf sx a = do\n          (f, vf1) <- runVarT vf a\n          flip fmap (runSplineT sx (f a)) $ \\case\n           Left c         -> Left c\n           Right (b, sx1) -> Right (b, SplineT $ g vf1 sx1)\n\n--------------------------------------------------------------------------------\n-- $proofs\n-- ==Left Identity\n-- > k =<< return c = k c\n--\n-- > -- Definition of =<<\n-- > fix (\\f s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (k c) a\n-- >       Right s' -> return (Right (fmap f s')))) (return c)\n--\n-- > -- Definition of fix\n-- > (\\s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (k c) a\n-- >       Right s' -> return (Right (fmap (k =<<) s')))) (return c)\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   runSplineT (return c) a >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Definition of return\n-- > SplineT (\\a ->\n-- >   runSplineT (SplineT (\\_ -> return (Left c))) a >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Newtype\n-- > SplineT (\\a ->\n-- >   (\\_ -> return (Left c)) a >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   return (Left c) >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- return x >>= f = f x\n-- > SplineT (\\a ->\n-- >   case (Left c) of\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Case evaluation\n-- > SplineT (\\a -> runSplineT (k c) a)\n--\n-- > -- Eta reduction\n-- > SplineT (runSplineT (k c))\n--\n-- > -- Newtype\n-- > k c\n--\n-- ==Right Identity\n-- > return =<< m = m\n--\n-- > -- Definition of =<<\n-- > fix (\\f s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (return c) a\n-- >       Right s' -> return (Right (fmap f s')))) m\n--\n-- > -- Definition of fix\n-- > (\\s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (return c) a\n-- >       Right s' -> return (Right (fmap (return =<<) s')))) m\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> runSplineT (return c) a\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- Definition of return\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> runSplineT (SplineT (\\_ -> return (Left c))) a\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- Newtype\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> (\\_ -> return (Left c)) a\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> return (Left c)\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- m >>= return . f = fmap f m\n-- > SplineT (\\a -> fmap (either id (fmap (return =<<))) (runSplineT m a))\n--\n-- > -- Coinduction\n-- > SplineT (\\a -> fmap (either id (fmap id)) (runSplineT m a))\n--\n-- > -- fmap id = id\n-- > SplineT (\\a -> fmap (either id id) (runSplineT m a))\n--\n-- > -- either id id = id\n-- > SplineT (\\a -> fmap id (runSplineT m a))\n--\n-- > -- fmap id = id\n-- > SplineT (\\a -> runSplineT m a)\n--\n-- > -- Eta reduction\n-- > SplineT (runSplineT m)\n--\n-- > -- Newtype\n-- > m\n--\n-- ==Application\n-- > (m >>= f) >>= g = m >>= (\\x -> f x >>= g)\n\n-- TODO: Finish the rest of the hand proofs","function_tokens":["adjustInput","vf0","s","=","SplineT","$","g","vf0","s","where","g","vf","sx","a","=","do","(","f",",","vf1",")","<-","runVarT","vf","a","flip","fmap","(","runSplineT","sx","(","f","a",")",")","$","\\","case","Left","c","->","Left","c","Right","(","b",",","sx1",")","->","Right","(","b",",","SplineT","$","g","vf1","sx1",")","--------------------------------------------------------------------------------","-- $proofs","-- ==Left Identity","-- > k =<< return c = k c","--","-- > -- Definition of =<<","-- > fix (\\f s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (k c) a","-- >       Right s' -> return (Right (fmap f s')))) (return c)","--","-- > -- Definition of fix","-- > (\\s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (k c) a","-- >       Right s' -> return (Right (fmap (k =<<) s')))) (return c)","--","-- > -- Application","-- > SplineT (\\a ->","-- >   runSplineT (return c) a >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Definition of return","-- > SplineT (\\a ->","-- >   runSplineT (SplineT (\\_ -> return (Left c))) a >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Newtype","-- > SplineT (\\a ->","-- >   (\\_ -> return (Left c)) a >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Application","-- > SplineT (\\a ->","-- >   return (Left c) >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- return x >>= f = f x","-- > SplineT (\\a ->","-- >   case (Left c) of","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Case evaluation","-- > SplineT (\\a -> runSplineT (k c) a)","--","-- > -- Eta reduction","-- > SplineT (runSplineT (k c))","--","-- > -- Newtype","-- > k c","--","-- ==Right Identity","-- > return =<< m = m","--","-- > -- Definition of =<<","-- > fix (\\f s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (return c) a","-- >       Right s' -> return (Right (fmap f s')))) m","--","-- > -- Definition of fix","-- > (\\s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (return c) a","-- >       Right s' -> return (Right (fmap (return =<<) s')))) m","--","-- > -- Application","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> runSplineT (return c) a","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- Definition of return","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> runSplineT (SplineT (\\_ -> return (Left c))) a","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- Newtype","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> (\\_ -> return (Left c)) a","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- Application","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> return (Left c)","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- m >>= return . f = fmap f m","-- > SplineT (\\a -> fmap (either id (fmap (return =<<))) (runSplineT m a))","--","-- > -- Coinduction","-- > SplineT (\\a -> fmap (either id (fmap id)) (runSplineT m a))","--","-- > -- fmap id = id","-- > SplineT (\\a -> fmap (either id id) (runSplineT m a))","--","-- > -- either id id = id","-- > SplineT (\\a -> fmap id (runSplineT m a))","--","-- > -- fmap id = id","-- > SplineT (\\a -> runSplineT m a)","--","-- > -- Eta reduction","-- > SplineT (runSplineT m)","--","-- > -- Newtype","-- > m","--","-- ==Application","-- > (m >>= f) >>= g = m >>= (\\x -> f x >>= g)","-- TODO: Finish the rest of the hand proofs"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L389-L519","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"f","parameters":"mb s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f mb s = runSplineT s >=> return . \\case\n            Left c        -> Left (mb, c)\n            Right (b, s1) -> Right (b, SplineT $ f (Just b) s1)\n\n-- | Produce the argument as an output value exactly once.\n--\n-- >>> :{\n-- let s = do step \"hi\"\n--            step \"there\"\n--            step \"friend\"\n-- in testVarOver (outputStream s \"\") [1,2,3,4]\n-- >>> :}\n-- \"hi\"\n-- \"there\"\n-- \"friend\"\n-- \"friend\"","function_tokens":["f","mb","s","=","runSplineT","s",">=>","return",".","\\","case","Left","c","->","Left","(","mb",",","c",")","Right","(","b",",","s1",")","->","Right","(","b",",","SplineT","$","f","(","Just","b",")","s1",")","-- | Produce the argument as an output value exactly once.","--","-- >>> :{","-- let s = do step \"hi\"","--            step \"there\"","--            step \"friend\"","-- in testVarOver (outputStream s \"\") [1,2,3,4]","-- >>> :}","-- \"hi\"","-- \"there\"","-- \"friend\"","-- \"friend\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L349-L365","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"targetStruct","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetStruct = toByteStruct id","function_tokens":["targetStruct","=","toByteStruct","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L190-L190","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = ReinterpretLogC $ case sig of\n    L (Log s) -> do\n      f <- ask @(s -> t)\n      ctx <$ log (f s)\n\n    R other   -> alg (runReinterpretLogC . hdl) (R other) ctx\n\n-- The 'ReinterpretLogC' runner.","function_tokens":["alg","hdl","sig","ctx","=","ReinterpretLogC","$","case","sig","of","L","(","Log","s",")","->","do","f","<-","ask","@","(","s","->","t",")","ctx","<$","log","(","f","s",")","R","other","->","alg","(","runReinterpretLogC",".","hdl",")","(","R","other",")","ctx","-- The 'ReinterpretLogC' runner."],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L123-L131","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"mergeAdjacent","parameters":"(a : b : rest)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeAdjacent (a : b : rest) | a `adjacent` b = merge a b : mergeAdjacent rest","function_tokens":["mergeAdjacent","(","a",":","b",":","rest",")","|","a","`","adjacent","`","b","=","merge","a","b",":","mergeAdjacent","rest"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L94-L94","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int32 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int32 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int32","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L377-L377","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"application","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"application = do\n  log (Debug \"debug message\")\n  log (Info \"info message\")\n\n-- The application runner. Interpret the application by:\n--\n-- * Reinterpreting 'Log Message' effects as 'Log String' effects.\n-- * Interpreting 'Log String' effects by printing to stdout.","function_tokens":["application","=","do","log","(","Debug","\"debug message\"",")","log","(","Info","\"info message\"",")","-- The application runner. Interpret the application by:","--","-- * Reinterpreting 'Log Message' effects as 'Log String' effects.","-- * Interpreting 'Log String' effects by printing to stdout."],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L58-L66","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotPNG.hs","language":"haskell","identifier":"mkMapPng","parameters":"path map","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkMapPng path map = do\n    renderableToFile fileOptions path $ mkMapR map\n    putStrLn (\"...output written to \" <> path)","function_tokens":["mkMapPng","path","map","=","do","renderableToFile","fileOptions","path","$","mkMapR","map","putStrLn","(","\"...output written to \"","<>","path",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotPNG.hs#L44-L48","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotPNG.hs","hash_val":49940,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"result = go is ts left n","function_tokens":["result","=","go","is","ts","left","n"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L201-L201","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"parseFromNumberedLines","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseFromNumberedLines =\n    snd . runWriter . evalStateT loop\n    where\n        loop =\n            do  (ls, mMarkerA) <- tryReadUpToMarker '<' Nothing\n                tell $ map (Left . snd) ls\n                case mMarkerA of\n                    Nothing -> pure ()\n                    Just markerA ->\n                        do  tell . pure . Right =<< parseConflict markerA\n                            loop","function_tokens":["parseFromNumberedLines","=","snd",".","runWriter",".","evalStateT","loop","where","loop","=","do","(","ls",",","mMarkerA",")","<-","tryReadUpToMarker","'<'","Nothing","tell","$","map","(","Left",".","snd",")","ls","case","mMarkerA","of","Nothing","->","pure","(",")","Just","markerA","->","do","tell",".","pure",".","Right","=<<","parseConflict","markerA","loop"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L112-L124","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(domain, ls') = splitAt n ls","function_tokens":["(","domain",",","ls'",")","=","splitAt","n","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L179-L179","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!w'' = mappend w (f w')","function_tokens":["w''","=","mappend","w","(","f","w'",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Church.hs#L79-L79","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Church.hs","hash_val":47515,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"f","parameters":"s b a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f s b a = do e <- s a\n                     case e of\n                       Left  _                -> return (b, done b)\n                       Right (b1, SplineT s1) -> return (b1, VarT $ f s1 b1)\n\n-- | Run the spline over the input values, gathering the output values in a\n-- list.","function_tokens":["f","s","b","a","=","do","e","<-","s","a","case","e","of","Left","_","->","return","(","b",",","done","b",")","Right","(","b1",",","SplineT","s1",")","->","return","(","b1",",","VarT","$","f","s1","b1",")","-- | Run the spline over the input values, gathering the output values in a","-- list."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L166-L173","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"mapOutput","parameters":"vf0 s0","argument_list":"","return_statement":"","docstring":"Map the output value of a spline.  >>> :{ let s = mapOutput (pure show) $ step 1 >> step 2 >> step 3 in testVarOver (outputStream s \"\") [(),(),()] >>> :} \"1\" \"2\" \"3\"","docstring_summary":"Map the output value of a spline.  >>> :{ let s = mapOutput (pure show) $ step 1 >> step 2 >> step 3 in testVarOver (outputStream s \"\") [(),(),()] >>> :} \"1\" \"2\" \"3\"","docstring_tokens":["Map","the","output","value","of","a","spline",".",">>>",":","{","let","s","=","mapOutput","(","pure","show",")","$","step","1",">>","step","2",">>","step","3","in","testVarOver","(","outputStream","s",")","[","()","()","()","]",">>>",":","}","1","2","3"],"function":"mapOutput vf0 s0 = SplineT $ g vf0 s0\n    where g vf s a = do\n            (f, vf1) <- runVarT vf a\n            flip fmap (runSplineT s a) $ \\case\n              Left c        -> Left c\n              Right (b, s1) -> Right (f b, SplineT $ g vf1 s1)\n\n-- | Map the input value of a spline.","function_tokens":["mapOutput","vf0","s0","=","SplineT","$","g","vf0","s0","where","g","vf","s","a","=","do","(","f",",","vf1",")","<-","runVarT","vf","a","flip","fmap","(","runSplineT","s","a",")","$","\\","case","Left","c","->","Left","c","Right","(","b",",","s1",")","->","Right","(","f","b",",","SplineT","$","g","vf1","s1",")","-- | Map the input value of a spline."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L379-L387","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"breakUpToMarker","parameters":"c mCount","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"breakUpToMarker c mCount =\n    state (break cond)\n    where\n        count = fromMaybe 7 mCount\n        prefix = replicate count c\n        cond (_, line) =\n            pre == prefix && rightCount\n            where\n                (pre, post) = splitAt count line\n                rightCount =\n                    case (mCount, post) of\n                    (Just{}, x:_) -> c \/= x\n                    _ -> True","function_tokens":["breakUpToMarker","c","mCount","=","state","(","break","cond",")","where","count","=","fromMaybe","7","mCount","prefix","=","replicate","count","c","cond","(","_",",","line",")","=","pre","==","prefix","&&","rightCount","where","(","pre",",","post",")","=","splitAt","count","line","rightCount","=","case","(","mCount",",","post",")","of","(","Just","{","}",",","x",":","_",")","->","c","\/=","x","_","->","True"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L58-L72","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(leftNodes, rightNodes) = splitBucket depth fst nodes","function_tokens":["(","leftNodes",",","rightNodes",")","=","splitBucket","depth","fst","nodes"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L172-L172","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show'","parameters":"(ArraySort i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show' (ArraySort i e) = \"(array \" ++ show' i ++ \" \" ++ show' e ++ \")\"","function_tokens":["show'","(","ArraySort","i","e",")","=","\"(array \"","++","show'","i","++","\" \"","++","show'","e","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L65-L65","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _       = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L291-L291","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zip6","parameters":"m1 m2 m3 m4 m5 m6","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip6 m1 m2 m3 m4 m5 m6\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 ||\n      MG.dim m4 \/= MG.dim m5 ||\n      MG.dim m5 \/= MG.dim m6 = error \"zip6: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zip6 (MG.flatten m1) (MG.flatten m2) (MG.flatten m3)\n                  (MG.flatten m4) (MG.flatten m5) $ MG.flatten m6","function_tokens":["zip6","m1","m2","m3","m4","m5","m6","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","||","MG","dim","m4","\/=","MG","dim","m5","||","MG","dim","m5","\/=","MG","dim","m6","=","error","\"zip6: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zip6","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","(","MG","flatten","m4",")","(","MG","flatten","m5",")","$","MG","flatten","m6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L510-L518","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(==) m1 m2 = MG.flatten m1 == MG.flatten m2","function_tokens":["(","==",")","m1","m2","=","MG","flatten","m1","==","MG","flatten","m2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L133-L133","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"setBodies","parameters":"f","argument_list":"","return_statement":"","docstring":"setter:","docstring_summary":"setter:","docstring_tokens":["setter",":"],"function":"setBodies f = runIdentity . bodies (Identity . f)","function_tokens":["setBodies","f","=","runIdentity",".","bodies","(","Identity",".","f",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L40-L40","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"prettyConflict","parameters":"(Conflict l1 c1 l2 c2)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"prettyConflict (Conflict l1 c1 l2 c2) = unlines\n    [ \"Conflict between edits:\"\n    , \"- \" ++ prettyChange l1 c1\n    , \"- \" ++ prettyChange l2 c2\n    ]","function_tokens":["prettyConflict","(","Conflict","l1","c1","l2","c2",")","=","unlines","[","\"Conflict between edits:\"",",","\"- \"","++","prettyChange","l1","c1",",","\"- \"","++","prettyChange","l2","c2","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L141-L145","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"emptyLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"emptyLine = newLine >> newLine","function_tokens":["emptyLine","=","newLine",">>","newLine"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L135-L135","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"replace","parameters":"line startCol endCol repl","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"replace line startCol endCol repl\n    | startCol > endCol = mempty\n    | otherwise         =\n        Edits $ M.singleton line [CLine startCol endCol repl]","function_tokens":["replace","line","startCol","endCol","repl","|","startCol",">","endCol","=","mempty","|","otherwise","=","Edits","$","M","singleton","line","[","CLine","startCol","endCol","repl","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L111-L114","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _          = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L351-L351","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(newElems, val) = go idStruct targetStruct 0 True elem","function_tokens":["(","newElems",",","val",")","=","go","idStruct","targetStruct","0","True","elem"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L65-L65","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"prettyChange","parameters":"l (CInsert ls)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"prettyChange l (CInsert ls) =\n    show l ++ \" insert \" ++ show (length ls) ++ \" lines\"","function_tokens":["prettyChange","l","(","CInsert","ls",")","=","show","l","++","\" insert \"","++","show","(","length","ls",")","++","\" lines\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L58-L59","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"forM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM = MG.forM","function_tokens":["forM","=","MG","forM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L254-L254","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"g","parameters":"vf s a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g vf s a = do\n            (f, vf1) <- runVarT vf a\n            flip fmap (runSplineT s a) $ \\case\n              Left c        -> Left c\n              Right (b, s1) -> Right (f b, SplineT $ g vf1 s1)\n\n-- | Map the input value of a spline.","function_tokens":["g","vf","s","a","=","do","(","f",",","vf1",")","<-","runVarT","vf","a","flip","fmap","(","runSplineT","s","a",")","$","\\","case","Left","c","->","Left","c","Right","(","b",",","s1",")","->","Right","(","f","b",",","SplineT","$","g","vf1","s1",")","-- | Map the input value of a spline."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L380-L387","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"edits","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"edits =\n        foldMap hsTyReplacements (everything modu) <>\n        foldMap hsSigReplacements (everything modu) <>\n        (if alp then addLanguagePragma lg \"UnicodeSyntax\" modu else mempty)","function_tokens":["edits","=","foldMap","hsTyReplacements","(","everything","modu",")","<>","foldMap","hsSigReplacements","(","everything","modu",")","<>","(","if","alp","then","addLanguagePragma","lg","\"UnicodeSyntax\"","modu","else","mempty",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L51-L54","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val   = id","function_tokens":["val","=","id"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L281-L281","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"withSort","parameters":"SBooleanSort     a","argument_list":"","return_statement":"","docstring":"Turn implicit sort parameter into explicit one","docstring_summary":"Turn implicit sort parameter into explicit one","docstring_tokens":["Turn","implicit","sort","parameter","into","explicit","one"],"function":"withSort SBooleanSort     a = a","function_tokens":["withSort","SBooleanSort","a","=","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L58-L58","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zip3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip3 = MG.zip3","function_tokens":["zip3","=","MG","zip3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L318-L318","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"new","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"new = go is ts (depth + 1) (valid && not i) left","function_tokens":["new","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L51-L51","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!w'' = mappend w w'","function_tokens":["w''","=","mappend","w","w'"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Church.hs#L73-L73","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Church.hs","hash_val":47515,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"sort'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sort' = choice [ bool, int, char '(' *> array <* char ')' ]","function_tokens":["sort'","=","choice","[","bool",",","int",",","char","'('","*>","array","<*","char","')'","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L130-L130","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _       = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L326-L326","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"version","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"version = undefined","function_tokens":["version","=","undefined"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L93-L93","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"rType","parameters":"PONG","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rType  PONG               = Just  R_PONG","function_tokens":["rType","PONG","=","Just","R_PONG"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L57-L57","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"hsTyReplacements","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hsTyReplacements _ = mempty","function_tokens":["hsTyReplacements","_","=","mempty"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L30-L30","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"liftA2","parameters":"f (StateC a) (StateC b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftA2 f (StateC a) (StateC b) = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' -> k s'' . f a') s')","function_tokens":["liftA2","f","(","StateC","a",")","(","StateC","b",")","=","StateC","$","\\","k","->","a","(","\\","s'","a'","->","b","(","\\","s''","->","k","s''",".","f","a'",")","s'",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L84-L85","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = RegEx","function_tokens":["val","=","RegEx"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L338-L338","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"benchmarks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmarks = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condBenchmarks packageDescription","function_tokens":["benchmarks","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condBenchmarks","packageDescription"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L70-L71","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DynamicSort a == DynamicSort b = case a %~ b of\n        Proved Refl -> True\n        Disproved _ -> False\n\n-- | A value of some sort","function_tokens":["DynamicSort","a","==","DynamicSort","b","=","case","a","%~","b","of","Proved","Refl","->","True","Disproved","_","->","False","-- | A value of some sort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L85-L90","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"force","parameters":"m@(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"force m@(Matrix r c _ _ _) = MG.fromVector (r,c) . G.force . MG.flatten $ m","function_tokens":["force","m","@","(","Matrix","r","c","_","_","_",")","=","MG","fromVector","(","r",",","c",")",".","G","force",".","MG","flatten","$","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L275-L275","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = Edits mempty","function_tokens":["mempty","=","Edits","mempty"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L95-L95","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Float x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Float x) = Just (realToFrac x)","function_tokens":["cast'","(","Float","x",")","=","Just","(","realToFrac","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L250-L250","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = Float . realToFrac","function_tokens":["val","=","Float",".","realToFrac"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L249-L249","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"checkChanges","parameters":"i (c1@(CLine xstart xend _) : c2@(CLine ystart _ _) : cs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkChanges i (c1@(CLine xstart xend _) : c2@(CLine ystart _ _) : cs)\n        | xstart == ystart = [Conflict i c1 i c2]\n        | xend > ystart    = [Conflict i c1 i c2]\n        | otherwise        = checkChanges i (c2 : cs)","function_tokens":["checkChanges","i","(","c1","@","(","CLine","xstart","xend","_",")",":","c2","@","(","CLine","ystart","_","_",")",":","cs",")","|","xstart","==","ystart","=","[","Conflict","i","c1","i","c2","]","|","xend",">","ystart","=","[","Conflict","i","c1","i","c2","]","|","otherwise","=","checkChanges","i","(","c2",":","cs",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L160-L163","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"showsPrec","parameters":"_ (Oid x y)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsPrec _ (Oid x y) = showHexLen 8 x . showHexLen 16 y","function_tokens":["showsPrec","_","(","Oid","x","y",")","=","showHexLen","8","x",".","showHexLen","16","y"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L442-L442","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _       = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L296-L296","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"splitTree","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"splitTree = split tree . nodeId $ node","function_tokens":["splitTree","=","split","tree",".","nodeId","$","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L143-L143","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val              = MinMax","function_tokens":["val","=","MinMax"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L388-L388","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"int","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"int   = string \"int\"  $> DynamicSort SIntegralSort","function_tokens":["int","=","string","\"int\"","$>","DynamicSort","SIntegralSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L127-L127","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unzip3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip3 = MG.unzip3","function_tokens":["unzip3","=","MG","unzip3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L352-L352","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"fail","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail = lift . Fail.fail","function_tokens":["fail","=","lift",".","Fail","fail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L107-L107","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/IORef.hs","language":"haskell","identifier":"runState","parameters":"s x","argument_list":"","return_statement":"","docstring":"Run a 'State' effect starting from the passed value.  @ 'runState' s ('pure' a) = 'pure' (s, a) @ @ 'runState' s 'get' = 'pure' (s, s) @ @ 'runState' s ('put' t) = 'pure' (t, ()) @  @since 1.1.2.0","docstring_summary":"Run a 'State' effect starting from the passed value.","docstring_tokens":["Run","a","State","effect","starting","from","the","passed","value","."],"function":"runState s x = do\n  ref <- liftIO $ newIORef s\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)","function_tokens":["runState","s","x","=","do","ref","<-","liftIO","$","newIORef","s","result","<-","runReader","ref",".","runStateC","$","x","final","<-","liftIO",".","readIORef","$","ref","pure","(","final",",","result",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/IORef.hs#L54-L59","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/IORef.hs","hash_val":53014,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DynamicallySorted sa a == DynamicallySorted sb b = case sa %~ sb of\n        Proved Refl -> a == b\n        Disproved _ -> False","function_tokens":["DynamicallySorted","sa","a","==","DynamicallySorted","sb","b","=","case","sa","%~","sb","of","Proved","Refl","->","a","==","b","Disproved","_","->","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L97-L101","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWith4","parameters":"f m1 m2 m3 m4","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith4 f m1 m2 m3 m4\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 = error \"zipWith4: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zipWith4 f (MG.flatten m1) (MG.flatten m2)\n                  (MG.flatten m3) $ MG.flatten m4","function_tokens":["zipWith4","f","m1","m2","m3","m4","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","=","error","\"zipWith4: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zipWith4","f","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","$","MG","flatten","m4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L350-L356","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L460-L460","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"beforeChange","parameters":"_             (CBlock _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"beforeChange _             (CBlock _ _)  = False","function_tokens":["beforeChange","_","(","CBlock","_","_",")","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L52-L52","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = MG.dim m","function_tokens":["d","=","MG","dim","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L591-L591","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(String x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (String x) = Just (Symbol x)","function_tokens":["cast'","(","String","x",")","=","Just","(","Symbol","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L350-L350","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L301-L301","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'Maybe","parameters":"Null","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'Maybe Null = Just Nothing","function_tokens":["cast'Maybe","Null","=","Just","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L228-L228","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"typed","parameters":"","argument_list":"","return_statement":"","docstring":"^ Convert Value to expected type. Error if not that type.","docstring_summary":"^ Convert Value to expected type. Error if not that type.","docstring_tokens":["^","Convert","Value","to","expected","type",".","Error","if","not","that","type","."],"function":"typed = fromJust . cast","function_tokens":["typed","=","fromJust",".","cast"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L207-L207","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"sigDigits","parameters":"n'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sigDigits n' = truncate (logBase 16 $ fromIntegral n' :: Double) + 1","function_tokens":["sigDigits","n'","=","truncate","(","logBase","16","$","fromIntegral","n'","::","Double",")","+","1"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L83-L83","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"takeColumn","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeColumn = MG.takeColumn","function_tokens":["takeColumn","=","MG","takeColumn"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L135-L135","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"raceAny","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"raceAny [] = pure mempty `_untilEvent` never","function_tokens":["raceAny","[","]","=","pure","mempty","`","_untilEvent","`","never"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L269-L269","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"sequence_","parameters":"(Matrix _ _ _ _ vec)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sequence_ (Matrix _ _ _ _ vec) = G.sequence_ vec","function_tokens":["sequence_","(","Matrix","_","_","_","_","vec",")","=","G","sequence_","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L602-L602","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"findLanguageExtensions","parameters":"verbose","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"findLanguageExtensions verbose =\n    findCabalFile verbose >>=\n    maybe (pure []) (readDefaultLanguageExtensions verbose)","function_tokens":["findLanguageExtensions","verbose","=","findCabalFile","verbose",">>=","maybe","(","pure","[","]",")","(","readDefaultLanguageExtensions","verbose",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L26-L28","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Inference.hs","language":"haskell","identifier":"askEnv","parameters":"","argument_list":"","return_statement":"","docstring":"A constrained wrapper around 'ask'.  Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the \/same\/ type parameter as its phantom type parameter.  Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their @env@ type parameters unify, allowing them to be inferred from context more often.","docstring_summary":"A constrained wrapper around 'ask'.  Like 'ask', 'askEnv' uses the same type parameter for both the 'Reader' and return types. Unlike 'ask'\u2014which doesn\u2019t impose any extra structure on the monad\u2014it\u2019s specialized to 'HasEnv', and uses the \/same\/ type parameter as its phantom type parameter.  Thus, any two calls to 'askEnv' occurring in the same 'HasEnv' context will be required to have their","docstring_tokens":["A","constrained","wrapper","around","ask",".","Like","ask","askEnv","uses","the","same","type","parameter","for","both","the","Reader","and","return","types",".","Unlike","ask","\u2014which","doesn\u2019t","impose","any","extra","structure","on","the","monad\u2014it\u2019s","specialized","to","HasEnv","and","uses","the","\/","same","\/","type","parameter","as","its","phantom","type","parameter",".","Thus","any","two","calls","to","askEnv","occurring","in","the","same","HasEnv","context","will","be","required","to","have","their"],"function":"askEnv = ask","function_tokens":["askEnv","=","ask"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Inference.hs#L40-L40","hash_key":"fused-effects\/fused-effects:examples\/Inference.hs","hash_val":49733,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ReaderC l <|> ReaderC r = ReaderC (liftA2 (<|>) l r)","function_tokens":["ReaderC","l","<|>","ReaderC","r","=","ReaderC","(","liftA2","(","<|>",")","l","r",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L71-L71","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"nextCount","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nextCount = atomicModifyIORef counter $ \\n -> (wrap24 (n + 1), n)","function_tokens":["nextCount","=","atomicModifyIORef","counter","$","\\","n","->","(","wrap24","(","n","+","1",")",",","n",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L469-L469","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotPNG.hs","language":"haskell","identifier":"fileOptions","parameters":"","argument_list":"","return_statement":"","docstring":"Default file options: PNG output and 1920x1080. To change the file size, you can do e.g. > fo_size .~ (640,480) $ fileOptions","docstring_summary":"Default file options: PNG output and 1920x1080. To change the file size, you can do e.g. > fo_size .~ (640,480) $ fileOptions","docstring_tokens":["Default","file","options",":","PNG","output","and","1920x1080",".","To","change","the","file","size","you","can","do","e",".","g",".",">","fo_size",".","~","(","640","480",")","$","fileOptions"],"function":"fileOptions = def { _fo_size = (1920, 1080) , _fo_format = PNG }","function_tokens":["fileOptions","=","def","{","_fo_size","=","(","1920",",","1080",")",",","_fo_format","=","PNG","}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotPNG.hs#L26-L26","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotPNG.hs","hash_val":49940,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"withSort","parameters":"SIntegralSort    a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withSort SIntegralSort    a = a","function_tokens":["withSort","SIntegralSort","a","=","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L59-L59","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"castingResult","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"castingResult = cast' v","function_tokens":["castingResult","=","cast'","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L235-L235","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f i = vec G.! (offset + i `mod` r * tda + i `div` r)","function_tokens":["f","i","=","vec","G","!","(","offset","+","i","`","mod","`","r","*","tda","+","i","`","div","`","r",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L212-L212","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val   = valList","function_tokens":["val","=","valList"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L285-L285","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"ident","parameters":"n","argument_list":"","return_statement":"","docstring":"O(m*n) Create an identity matrix","docstring_summary":"O(m*n) Create an identity matrix","docstring_tokens":["O","(","m","*","n",")","Create","an","identity","matrix"],"function":"ident n = diagRect 0 (n,n) $ replicate n 1","function_tokens":["ident","n","=","diagRect","0","(","n",",","n",")","$","replicate","n","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L217-L217","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fresh\/Strict.hs","language":"haskell","identifier":"runFresh","parameters":"n (FreshC m)","argument_list":"","return_statement":"","docstring":"Run a 'Fresh' effect counting up from 0.  @ 'runFresh' n ('pure' a) = 'pure' (n, a) @ @ 'runFresh' n 'fresh' = 'pure' (n '+' 1, n) @  @since 0.1.0.0","docstring_summary":"Run a 'Fresh' effect counting up from 0.","docstring_tokens":["Run","a","Fresh","effect","counting","up","from","0","."],"function":"runFresh n (FreshC m) = runState n m","function_tokens":["runFresh","n","(","FreshC","m",")","=","runState","n","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fresh\/Strict.hs#L41-L41","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fresh\/Strict.hs","hash_val":46850,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"adjust","parameters":"xstart xend x (CLine ystart yend y)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"adjust xstart xend x (CLine ystart yend y)\n        | ystart >= xend =\n            let offset = length x - (xend - xstart) in\n            CLine (ystart + offset) (yend + offset) y\n        | otherwise     = CLine ystart yend y","function_tokens":["adjust","xstart","xend","x","(","CLine","ystart","yend","y",")","|","ystart",">=","xend","=","let","offset","=","length","x","-","(","xend","-","xstart",")","in","CLine","(","ystart","+","offset",")","(","yend","+","offset",")","y","|","otherwise","=","CLine","ystart","yend","y"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L187-L191","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"evalState","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'State' effect, yielding the result value and discarding the final state.  @ 'evalState' = 'runState' ('const' 'pure') @  @since 1.1.0.0","docstring_summary":"Run a 'State' effect, yielding the result value and discarding the final state.","docstring_tokens":["Run","a","State","effect","yielding","the","result","value","and","discarding","the","final","state","."],"function":"evalState = runState (const pure)","function_tokens":["evalState","=","runState","(","const","pure",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L59-L59","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"generate","parameters":"(r,c) f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"generate (r,c) f = MG.fromVector (r,c) . G.generate (r*c) $ \\i -> f (i `divMod` c)","function_tokens":["generate","(","r",",","c",")","f","=","MG","fromVector","(","r",",","c",")",".","G","generate","(","r","*","c",")","$","\\","i","->","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L606-L606","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"forM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM_ = flip mapM_","function_tokens":["forM_","=","flip","mapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L326-L326","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC a *> StateC b = StateC $ \\ k -> a (const . b k)","function_tokens":["StateC","a","*>","StateC","b","=","StateC","$","\\","k","->","a","(","const",".","b","k",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L88-L88","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"tryReadUpToMarker","parameters":"c mCount","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tryReadUpToMarker c mCount =\n    (,) <$> breakUpToMarker c mCount <*> readHead","function_tokens":["tryReadUpToMarker","c","mCount","=","(",",",")","<$>","breakUpToMarker","c","mCount","<*>","readHead"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L81-L82","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"forkOS","parameters":"","argument_list":"","return_statement":"","docstring":"Like @Control.Concurrent.'Control.Concurrent.forkOS'@ but returns a computation that when executed blocks until the thread terminates then returns the final value of the thread.","docstring_summary":"Like","docstring_tokens":["Like"],"function":"forkOS = fork Control.Concurrent.forkOS","function_tokens":["forkOS","=","fork","Control","Concurrent","forkOS"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L90-L90","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' = cast'List","function_tokens":["cast'","=","cast'List"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L286-L286","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'List","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'List _         = Nothing","function_tokens":["cast'List","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L226-L226","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"^ If Just value then return one field document, otherwise return empty document","docstring_summary":"^ If Just value then return one field document, otherwise return empty document","docstring_tokens":["^","If","Just","value","then","return","one","field","document","otherwise","return","empty","document"],"function":"k =? ma = maybeToList (fmap (k =:) ma)","function_tokens":["k","=?","ma","=","maybeToList","(","fmap","(","k","=:",")","ma",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L143-L143","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"map","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"map = MG.map","function_tokens":["map","=","MG","map"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L232-L232","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Edits l <> Edits r = Edits $ M.unionWith mergeChanges l r","function_tokens":["Edits","l","<>","Edits","r","=","Edits","$","M","unionWith","mergeChanges","l","r"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L90-L90","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"imapM","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","yielding","a","matrix","of","results","."],"function":"imapM = MG.imapM","function_tokens":["imapM","=","MG","imapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L243-L243","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val           = UTC","function_tokens":["val","=","UTC"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L324-L324","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"setStrings","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setStrings = setEachBody . map","function_tokens":["setStrings","=","setEachBody",".","map"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L46-L46","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"imapM_","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","ignoring","the","results","."],"function":"imapM_ = MG.imapM_","function_tokens":["imapM_","=","MG","imapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L251-L251","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Lift.hs","language":"haskell","identifier":"sendIO","parameters":"","argument_list":"","return_statement":"","docstring":"A type-restricted variant of 'sendM' for 'IO' actions.  This is particularly useful when you have a @'Has' ('Lift' 'IO') sig m@ constraint for the use of 'liftWith', and want to run an action abstracted over 'Control.Monad.IO.Class.MonadIO'. 'IO' has a 'Control.Monad.IO.Class.MonadIO' instance, and 'sendIO'\u2019s type restricts the action\u2019s type to 'IO' without further type annotations.  @since 1.0.2.0","docstring_summary":"A type-restricted variant of 'sendM' for 'IO' actions.  This is particularly useful when you have a","docstring_tokens":["A","type","-","restricted","variant","of","sendM","for","IO","actions",".","This","is","particularly","useful","when","you","have","a"],"function":"sendIO = sendM","function_tokens":["sendIO","=","sendM"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Lift.hs#L46-L46","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Lift.hs","hash_val":53563,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"liftIO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO = lift . liftIO","function_tokens":["liftIO","=","lift",".","liftIO"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L115-L115","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fail\/Either.hs","language":"haskell","identifier":"runFail","parameters":"(FailC m)","argument_list":"","return_statement":"","docstring":"Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.  @ 'runFail' ('pure' a) = 'pure' ('Right' a) @ @ 'runFail' ('Fail.fail' s) = 'pure' ('Left' s) @  @since 1.0.0.0","docstring_summary":"Run a 'Control.Effect.Fail.Fail' effect, returning failure messages in 'Left' and successful computations\u2019 results in 'Right'.","docstring_tokens":["Run","a","Control",".","Effect",".","Fail",".","Fail","effect","returning","failure","messages","in","Left","and","successful","computations\u2019","results","in","Right","."],"function":"runFail (FailC m) = runThrow m","function_tokens":["runFail","(","FailC","m",")","=","runThrow","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fail\/Either.hs#L39-L39","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fail\/Either.hs","hash_val":46921,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWith4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith4 = MG.zipWith4","function_tokens":["zipWith4","=","MG","zipWith4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L271-L271","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"r","parameters":"c d","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r c d = return $ Left (c, d)","function_tokens":["r","c","d","=","return","$","Left","(","c",",","d",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L295-L295","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unsafeFromVector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFromVector = MG.unsafeFromVector","function_tokens":["unsafeFromVector","=","MG","unsafeFromVector"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L141-L141","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"send","parameters":"kh peer cmd","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"send kh peer cmd = writeChan (sendChan kh) (cmd, peer)","function_tokens":["send","kh","peer","cmd","=","writeChan","(","sendChan","kh",")","(","cmd",",","peer",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L114-L114","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Lift.hs","language":"haskell","identifier":"sendM","parameters":"m","argument_list":"","return_statement":"","docstring":"Given a @Lift n@ constraint in a signature carried by @m@, 'sendM' promotes arbitrary actions of type @n a@ to @m a@. It is spiritually similar to @lift@ from the @MonadTrans@ typeclass.  @since 1.0.0.0","docstring_summary":"Given a","docstring_tokens":["Given","a"],"function":"sendM m = liftWith (\\ _ ctx -> (<$ ctx) <$> m)","function_tokens":["sendM","m","=","liftWith","(","\\","_","ctx","->","(","<$","ctx",")","<$>","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Lift.hs#L37-L37","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Lift.hs","hash_val":53563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = MG.cols m1","function_tokens":["c","=","MG","cols","m1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L459-L459","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(v1, v2, v3, v4, v5, v6) = G.unzip6 $ MG.flatten m","function_tokens":["(","v1",",","v2",",","v3",",","v4",",","v5",",","v6",")","=","G","unzip6","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L592-L592","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"checkChanges","parameters":"_ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkChanges _ [] = []","function_tokens":["checkChanges","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L152-L152","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L409-L409","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Sym x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Sym x)    = Just x","function_tokens":["cast'","(","Sym","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L349-L349","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"readerExamples","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readerExamples = testGroup \"Reader\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" sample)))) === 15\n  , testProperty \"Reader.Labelled helpers\" . property $\n    run (runReader (5 :: Int) (runLabelled @\"fore\" (runReader (10 :: Int) (runLabelled @\"aft\" withHelpers)))) === 15\n  , testProperty \"Nat labels\" . property $\n    run (runReader (5 :: Int) (runLabelled @1 (runReader (10 :: Int) (runLabelled @2 numerically)))) === 15\n  ]","function_tokens":["readerExamples","=","testGroup","\"Reader\"","[","testProperty","\"runUnderLabel\"",".","property","$","run","(","runReader","(","5","::","Int",")","(","runLabelled","@","\"fore\"","(","runReader","(","10","::","Int",")","(","runLabelled","@","\"aft\"","sample",")",")",")",")","===","15",",","testProperty","\"Reader.Labelled helpers\"",".","property","$","run","(","runReader","(","5","::","Int",")","(","runLabelled","@","\"fore\"","(","runReader","(","10","::","Int",")","(","runLabelled","@","\"aft\"","withHelpers",")",")",")",")","===","15",",","testProperty","\"Nat labels\"",".","property","$","run","(","runReader","(","5","::","Int",")","(","runLabelled","@","1","(","runReader","(","10","::","Int",")","(","runLabelled","@","2","numerically",")",")",")",")","===","15","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L36-L43","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"i (CLine xstart xend x : cs) (l : ls)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go i (CLine xstart xend x : cs) (l : ls) =\n        let l' = take (xstart - 1) l ++ x ++ drop (xend - 1) l in\n        go i (adjust xstart xend x <$> cs) (l' : ls)","function_tokens":["go","i","(","CLine","xstart","xend","x",":","cs",")","(","l",":","ls",")","=","let","l'","=","take","(","xstart","-","1",")","l","++","x","++","drop","(","xend","-","1",")","l","in","go","i","(","adjust","xstart","xend","x","<$>","cs",")","(","l'",":","ls",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L181-L183","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"machineId","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"machineId = unsafePerformIO (makeWord24 . S.unpack . S.take 3 . MD5.hash . SC.pack <$> getHostName)","function_tokens":["machineId","=","unsafePerformIO","(","makeWord24",".","S","unpack",".","S","take","3",".","MD5","hash",".","SC","pack","<$>","getHostName",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L463-L463","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC f <*> StateC a = StateC $ \\ k -> f (\\ s f' -> a (\\ s' -> k s' . f') s)","function_tokens":["StateC","f","<*>","StateC","a","=","StateC","$","\\","k","->","f","(","\\","s","f'","->","a","(","\\","s'","->","k","s'",".","f'",")","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L81-L81","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int32 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int32 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int32","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L363-L363","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Sum.hs","language":"haskell","identifier":"inj","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"inj = R . inj","function_tokens":["inj","=","R",".","inj"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Sum.hs#L66-L66","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Sum.hs","hash_val":46968,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(!) = (MG.!)","function_tokens":["(","!",")","=","(","MG","!",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L129-L129","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"targetStruct","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetStruct = toByteStruct id","function_tokens":["targetStruct","=","toByteStruct","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L85-L85","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"defaultExtensions","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultExtensions = map fromEnabled . filter isEnabled $\n        concatMap Cabal.defaultExtensions gatherBuildInfos\n        where isEnabled (Language.EnableExtension _) = True\n              isEnabled _                            = False\n\n              fromEnabled (Language.EnableExtension x) = x\n              fromEnabled x                             =\n                error $ \"Language.Haskell.Stylish.Config.readLanguageExtensions: \" <>\n                        \"invalid LANGUAGE pragma:  \" <> show x","function_tokens":["defaultExtensions","=","map","fromEnabled",".","filter","isEnabled","$","concatMap","Cabal","defaultExtensions","gatherBuildInfos","where","isEnabled","(","Language","EnableExtension","_",")","=","True","isEnabled","_","=","False","fromEnabled","(","Language","EnableExtension","x",")","=","x","fromEnabled","x","=","error","$","\"Language.Haskell.Stylish.Config.readLanguageExtensions: \"","<>","\"invalid LANGUAGE pragma:  \"","<>","show","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L81-L90","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Inference.hs","language":"haskell","identifier":"example","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"example = testGroup \"inference\"\n  [ testProperty \"type applications instantiate types\" . property $ do\n  -- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.\n    x <- forAll Gen.alphaNum\n    run (runEnv [x] ((++) <$> ask @String <*> ask @String)) === [x, x]\n  -- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.\n  --\n  -- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.\n  , testProperty \"phantom type parameters constrain inference\" . property $ do\n    x <- forAll (Gen.integral (Range.linear 0 100))\n    run (runEnv [x] ((++) <$> askEnv <*> askEnv)) === [x, x :: Integer]\n  ]","function_tokens":["example","=","testGroup","\"inference\"","[","testProperty","\"type applications instantiate types\"",".","property","$","do","-- Without @-XTypeApplications@ or some other constraint on the type, 'ask' would error: all @ghc@ would be able to prove about type of the 'Reader' effect, and thus the return type of 'ask', is that it\u2019s a list of some kind. The type application allows us to specify it.","x","<-","forAll","Gen","alphaNum","run","(","runEnv","[","x","]","(","(","++",")","<$>","ask","@","String","<*>","ask","@","String",")",")","===","[","x",",","x","]","-- However, when the type is polymorphic, this can require contortions: @-XScopedTypeVariables@ and @forall@ annotations just to bring the type variables into scope, etc., and can be especially inconvenient in @ghci.","--","-- Sometimes we would like to be able to constrain the type by context instead. In these cases, we can use a @newtype@ with a phantom type parameter, plus a wrapper around 'ask' which uses that type parameter to constrain its return type, to provide enough context for the types to be inferred without annotation or @-XTypeApplications@.",",","testProperty","\"phantom type parameters constrain inference\"",".","property","$","do","x","<-","forAll","(","Gen","integral","(","Range","linear","0","100",")",")","run","(","runEnv","[","x","]","(","(","++",")","<$>","askEnv","<*>","askEnv",")",")","===","[","x",",","x","::","Integer","]","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Inference.hs#L20-L31","hash_key":"fused-effects\/fused-effects:examples\/Inference.hs","hash_val":49733,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"roundTo","parameters":"mult n","argument_list":"","return_statement":"","docstring":"^ Round second number to nearest multiple of first number. Eg: roundTo (1\/1000) 0.12345 = 0.123","docstring_summary":"^ Round second number to nearest multiple of first number. Eg: roundTo (1\/1000) 0.12345 = 0.123","docstring_tokens":["^","Round","second","number","to","nearest","multiple","of","first","number",".","Eg",":","roundTo","(","1","\/","1000",")","0",".","12345","=","0",".","123"],"function":"roundTo mult n = fromIntegral (round (n \/ mult) :: Integer) * mult","function_tokens":["roundTo","mult","n","=","fromIntegral","(","round","(","n","\/","mult",")","::","Integer",")","*","mult"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L77-L77","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'List","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'List _                = Nothing","function_tokens":["cast'List","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L270-L270","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _       = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L331-L331","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L304-L304","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"forkOn","parameters":"","argument_list":"","return_statement":"","docstring":"Like @Control.Concurrent.'Control.Concurrent.forkOn'@ but returns a computation that when executed blocks until the thread terminates then returns the final value of the thread.","docstring_summary":"Like","docstring_tokens":["Like"],"function":"forkOn = fork . rawForkOn","function_tokens":["forkOn","=","fork",".","rawForkOn"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L96-L96","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"lookup","parameters":"tree id","argument_list":"","return_statement":"","docstring":"Lookup a node within a NodeTree","docstring_summary":"Lookup a node within a NodeTree","docstring_tokens":["Lookup","a","node","within","a","NodeTree"],"function":"lookup tree id = applyAt tree id f\n    where f _ _ = L.find (idMatches id) . map fst . fst\n\n-- | Delete a Node corresponding to a supplied Id from a NodeTree","function_tokens":["lookup","tree","id","=","applyAt","tree","id","f","where","f","_","_","=","L","find","(","idMatches","id",")",".","map","fst",".","fst","-- | Delete a Node corresponding to a supplied Id from a NodeTree"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L104-L108","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"go","parameters":"(b1, x) gs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (b1, x) gs = case break (adjacent b1 . fst) gs of\n        (_, [])               -> (b1, [x]) : gs\n        (ys, ((b2, xs) : zs)) -> (merge b1 b2, x : xs) : (ys ++ zs)","function_tokens":["go","(","b1",",","x",")","gs","=","case","break","(","adjacent","b1",".","fst",")","gs","of","(","_",",","[","]",")","->","(","b1",",","[","x","]",")",":","gs","(","ys",",","(","(","b2",",","xs",")",":","zs",")",")","->","(","merge","b1","b2",",","x",":","xs",")",":","(","ys","++","zs",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L89-L93","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/State\/Labelled.hs","language":"haskell","identifier":"get","parameters":"","argument_list":"","return_statement":"","docstring":"Get the current state value.  @ runState a ('runLabelled' @label ('get' @label) '>>=' k) = runState a (k a) @  @since 1.0.2.0","docstring_summary":"Get the current state value.","docstring_tokens":["Get","the","current","state","value","."],"function":"get = runUnderLabel @label S.get","function_tokens":["get","=","runUnderLabel","@","label","S","get"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/State\/Labelled.hs#L37-L37","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/State\/Labelled.hs","hash_val":51637,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int64 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int64 x) = Just (fromEnum x)","function_tokens":["cast'","(","Int64","x",")","=","Just","(","fromEnum","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L370-L370","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zip6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip6 = MG.zip6","function_tokens":["zip6","=","MG","zip6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L335-L335","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zip4","parameters":"m1 m2 m3 m4","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip4 m1 m2 m3 m4\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 = error \"zip4: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zip4 (MG.flatten m1) (MG.flatten m2)\n                  (MG.flatten m3) $ MG.flatten m4","function_tokens":["zip4","m1","m2","m3","m4","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","=","error","\"zip4: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zip4","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","$","MG","flatten","m4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L483-L489","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"idMatches","parameters":"id node","argument_list":"","return_statement":"","docstring":"Helper function used for KBucket manipulation","docstring_summary":"Helper function used for KBucket manipulation","docstring_tokens":["Helper","function","used","for","KBucket","manipulation"],"function":"idMatches id node = id == nodeId node","function_tokens":["idMatches","id","node","=","id","==","nodeId","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L219-L219","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"checkChanges","parameters":"i [c1@(CBlock n _)]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkChanges i [c1@(CBlock n _)] = do\n        i' <- [i + 1 .. i + n - 1]\n        case M.lookup i' edits of\n            Just (c2 : _) -> [Conflict i c1 i' c2]\n            _             -> []","function_tokens":["checkChanges","i","[","c1","@","(","CBlock","n","_",")","]","=","do","i'","<-","[","i","+","1","..","i","+","n","-","1","]","case","M","lookup","i'","edits","of","Just","(","c2",":","_",")","->","[","Conflict","i","c1","i'","c2","]","_","->","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L155-L160","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"fail","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail = ReaderC . const . Fail.fail","function_tokens":["fail","=","ReaderC",".","const",".","Fail","fail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L79-L79","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Except.hs","language":"haskell","identifier":"justDoIt","parameters":"a","argument_list":"","return_statement":"","docstring":"Just try to perform the action and eat any IO exception. We want this to happen because we'll be using this to try several commands and don't expect all of them to succeed.","docstring_summary":"Just try to perform the action and eat any IO exception. We want this to happen because we'll be using this to try several commands and don't expect all of them to succeed.","docstring_tokens":["Just","try","to","perform","the","action","and","eat","any","IO","exception",".","We","want","this","to","happen","because","we","ll","be","using","this","to","try","several","commands","and","don","t","expect","all","of","them","to","succeed","."],"function":"justDoIt a = catchIO a $ const (pure ())","function_tokens":["justDoIt","a","=","catchIO","a","$","const","(","pure","(",")",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Except.hs#L50-L50","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Except.hs","hash_val":50331,"partition":"valid"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotPNG.hs","language":"haskell","identifier":"mkLensMap","parameters":"title filepath lens districts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkLensMap title filepath lens districts = case getExt filepath of\n    \"png\" -> makeLensMapPng title filepath lens districts\n    \"svg\" -> makeLensMapSVG title filepath lens districts\n\n-- | Given a `Map`, write it to file.","function_tokens":["mkLensMap","title","filepath","lens","districts","=","case","getExt","filepath","of","\"png\"","->","makeLensMapPng","title","filepath","lens","districts","\"svg\"","->","makeLensMapSVG","title","filepath","lens","districts","-- | Given a `Map`, write it to file. "],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotPNG.hs#L38-L43","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotPNG.hs","hash_val":49940,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"targetStruct","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetStruct = toByteStruct id","function_tokens":["targetStruct","=","toByteStruct","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L40-L40","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"toStaticSort","parameters":"dx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toStaticSort dx = case dx of\n    DynamicSort x -> case x %~ (sing :: Sing s) of\n        Proved Refl -> Just x\n        Disproved _ -> Nothing\n\n-- | Converts a statically sorted expression to a dynamically sorted one.","function_tokens":["toStaticSort","dx","=","case","dx","of","DynamicSort","x","->","case","x","%~","(","sing","::","Sing","s",")","of","Proved","Refl","->","Just","x","Disproved","_","->","Nothing","-- | Converts a statically sorted expression to a dynamically sorted one."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L106-L112","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"diag","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_summary":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_tokens":["O","(","m","*","n",")","Create","a","square","matrix","with","given","diagonal","other","entries","default","to","0"],"function":"diag = MG.diag","function_tokens":["diag","=","MG","diag"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L206-L206","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"composite","parameters":"mid pid inc","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"composite mid pid inc = fromIntegral mid `shift` 40 .|. fromIntegral pid `shift` 24 .|. fromIntegral inc","function_tokens":["composite","mid","pid","inc","=","fromIntegral","mid","`","shift","`","40",".|.","fromIntegral","pid","`","shift","`","24",".|.","fromIntegral","inc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L472-L472","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show","parameters":"s@IntegralSort","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show s@IntegralSort  = show' s","function_tokens":["show","s","@","IntegralSort","=","show'","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L69-L69","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L396-L396","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"blockLength","parameters":"(Block start end)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"blockLength (Block start end) = end - start + 1","function_tokens":["blockLength","(","Block","start","end",")","=","end","-","start","+","1"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L50-L50","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(v1, v2) = G.unzip $ MG.flatten m","function_tokens":["(","v1",",","v2",")","=","G","unzip","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L541-L541","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"cond","parameters":"(_, line)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cond (_, line) =\n            pre == prefix && rightCount\n            where\n                (pre, post) = splitAt count line\n                rightCount =\n                    case (mCount, post) of\n                    (Just{}, x:_) -> c \/= x\n                    _ -> True","function_tokens":["cond","(","_",",","line",")","=","pre","==","prefix","&&","rightCount","where","(","pre",",","post",")","=","splitAt","count","line","rightCount","=","case","(","mCount",",","post",")","of","(","Just","{","}",",","x",":","_",")","->","c","\/=","x","_","->","True"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L63-L72","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"toLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) List of lists","docstring_summary":"O(m*n) List of lists","docstring_tokens":["O","(","m","*","n",")","List","of","lists"],"function":"toLists = MG.toLists","function_tokens":["toLists","=","MG","toLists"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L185-L185","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/IORef.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L act -> do\n      ref <- StateC (ask @(IORef s))\n      (<$ ctx) <$> case act of\n        Put s -> liftIO (writeIORef ref s)\n        Get   -> liftIO (readIORef ref)\n    R other -> StateC (alg (runStateC . hdl) (R other) ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","act","->","do","ref","<-","StateC","(","ask","@","(","IORef","s",")",")","(","<$","ctx",")","<$>","case","act","of","Put","s","->","liftIO","(","writeIORef","ref","s",")","Get","->","liftIO","(","readIORef","ref",")","R","other","->","StateC","(","alg","(","runStateC",".","hdl",")","(","R","other",")","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/IORef.hs#L100-L107","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/IORef.hs","hash_val":53014,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"freeText","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeText = undefined","function_tokens":["freeText","=","undefined"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L99-L99","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unzip6","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip6 m = ( MG.fromVector d v1\n           , MG.fromVector d v2\n           , MG.fromVector d v3\n           , MG.fromVector d v4\n           , MG.fromVector d v5\n           , MG.fromVector d v6\n           )\n  where\n    d = MG.dim m\n    (v1, v2, v3, v4, v5, v6) = G.unzip6 $ MG.flatten m","function_tokens":["unzip6","m","=","(","MG","fromVector","d","v1",",","MG","fromVector","d","v2",",","MG","fromVector","d","v3",",","MG","fromVector","d","v4",",","MG","fromVector","d","v5",",","MG","fromVector","d","v6",")","where","d","=","MG","dim","m","(","v1",",","v2",",","v3",",","v4",",","v5",",","v6",")","=","G","unzip6","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L583-L593","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L358-L358","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"offset'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"offset' = offset + i * tda + j","function_tokens":["offset'","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L205-L205","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/IORef.hs","language":"haskell","identifier":"evalState","parameters":"s x","argument_list":"","return_statement":"","docstring":"Run a 'State' effect, yielding the result value and discarding the final state.  @ 'evalState' s m = 'fmap' 'snd' ('runState' s m) @  @since 1.1.2.0","docstring_summary":"Run a 'State' effect, yielding the result value and discarding the final state.","docstring_tokens":["Run","a","State","effect","yielding","the","result","value","and","discarding","the","final","state","."],"function":"evalState s x = do\n  ref <- liftIO $ newIORef s\n  runReader ref . runStateC $ x","function_tokens":["evalState","s","x","=","do","ref","<-","liftIO","$","newIORef","s","runReader","ref",".","runStateC","$","x"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/IORef.hs#L79-L82","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/IORef.hs","hash_val":53014,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"izipWith5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith5 = MG.izipWith5","function_tokens":["izipWith5","=","MG","izipWith5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L301-L301","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = MG.cols m1","function_tokens":["c","=","MG","cols","m1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L423-L423","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"prettyLines","parameters":"Conflict{cMarkers, cMarkerEnd, cBodies}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyLines Conflict{cMarkers, cMarkerEnd, cBodies} =\n    concat ((:) <$> (snd <$> cMarkers) <*> cBodies) <> [snd cMarkerEnd]","function_tokens":["prettyLines","Conflict","{","cMarkers",",","cMarkerEnd",",","cBodies","}","=","concat","(","(",":",")","<$>","(","snd","<$>","cMarkers",")","<*>","cBodies",")","<>","[","snd","cMarkerEnd","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L49-L50","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"bench\/Main.hs","language":"haskell","identifier":"where","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"where x = foldl (>>>) (var (+1)) $ replicate (n - 1) $ var (+1)","function_tokens":["where","x","=","foldl","(",">>>",")","(","var","(","+","1",")",")","$","replicate","(","n","-","1",")","$","var","(","+","1",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/bench\/Main.hs#L28-L28","hash_key":"schell\/varying:bench\/Main.hs","hash_val":49067,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"exclude","parameters":"keys","argument_list":"","return_statement":"","docstring":"^ Exclude fields from document in label list","docstring_summary":"^ Exclude fields from document in label list","docstring_tokens":["^","Exclude","fields","from","document","in","label","list"],"function":"exclude keys = filter (\\(k := _) -> notElem k keys)","function_tokens":["exclude","keys","=","filter","(","\\","(","k",":=","_",")","->","notElem","k","keys",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L121-L121","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fresh\/Strict.hs","language":"haskell","identifier":"evalFresh","parameters":"n (FreshC m)","argument_list":"","return_statement":"","docstring":"Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.  @ 'evalFresh' n ('pure' a) = 'pure' a @ @ 'evalFresh' n 'fresh' = 'pure' n @  @since 1.0.0.0","docstring_summary":"Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.","docstring_tokens":["Run","a","Fresh","effect","counting","up","from","an","initial","value","and","forgetting","the","final","value","."],"function":"evalFresh n (FreshC m) = evalState n m","function_tokens":["evalFresh","n","(","FreshC","m",")","=","evalState","n","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fresh\/Strict.hs#L55-L55","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fresh\/Strict.hs","hash_val":46850,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"go","parameters":"n' xss v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go n' xss v = foldM_ f 0 xss >> return v\n      where\n        f !cr xs = do (r', _) <- foldM g (0, 0) xs\n                      return $ cr + r'\n          where\n            g (!maxR, !cc) x = do\n                let (r,c) = MG.dim x\n                    vec = MG.flatten x\n                    step i u = do\n                        GM.unsafeWrite v ((cr + i `div` c) * n' + i `mod` c + cc) u\n                        return (i+1)\n                G.foldM'_ step (0::Int) vec\n                return (max maxR r, cc + c)\n    -- figure out the dimension of the new matrix","function_tokens":["go","n'","xss","v","=","foldM_","f","0","xss",">>","return","v","where","f","cr","xs","=","do","(","r'",",","_",")","<-","foldM","g","(","0",",","0",")","xs","return","$","cr","+","r'","where","g","(","maxR",",","cc",")","x","=","do","let","(","r",",","c",")","=","MG","dim","x","vec","=","MG","flatten","x","step","i","u","=","do","GM","unsafeWrite","v","(","(","cr","+","i","`","div","`","c",")","*","n'","+","i","`","mod","`","c","+","cc",")","u","return","(","i","+","1",")","G","foldM'_","step","(","0","::","Int",")","vec","return","(","max","maxR","r",",","cc","+","c",")","-- figure out the dimension of the new matrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L248-L262","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"lnat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lnat   = natural lexer","function_tokens":["lnat","=","natural","lexer"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L129-L129","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"fromEnabled","parameters":"(Language.EnableExtension x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromEnabled (Language.EnableExtension x) = x","function_tokens":["fromEnabled","(","Language","EnableExtension","x",")","=","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L86-L86","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"numerically","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"numerically = liftA2 (+) (L.ask @1) (L.ask @2)","function_tokens":["numerically","=","liftA2","(","+",")","(","L","ask","@","1",")","(","L","ask","@","2",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L33-L33","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Float x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Float x) = Just (round x)","function_tokens":["cast'","(","Float","x",")","=","Just","(","round","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L364-L364","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (False:ts) depth valid (Split left right)","argument_list":"","return_statement":"","docstring":"If the bit is a 0, go left","docstring_summary":"If the bit is a 0, go left","docstring_tokens":["If","the","bit","is","a","0","go","left"],"function":"go (i:is) (False:ts) depth valid (Split left right) =\n               let new = go is ts (depth + 1) (valid && not i) left\n               in  Split new right","function_tokens":["go","(","i",":","is",")","(","False",":","ts",")","depth","valid","(","Split","left","right",")","=","let","new","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left","in","Split","new","right"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L50-L52","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"llex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"llex   = lexeme lexer","function_tokens":["llex","=","lexeme","lexer"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L128-L128","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(new, val) = go is ts (depth + 1) (valid && i) right","function_tokens":["(","new",",","val",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L79-L79","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"counter","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"counter = unsafePerformIO (newIORef 0)","function_tokens":["counter","=","unsafePerformIO","(","newIORef","0",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L466-L466","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"styleSheetDirective","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"styleSheetDirective = mzero","function_tokens":["styleSheetDirective","=","mzero"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L85-L85","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"rightCount","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rightCount =\n                    case (mCount, post) of\n                    (Just{}, x:_) -> c \/= x\n                    _ -> True","function_tokens":["rightCount","=","case","(","mCount",",","post",")","of","(","Just","{","}",",","x",":","_",")","->","c","\/=","x","_","->","True"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L67-L72","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"findClosest","parameters":"(NodeTree idStruct elem) id n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findClosest (NodeTree idStruct elem) id n =\n    let targetStruct = toByteStruct id\n    in go idStruct targetStruct elem n\n    where -- This function is partial for the same reason as in modifyAt\n          --\n          -- Take the n closest nodes\n          go _ _ (Bucket (nodes, _)) n\n            | length nodes <= n = map fst nodes\n            | otherwise = take n . sortByDistanceTo (map fst nodes) $ id\n          -- Take the closest nodes from the left child first, if those aren't\n          -- enough, take the rest from the right\n          go (i:is) (False:ts) (Split left right) n =\n            let result = go is ts left n\n            in if length result == n\n                then result\n                else result ++ go is ts right n\n          -- Take the closest nodes from the right child first, if those aren't\n          -- enough, take the rest from the left\n          go (i:is) (True:ts) (Split left right) n =\n            let result = go is ts right n\n            in if length result == n\n                then result\n                else result ++ go is ts left n\n\n-- Extract original Id from NodeTree","function_tokens":["findClosest","(","NodeTree","idStruct","elem",")","id","n","=","let","targetStruct","=","toByteStruct","id","in","go","idStruct","targetStruct","elem","n","where","-- This function is partial for the same reason as in modifyAt","--","-- Take the n closest nodes","go","_","_","(","Bucket","(","nodes",",","_",")",")","n","|","length","nodes","<=","n","=","map","fst","nodes","|","otherwise","=","take","n",".","sortByDistanceTo","(","map","fst","nodes",")","$","id","-- Take the closest nodes from the left child first, if those aren't","-- enough, take the rest from the right","go","(","i",":","is",")","(","False",":","ts",")","(","Split","left","right",")","n","=","let","result","=","go","is","ts","left","n","in","if","length","result","==","n","then","result","else","result","++","go","is","ts","right","n","-- Take the closest nodes from the right child first, if those aren't","-- enough, take the rest from the left","go","(","i",":","is",")","(","True",":","ts",")","(","Split","left","right",")","n","=","let","result","=","go","is","ts","right","n","in","if","length","result","==","n","then","result","else","result","++","go","is","ts","left","n","-- Extract original Id from NodeTree"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L189-L214","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"i [] (l : ls)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go i [] (l : ls) = l : go (i + 1) (editsFor $ i + 1) ls","function_tokens":["go","i","[","]","(","l",":","ls",")","=","l",":","go","(","i","+","1",")","(","editsFor","$","i","+","1",")","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L176-L176","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"deleted","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleted = filter (not . idMatches id . fst) $ nodes","function_tokens":["deleted","=","filter","(","not",".","idMatches","id",".","fst",")","$","nodes"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L111-L111","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"forM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM = flip mapM","function_tokens":["forM","=","flip","mapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L322-L322","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"bench\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"IO ()\nmain = do\n    let run v a = runIdentity (fst <$> runVarT v a)\n    defaultMain [ bgroup \"runVarT\" [ bench \"1\" $ nf (run $ chain 1) 0\n                                   , bench \"2\" $ nf (run $ chain 2) 0\n                                   , bench \"4\" $ nf (run $ chain 4) 0\n                                   , bench \"8\" $ nf (run $ chain 8) 0\n                                   , bench \"16\" $ nf (run $ chain 16) 0\n                                   , bench \"32\" $ nf (run $ chain 32) 0\n                                   , bench \"64\" $ nf (run $ chain 64) 0\n                                   , bench \"128\" $ nf (run $ chain 128) 0\n                                   ]\n                , bgroup \"TweenT\"\n                    [ bench \"tweenStream\" $\n                        nf (run $ tweenStream myTween 0) 0\n                    ]\n                ]\n    return ()","function_tokens":["IO","(",")","main","=","do","let","run","v","a","=","runIdentity","(","fst","<$>","runVarT","v","a",")","defaultMain","[","bgroup","\"runVarT\"","[","bench","\"1\"","$","nf","(","run","$","chain","1",")","0",",","bench","\"2\"","$","nf","(","run","$","chain","2",")","0",",","bench","\"4\"","$","nf","(","run","$","chain","4",")","0",",","bench","\"8\"","$","nf","(","run","$","chain","8",")","0",",","bench","\"16\"","$","nf","(","run","$","chain","16",")","0",",","bench","\"32\"","$","nf","(","run","$","chain","32",")","0",",","bench","\"64\"","$","nf","(","run","$","chain","64",")","0",",","bench","\"128\"","$","nf","(","run","$","chain","128",")","0","]",",","bgroup","\"TweenT\"","[","bench","\"tweenStream\"","$","nf","(","run","$","tweenStream","myTween","0",")","0","]","]","return","(",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/bench\/Main.hs#L7-L26","hash_key":"schell\/varying:bench\/Main.hs","hash_val":49067,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unzip4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip4 = MG.unzip4","function_tokens":["unzip4","=","MG","unzip4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L357-L357","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"fr","parameters":"c vb","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fr c vb = runSplineT vb >=> \\case\n          Left d         -> r c d\n          Right (b, vb1) -> return $ Right (b, SplineT $ fr c vb1)","function_tokens":["fr","c","vb","=","runSplineT","vb",">=>","\\","case","Left","d","->","r","c","d","Right","(","b",",","vb1",")","->","return","$","Right","(","b",",","SplineT","$","fr","c","vb1",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L297-L301","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"lstr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lstr   = stringLiteral lexer","function_tokens":["lstr","=","stringLiteral","lexer"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L130-L130","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = StateC $ \\ k s -> case sig of\n    L Get     -> k s (s <$ ctx)\n    L (Put s) -> k s       ctx\n    R other   -> thread (uncurry (runState (curry pure)) ~<~ hdl) other (s, ctx) >>= uncurry k","function_tokens":["alg","hdl","sig","ctx","=","StateC","$","\\","k","s","->","case","sig","of","L","Get","->","k","s","(","s","<$","ctx",")","L","(","Put","s",")","->","k","s","ctx","R","other","->","thread","(","uncurry","(","runState","(","curry","pure",")",")","~<~","hdl",")","other","(","s",",","ctx",")",">>=","uncurry","k"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L125-L129","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"imapM","parameters":"f m@(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","yielding","a","matrix","of","results","."],"function":"imapM f m@(Matrix r c _ _ _) = fmap (MG.fromVector (r,c)) $ G.imapM f' $\n    MG.flatten m\n  where\n    f' i = f (i `divMod` c)","function_tokens":["imapM","f","m","@","(","Matrix","r","c","_","_","_",")","=","fmap","(","MG","fromVector","(","r",",","c",")",")","$","G","imapM","f'","$","MG","flatten","m","where","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L301-L305","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L340-L340","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bench\/Main.hs","language":"haskell","identifier":"fib","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fib n = fib (n-1) + fib (n-2)","function_tokens":["fib","n","=","fib","(","n","-","1",")","+","fib","(","n","-","2",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bench\/Main.hs#L11-L11","hash_key":"knupfer\/chronos:bench\/Main.hs","hash_val":48994,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"findCabalFile","parameters":"verbose","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Find the closest .cabal file, possibly going up the directory structure.","docstring_summary":"------------------------------------------------------------------------------ Find the closest .cabal file, possibly going up the directory structure.","docstring_tokens":["------------------------------------------------------------------------------","Find","the","closest",".","cabal","file","possibly","going","up","the","directory","structure","."],"function":"findCabalFile verbose = do\n  potentialProjectRoots <- ancestors <$> getCurrentDirectory\n  potentialCabalFile <- filter isRight <$>\n    traverse Cabal.findPackageDesc potentialProjectRoots\n  case potentialCabalFile of\n    [Right cabalFile] -> return (Just cabalFile)\n    _ -> do\n      verbose $ \".cabal file not found, directories searched: \" <>\n        show potentialProjectRoots\n      verbose $ \"Stylish Haskell will work basing on LANGUAGE pragmas in source files.\"\n      return Nothing\n\n\n--------------------------------------------------------------------------------\n-- | Extract @default-extensions@ fields from a @.cabal@ file","function_tokens":["findCabalFile","verbose","=","do","potentialProjectRoots","<-","ancestors","<$>","getCurrentDirectory","potentialCabalFile","<-","filter","isRight","<$>","traverse","Cabal","findPackageDesc","potentialProjectRoots","case","potentialCabalFile","of","[","Right","cabalFile","]","->","return","(","Just","cabalFile",")","_","->","do","verbose","$","\".cabal file not found, directories searched: \"","<>","show","potentialProjectRoots","verbose","$","\"Stylish Haskell will work basing on LANGUAGE pragmas in source files.\"","return","Nothing","--------------------------------------------------------------------------------","-- | Extract @default-extensions@ fields from a @.cabal@ file"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L34-L49","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"fork","parameters":"doFork","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Utils ------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------ Utils ------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------","Utils","------------------------------------------------------------------------------"],"function":"fork doFork = \\a -> do\n  res <- newEmptyMVar\n  tid <- mask $ \\restore -> doFork $ try (restore a) >>= putMVar res\n  return (tid, readMVar res)","function_tokens":["fork","doFork","=","\\","a","->","do","res","<-","newEmptyMVar","tid","<-","mask","$","\\","restore","->","doFork","$","try","(","restore","a",")",">>=","putMVar","res","return","(","tid",",","readMVar","res",")"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L118-L123","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"outputStream","parameters":"(SplineT s0) b0","argument_list":"","return_statement":"","docstring":"Permute a spline into one continuous stream. Since a spline is not guaranteed to be defined over any domain (specifically on its edges), this function takes a default value to use as the \"last known value\".  >>> :{ let s :: SplineT () String IO () s = do first <- pure \"accumulating until 3\" `_untilEvent` (1 >>> after 3) secnd <- pure \"accumulating until 4\" `_untilEvent` (1 >>> after 4) if first + secnd == 7 then step \"done\" else step \"something went wrong!\" v = outputStream s \"\" in testVarOver v $ replicate 6 () >>> :} \"accumulating until 3\" \"accumulating until 3\" \"accumulating until 4\" \"accumulating until 4\" \"accumulating until 4\" \"done\"","docstring_summary":"Permute a spline into one continuous stream. Since a spline is not guaranteed to be defined over any domain (specifically on its edges), this function takes a default value to use as the \"last known value\".  >>> :{ let s :: SplineT () String IO () s = do first <- pure \"accumulating until 3\" `_untilEvent` (1 >>> after 3) secnd <- pure \"accumulating until 4\" `_untilEvent` (1 >>> after 4) if first + secnd == 7 then step \"done\" else step \"something went wrong!\" v = outputStream s \"\" in testVarOver v $ replicate 6 () >>> :} \"accumulating until 3\" \"accumulating until 3\" \"accumulating until 4\" \"accumulating until 4\" \"accumulating until 4\" \"done\"","docstring_tokens":["Permute","a","spline","into","one","continuous","stream",".","Since","a","spline","is","not","guaranteed","to","be","defined","over","any","domain","(","specifically","on","its","edges",")","this","function","takes","a","default","value","to","use","as","the","last","known","value",".",">>>",":","{","let","s","::","SplineT","()","String","IO","()","s","=","do","first","<","-","pure","accumulating","until","3","_untilEvent","(","1",">>>","after","3",")","secnd","<","-","pure","accumulating","until","4","_untilEvent","(","1",">>>","after","4",")","if","first","+","secnd","==","7","then","step","done","else","step","something","went","wrong!","v","=","outputStream","s","in","testVarOver","v","$","replicate","6","()",">>>",":","}","accumulating","until","3","accumulating","until","3","accumulating","until","4","accumulating","until","4","accumulating","until","4","done"],"function":"outputStream (SplineT s0) b0 = VarT $ f s0 b0\n  where f s b a = do e <- s a\n                     case e of\n                       Left  _                -> return (b, done b)\n                       Right (b1, SplineT s1) -> return (b1, VarT $ f s1 b1)\n\n-- | Run the spline over the input values, gathering the output values in a\n-- list.","function_tokens":["outputStream","(","SplineT","s0",")","b0","=","VarT","$","f","s0","b0","where","f","s","b","a","=","do","e","<-","s","a","case","e","of","Left","_","->","return","(","b",",","done","b",")","Right","(","b1",",","SplineT","s1",")","->","return","(","b1",",","VarT","$","f","s1","b1",")","-- | Run the spline over the input values, gathering the output values in a","-- list."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L165-L173","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"sendProcess","parameters":"sock id chan","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sendProcess sock id chan = (withSocketsDo . forever $ do\n    (cmd, Peer host port) <- readChan chan\n\n    -- Get Peer's address\n    (peeraddr:_) <- getAddrInfo Nothing (Just host)\n                      (Just . show . fromIntegral $ port)\n\n    -- Send the signal\n    let sig = serialize id cmd\n    S.sendTo sock sig (addrAddress peeraddr))\n        -- Close socket on exception (ThreadKilled)\n        `finally` sClose sock","function_tokens":["sendProcess","sock","id","chan","=","(","withSocketsDo",".","forever","$","do","(","cmd",",","Peer","host","port",")","<-","readChan","chan","-- Get Peer's address","(","peeraddr",":","_",")","<-","getAddrInfo","Nothing","(","Just","host",")","(","Just",".","show",".","fromIntegral","$","port",")","-- Send the signal","let","sig","=","serialize","id","cmd","S","sendTo","sock","sig","(","addrAddress","peeraddr",")",")","-- Close socket on exception (ThreadKilled)","`","finally","`","sClose","sock"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L65-L76","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unzip","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip m = (MG.fromVector d v1, MG.fromVector d v2)\n  where\n    d = MG.dim m\n    (v1, v2) = G.unzip $ MG.flatten m","function_tokens":["unzip","m","=","(","MG","fromVector","d","v1",",","MG","fromVector","d","v2",")","where","d","=","MG","dim","m","(","v1",",","v2",")","=","G","unzip","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L538-L542","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"untilProc","parameters":"ve","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"untilProc ve = SplineT $ runVarT ve >=> return . \\case\n  (Just b,    _) -> Left b\n  (Nothing, ve1) -> Right (Nothing, untilProc ve1)\n\n-- | Create a spline from an event stream. Outputs @b@ until the event stream\n-- inhibits, at which point the spline concludes with @()@.","function_tokens":["untilProc","ve","=","SplineT","$","runVarT","ve",">=>","return",".","\\","case","(","Just","b",",","_",")","->","Left","b","(","Nothing",",","ve1",")","->","Right","(","Nothing",",","untilProc","ve1",")","-- | Create a spline from an event stream. Outputs @b@ until the event stream","-- inhibits, at which point the spline concludes with @()@."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L188-L194","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"_ _ depth valid (Bucket b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ _ depth valid (Bucket b) = f depth valid b","function_tokens":["go","_","_","depth","valid","(","Bucket","b",")","=","f","depth","valid","b"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L90-L90","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"i (CBlock n f : _cs) ls","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go i (CBlock n f : _cs) ls =\n        let (domain, ls') = splitAt n ls in\n        f domain ++ go (i + n) (editsFor $ i + n) ls'","function_tokens":["go","i","(","CBlock","n","f",":","_cs",")","ls","=","let","(","domain",",","ls'",")","=","splitAt","n","ls","in","f","domain","++","go","(","i","+","n",")","(","editsFor","$","i","+","n",")","ls'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L178-L180","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _ = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L275-L275","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"g","parameters":"(!maxR, !cc) x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g (!maxR, !cc) x = do\n                let (r,c) = MG.dim x\n                    vec = MG.flatten x\n                    step i u = do\n                        GM.unsafeWrite v ((cr + i `div` c) * n' + i `mod` c + cc) u\n                        return (i+1)\n                G.foldM'_ step (0::Int) vec\n                return (max maxR r, cc + c)\n    -- figure out the dimension of the new matrix","function_tokens":["g","(","maxR",",","cc",")","x","=","do","let","(","r",",","c",")","=","MG","dim","x","vec","=","MG","flatten","x","step","i","u","=","do","GM","unsafeWrite","v","(","(","cr","+","i","`","div","`","c",")","*","n'","+","i","`","mod","`","c","+","cc",")","u","return","(","i","+","1",")","G","foldM'_","step","(","0","::","Int",")","vec","return","(","max","maxR","r",",","cc","+","c",")","-- figure out the dimension of the new matrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L253-L262","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"valMaybe","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"valMaybe = maybe Null val","function_tokens":["valMaybe","=","maybe","Null","val"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L221-L221","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"parseSort","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseSort = choice [ bool, int, array ] <?> \"Sort\" where\n        bool  = string \"bool\" $> DynamicSort SBooleanSort\n        int   = string \"int\"  $> DynamicSort SIntegralSort\n        array = array' <$> (string \"array\" *> space *> sort') <*> (space *> sort')\n\n        sort' = choice [ bool, int, char '(' *> array <* char ')' ]\n\n        array' :: DynamicSort -> DynamicSort -> DynamicSort\n        array' (DynamicSort i) (DynamicSort e) = DynamicSort (SArraySort i e)","function_tokens":["parseSort","=","choice","[","bool",",","int",",","array","]","<?>","\"Sort\"","where","bool","=","string","\"bool\"","$>","DynamicSort","SBooleanSort","int","=","string","\"int\"","$>","DynamicSort","SIntegralSort","array","=","array'","<$>","(","string","\"array\"","*>","space","*>","sort'",")","<*>","(","space","*>","sort'",")","sort'","=","choice","[","bool",",","int",",","char","'('","*>","array","<*","char","')'","]","array'","::","DynamicSort","->","DynamicSort","->","DynamicSort","array'","(","DynamicSort","i",")","(","DynamicSort","e",")","=","DynamicSort","(","SArraySort","i","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L125-L133","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"liftIO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO = ReaderC . const . liftIO","function_tokens":["liftIO","=","ReaderC",".","const",".","liftIO"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L87-L87","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"diag","parameters":"d","argument_list":"","return_statement":"","docstring":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_summary":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_tokens":["O","(","m","*","n",")","Create","a","square","matrix","with","given","diagonal","other","entries","default","to","0"],"function":"diag d = diagRect 0 (n,n) d\n  where n = length . F.toList $ d","function_tokens":["diag","d","=","diagRect","0","(","n",",","n",")","d","where","n","=","length",".","F","toList","$","d"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L224-L226","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (True:ts) depth valid (Split _ right)","argument_list":"","return_statement":"","docstring":"Otherwise, continue to the right","docstring_summary":"Otherwise, continue to the right","docstring_tokens":["Otherwise","continue","to","the","right"],"function":"go (i:is) (True:ts) depth valid (Split _ right) =\n               go is ts (depth + 1) (valid && i) right","function_tokens":["go","(","i",":","is",")","(","True",":","ts",")","depth","valid","(","Split","_","right",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L95-L96","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"g","parameters":"j","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g j = m MG.! (i,j) == m MG.! (j,i)","function_tokens":["g","j","=","m","MG","!","(","i",",","j",")","==","m","MG","!","(","j",",","i",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L271-L271","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"execState","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'State' effect, yielding the final state and discarding the return value.  @ 'execState' = 'runState' ('const' '.' 'pure') @  @since 1.1.0.0","docstring_summary":"Run a 'State' effect, yielding the final state and discarding the return value.","docstring_tokens":["Run","a","State","effect","yielding","the","final","state","and","discarding","the","return","value","."],"function":"execState = runState (const . pure)","function_tokens":["execState","=","runState","(","const",".","pure",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L70-L70","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"pure","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure = ReaderC . const . pure","function_tokens":["pure","=","ReaderC",".","const",".","pure"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L51-L51","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"include","parameters":"keys doc","argument_list":"","return_statement":"","docstring":"^ Only include fields of document in label list","docstring_summary":"^ Only include fields of document in label list","docstring_tokens":["^","Only","include","fields","of","document","in","label","list"],"function":"include keys doc = mapMaybe (\\k -> find ((k ==) . label) doc) keys","function_tokens":["include","keys","doc","=","mapMaybe","(","\\","k","->","find","(","(","k","==",")",".","label",")","doc",")","keys"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L117-L117","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"adjust","parameters":"_ _ _ (CBlock n f)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"adjust _ _ _ (CBlock n f) = CBlock n f","function_tokens":["adjust","_","_","_","(","CBlock","n","f",")","=","CBlock","n","f"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L186-L186","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"needsSplit","parameters":"depth valid (nodes, _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"needsSplit depth valid (nodes, _) =\n            let maxDepth = (length . toByteStruct . nodeId $ node) - 1\n            in  -- A new node will be inserted\n                node `notElem` map fst nodes &&\n                -- The bucket is full\n                length nodes >= 7 &&\n                -- The bucket may be split\n                (depth < 5 || valid) && depth <= maxDepth","function_tokens":["needsSplit","depth","valid","(","nodes",",","_",")","=","let","maxDepth","=","(","length",".","toByteStruct",".","nodeId","$","node",")","-","1","in","-- A new node will be inserted","node","`","notElem","`","map","fst","nodes","&&","-- The bucket is full","length","nodes",">=","7","&&","-- The bucket may be split","(","depth","<","5","||","valid",")","&&","depth","<=","maxDepth"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L148-L155","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show","parameters":"s@BooleanSort","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show s@BooleanSort   = show' s","function_tokens":["show","s","@","BooleanSort","=","show'","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L68-L68","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"extractId","parameters":"(NodeTree id _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"extractId (NodeTree id _) = fromByteStruct id","function_tokens":["extractId","(","NodeTree","id","_",")","=","fromByteStruct","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L215-L215","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"show","parameters":"edits","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show edits = unlines $ do\n        (line, changes) <- M.toAscList $ unEdits edits\n        prettyChange line <$> changes\n\n\n--------------------------------------------------------------------------------","function_tokens":["show","edits","=","unlines","$","do","(","line",",","changes",")","<-","M","toAscList","$","unEdits","edits","prettyChange","line","<$>","changes","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L83-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"informationField","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"informationField = do\n    letter\n    char ':'\n    -- TODO anything not \\n\n    char '\\n'              \n    return undefined\n\n-- Not parsed, see Limitations","function_tokens":["informationField","=","do","letter","char","':'","-- TODO anything not \\n","char","'\\n'","return","undefined","-- Not parsed, see Limitations"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L76-L84","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"mergeAdjacent","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeAdjacent []             = []","function_tokens":["mergeAdjacent","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L96-L96","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val               = UserDef","function_tokens":["val","=","UserDef"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L309-L309","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"bs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bs = toByteStruct . nodeId . f $ n","function_tokens":["bs","=","toByteStruct",".","nodeId",".","f","$","n"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L180-L180","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,c) = MG.dim x","function_tokens":["(","r",",","c",")","=","MG","dim","x"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L254-L254","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"readUpToMarker","parameters":"c mCount","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readUpToMarker c mCount = do\n    res <- tryReadUpToMarker c mCount\n    case res of\n        (ls, Just h)  -> pure (ls, h)\n        (ls, Nothing) ->\n            error $ concat\n            [ \"Parse error: failed reading up to marker: \"\n            , show c, \", got:\"\n            , concatMap (\\(l,s) -> \"\\n\" ++ show l ++ \"\\t\" ++ s) $ take 5 ls\n            ]","function_tokens":["readUpToMarker","c","mCount","=","do","res","<-","tryReadUpToMarker","c","mCount","case","res","of","(","ls",",","Just","h",")","->","pure","(","ls",",","h",")","(","ls",",","Nothing",")","->","error","$","concat","[","\"Parse error: failed reading up to marker: \"",",","show","c",",","\", got:\"",",","concatMap","(","\\","(","l",",","s",")","->","\"\\n\"","++","show","l","++","\"\\t\"","++","s",")","$","take","5","ls","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L87-L98","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWith5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith5 = MG.zipWith5","function_tokens":["zipWith5","=","MG","zipWith5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L276-L276","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Sum.hs","language":"haskell","identifier":"reassociateSumL","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reassociateSumL = \\case\n  L l     -> L (L l)\n  R (L l) -> L (R l)\n  R (R r) -> R r","function_tokens":["reassociateSumL","=","\\","case","L","l","->","L","(","L","l",")","R","(","L","l",")","->","L","(","R","l",")","R","(","R","r",")","->","R","r"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Sum.hs#L74-L78","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Sum.hs","hash_val":46968,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"lname","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lname  = identifier lexer","function_tokens":["lname","=","identifier","lexer"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L131-L131","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"changeLine","parameters":"start f","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"changeLine start f = changeLines (Block start start) $ \\ls -> case ls of\n    l : _ -> f l\n    _     -> f \"\"\n\n\n--------------------------------------------------------------------------------","function_tokens":["changeLine","start","f","=","changeLines","(","Block","start","start",")","$","\\","ls","->","case","ls","of","l",":","_","->","f","l","_","->","f","\"\"","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L119-L125","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"subMatrix","parameters":"(i,j) (i',j') (Matrix _ _ tda offset vec)","argument_list":"","return_statement":"","docstring":"O(1) Extract sub matrix","docstring_summary":"O(1) Extract sub matrix","docstring_tokens":["O","(","1",")","Extract","sub","matrix"],"function":"subMatrix (i,j) (i',j') (Matrix _ _ tda offset vec)\n    | m' <= 0 || n' <= 0 = MG.empty\n    | otherwise = Matrix m' n' tda offset' vec\n  where\n    m' = i' - i + 1\n    n' = j' - j + 1\n    offset' = offset + i * tda + j","function_tokens":["subMatrix","(","i",",","j",")","(","i'",",","j'",")","(","Matrix","_","_","tda","offset","vec",")","|","m'","<=","0","||","n'","<=","0","=","MG","empty","|","otherwise","=","Matrix","m'","n'","tda","offset'","vec","where","m'","=","i'","-","i","+","1","n'","=","j'","-","j","+","1","offset'","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L199-L206","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L372-L372","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"bench\/Main.hs","language":"haskell","identifier":"run","parameters":"v a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"run v a = runIdentity (fst <$> runVarT v a)","function_tokens":["run","v","a","=","runIdentity","(","fst","<$>","runVarT","v","a",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/bench\/Main.hs#L9-L9","hash_key":"schell\/varying:bench\/Main.hs","hash_val":49067,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val           = Fun","function_tokens":["val","=","Fun"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L294-L294","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"toList","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a list by concatenating rows","docstring_summary":"O(m*n) Create a list by concatenating rows","docstring_tokens":["O","(","m","*","n",")","Create","a","list","by","concatenating","rows"],"function":"toList = MG.toList","function_tokens":["toList","=","MG","toList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L181-L181","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"lexer","parameters":"","argument_list":"","return_statement":"","docstring":"----------------------------------------------------------------------------------- Lexer -----------------------------------------------------------------------------------","docstring_summary":"----------------------------------------------------------------------------------- Lexer -----------------------------------------------------------------------------------","docstring_tokens":["-----------------------------------------------------------------------------------","Lexer","-----------------------------------------------------------------------------------"],"function":"lexer = makeTokenParser $ LanguageDef {\n    commentStart    =  \"[r:\",\n    commentEnd      =  \"]\",\n    commentLine     =  \"%\",\n    nestedComments  =  False,\n    identStart      =  (letter <|> char '_'),\n    identLetter     =  (alphaNum <|> char '_'),\n    opStart         =  mzero,\n    opLetter        =  mzero,\n    reservedNames   =  reservedNames,\n    reservedOpNames =  mzero,\n    caseSensitive   =  True\n    }\n    where\n        reservedNames = []\n\n-- Convenient synonyms, not exported","function_tokens":["lexer","=","makeTokenParser","$","LanguageDef","{","commentStart","=","\"[r:\"",",","commentEnd","=","\"]\"",",","commentLine","=","\"%\"",",","nestedComments","=","False",",","identStart","=","(","letter","<|>","char","'_'",")",",","identLetter","=","(","alphaNum","<|>","char","'_'",")",",","opStart","=","mzero",",","opLetter","=","mzero",",","reservedNames","=","reservedNames",",","reservedOpNames","=","mzero",",","caseSensitive","=","True","}","where","reservedNames","=","[","]","-- Convenient synonyms, not exported"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L111-L128","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'List","parameters":"(Sym (Symbol x))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'List (Sym (Symbol x)) = Just $ T.unpack x","function_tokens":["cast'List","(","Sym","(","Symbol","x",")",")","=","Just","$","T","unpack","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L269-L269","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"mergeChanges","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Merge in order","docstring_summary":"------------------------------------------------------------------------------ Merge in order","docstring_tokens":["------------------------------------------------------------------------------","Merge","in","order"],"function":"mergeChanges = go\n  where\n    go []       ys       = ys\n    go xs       []       = xs\n    go (x : xs) (y : ys) =\n        if x `beforeChange` y then x : go xs (y : ys) else y : go (x : xs) ys\n\n\n--------------------------------------------------------------------------------\n-- Stores sorted spans to change per line.","function_tokens":["mergeChanges","=","go","where","go","[","]","ys","=","ys","go","xs","[","]","=","xs","go","(","x",":","xs",")","(","y",":","ys",")","=","if","x","`","beforeChange","`","y","then","x",":","go","xs","(","y",":","ys",")","else","y",":","go","(","x",":","xs",")","ys","--------------------------------------------------------------------------------","-- Stores sorted spans to change per line."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L68-L78","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) = merge","function_tokens":["(","<>",")","=","merge"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L32-L32","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"izipWith6","parameters":"f m1 m2 m3 m4 m5 m6","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith6 f m1 m2 m3 m4 m5 m6\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 ||\n      MG.dim m4 \/= MG.dim m5 ||\n      MG.dim m5 \/= MG.dim m6 = error \"izipWith6: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.izipWith6 f' (MG.flatten m1) (MG.flatten m2) (MG.flatten m3)\n                  (MG.flatten m4) (MG.flatten m5) $ MG.flatten m6\n  where\n    c = MG.cols m1\n    f' i = f (i `divMod` c)","function_tokens":["izipWith6","f","m1","m2","m3","m4","m5","m6","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","||","MG","dim","m4","\/=","MG","dim","m5","||","MG","dim","m5","\/=","MG","dim","m6","=","error","\"izipWith6: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","izipWith6","f'","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","(","MG","flatten","m4",")","(","MG","flatten","m5",")","$","MG","flatten","m6","where","c","=","MG","cols","m1","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L449-L461","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'List","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'List v = case v of\n                 Doc x -> Just x\n                 _     -> Nothing","function_tokens":["cast'List","v","=","case","v","of","Doc","x","->","Just","x","_","->","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L276-L280","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Float x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Float x) = Just (round x)","function_tokens":["cast'","(","Float","x",")","=","Just","(","round","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L371-L371","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"mergeAdjacent","parameters":"(a : rest)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeAdjacent (a : rest)     = a : mergeAdjacent rest","function_tokens":["mergeAdjacent","(","a",":","rest",")","=","a",":","mergeAdjacent","rest"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L95-L95","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWith3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith3 = MG.zipWith3","function_tokens":["zipWith3","=","MG","zipWith3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L266-L266","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int64 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int64 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int64","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L378-L378","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"readDefaultLanguageExtensions","parameters":"verbose cabalFile","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readDefaultLanguageExtensions verbose cabalFile = do\n  verbose $ \"Parsing \" <> cabalFile <> \"...\"\n  packageDescription <- Cabal.readGenericPackageDescription Cabal.silent cabalFile\n  let library :: [Cabal.Library]\n      library = maybeToList $ fst . Cabal.ignoreConditions <$>\n        Cabal.condLibrary packageDescription\n\n      subLibraries :: [Cabal.Library]\n      subLibraries = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condSubLibraries packageDescription\n\n      executables :: [Cabal.Executable]\n      executables = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condExecutables packageDescription\n\n      testSuites :: [Cabal.TestSuite]\n      testSuites = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condTestSuites packageDescription\n\n      benchmarks :: [Cabal.Benchmark]\n      benchmarks = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condBenchmarks packageDescription\n\n      gatherBuildInfos :: [Cabal.BuildInfo]\n      gatherBuildInfos = map Cabal.libBuildInfo library <>\n                         map Cabal.libBuildInfo subLibraries <>\n                         map Cabal.buildInfo executables <>\n                         map Cabal.testBuildInfo testSuites <>\n                         map Cabal.benchmarkBuildInfo benchmarks\n\n      defaultExtensions :: [Language.KnownExtension]\n      defaultExtensions = map fromEnabled . filter isEnabled $\n        concatMap Cabal.defaultExtensions gatherBuildInfos\n        where isEnabled (Language.EnableExtension _) = True\n              isEnabled _                            = False\n\n              fromEnabled (Language.EnableExtension x) = x\n              fromEnabled x                             =\n                error $ \"Language.Haskell.Stylish.Config.readLanguageExtensions: \" <>\n                        \"invalid LANGUAGE pragma:  \" <> show x\n  verbose $ \"Gathered default-extensions: \" <> show defaultExtensions\n  pure $ nub defaultExtensions","function_tokens":["readDefaultLanguageExtensions","verbose","cabalFile","=","do","verbose","$","\"Parsing \"","<>","cabalFile","<>","\"...\"","packageDescription","<-","Cabal","readGenericPackageDescription","Cabal","silent","cabalFile","let","library","::","[","Cabal","Library","]","library","=","maybeToList","$","fst",".","Cabal","ignoreConditions","<$>","Cabal","condLibrary","packageDescription","subLibraries","::","[","Cabal","Library","]","subLibraries","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condSubLibraries","packageDescription","executables","::","[","Cabal","Executable","]","executables","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condExecutables","packageDescription","testSuites","::","[","Cabal","TestSuite","]","testSuites","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condTestSuites","packageDescription","benchmarks","::","[","Cabal","Benchmark","]","benchmarks","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condBenchmarks","packageDescription","gatherBuildInfos","::","[","Cabal","BuildInfo","]","gatherBuildInfos","=","map","Cabal","libBuildInfo","library","<>","map","Cabal","libBuildInfo","subLibraries","<>","map","Cabal","buildInfo","executables","<>","map","Cabal","testBuildInfo","testSuites","<>","map","Cabal","benchmarkBuildInfo","benchmarks","defaultExtensions","::","[","Language","KnownExtension","]","defaultExtensions","=","map","fromEnabled",".","filter","isEnabled","$","concatMap","Cabal","defaultExtensions","gatherBuildInfos","where","isEnabled","(","Language","EnableExtension","_",")","=","True","isEnabled","_","=","False","fromEnabled","(","Language","EnableExtension","x",")","=","x","fromEnabled","x","=","error","$","\"Language.Haskell.Stylish.Config.readLanguageExtensions: \"","<>","\"invalid LANGUAGE pragma:  \"","<>","show","x","verbose","$","\"Gathered default-extensions: \"","<>","show","defaultExtensions","pure","$","nub","defaultExtensions"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L50-L91","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"newLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newLine = string \"\\r\\n\" <|> string \"\\n\"","function_tokens":["newLine","=","string","\"\\r\\n\"","<|>","string","\"\\n\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L136-L136","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"bool","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bool  = string \"bool\" $> DynamicSort SBooleanSort","function_tokens":["bool","=","string","\"bool\"","$>","DynamicSort","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L126-L126","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"result = fromIntegral n","function_tokens":["result","=","fromIntegral","n"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L398-L398","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"_ _ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ _ [] = []","function_tokens":["go","_","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L175-L175","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"toColumns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toColumns = MG.toColumns","function_tokens":["toColumns","=","MG","toColumns"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L177-L177","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"lookup","parameters":"k doc","argument_list":"","return_statement":"","docstring":"^ Lookup value of field in document and cast to expected type. Fail (Nothing) if field not found or value not of expected type.","docstring_summary":"^ Lookup value of field in document and cast to expected type. Fail (Nothing) if field not found or value not of expected type.","docstring_tokens":["^","Lookup","value","of","field","in","document","and","cast","to","expected","type",".","Fail","(","Nothing",")","if","field","not","found","or","value","not","of","expected","type","."],"function":"lookup k doc = cast =<< look k doc","function_tokens":["lookup","k","doc","=","cast","=<<","look","k","doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L102-L102","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"example","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"example = testGroup \"Control.Effect.Labelled\"\n  [ readerExamples\n  , stateExamples\n  ]","function_tokens":["example","=","testGroup","\"Control.Effect.Labelled\"","[","readerExamples",",","stateExamples","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L75-L78","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val           = Md5","function_tokens":["val","=","Md5"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L304-L304","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(v1, v2, v3, v4, v5) = G.unzip5 $ MG.flatten m","function_tokens":["(","v1",",","v2",",","v3",",","v4",",","v5",")","=","G","unzip5","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L576-L576","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"mapM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM_ = MG.mapM_","function_tokens":["mapM_","=","MG","mapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L246-L246","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"abcFile","parameters":"","argument_list":"","return_statement":"","docstring":"----------------------------------------------------------------------------------- Parsers -----------------------------------------------------------------------------------","docstring_summary":"----------------------------------------------------------------------------------- Parsers -----------------------------------------------------------------------------------","docstring_tokens":["-----------------------------------------------------------------------------------","Parsers","-----------------------------------------------------------------------------------"],"function":"abcFile = do                      \n    -- optional byteOrderMark\n    string \"%abc\"\n    optional $ string \"-\" >> version\n    optional $ fileHeader    \n    fileBody\n    return undefined","function_tokens":["abcFile","=","do","-- optional byteOrderMark","string","\"%abc\"","optional","$","string","\"-\"",">>","version","optional","$","fileHeader","fileBody","return","undefined"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L56-L64","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"[]       ys","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go []       ys       = ys","function_tokens":["go","[","]","ys","=","ys"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L70-L70","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"f","parameters":"_ _ (nodes, cache)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f _ _ (nodes, cache) =\n              let deleted = filter (not . idMatches id . fst) $ nodes\n              in Bucket (deleted, cache)","function_tokens":["f","_","_","(","nodes",",","cache",")","=","let","deleted","=","filter","(","not",".","idMatches","id",".","fst",")","$","nodes","in","Bucket","(","deleted",",","cache",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L110-L112","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"beforeChange","parameters":"(CInsert _)   _","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Due to the function in CBlock we cannot write a lawful Ord instance, but this lets us merge-sort changes.","docstring_summary":"------------------------------------------------------------------------------ Due to the function in CBlock we cannot write a lawful Ord instance, but this lets us merge-sort changes.","docstring_tokens":["------------------------------------------------------------------------------","Due","to","the","function","in","CBlock","we","cannot","write","a","lawful","Ord","instance","but","this","lets","us","merge","-","sort","changes","."],"function":"beforeChange (CInsert _)   _             = True","function_tokens":["beforeChange","(","CInsert","_",")","_","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L49-L49","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"izipWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith = MG.izipWith","function_tokens":["izipWith","=","MG","izipWith"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L286-L286","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(Split left right)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Split left right) = go left ++ go right","function_tokens":["go","(","Split","left","right",")","=","go","left","++","go","right"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L224-L224","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"lift","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift m = StateC $ \\ k s -> m >>= k s","function_tokens":["lift","m","=","StateC","$","\\","k","s","->","m",">>=","k","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L121-L121","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"fileBody","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fileBody = (flip sepBy) emptyLine $ mzero\n    <|> fmap Tune abcTune\n    <|> fmap FreeText freeText \n    <|> fmap TypesetText typeSetText","function_tokens":["fileBody","=","(","flip","sepBy",")","emptyLine","$","mzero","<|>","fmap","Tune","abcTune","<|>","fmap","FreeText","freeText","<|>","fmap","TypesetText","typeSetText"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L70-L73","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val           = UTC . posixSecondsToUTCTime . roundTo (1\/1000)","function_tokens":["val","=","UTC",".","posixSecondsToUTCTime",".","roundTo","(","1","\/","1000",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L329-L329","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Log message) -> ctx <$ liftIO (putStrLn message)\n\n    R other         -> LogStdoutC (alg (runLogStdout . hdl) other ctx)\n\n\n-- Carrier two: reinterpret a program that logs 's's into one that logs 't's\n-- using a function (provided at runtime) from 's' to 't'.","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Log","message",")","->","ctx","<$","liftIO","(","putStrLn","message",")","R","other","->","LogStdoutC","(","alg","(","runLogStdout",".","hdl",")","other","ctx",")","-- Carrier two: reinterpret a program that logs 's's into one that logs 't's","-- using a function (provided at runtime) from 's' to 't'."],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L104-L112","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"_ _ (Bucket (nodes, _)) n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ _ (Bucket (nodes, _)) n\n            | length nodes <= n = map fst nodes\n            | otherwise = take n . sortByDistanceTo (map fst nodes) $ id","function_tokens":["go","_","_","(","Bucket","(","nodes",",","_",")",")","n","|","length","nodes","<=","n","=","map","fst","nodes","|","otherwise","=","take","n",".","sortByDistanceTo","(","map","fst","nodes",")","$","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L195-L197","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"matches","parameters":"regA (regB, _, _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matches regA (regB, _, _) = matchRegistrations regA regB","function_tokens":["matches","regA","(","regB",",","_",",","_",")","=","matchRegistrations","regA","regB"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L132-L132","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unsafeThaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeThaw = MG.unsafeThaw","function_tokens":["unsafeThaw","=","MG","unsafeThaw"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L385-L385","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"untilEvent_","parameters":"v ve","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"untilEvent_ v ve = fst <$> untilEvent v ve","function_tokens":["untilEvent_","v","ve","=","fst","<$>","untilEvent","v","ve"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L214-L214","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"parseConflict","parameters":"markerA","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseConflict markerA =\n    do  (linesA   , markerBase) <- readUpToMarker '|' markerCount\n        (linesBase, markerB)    <- readUpToMarker '=' markerCount\n        (linesB   , markerEnd)  <- readUpToMarker '>' markerCount\n        pure Conflict\n            { cMarkers    = Sides markerA markerBase markerB\n            , cMarkerEnd  = markerEnd\n            , cBodies     = fmap snd <$> Sides linesA linesBase linesB\n            }\n    where\n        markerCount = Just (length (takeWhile (== '<') (snd markerA)))","function_tokens":["parseConflict","markerA","=","do","(","linesA",",","markerBase",")","<-","readUpToMarker","'|'","markerCount","(","linesBase",",","markerB",")","<-","readUpToMarker","'='","markerCount","(","linesB",",","markerEnd",")","<-","readUpToMarker","'>'","markerCount","pure","Conflict","{","cMarkers","=","Sides","markerA","markerBase","markerB",",","cMarkerEnd","=","markerEnd",",","cBodies","=","fmap","snd","<$>","Sides","linesA","linesBase","linesB","}","where","markerCount","=","Just","(","length","(","takeWhile","(","==","'<'",")","(","snd","markerA",")",")",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L99-L111","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"adjacent","parameters":"b1 b2","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"adjacent b1 b2 = follows b1 b2 || follows b2 b1\n  where\n    follows (Block _ e1) (Block s2 _) = e1 == s2 || e1 + 1 == s2\n\n\n--------------------------------------------------------------------------------","function_tokens":["adjacent","b1","b2","=","follows","b1","b2","||","follows","b2","b1","where","follows","(","Block","_","e1",")","(","Block","s2","_",")","=","e1","==","s2","||","e1","+","1","==","s2","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L60-L66","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"beforeChange","parameters":"(CLine x _ _) (CLine y _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"beforeChange (CLine x _ _) (CLine y _ _) = x <= y","function_tokens":["beforeChange","(","CLine","x","_","_",")","(","CLine","y","_","_",")","=","x","<=","y"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L53-L53","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"map","parameters":"f m@(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"map f m@(Matrix r c _ _ _) = MG.fromVector (r,c) $ G.map f . MG.flatten $ m","function_tokens":["map","f","m","@","(","Matrix","r","c","_","_","_",")","=","MG","fromVector","(","r",",","c",")","$","G","map","f",".","MG","flatten","$","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L279-L279","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int32 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int32 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int32","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L369-L369","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val           = Bin","function_tokens":["val","=","Bin"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L289-L289","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"create","parameters":"id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"create id = NodeTree (toByteStruct id) . Bucket $ ([], [])","function_tokens":["create","id","=","NodeTree","(","toByteStruct","id",")",".","Bucket","$","(","[","]",",","[","]",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L100-L100","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Errors.hs","language":"haskell","identifier":"unmarshalALErrorCategory","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalALErrorCategory x\n   | x == al_INVALID_ENUM = ALInvalidEnum\n   | x == al_INVALID_VALUE = ALInvalidValue\n   | x == al_INVALID_OPERATION = ALInvalidOperation\n   | x == al_INVALID_NAME = ALInvalidName\n   | x == al_OUT_OF_MEMORY = ALOutOfMemory\n   | otherwise = error (\"unmarshalALErrorCategory: illegal value \" ++ show x)","function_tokens":["unmarshalALErrorCategory","x","|","x","==","al_INVALID_ENUM","=","ALInvalidEnum","|","x","==","al_INVALID_VALUE","=","ALInvalidValue","|","x","==","al_INVALID_OPERATION","=","ALInvalidOperation","|","x","==","al_INVALID_NAME","=","ALInvalidName","|","x","==","al_OUT_OF_MEMORY","=","ALOutOfMemory","|","otherwise","=","error","(","\"unmarshalALErrorCategory: illegal value \"","++","show","x",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Errors.hs#L53-L59","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Errors.hs","hash_val":54514,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"i'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"i' = offset + i * tda","function_tokens":["i'","=","offset","+","i","*","tda"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L156-L156","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sf <*> sx = do\n    f <- sf\n    f <$> sx\n\n\n-- | A spline is a transformer by running the effect and immediately concluding,\n-- using the effect's result as the result value.\n--\n-- >>> :{\n-- let s = do () <- lift $ print \"Hello\"\n--            step 2\n--     v = outputStream s 0\n-- in testVarOver v [()]\n-- >>> :}\n-- \"Hello\"\n-- 2","function_tokens":["sf","<*>","sx","=","do","f","<-","sf","f","<$>","sx","-- | A spline is a transformer by running the effect and immediately concluding,","-- using the effect's result as the result value.","--","-- >>> :{","-- let s = do () <- lift $ print \"Hello\"","--            step 2","--     v = outputStream s 0","-- in testVarOver v [()]","-- >>> :}","-- \"Hello\"","-- 2"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L115-L131","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"toStaticallySorted","parameters":"dx","argument_list":"","return_statement":"","docstring":"Tries to convert an expression (`DynamicallySorted`) of some sort to an expression of requested sort. Performs no conversions.","docstring_summary":"Tries to convert an expression (`DynamicallySorted`) of some sort to an expression of requested sort. Performs no conversions.","docstring_tokens":["Tries","to","convert","an","expression","(","DynamicallySorted",")","of","some","sort","to","an","expression","of","requested","sort",".","Performs","no","conversions","."],"function":"toStaticallySorted dx = case dx of\n    DynamicallySorted s x -> case s %~ (sing :: Sing s) of\n        Proved Refl -> Just x\n        Disproved _ -> Nothing\n\n-- | Parser that accepts sort definitions such as @bool@, @int@, @array int int@, @array int (array ...)@.","function_tokens":["toStaticallySorted","dx","=","case","dx","of","DynamicallySorted","s","x","->","case","s","%~","(","sing","::","Sing","s",")","of","Proved","Refl","->","Just","x","Disproved","_","->","Nothing","-- | Parser that accepts sort definitions such as @bool@, @int@, @array int int@, @array int (array ...)@."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L118-L124","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L246-L246","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'List","parameters":"(Array x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'List (Array x) = mapM cast x","function_tokens":["cast'List","(","Array","x",")","=","mapM","cast","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L225-L225","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"fmap","parameters":"f (SplineT s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f (SplineT s) = SplineT $ s >=> \\case\n    Left c        -> return $ Left $ f c\n    Right (b, s1) -> return $ Right (b, fmap f s1)\n\n-- | A spline responds to bind by running until it concludes in a value,\n-- then uses that value to run the next spline.\n--\n-- Note - checkout the <$proofs proofs>","function_tokens":["fmap","f","(","SplineT","s",")","=","SplineT","$","s",">=>","\\","case","Left","c","->","return","$","Left","$","f","c","Right","(","b",",","s1",")","->","return","$","Right","(","b",",","fmap","f","s1",")","-- | A spline responds to bind by running until it concludes in a value,","-- then uses that value to run the next spline.","--","-- Note - checkout the <$proofs proofs>"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L84-L92","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"fromEvent","parameters":"ve","argument_list":"","return_statement":"","docstring":"Create a spline from an event stream.","docstring_summary":"Create a spline from an event stream.","docstring_tokens":["Create","a","spline","from","an","event","stream","."],"function":"fromEvent ve = SplineT $ \\a -> do\n  (e, ve1) <- runVarT ve a\n  return $ case e of\n    Just b  -> Left b\n    Nothing -> Right (Nothing, fromEvent ve1)\n\n-- | Create a spline from an event stream. Outputs 'noevent' until the event\n-- stream procs, at which point the spline concludes with the event value.","function_tokens":["fromEvent","ve","=","SplineT","$","\\","a","->","do","(","e",",","ve1",")","<-","runVarT","ve","a","return","$","case","e","of","Just","b","->","Left","b","Nothing","->","Right","(","Nothing",",","fromEvent","ve1",")","-- | Create a spline from an event stream. Outputs 'noevent' until the event","-- stream procs, at which point the spline concludes with the event value."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L179-L187","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = length . F.toList $ d","function_tokens":["n","=","length",".","F","toList","$","d"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L225-L225","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"bit","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bit = bs !! i","function_tokens":["bit","=","bs","!!","i"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L181-L181","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ReaderC a >>= f = ReaderC (\\ r -> a r >>= runReader r . f)","function_tokens":["ReaderC","a",">>=","f","=","ReaderC","(","\\","r","->","a","r",">>=","runReader","r",".","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L75-L75","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"rows","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rows = MG.rows","function_tokens":["rows","=","MG","rows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L120-L120","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val x   = valList [x]","function_tokens":["val","x","=","valList","[","x","]"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L262-L262","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"mapM_","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM_ f = G.mapM_ f . MG.flatten","function_tokens":["mapM_","f","=","G","mapM_","f",".","MG","flatten"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L308-L308","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet.hs","language":"haskell","identifier":"benchmark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark = bgroup \"NonDet\"\n  [ bgroup \"N-queens problem\"\n    [ NQueens.benchmark \"NonDet.Church\" (run . NonDet.Church.runNonDetA)\n    , NQueens.benchmark \"[]\"            (id @[_])\n    ]\n  ]","function_tokens":["benchmark","=","bgroup","\"NonDet\"","[","bgroup","\"N-queens problem\"","[","NQueens","benchmark","\"NonDet.Church\"","(","run",".","NonDet","Church","runNonDetA",")",",","NQueens","benchmark","\"[]\"","(","id","@","[","_","]",")","]","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet.hs#L12-L17","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet.hs","hash_val":46700,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"splitBucket","parameters":"_ _ []","argument_list":"","return_statement":"","docstring":"Recursivly split the nodes into two buckets","docstring_summary":"Recursivly split the nodes into two buckets","docstring_tokens":["Recursivly","split","the","nodes","into","two","buckets"],"function":"splitBucket _ _ []     = ([], [])","function_tokens":["splitBucket","_","_","[","]","=","(","[","]",",","[","]",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L179-L179","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Except.hs","language":"haskell","identifier":"explainError","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"explainError = die . (\"Could not continue because: \" ++)","function_tokens":["explainError","=","die",".","(","\"Could not continue because: \"","++",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Except.hs#L43-L43","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Except.hs","hash_val":50331,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"abcTune","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"abcTune = undefined","function_tokens":["abcTune","=","undefined"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L96-L96","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int32 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int32 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int32","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L251-L251","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"typeOfVal","parameters":"","argument_list":"","return_statement":"","docstring":"^ Type of typed value","docstring_summary":"^ Type of typed value","docstring_tokens":["^","Type","of","typed","value"],"function":"typeOfVal = fval typeOf","function_tokens":["typeOfVal","=","fval","typeOf"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L211-L211","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"beforeChange","parameters":"_             (CInsert _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"beforeChange _             (CInsert _)   = False","function_tokens":["beforeChange","_","(","CInsert","_",")","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L50-L50","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (True:ts) depth valid (Split left right)","argument_list":"","return_statement":"","docstring":"Otherwise, continue to the right","docstring_summary":"Otherwise, continue to the right","docstring_tokens":["Otherwise","continue","to","the","right"],"function":"go (i:is) (True:ts) depth valid (Split left right) =\n               let new = go is ts (depth + 1) (valid && i) right\n               in  Split left new","function_tokens":["go","(","i",":","is",")","(","True",":","ts",")","depth","valid","(","Split","left","right",")","=","let","new","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right","in","Split","left","new"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L54-L56","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"_ _ depth valid (Bucket b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ _ depth valid (Bucket b) = f depth valid b","function_tokens":["go","_","_","depth","valid","(","Bucket","b",")","=","f","depth","valid","b"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L48-L48","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"idx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"idx = offset + i * tda + j","function_tokens":["idx","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L146-L146","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = MG.dim m","function_tokens":["d","=","MG","dim","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L560-L560","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"stateExamples","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stateExamples = testGroup \"State\"\n  [ testProperty \"runUnderLabel\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" sampleS)))) === 15\n  , testProperty \"State.Labelled helpers\" . property $\n    run (evalState (5 :: Int) (runLabelled @\"fore\" (evalState (10 :: Int) (runLabelled @\"aft\" helpersS)))) === 15\n  , testProperty \"Boolean labels\" . property $\n    run (evalState (5 :: Int) (runLabelled @'True (evalState (10 :: Int) (runLabelled @'False boolean)))) === 15\n  ]","function_tokens":["stateExamples","=","testGroup","\"State\"","[","testProperty","\"runUnderLabel\"",".","property","$","run","(","evalState","(","5","::","Int",")","(","runLabelled","@","\"fore\"","(","evalState","(","10","::","Int",")","(","runLabelled","@","\"aft\"","sampleS",")",")",")",")","===","15",",","testProperty","\"State.Labelled helpers\"",".","property","$","run","(","evalState","(","5","::","Int",")","(","runLabelled","@","\"fore\"","(","evalState","(","10","::","Int",")","(","runLabelled","@","\"aft\"","helpersS",")",")",")",")","===","15",",","testProperty","\"Boolean labels\"",".","property","$","run","(","evalState","(","5","::","Int",")","(","runLabelled","@","'","True","(","evalState","(","10","::","Int",")","(","runLabelled","@","'","False","boolean",")",")",")",")","===","15","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L64-L71","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val                    = String","function_tokens":["val","=","String"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L256-L256","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"rType","parameters":"(RETURN_NODES id _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rType (RETURN_NODES id _) = Just (R_RETURN_NODES id)","function_tokens":["rType","(","RETURN_NODES","id","_",")","=","Just","(","R_RETURN_NODES","id",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L59-L59","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Except.hs","language":"haskell","identifier":"withExceptionHandling","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withExceptionHandling = flip catches exceptionHandlers","function_tokens":["withExceptionHandling","=","flip","catches","exceptionHandlers"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Except.hs#L32-L32","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Except.hs","hash_val":50331,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(leftCache, rightCache) = splitBucket depth id cache","function_tokens":["(","leftCache",",","rightCache",")","=","splitBucket","depth","id","cache"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L173-L173","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L385-L385","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ReaderC u <* ReaderC v = ReaderC $ \\ r -> u r <* v r","function_tokens":["ReaderC","u","<*","ReaderC","v","=","ReaderC","$","\\","r","->","u","r","<*","v","r"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L64-L64","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"imap","parameters":"f m@(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f m@(Matrix r c _ _ _) = MG.fromVector (r,c) $ G.imap f' . MG.flatten $ m\n  where\n    f' i = f (i `divMod` c)","function_tokens":["imap","f","m","@","(","Matrix","r","c","_","_","_",")","=","MG","fromVector","(","r",",","c",")","$","G","imap","f'",".","MG","flatten","$","m","where","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L283-L286","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"rType","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rType _ = Nothing","function_tokens":["rType","_","=","Nothing"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L60-L60","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bench\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain $ map (\\n -> bench (\"fib \" ++ show n) fib n) [1..10]","function_tokens":["main","=","defaultMain","$","map","(","\\","n","->","bench","(","\"fib \"","++","show","n",")","fib","n",")","[","1","..","10","]"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bench\/Main.hs#L6-L6","hash_key":"knupfer\/chronos:bench\/Main.hs","hash_val":48994,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(RegEx x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (RegEx x) = Just x","function_tokens":["cast'","(","RegEx","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L339-L339","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWith3","parameters":"f m1 m2 m3","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith3 f m1 m2 m3\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 = error \"zipWith3: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zipWith3 f (MG.flatten m1) (MG.flatten m2) $ MG.flatten m3","function_tokens":["zipWith3","f","m1","m2","m3","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","=","error","\"zipWith3: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zipWith3","f","(","MG","flatten","m1",")","(","MG","flatten","m2",")","$","MG","flatten","m3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L340-L344","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"subLibraries","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subLibraries = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condSubLibraries packageDescription","function_tokens":["subLibraries","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condSubLibraries","packageDescription"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L58-L59","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"fromColumns","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from columns","docstring_summary":"O(m*n) Create matrix from columns","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","columns"],"function":"fromColumns = MG.fromColumns","function_tokens":["fromColumns","=","MG","fromColumns"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L164-L164","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"forkOnWithUnmask","parameters":"","argument_list":"","return_statement":"","docstring":"Like @Control.Concurrent.'Control.Concurrent.forkOnWithUnmask'@ but returns a computation that when executed blocks until the thread terminates then returns the final value of the thread.","docstring_summary":"Like","docstring_tokens":["Like"],"function":"forkOnWithUnmask = forkWithUnmask . Control.Concurrent.forkOnWithUnmask","function_tokens":["forkOnWithUnmask","=","forkWithUnmask",".","Control","Concurrent","forkOnWithUnmask"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L110-L110","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"lres","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lres   = reserved lexer","function_tokens":["lres","=","reserved","lexer"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L132-L132","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"register","parameters":"reg rq chan","argument_list":"","return_statement":"","docstring":"Register a channel as handler for a reply","docstring_summary":"Register a channel as handler for a reply","docstring_tokens":["Register","a","channel","as","handler","for","a","reply"],"function":"register reg rq chan = do\n    tId <- timeoutThread reg rq\n    atomically $ do\n        rQueue <- readTVar . queue $ rq\n        writeTVar (queue rq) $ rQueue ++ [(reg, chan, tId)]","function_tokens":["register","reg","rq","chan","=","do","tId","<-","timeoutThread","reg","rq","atomically","$","do","rQueue","<-","readTVar",".","queue","$","rq","writeTVar","(","queue","rq",")","$","rQueue","++","[","(","reg",",","chan",",","tId",")","]"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L87-L93","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"targetStruct","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetStruct    = toByteStruct id","function_tokens":["targetStruct","=","toByteStruct","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L64-L64","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Church.hs","language":"haskell","identifier":"runWriter","parameters":"k","argument_list":"","return_statement":"","docstring":"Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.  @ 'runWriter' k ('pure' a) = k 'mempty' a @ @ 'runWriter' k ('tell' w) = k w () @ @ 'runWriter' k ('listen' ('tell' w)) = k w (w, ()) @ @ 'runWriter' k ('censor' f ('tell' w)) = k (f w) () @  @since 1.1.0.0","docstring_summary":"Run a 'Writer' effect with a 'Monoid'al log, applying a continuation to the final log and result.","docstring_tokens":["Run","a","Writer","effect","with","a","Monoid","al","log","applying","a","continuation","to","the","final","log","and","result","."],"function":"runWriter k = runState k mempty . runWriterC","function_tokens":["runWriter","k","=","runState","k","mempty",".","runWriterC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Church.hs#L51-L51","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Church.hs","hash_val":47515,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"f","parameters":"_ _ (nodes, cache)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f _ _ (nodes, cache) = case L.find (idMatches id . fst) nodes of\n            -- Delete a node that exceeded the limit. Don't contact it again\n            --   as it is now considered dead\n            Just x@(_, 4) -> (Bucket (L.delete x $ nodes, cache), False)\n            -- Increment the timeoutCount\n            Just x@(n, timeoutCount) ->\n                 (Bucket ((n, timeoutCount + 1) : L.delete x nodes, cache), True)\n            -- Don't contact an unknown node a second time\n            Nothing -> (Bucket (nodes, cache), False)\n\n-- | Refresh the node corresponding to a supplied Id by placing it at the first\n--   index of it's KBucket and reseting its timeoutCount, then return a Bucket\n--   NodeTreeElem","function_tokens":["f","_","_","(","nodes",",","cache",")","=","case","L","find","(","idMatches","id",".","fst",")","nodes","of","-- Delete a node that exceeded the limit. Don't contact it again","--   as it is now considered dead","Just","x","@","(","_",",","4",")","->","(","Bucket","(","L","delete","x","$","nodes",",","cache",")",",","False",")","-- Increment the timeoutCount","Just","x","@","(","n",",","timeoutCount",")","->","(","Bucket","(","(","n",",","timeoutCount","+","1",")",":","L","delete","x","nodes",",","cache",")",",","True",")","-- Don't contact an unknown node a second time","Nothing","->","(","Bucket","(","nodes",",","cache",")",",","False",")","-- | Refresh the node corresponding to a supplied Id by placing it at the first","--   index of it's KBucket and reseting its timeoutCount, then return a Bucket","--   NodeTreeElem"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L119-L132","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = Float","function_tokens":["val","=","Float"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L242-L242","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"new","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"new = go is ts (depth + 1) (valid && i) right","function_tokens":["new","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L55-L55","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWith6","parameters":"f m1 m2 m3 m4 m5 m6","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith6 f m1 m2 m3 m4 m5 m6\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 ||\n      MG.dim m4 \/= MG.dim m5 ||\n      MG.dim m5 \/= MG.dim m6 = error \"zipWith6: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zipWith6 f (MG.flatten m1) (MG.flatten m2) (MG.flatten m3)\n                  (MG.flatten m4) (MG.flatten m5) $ MG.flatten m6","function_tokens":["zipWith6","f","m1","m2","m3","m4","m5","m6","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","||","MG","dim","m4","\/=","MG","dim","m5","||","MG","dim","m5","\/=","MG","dim","m6","=","error","\"zipWith6: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zipWith6","f","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","(","MG","flatten","m4",")","(","MG","flatten","m5",")","$","MG","flatten","m6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L377-L385","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"step","parameters":"b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"step b = SplineT $ const $ return $ Right (b, return ())","function_tokens":["step","b","=","SplineT","$","const","$","return","$","Right","(","b",",","return","(",")",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L366-L366","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"toList","parameters":"(NodeTree _ elems)","argument_list":"","return_statement":"","docstring":"Turn the NodeTree into a list of nodes","docstring_summary":"Turn the NodeTree into a list of nodes","docstring_tokens":["Turn","the","NodeTree","into","a","list","of","nodes"],"function":"toList (NodeTree _ elems) = go elems\n    where go (Split left right) = go left ++ go right\n          go (Bucket b) = map fst . fst $ b\n\n-- | Fold over the buckets","function_tokens":["toList","(","NodeTree","_","elems",")","=","go","elems","where","go","(","Split","left","right",")","=","go","left","++","go","right","go","(","Bucket","b",")","=","map","fst",".","fst","$","b","-- | Fold over the buckets"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L223-L228","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"^ Field with given label and typed value","docstring_summary":"^ Field with given label and typed value","docstring_tokens":["^","Field","with","given","label","and","typed","value"],"function":"k =: v = k := val v","function_tokens":["k","=:","v","=","k",":=","val","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L139-L139","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"flush","parameters":"rq","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flush rq = do\n    rQueue <- atomically $ do\n        rQueue <- readTVar . queue $ rq\n        writeTVar (queue rq) []\n        return rQueue\n\n    forM_ rQueue $ \\(_, chan, tId) -> do\n        killThread tId\n        writeChan chan Closed","function_tokens":["flush","rq","=","do","rQueue","<-","atomically","$","do","rQueue","<-","readTVar",".","queue","$","rq","writeTVar","(","queue","rq",")","[","]","return","rQueue","forM_","rQueue","$","\\","(","_",",","chan",",","tId",")","->","do","killThread","tId","writeChan","chan","Closed"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L136-L144","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val               = JavaScr","function_tokens":["val","=","JavaScr"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L343-L343","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"i (CInsert ls' : cs) ls","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go i (CInsert ls' : cs) ls = ls' ++ go i cs ls","function_tokens":["go","i","(","CInsert","ls'",":","cs",")","ls","=","ls'","++","go","i","cs","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L177-L177","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int64 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int64 x) = fitInt x","function_tokens":["cast'","(","Int64","x",")","=","fitInt","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L356-L356","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(JavaScr x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (JavaScr x) = Just x","function_tokens":["cast'","(","JavaScr","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L344-L344","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"untilEvent","parameters":"v ve","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"untilEvent v ve = SplineT $ f ((,) <$> v <*> ve)\n  where f vve a = do t <-runVarT vve a\n                     return $ case t of\n                       ((b, Nothing), vve1) -> Right (b, SplineT $ f vve1)\n                       ((b, Just c),    _)  -> Left (b, c)\n\n-- | A variant of 'untilEvent' that results in the last known output value.","function_tokens":["untilEvent","v","ve","=","SplineT","$","f","(","(",",",")","<$>","v","<*>","ve",")","where","f","vve","a","=","do","t","<-","runVarT","vve","a","return","$","case","t","of","(","(","b",",","Nothing",")",",","vve1",")","->","Right","(","b",",","SplineT","$","f","vve1",")","(","(","b",",","Just","c",")",",","_",")","->","Left","(","b",",","c",")","-- | A variant of 'untilEvent' that results in the last known output value."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L205-L212","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"runState","parameters":"f s (StateC m)","argument_list":"","return_statement":"","docstring":"Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.  @ 'runState' k s ('pure' a) = k s a @ @ 'runState' k s 'get' = k s s @ @ 'runState' k s ('put' t) = k t () @  @since 1.1.0.0","docstring_summary":"Run a 'State' effect starting from the passed value, applying a continuation to the final state and result.","docstring_tokens":["Run","a","State","effect","starting","from","the","passed","value","applying","a","continuation","to","the","final","state","and","result","."],"function":"runState f s (StateC m) = m f s","function_tokens":["runState","f","s","(","StateC","m",")","=","m","f","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L48-L48","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"offset","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"offset = length x - (xend - xstart)","function_tokens":["offset","=","length","x","-","(","xend","-","xstart",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L189-L189","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Church.hs","language":"haskell","identifier":"execWriter","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.  @ 'execWriter' = 'runWriter' ('const' '.' 'pure') @  @since 1.1.0.0","docstring_summary":"Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.","docstring_tokens":["Run","a","Writer","effect","with","a","Monoid","al","log","producing","the","final","log","and","discarding","the","result","value","."],"function":"execWriter = runWriter (const . pure)","function_tokens":["execWriter","=","runWriter","(","const",".","pure",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Church.hs#L62-L62","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Church.hs","hash_val":47515,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ReaderC f <*> ReaderC a = ReaderC (liftA2 (<*>) f a)","function_tokens":["ReaderC","f","<*>","ReaderC","a","=","ReaderC","(","liftA2","(","<*>",")","f","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L54-L54","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast","parameters":"v","argument_list":"","return_statement":"","docstring":"^ Convert Value to expected type, or fail (e.g. Nothing) if not of that type","docstring_summary":"^ Convert Value to expected type, or fail (e.g. Nothing) if not of that type","docstring_tokens":["^","Convert","Value","to","expected","type","or","fail","(","e",".","g",".","Nothing",")","if","not","of","that","type"],"function":"cast v = maybe notType return castingResult\n    where\n      castingResult = cast' v\n      unMaybe :: Maybe a -> a\n      unMaybe = undefined\n      notType = fail $ \"expected \" ++ show (typeOf $ unMaybe castingResult) ++ \": \" ++ show v","function_tokens":["cast","v","=","maybe","notType","return","castingResult","where","castingResult","=","cast'","v","unMaybe","::","Maybe","a","->","a","unMaybe","=","undefined","notType","=","fail","$","\"expected \"","++","show","(","typeOf","$","unMaybe","castingResult",")","++","\": \"","++","show","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L233-L239","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = ObjId","function_tokens":["val","=","ObjId"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L314-L314","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"err","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"err = error $ show n ++ \" is too large for Bson Int Value\"","function_tokens":["err","=","error","$","show","n","++","\" is too large for Bson Int Value\""],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L376-L376","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(String x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (String x)       = Just x","function_tokens":["cast'","(","String","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L257-L257","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"fromBlocks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromBlocks = MG.fromBlocks","function_tokens":["fromBlocks","=","MG","fromBlocks"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L220-L220","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (False:ts) (Split left right) n","argument_list":"","return_statement":"","docstring":"Take the closest nodes from the left child first, if those aren't enough, take the rest from the right","docstring_summary":"Take the closest nodes from the left child first, if those aren't enough, take the rest from the right","docstring_tokens":["Take","the","closest","nodes","from","the","left","child","first","if","those","aren","t","enough","take","the","rest","from","the","right"],"function":"go (i:is) (False:ts) (Split left right) n =\n            let result = go is ts left n\n            in if length result == n\n                then result\n                else result ++ go is ts right n","function_tokens":["go","(","i",":","is",")","(","False",":","ts",")","(","Split","left","right",")","n","=","let","result","=","go","is","ts","left","n","in","if","length","result","==","n","then","result","else","result","++","go","is","ts","right","n"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L200-L204","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Unique\/Really.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s = hashWithSalt s . hashUnique","function_tokens":["hashWithSalt","s","=","hashWithSalt","s",".","hashUnique"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Unique\/Really.hs#L66-L66","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Unique\/Really.hs","hash_val":52947,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"forM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM_ = MG.forM_","function_tokens":["forM_","=","MG","forM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L257-L257","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"runReader","parameters":"r (ReaderC runReaderC)","argument_list":"","return_statement":"","docstring":"Run a 'Reader' effect with the passed environment value.  @ 'runReader' a 'ask' = 'pure' a @ @ 'runReader' a ('pure' b) = 'pure' b @ @ 'runReader' a ('local' f m) = 'runReader' (f a) m @  @since 1.0.0.0","docstring_summary":"Run a 'Reader' effect with the passed environment value.","docstring_tokens":["Run","a","Reader","effect","with","the","passed","environment","value","."],"function":"runReader r (ReaderC runReaderC) = runReaderC r","function_tokens":["runReader","r","(","ReaderC","runReaderC",")","=","runReaderC","r"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L43-L43","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"go","parameters":"_   []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _   []       = False","function_tokens":["go","_","[","]","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L74-L74","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWith","parameters":"f m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith f m1 m2\n    | MG.dim m1 \/= MG.dim m2 = error \"zipWith: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zipWith f (MG.flatten m1) $ MG.flatten m2","function_tokens":["zipWith","f","m1","m2","|","MG","dim","m1","\/=","MG","dim","m2","=","error","\"zipWith: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zipWith","f","(","MG","flatten","m1",")","$","MG","flatten","m2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L331-L334","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"bench\/Main.hs","language":"haskell","identifier":"myTween","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"myTween = do\n  void $ tween_ easeInExpo 0 100 1\n  void $ tween_ easeOutExpo 100 0 1\n  myTween","function_tokens":["myTween","=","do","void","$","tween_","easeInExpo","0","100","1","void","$","tween_","easeOutExpo","100","0","1","myTween"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/bench\/Main.hs#L31-L34","hash_key":"schell\/varying:bench\/Main.hs","hash_val":49067,"partition":"valid"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Unique\/Really.hs","language":"haskell","identifier":"newUnique","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newUnique = do\n    x <- Data.Unique.newUnique\n    _ <- evaluate x\n    Unique <$> makeStableName x","function_tokens":["newUnique","=","do","x","<-","Data","Unique","newUnique","_","<-","evaluate","x","Unique","<$>","makeStableName","x"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Unique\/Really.hs#L23-L28","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Unique\/Really.hs","hash_val":52947,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L285-L285","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"modifyAt","parameters":"(NodeTree idStruct elem) id f","argument_list":"","return_statement":"","docstring":"Modify the position in the tree where the supplied id would be","docstring_summary":"Modify the position in the tree where the supplied id would be","docstring_tokens":["Modify","the","position","in","the","tree","where","the","supplied","id","would","be"],"function":"modifyAt (NodeTree idStruct elem) id f =\n    let targetStruct = toByteStruct id\n        newElems     = go idStruct targetStruct 0 True elem\n    in  NodeTree idStruct newElems\n    where -- This function is partial, but we know that there will alwasys be a\n          -- bucket at the end. Therefore, we don't have to check for empty\n          -- ByteStructs\n          --\n          -- Apply the function to the position of the bucket\n          go _ _ depth valid (Bucket b) = f depth valid b\n          -- If the bit is a 0, go left\n          go (i:is) (False:ts) depth valid (Split left right) =\n               let new = go is ts (depth + 1) (valid && not i) left\n               in  Split new right\n          -- Otherwise, continue to the right\n          go (i:is) (True:ts) depth valid (Split left right) =\n               let new = go is ts (depth + 1) (valid && i) right\n               in  Split left new\n\n-- | Modify and apply a function at the position in the tree where the\n--   supplied id would be","function_tokens":["modifyAt","(","NodeTree","idStruct","elem",")","id","f","=","let","targetStruct","=","toByteStruct","id","newElems","=","go","idStruct","targetStruct","0","True","elem","in","NodeTree","idStruct","newElems","where","-- This function is partial, but we know that there will alwasys be a","-- bucket at the end. Therefore, we don't have to check for empty","-- ByteStructs","--","-- Apply the function to the position of the bucket","go","_","_","depth","valid","(","Bucket","b",")","=","f","depth","valid","b","-- If the bit is a 0, go left","go","(","i",":","is",")","(","False",":","ts",")","depth","valid","(","Split","left","right",")","=","let","new","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left","in","Split","new","right","-- Otherwise, continue to the right","go","(","i",":","is",")","(","True",":","ts",")","depth","valid","(","Split","left","right",")","=","let","new","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right","in","Split","left","new","-- | Modify and apply a function at the position in the tree where the","--   supplied id would be"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L39-L60","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"executables","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"executables = fst . Cabal.ignoreConditions . snd <$>\n        Cabal.condExecutables packageDescription","function_tokens":["executables","=","fst",".","Cabal","ignoreConditions",".","snd","<$>","Cabal","condExecutables","packageDescription"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L62-L63","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"capture","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"capture = SplineT . f Nothing\n    where f mb s = runSplineT s >=> return . \\case\n            Left c        -> Left (mb, c)\n            Right (b, s1) -> Right (b, SplineT $ f (Just b) s1)\n\n-- | Produce the argument as an output value exactly once.\n--\n-- >>> :{\n-- let s = do step \"hi\"\n--            step \"there\"\n--            step \"friend\"\n-- in testVarOver (outputStream s \"\") [1,2,3,4]\n-- >>> :}\n-- \"hi\"\n-- \"there\"\n-- \"friend\"\n-- \"friend\"","function_tokens":["capture","=","SplineT",".","f","Nothing","where","f","mb","s","=","runSplineT","s",">=>","return",".","\\","case","Left","c","->","Left","(","mb",",","c",")","Right","(","b",",","s1",")","->","Right","(","b",",","SplineT","$","f","(","Just","b",")","s1",")","-- | Produce the argument as an output value exactly once.","--","-- >>> :{","-- let s = do step \"hi\"","--            step \"there\"","--            step \"friend\"","-- in testVarOver (outputStream s \"\") [1,2,3,4]","-- >>> :}","-- \"hi\"","-- \"there\"","-- \"friend\"","-- \"friend\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L348-L365","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"overlapping","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"overlapping = go IS.empty\n  where\n    go _   []       = False\n    go acc (b : bs) =\n        let ints = [blockStart b .. blockEnd b] in\n        if any (`IS.member` acc) ints\n            then True\n            else go (IS.union acc $ IS.fromList ints) bs\n\n\n--------------------------------------------------------------------------------\n-- | Groups adjacent blocks into larger blocks","function_tokens":["overlapping","=","go","IS","empty","where","go","_","[","]","=","False","go","acc","(","b",":","bs",")","=","let","ints","=","[","blockStart","b","..","blockEnd","b","]","in","if","any","(","`","IS","member","`","acc",")","ints","then","True","else","go","(","IS","union","acc","$","IS","fromList","ints",")","bs","--------------------------------------------------------------------------------","-- | Groups adjacent blocks into larger blocks"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L72-L84","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"wrap24","parameters":"n","argument_list":"","return_statement":"","docstring":"^ low 3 bytes only, high byte must be zero","docstring_summary":"^ low 3 bytes only, high byte must be zero","docstring_tokens":["^","low","3","bytes","only","high","byte","must","be","zero"],"function":"wrap24 n = n `mod` 0x1000000","function_tokens":["wrap24","n","=","n","`","mod","`","0x1000000"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L478-L478","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Interpret.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = 100000","function_tokens":["n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Interpret.hs#L43-L43","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Interpret.hs","hash_val":54530,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"fromEnabled","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromEnabled x                             =\n                error $ \"Language.Haskell.Stylish.Config.readLanguageExtensions: \" <>\n                        \"invalid LANGUAGE pragma:  \" <> show x","function_tokens":["fromEnabled","x","=","error","$","\"Language.Haskell.Stylish.Config.readLanguageExtensions: \"","<>","\"invalid LANGUAGE pragma:  \"","<>","show","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L87-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = Int64","function_tokens":["val","=","Int64"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L361-L361","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"go","parameters":"xs c' v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go xs c' v = F.foldlM f 0 xs >> return v\n      where\n        f !i x = GM.unsafeWrite v (i*(c'+1)) x >> return (i+1)","function_tokens":["go","xs","c'","v","=","F","foldlM","f","0","xs",">>","return","v","where","f","i","x","=","GM","unsafeWrite","v","(","i","*","(","c'","+","1",")",")","x",">>","return","(","i","+","1",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L236-L239","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f","parameters":"!cr xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f !cr xs = do (r', _) <- foldM g (0, 0) xs\n                      return $ cr + r'\n          where\n            g (!maxR, !cc) x = do\n                let (r,c) = MG.dim x\n                    vec = MG.flatten x\n                    step i u = do\n                        GM.unsafeWrite v ((cr + i `div` c) * n' + i `mod` c + cc) u\n                        return (i+1)\n                G.foldM'_ step (0::Int) vec\n                return (max maxR r, cc + c)\n    -- figure out the dimension of the new matrix","function_tokens":["f","cr","xs","=","do","(","r'",",","_",")","<-","foldM","g","(","0",",","0",")","xs","return","$","cr","+","r'","where","g","(","maxR",",","cc",")","x","=","do","let","(","r",",","c",")","=","MG","dim","x","vec","=","MG","flatten","x","step","i","u","=","do","GM","unsafeWrite","v","(","(","cr","+","i","`","div","`","c",")","*","n'","+","i","`","mod","`","c","+","cc",")","u","return","(","i","+","1",")","G","foldM'_","step","(","0","::","Int",")","vec","return","(","max","maxR","r",",","cc","+","c",")","-- figure out the dimension of the new matrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L250-L262","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"diagRect","parameters":"z0 (r,c) d","argument_list":"","return_statement":"","docstring":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_summary":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_tokens":["O","(","m","*","n",")","Create","a","rectangular","matrix","with","default","values","and","given","diagonal"],"function":"diagRect z0 (r,c) d = MG.fromVector (r,c) $ G.create $ GM.replicate n z0 >>= go d c\n  where\n    go xs c' v = F.foldlM f 0 xs >> return v\n      where\n        f !i x = GM.unsafeWrite v (i*(c'+1)) x >> return (i+1)\n    n = r * c","function_tokens":["diagRect","z0","(","r",",","c",")","d","=","MG","fromVector","(","r",",","c",")","$","G","create","$","GM","replicate","n","z0",">>=","go","d","c","where","go","xs","c'","v","=","F","foldlM","f","0","xs",">>","return","v","where","f","i","x","=","GM","unsafeWrite","v","(","i","*","(","c'","+","1",")",")","x",">>","return","(","i","+","1",")","n","=","r","*","c"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L234-L240","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bench\/Main.hs","language":"haskell","identifier":"fib","parameters":"2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fib 2 = 1","function_tokens":["fib","2","=","1"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bench\/Main.hs#L10-L10","hash_key":"knupfer\/chronos:bench\/Main.hs","hash_val":48994,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(UserDef x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (UserDef x) = Just x","function_tokens":["cast'","(","UserDef","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L310-L310","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"pretty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty = unlines . prettyLines","function_tokens":["pretty","=","unlines",".","prettyLines"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L53-L53","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"reservedNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reservedNames = []","function_tokens":["reservedNames","=","[","]"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L125-L125","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"forkIOWithUnmask","parameters":"","argument_list":"","return_statement":"","docstring":"Like @Control.Concurrent.'Control.Concurrent.forkIOWithUnmask'@ but returns a computation that when executed blocks until the thread terminates then returns the final value of the thread.","docstring_summary":"Like","docstring_tokens":["Like"],"function":"forkIOWithUnmask = forkWithUnmask Control.Concurrent.forkIOWithUnmask","function_tokens":["forkIOWithUnmask","=","forkWithUnmask","Control","Concurrent","forkIOWithUnmask"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L103-L103","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"isEnabled","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isEnabled _                            = False","function_tokens":["isEnabled","_","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L84-L84","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"result = go is ts right n","function_tokens":["result","=","go","is","ts","right","n"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L208-L208","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"izipWith3","parameters":"f m1 m2 m3","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith3 f m1 m2 m3\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 = error \"izipWith3: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.izipWith3 f' (MG.flatten m1) (MG.flatten m2) $ MG.flatten m3\n  where\n    c = MG.cols m1\n    f' i = f (i `divMod` c)","function_tokens":["izipWith3","f","m1","m2","m3","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","=","error","\"izipWith3: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","izipWith3","f'","(","MG","flatten","m1",")","(","MG","flatten","m2",")","$","MG","flatten","m3","where","c","=","MG","cols","m1","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L402-L410","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (False:ts) depth valid (Split left right)","argument_list":"","return_statement":"","docstring":"If the bit is a 0, go left","docstring_summary":"If the bit is a 0, go left","docstring_tokens":["If","the","bit","is","a","0","go","left"],"function":"go (i:is) (False:ts) depth valid (Split left right) =\n               let (new, val) = go is ts (depth + 1) (valid && not i) left\n               in  (Split new right, val)","function_tokens":["go","(","i",":","is",")","(","False",":","ts",")","depth","valid","(","Split","left","right",")","=","let","(","new",",","val",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left","in","(","Split","new","right",",","val",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L74-L76","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"diagRect","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_summary":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_tokens":["O","(","m","*","n",")","Create","a","rectangular","matrix","with","default","values","and","given","diagonal"],"function":"diagRect = MG.diagRect","function_tokens":["diagRect","=","MG","diagRect"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L214-L214","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"editsFor","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"editsFor i = fromMaybe [] $ M.lookup i edits","function_tokens":["editsFor","i","=","fromMaybe","[","]","$","M","lookup","i","edits"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L173-L173","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotPNG.hs","language":"haskell","identifier":"makeLensMapPng","parameters":"title filepath lens districts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeLensMapPng title filepath lens districts = do\n    renderableToFile fileOptions filepath $ mkRenderableLens lens districts title\n    putStrLn (\"...output written to \" <> filepath)\n\n{--\nmakeMapPng' :: String -> FilePath -> [Polygon] -> IO ()\nmakeMapPng' = (flip zip (forever $ \"\")) -.** makeLabelledMapPng\n--}","function_tokens":["makeLensMapPng","title","filepath","lens","districts","=","do","renderableToFile","fileOptions","filepath","$","mkRenderableLens","lens","districts","title","putStrLn","(","\"...output written to \"","<>","filepath",")","{--\nmakeMapPng' :: String -> FilePath -> [Polygon] -> IO ()\nmakeMapPng' = (flip zip (forever $ \"\")) -.** makeLabelledMapPng\n--}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotPNG.hs#L49-L56","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotPNG.hs","hash_val":49940,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/IORef.hs","language":"haskell","identifier":"runStateRef","parameters":"ref x","argument_list":"","return_statement":"","docstring":"Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.  @since 1.1.2.0","docstring_summary":"Run a 'State' effect starting from the passed 'IORef'. This function is lawless, given that the underlying IORef can be modified by another thread.","docstring_tokens":["Run","a","State","effect","starting","from","the","passed","IORef",".","This","function","is","lawless","given","that","the","underlying","IORef","can","be","modified","by","another","thread","."],"function":"runStateRef ref x = do\n  result <- runReader ref . runStateC $ x\n  final <- liftIO . readIORef $ ref\n  pure (final, result)","function_tokens":["runStateRef","ref","x","=","do","result","<-","runReader","ref",".","runStateC","$","x","final","<-","liftIO",".","readIORef","$","ref","pure","(","final",",","result",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/IORef.hs#L65-L69","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/IORef.hs","hash_val":53014,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"fromLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_summary":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","list","of","lists","it","doesn","t","check","if","the","list","of","list","is","a","valid","matrix"],"function":"fromLists = MG.fromLists","function_tokens":["fromLists","=","MG","fromLists"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L156-L156","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"emptyReplyQueue","parameters":"","argument_list":"","return_statement":"","docstring":"Create a new ReplyQueue","docstring_summary":"Create a new ReplyQueue","docstring_tokens":["Create","a","new","ReplyQueue"],"function":"emptyReplyQueue = liftM3 RQ (atomically . newTVar $ []) newChan $ newChan","function_tokens":["emptyReplyQueue","=","liftM3","RQ","(","atomically",".","newTVar","$","[","]",")","newChan","$","newChan"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L82-L82","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","language":"haskell","identifier":"isEnabled","parameters":"(Language.EnableExtension _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isEnabled (Language.EnableExtension _) = True","function_tokens":["isEnabled","(","Language","EnableExtension","_",")","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs#L83-L83","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config\/Cabal.hs","hash_val":48173,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC a <* StateC b = StateC $ \\ k ->\n    a (\\ s' a' -> b (\\ s'' _ -> k s'' a') s')","function_tokens":["StateC","a","<*","StateC","b","=","StateC","$","\\","k","->","a","(","\\","s'","a'","->","b","(","\\","s''","_","->","k","s''","a'",")","s'",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L91-L92","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"makeWord24","parameters":"","argument_list":"","return_statement":"","docstring":"^ Put last 3 bytes into a Word24. Expected to be called on very short list","docstring_summary":"^ Put last 3 bytes into a Word24. Expected to be called on very short list","docstring_tokens":["^","Put","last","3","bytes","into","a","Word24",".","Expected","to","be","called","on","very","short","list"],"function":"makeWord24 = foldl (\\a b -> a `shift` 8 .|. fromIntegral b) 0","function_tokens":["makeWord24","=","foldl","(","\\","a","b","->","a","`","shift","`","8",".|.","fromIntegral","b",")","0"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L482-L482","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"array","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"array = array' <$> (string \"array\" *> space *> sort') <*> (space *> sort')","function_tokens":["array","=","array'","<$>","(","string","\"array\"","*>","space","*>","sort'",")","<*>","(","space","*>","sort'",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L128-L128","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(pre, post) = splitAt count line","function_tokens":["(","pre",",","post",")","=","splitAt","count","line"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L66-L66","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"freeze","parameters":"(MMatrix r c tda offset v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeze (MMatrix r c tda offset v) = Matrix r c tda offset `liftM` G.freeze v","function_tokens":["freeze","(","MMatrix","r","c","tda","offset","v",")","=","Matrix","r","c","tda","offset","`","liftM","`","G","freeze","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L172-L172","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"rnf","parameters":"(Matrix _ _ _ _ vec)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rnf (Matrix _ _ _ _ vec) = rnf vec","function_tokens":["rnf","(","Matrix","_","_","_","_","vec",")","=","rnf","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L136-L136","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Bool x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Bool x) = Just x","function_tokens":["cast'","(","Bool","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L320-L320","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"closeK","parameters":"kh","argument_list":"","return_statement":"","docstring":"Close the connection corresponding to a KademliaHandle","docstring_summary":"Close the connection corresponding to a KademliaHandle","docstring_tokens":["Close","the","connection","corresponding","to","a","KademliaHandle"],"function":"closeK kh = do\n    -- Kill recvThread\n    empty <- isEmptyMVar . recvThread $ kh\n    unless empty $ do\n        tId <- takeMVar . recvThread $ kh\n        killThread tId\n\n    -- Kill sendThread\n    killThread . sendThread $ kh\n\n    yield","function_tokens":["closeK","kh","=","do","-- Kill recvThread","empty","<-","isEmptyMVar",".","recvThread","$","kh","unless","empty","$","do","tId","<-","takeMVar",".","recvThread","$","kh","killThread","tId","-- Kill sendThread","killThread",".","sendThread","$","kh","yield"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L123-L133","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"markerCount","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"markerCount = Just (length (takeWhile (== '<') (snd markerA)))","function_tokens":["markerCount","=","Just","(","length","(","takeWhile","(","==","'<'",")","(","snd","markerA",")",")",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L109-L109","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"hsSigReplacements","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hsSigReplacements _ = mempty","function_tokens":["hsSigReplacements","_","=","mempty"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L39-L39","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = CollectLogMessagesC $ case sig of\n    L (Log s) -> ctx <$ tell [s]\n\n    R other   -> alg (runCollectLogMessagesC . hdl) (R other) ctx\n\n-- The 'CollectLogMessagesC' runner.","function_tokens":["alg","hdl","sig","ctx","=","CollectLogMessagesC","$","case","sig","of","L","(","Log","s",")","->","ctx","<$","tell","[","s","]","R","other","->","alg","(","runCollectLogMessagesC",".","hdl",")","(","R","other",")","ctx","-- The 'CollectLogMessagesC' runner."],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L147-L153","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/Setup.hs#L2-L2","hash_key":"vmchale\/hgis:Setup.hs","hash_val":54863,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unzip5","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip5 m = ( MG.fromVector d v1\n           , MG.fromVector d v2\n           , MG.fromVector d v3\n           , MG.fromVector d v4\n           , MG.fromVector d v5\n           )\n  where\n    d = MG.dim m\n    (v1, v2, v3, v4, v5) = G.unzip5 $ MG.flatten m","function_tokens":["unzip5","m","=","(","MG","fromVector","d","v1",",","MG","fromVector","d","v2",",","MG","fromVector","d","v3",",","MG","fromVector","d","v4",",","MG","fromVector","d","v5",")","where","d","=","MG","dim","m","(","v1",",","v2",",","v3",",","v4",",","v5",")","=","G","unzip5","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L568-L577","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"groupAdjacent","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"groupAdjacent = foldr go []\n  where\n    -- This code is ugly and not optimal, and no fucks were given.\n    go (b1, x) gs = case break (adjacent b1 . fst) gs of\n        (_, [])               -> (b1, [x]) : gs\n        (ys, ((b2, xs) : zs)) -> (merge b1 b2, x : xs) : (ys ++ zs)","function_tokens":["groupAdjacent","=","foldr","go","[","]","where","-- This code is ugly and not optimal, and no fucks were given.","go","(","b1",",","x",")","gs","=","case","break","(","adjacent","b1",".","fst",")","gs","of","(","_",",","[","]",")","->","(","b1",",","[","x","]",")",":","gs","(","ys",",","(","(","b2",",","xs",")",":","zs",")",")","->","(","merge","b1","b2",",","x",":","xs",")",":","(","ys","++","zs",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L86-L93","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/lib\/HSInstall\/Paths.hs","language":"haskell","identifier":"getShareDir","parameters":"cabalDataDir","argument_list":"","return_statement":"","docstring":"{- |\nGet a path to the share directory relative to the binary location. The\nargument passed here is expected to be the output of @getDataDir@ generated\nby Cabal at compile time in the @Paths_PROJECTNAME@ module.\n\nUsage:\n\n@\nimport HSInstall.Paths ( getShareDir )\nimport Paths_PROJECTNAME ( getDataDir )\n\nshareDir <- getShareDir getDataDir\n@\n\nIf your binary is at @\\\/foo\\\/bar\\\/usr\\\/bin\\\/BINARY@, this library will generate\nthis path: @\\\/foo\\\/bar\\\/usr\\\/share\\\/PROJECTNAME@\n-}","docstring_summary":"{- |\nGet a path to the share directory relative to the binary location. The\nargument passed here is expected to be the output of @getDataDir@ generated\nby Cabal at compile time in the @Paths_PROJECTNAME@ module.","docstring_tokens":["{","-","|","Get","a","path","to","the","share","directory","relative","to","the","binary","location",".","The","argument","passed","here","is","expected","to","be","the","output","of","@getDataDir@","generated","by","Cabal","at","compile","time","in","the","@Paths_PROJECTNAME@","module","."],"function":"getShareDir cabalDataDir = do\n  appDir <- stripVersion . takeFileName <$> cabalDataDir\n  sharePath <- ( <\/> \"share\" <\/> appDir )\n    . takeDirectory . takeDirectory <$> getExecutablePath\n\n  sharePathExists <- doesDirectoryExist sharePath\n  if sharePathExists\n    then return sharePath\n    else fail $ \"Share directory \" ++ sharePath ++ \" does not exist\"","function_tokens":["getShareDir","cabalDataDir","=","do","appDir","<-","stripVersion",".","takeFileName","<$>","cabalDataDir","sharePath","<-","(","<\/>","\"share\"","<\/>","appDir",")",".","takeDirectory",".","takeDirectory","<$>","getExecutablePath","sharePathExists","<-","doesDirectoryExist","sharePath","if","sharePathExists","then","return","sharePath","else","fail","$","\"Share directory \"","++","sharePath","++","\" does not exist\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/lib\/HSInstall\/Paths.hs#L33-L44","hash_key":"dino-\/hsinstall:src\/lib\/HSInstall\/Paths.hs","hash_val":52086,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"withRunInIO","parameters":"inner","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withRunInIO inner = ReaderC $ \\ r -> withRunInIO $ \\ run -> inner (run . runReader r)","function_tokens":["withRunInIO","inner","=","ReaderC","$","\\","r","->","withRunInIO","$","\\","run","->","inner","(","run",".","runReader","r",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L104-L104","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"loop","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop =\n            do  (ls, mMarkerA) <- tryReadUpToMarker '<' Nothing\n                tell $ map (Left . snd) ls\n                case mMarkerA of\n                    Nothing -> pure ()\n                    Just markerA ->\n                        do  tell . pure . Right =<< parseConflict markerA\n                            loop","function_tokens":["loop","=","do","(","ls",",","mMarkerA",")","<-","tryReadUpToMarker","'<'","Nothing","tell","$","map","(","Left",".","snd",")","ls","case","mMarkerA","of","Nothing","->","pure","(",")","Just","markerA","->","do","tell",".","pure",".","Right","=<<","parseConflict","markerA","loop"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L115-L124","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Unique\/Really.hs","language":"haskell","identifier":"hashUnique","parameters":"(Unique s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashUnique (Unique s) = hashStableName s","function_tokens":["hashUnique","(","Unique","s",")","=","hashStableName","s"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Unique\/Really.hs#L28-L28","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Unique\/Really.hs","hash_val":52947,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"cols","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cols = MG.cols","function_tokens":["cols","=","MG","cols"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L123-L123","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"generate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"generate = MG.generate","function_tokens":["generate","=","MG","generate"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L379-L379","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(SplineT s0) >>= f = SplineT $ g s0\n    where g s a = do e <- s a\n                     case e of\n                       Left  c               -> runSplineT (f c) a\n                       Right (b, SplineT s1) -> return $ Right (b, SplineT $ g s1)\n\n\n-- | A spline responds to 'pure' by returning a spline that never produces an\n-- output value and immediately returns the argument. It responds to '<*>' by\n-- applying the left arguments result value (the function) to the right\n-- arguments result value (the argument), sequencing them both in serial.\n--\n-- @\n-- pure = return\n-- sf <*> sx = do\n--   f <- sf\n--   x <- sx\n--   return $ f x\n-- @","function_tokens":["(","SplineT","s0",")",">>=","f","=","SplineT","$","g","s0","where","g","s","a","=","do","e","<-","s","a","case","e","of","Left","c","->","runSplineT","(","f","c",")","a","Right","(","b",",","SplineT","s1",")","->","return","$","Right","(","b",",","SplineT","$","g","s1",")","-- | A spline responds to 'pure' by returning a spline that never produces an","-- output value and immediately returns the argument. It responds to '<*>' by","-- applying the left arguments result value (the function) to the right","-- arguments result value (the argument), sequencing them both in serial.","--","-- @","-- pure = return","-- sf <*> sx = do","--   f <- sf","--   x <- sx","--   return $ f x","-- @"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L94-L113","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = ReaderC (const empty)","function_tokens":["empty","=","ReaderC","(","const","empty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L68-L68","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unsafeFreeze","parameters":"(MMatrix r c tda offset v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFreeze (MMatrix r c tda offset v) = Matrix r c tda offset `liftM` G.unsafeFreeze v","function_tokens":["unsafeFreeze","(","MMatrix","r","c","tda","offset","v",")","=","Matrix","r","c","tda","offset","`","liftM","`","G","unsafeFreeze","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L175-L175","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"count","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"count = fromMaybe 7 mCount","function_tokens":["count","=","fromMaybe","7","mCount"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L61-L61","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"toRegistration","parameters":"(Timeout reg)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toRegistration (Timeout reg) = Just reg","function_tokens":["toRegistration","(","Timeout","reg",")","=","Just","reg"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L50-L50","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(v1, v2, v3, v4) = G.unzip4 $ MG.flatten m","function_tokens":["(","v1",",","v2",",","v3",",","v4",")","=","G","unzip4","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L561-L561","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"refresh","parameters":"node (nodes, cache)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"refresh node (nodes, cache) =\n         Bucket (case L.find (idMatches (nodeId node) . fst) nodes of\n            Just x@(n, _) -> (n, 0) : L.delete x nodes\n            _             -> nodes\n            , cache)","function_tokens":["refresh","node","(","nodes",",","cache",")","=","Bucket","(","case","L","find","(","idMatches","(","nodeId","node",")",".","fst",")","nodes","of","Just","x","@","(","n",",","_",")","->","(","n",",","0",")",":","L","delete","x","nodes","_","->","nodes",",","cache",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L133-L137","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (True:ts) depth valid (Split left right)","argument_list":"","return_statement":"","docstring":"Otherwise, continue to the right","docstring_summary":"Otherwise, continue to the right","docstring_tokens":["Otherwise","continue","to","the","right"],"function":"go (i:is) (True:ts) depth valid (Split left right) =\n               let (new, val) = go is ts (depth + 1) (valid && i) right\n               in  (Split left new, val)","function_tokens":["go","(","i",":","is",")","(","True",":","ts",")","depth","valid","(","Split","left","right",")","=","let","(","new",",","val",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right","in","(","Split","left","new",",","val",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L78-L80","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(MinMax x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (MinMax x) = Just x","function_tokens":["cast'","(","MinMax","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L389-L389","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unzip3","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip3 m = (MG.fromVector d v1, MG.fromVector d v2, MG.fromVector d v3)\n  where\n    d = MG.dim m\n    (v1, v2, v3) = G.unzip3 $ MG.flatten m","function_tokens":["unzip3","m","=","(","MG","fromVector","d","v1",",","MG","fromVector","d","v2",",","MG","fromVector","d","v3",")","where","d","=","MG","dim","m","(","v1",",","v2",",","v3",")","=","G","unzip3","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L546-L550","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"helpersS","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"helpersS = liftA2 (+) (L.get @\"fore\") (L.get @\"aft\")","function_tokens":["helpersS","=","liftA2","(","+",")","(","L","get","@","\"fore\"",")","(","L","get","@","\"aft\"",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L55-L55","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Inference.hs","language":"haskell","identifier":"runEnv","parameters":"r","argument_list":"","return_statement":"","docstring":"A handler for 'HasEnv' & 'ReaderC' with the same @env@ parameter.  Any 'askEnv's occurring in the second argument will have to unify not only with each other, but also with the first argument. Thus, if @ghc@ can infer the type of the any of these, it can infer all of them.","docstring_summary":"A handler for 'HasEnv' & 'ReaderC' with the same","docstring_tokens":["A","handler","for","HasEnv","&","ReaderC","with","the","same"],"function":"runEnv r = runReader r . runHasEnv","function_tokens":["runEnv","r","=","runReader","r",".","runHasEnv"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Inference.hs#L46-L46","hash_key":"fused-effects\/fused-effects:examples\/Inference.hs","hash_val":49733,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/State\/Labelled.hs","language":"haskell","identifier":"modifyLazy","parameters":"f","argument_list":"","return_statement":"","docstring":"Replace the state value with the result of applying a function to the current state value. This is lazy in the new state; injudicious use of this function may lead to space leaks.  @ 'modifyLazy' f = 'get' '>>=' 'put' . f @  @since 1.0.2.0","docstring_summary":"Replace the state value with the result of applying a function to the current state value. This is lazy in the new state; injudicious use of this function may lead to space leaks.","docstring_tokens":["Replace","the","state","value","with","the","result","of","applying","a","function","to","the","current","state","value",".","This","is","lazy","in","the","new","state",";","injudicious","use","of","this","function","may","lead","to","space","leaks","."],"function":"modifyLazy f = runUnderLabel @label (S.modifyLazy f)","function_tokens":["modifyLazy","f","=","runUnderLabel","@","label","(","S","modifyLazy","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/State\/Labelled.hs#L83-L83","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/State\/Labelled.hs","hash_val":51637,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"merge","parameters":"apnd s1 s2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge apnd s1 s2 = SplineT $ f s1 s2\n\n  where r c d = return $ Left (c, d)\n\n        fr c vb = runSplineT vb >=> \\case\n          Left d         -> r c d\n          Right (b, vb1) -> return $ Right (b, SplineT $ fr c vb1)\n\n        fl d va = runSplineT va >=> \\case\n          Left c         -> r c d\n          Right (b, va1) -> return $ Right (b, SplineT $ fl d va1)\n\n        f va vb a = runSplineT va a >>= \\case\n          Left c -> fr c vb a\n          Right (b1, va1) -> runSplineT vb a >>= \\case\n            Left d -> return $ Right (b1, SplineT $ fl d va1)\n            Right (b2, vb1) -> return $ Right (apnd b1 b2, SplineT $ f va1 vb1)\n\n-- | Capture the spline's last output value and tuple it with the\n-- spline's result. This is helpful when you want to sample the last\n-- output value in order to determine the next spline to sequence.\n--\n-- The tupled value is returned in as a 'Maybe b' since it is not\n-- guaranteed that an output value is produced before a Spline concludes.\n--\n-- >>> :{\n-- let\n--   s :: MonadIO m => SplineT () Int m String\n--   s = do\n--     (mayX, boomStr) <-\n--       capture\n--         $ do\n--           step 0\n--           step 1\n--           step 2\n--           return \"boom\"\n--     -- x is 2, but 'capture' can't be sure of that\n--     maybe\n--       (return \"Failure\")\n--       ( (>> return boomStr)\n--         . step\n--         . (+1)\n--       )\n--       mayX\n-- in\n--   testVarOver (outputStream s 666) [(),(),(),()]\n-- >>> :}\n-- 0\n-- 1\n-- 2\n-- 3","function_tokens":["merge","apnd","s1","s2","=","SplineT","$","f","s1","s2","where","r","c","d","=","return","$","Left","(","c",",","d",")","fr","c","vb","=","runSplineT","vb",">=>","\\","case","Left","d","->","r","c","d","Right","(","b",",","vb1",")","->","return","$","Right","(","b",",","SplineT","$","fr","c","vb1",")","fl","d","va","=","runSplineT","va",">=>","\\","case","Left","c","->","r","c","d","Right","(","b",",","va1",")","->","return","$","Right","(","b",",","SplineT","$","fl","d","va1",")","f","va","vb","a","=","runSplineT","va","a",">>=","\\","case","Left","c","->","fr","c","vb","a","Right","(","b1",",","va1",")","->","runSplineT","vb","a",">>=","\\","case","Left","d","->","return","$","Right","(","b1",",","SplineT","$","fl","d","va1",")","Right","(","b2",",","vb1",")","->","return","$","Right","(","apnd","b1","b2",",","SplineT","$","f","va1","vb1",")","-- | Capture the spline's last output value and tuple it with the","-- spline's result. This is helpful when you want to sample the last","-- output value in order to determine the next spline to sequence.","--","-- The tupled value is returned in as a 'Maybe b' since it is not","-- guaranteed that an output value is produced before a Spline concludes.","--","-- >>> :{","-- let","--   s :: MonadIO m => SplineT () Int m String","--   s = do","--     (mayX, boomStr) <-","--       capture","--         $ do","--           step 0","--           step 1","--           step 2","--           return \"boom\"","--     -- x is 2, but 'capture' can't be sure of that","--     maybe","--       (return \"Failure\")","--       ( (>> return boomStr)","--         . step","--         . (+1)","--       )","--       mayX","-- in","--   testVarOver (outputStream s 666) [(),(),(),()]","-- >>> :}","-- 0","-- 1","-- 2","-- 3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L293-L344","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"f","parameters":"ys []     b _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f ys []     b _    = return $ Right (b, SplineT $ f [] ys mempty)","function_tokens":["f","ys","[","]","b","_","=","return","$","Right","(","b",",","SplineT","$","f","[","]","ys","mempty",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L271-L271","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"sigDigits","parameters":"0","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sigDigits 0 = 1","function_tokens":["sigDigits","0","=","1"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L82-L82","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"adjust","parameters":"_ _ _ (CInsert xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"adjust _ _ _ (CInsert xs) = CInsert xs","function_tokens":["adjust","_","_","_","(","CInsert","xs",")","=","CInsert","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L185-L185","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"sample","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sample = liftA2 (+) (runUnderLabel @\"fore\" ask) (runUnderLabel @\"aft\" ask)","function_tokens":["sample","=","liftA2","(","+",")","(","runUnderLabel","@","\"fore\"","ask",")","(","runUnderLabel","@","\"aft\"","ask",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L21-L21","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = Int32","function_tokens":["val","=","Int32"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L354-L354","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"subMatrix","parameters":"","argument_list":"","return_statement":"","docstring":"O(1) Extract sub matrix","docstring_summary":"O(1) Extract sub matrix","docstring_tokens":["O","(","1",")","Extract","sub","matrix"],"function":"subMatrix = MG.subMatrix","function_tokens":["subMatrix","=","MG","subMatrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L196-L196","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(new, val) = go is ts (depth + 1) (valid && not i) left","function_tokens":["(","new",",","val",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L75-L75","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _           = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L345-L345","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"forkIO","parameters":"","argument_list":"","return_statement":"","docstring":"Like @Control.Concurrent.'Control.Concurrent.forkIO'@ but returns a computation that when executed blocks until the thread terminates then returns the final value of the thread.","docstring_summary":"Like","docstring_tokens":["Like"],"function":"forkIO = fork rawForkIO","function_tokens":["forkIO","=","fork","rawForkIO"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L84-L84","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"safeHead","parameters":"list","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"safeHead list = case list of\n                           x:_ -> Just x\n                           _   -> Nothing","function_tokens":["safeHead","list","=","case","list","of","x",":","_","->","Just","x","_","->","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L265-L268","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"valList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"valList = String . T.pack","function_tokens":["valList","=","String",".","T","pack"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L263-L263","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"result = fromMaybe err (lookup k doc)","function_tokens":["result","=","fromMaybe","err","(","lookup","k","doc",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L112-L112","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/State\/Labelled.hs","language":"haskell","identifier":"gets","parameters":"f","argument_list":"","return_statement":"","docstring":"Project a function out of the current state value.  @ 'gets' f = 'fmap' f 'get' @  @since 1.0.2.0","docstring_summary":"Project a function out of the current state value.","docstring_tokens":["Project","a","function","out","of","the","current","state","value","."],"function":"gets f = runUnderLabel @label (S.gets f)","function_tokens":["gets","f","=","runUnderLabel","@","label","(","S","gets","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/State\/Labelled.hs#L48-L48","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/State\/Labelled.hs","hash_val":51637,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = ReaderC . const","function_tokens":["lift","=","ReaderC",".","const"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L93-L93","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"ssortToSort","parameters":"SIntegralSort","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ssortToSort SIntegralSort    = IntegralSort","function_tokens":["ssortToSort","SIntegralSort","=","IntegralSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L74-L74","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain $ map checkTestTree\n  [ Inference.example\n  , Parser.example\n  , ReinterpretLog.example\n  , Teletype.example\n  , Labelled.example\n  ]","function_tokens":["main","=","defaultMain","$","map","checkTestTree","[","Inference","example",",","Parser","example",",","ReinterpretLog","example",",","Teletype","example",",","Labelled","example","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Main.hs#L14-L20","hash_key":"fused-effects\/fused-effects:examples\/Main.hs","hash_val":53801,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"(x : xs) (y : ys)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (x : xs) (y : ys) =\n        if x `beforeChange` y then x : go xs (y : ys) else y : go (x : xs) ys","function_tokens":["go","(","x",":","xs",")","(","y",":","ys",")","=","if","x","`","beforeChange","`","y","then","x",":","go","xs","(","y",":","ys",")","else","y",":","go","(","x",":","xs",")","ys"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L72-L73","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"bodies","parameters":"f c@Conflict{cBodies}","argument_list":"","return_statement":"","docstring":"traversal","docstring_summary":"traversal","docstring_tokens":["traversal"],"function":"bodies f c@Conflict{cBodies} = (\\x -> c{cBodies = x}) <$> f cBodies","function_tokens":["bodies","f","c","@","Conflict","{","cBodies","}","=","(","\\","x","->","c","{","cBodies","=","x","}",")","<$>","f","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L36-L36","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"prefix","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prefix = replicate count c","function_tokens":["prefix","=","replicate","count","c"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L62-L62","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"sequence","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sequence = MG.sequence","function_tokens":["sequence","=","MG","sequence"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L372-L372","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"delete","parameters":"tree id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delete tree id = modifyAt tree id f\n    where f _ _ (nodes, cache) =\n              let deleted = filter (not . idMatches id . fst) $ nodes\n              in Bucket (deleted, cache)\n\n-- | Handle a timed out node by incrementing its timeoutCount and deleting it\n--  if the count exceeds the limit. Also, return wether it's reasonable to ping\n--  the node again.","function_tokens":["delete","tree","id","=","modifyAt","tree","id","f","where","f","_","_","(","nodes",",","cache",")","=","let","deleted","=","filter","(","not",".","idMatches","id",".","fst",")","$","nodes","in","Bucket","(","deleted",",","cache",")","-- | Handle a timed out node by incrementing its timeoutCount and deleting it","--  if the count exceeds the limit. Also, return wether it's reasonable to ping","--  the node again."],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L109-L117","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"handleTimeout","parameters":"tree id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"handleTimeout tree id = bothAt tree id f\n    where f _ _ (nodes, cache) = case L.find (idMatches id . fst) nodes of\n            -- Delete a node that exceeded the limit. Don't contact it again\n            --   as it is now considered dead\n            Just x@(_, 4) -> (Bucket (L.delete x $ nodes, cache), False)\n            -- Increment the timeoutCount\n            Just x@(n, timeoutCount) ->\n                 (Bucket ((n, timeoutCount + 1) : L.delete x nodes, cache), True)\n            -- Don't contact an unknown node a second time\n            Nothing -> (Bucket (nodes, cache), False)\n\n-- | Refresh the node corresponding to a supplied Id by placing it at the first\n--   index of it's KBucket and reseting its timeoutCount, then return a Bucket\n--   NodeTreeElem","function_tokens":["handleTimeout","tree","id","=","bothAt","tree","id","f","where","f","_","_","(","nodes",",","cache",")","=","case","L","find","(","idMatches","id",".","fst",")","nodes","of","-- Delete a node that exceeded the limit. Don't contact it again","--   as it is now considered dead","Just","x","@","(","_",",","4",")","->","(","Bucket","(","L","delete","x","$","nodes",",","cache",")",",","False",")","-- Increment the timeoutCount","Just","x","@","(","n",",","timeoutCount",")","->","(","Bucket","(","(","n",",","timeoutCount","+","1",")",":","L","delete","x","nodes",",","cache",")",",","True",")","-- Don't contact an unknown node a second time","Nothing","->","(","Bucket","(","nodes",",","cache",")",",","False",")","-- | Refresh the node corresponding to a supplied Id by placing it at the first","--   index of it's KBucket and reseting its timeoutCount, then return a Bucket","--   NodeTreeElem"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L118-L132","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"runApplication","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"runApplication\n  = runLogStdout                    -- IO ()\n  . reinterpretLog renderLogMessage -- LogStdoutC IO ()\n  $ application","function_tokens":["runApplication","=","runLogStdout","-- IO ()",".","reinterpretLog","renderLogMessage","-- LogStdoutC IO ()","$","application"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L67-L70","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"mapM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM = MG.mapM","function_tokens":["mapM","=","MG","mapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L238-L238","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"hsTyReplacements","parameters":"(GHC.HsFunTy xann arr _ _)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"hsTyReplacements (GHC.HsFunTy xann arr _ _)\n    | GHC.HsUnrestrictedArrow GHC.NormalSyntax <- arr\n    , GHC.AddRarrowAnn (GHC.EpaSpan loc) <- GHC.anns xann =\n        Editor.replaceRealSrcSpan loc \"\u2192\"","function_tokens":["hsTyReplacements","(","GHC","HsFunTy","xann","arr","_","_",")","|","GHC","HsUnrestrictedArrow","GHC","NormalSyntax","<-","arr",",","GHC","AddRarrowAnn","(","GHC","EpaSpan","loc",")","<-","GHC","anns","xann","=","Editor","replaceRealSrcSpan","loc","\"\u2192\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L22-L25","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"byteOrderMark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"byteOrderMark = do\n    char '\\xFFFE' <|> char '\\xFEFF'\n    return ()","function_tokens":["byteOrderMark","=","do","char","'\\xFFFE'","<|>","char","'\\xFEFF'","return","(",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L88-L92","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/lib\/HSInstall\/Paths.hs","language":"haskell","identifier":"stripVersion","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stripVersion = reverse . tail . dropWhile (\/= '-') . reverse","function_tokens":["stripVersion","=","reverse",".","tail",".","dropWhile","(","\/=","'-'",")",".","reverse"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/lib\/HSInstall\/Paths.hs#L45-L45","hash_key":"dino-\/hsinstall:src\/lib\/HSInstall\/Paths.hs","hash_val":52086,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWithM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM = MG.zipWithM","function_tokens":["zipWithM","=","MG","zipWithM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L339-L339","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"izipWith6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith6 = MG.izipWith6","function_tokens":["izipWith6","=","MG","izipWith6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L308-L308","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"f","parameters":"depth _ (nodes, cache)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f depth _ (nodes, cache) =\n            let (leftNodes, rightNodes) = splitBucket depth fst nodes\n                (leftCache, rightCache) = splitBucket depth id cache\n            in  Split\n                   (Bucket (leftNodes, leftCache))\n                   (Bucket (rightNodes, rightCache))","function_tokens":["f","depth","_","(","nodes",",","cache",")","=","let","(","leftNodes",",","rightNodes",")","=","splitBucket","depth","fst","nodes","(","leftCache",",","rightCache",")","=","splitBucket","depth","id","cache","in","Split","(","Bucket","(","leftNodes",",","leftCache",")",")","(","Bucket","(","rightNodes",",","rightCache",")",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L171-L176","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"withSort","parameters":"(SArraySort i e) a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withSort (SArraySort i e) a = withSort i $ withSort e $ a","function_tokens":["withSort","(","SArraySort","i","e",")","a","=","withSort","i","$","withSort","e","$","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L60-L60","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L365-L365","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = StateC $ \\ k s -> k s a","function_tokens":["pure","a","=","StateC","$","\\","k","s","->","k","s","a"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L78-L78","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show","parameters":"(ArraySort i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (ArraySort i e) = \"array \" ++ show' i ++ \" \" ++ show' e","function_tokens":["show","(","ArraySort","i","e",")","=","\"array \"","++","show'","i","++","\" \"","++","show'","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L70-L70","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"g","parameters":"vf sx a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g vf sx a = do\n          (f, vf1) <- runVarT vf a\n          flip fmap (runSplineT sx (f a)) $ \\case\n           Left c         -> Left c\n           Right (b, sx1) -> Right (b, SplineT $ g vf1 sx1)\n\n--------------------------------------------------------------------------------\n-- $proofs\n-- ==Left Identity\n-- > k =<< return c = k c\n--\n-- > -- Definition of =<<\n-- > fix (\\f s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (k c) a\n-- >       Right s' -> return (Right (fmap f s')))) (return c)\n--\n-- > -- Definition of fix\n-- > (\\s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (k c) a\n-- >       Right s' -> return (Right (fmap (k =<<) s')))) (return c)\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   runSplineT (return c) a >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Definition of return\n-- > SplineT (\\a ->\n-- >   runSplineT (SplineT (\\_ -> return (Left c))) a >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Newtype\n-- > SplineT (\\a ->\n-- >   (\\_ -> return (Left c)) a >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   return (Left c) >>= \\case\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- return x >>= f = f x\n-- > SplineT (\\a ->\n-- >   case (Left c) of\n-- >     Left c -> runSplineT (k c) a\n-- >     Right s' -> return (Right (fmap (k =<<) s')))\n--\n-- > -- Case evaluation\n-- > SplineT (\\a -> runSplineT (k c) a)\n--\n-- > -- Eta reduction\n-- > SplineT (runSplineT (k c))\n--\n-- > -- Newtype\n-- > k c\n--\n-- ==Right Identity\n-- > return =<< m = m\n--\n-- > -- Definition of =<<\n-- > fix (\\f s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (return c) a\n-- >       Right s' -> return (Right (fmap f s')))) m\n--\n-- > -- Definition of fix\n-- > (\\s ->\n-- >   SplineT (\\a ->\n-- >     runSplineT s a >>= \\case\n-- >       Left c -> runSplineT (return c) a\n-- >       Right s' -> return (Right (fmap (return =<<) s')))) m\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> runSplineT (return c) a\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- Definition of return\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> runSplineT (SplineT (\\_ -> return (Left c))) a\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- Newtype\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> (\\_ -> return (Left c)) a\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- Application\n-- > SplineT (\\a ->\n-- >   runSplineT m a >>= \\case\n-- >     Left c -> return (Left c)\n-- >     Right s' -> return (Right (fmap (return =<<) s')))\n--\n-- > -- m >>= return . f = fmap f m\n-- > SplineT (\\a -> fmap (either id (fmap (return =<<))) (runSplineT m a))\n--\n-- > -- Coinduction\n-- > SplineT (\\a -> fmap (either id (fmap id)) (runSplineT m a))\n--\n-- > -- fmap id = id\n-- > SplineT (\\a -> fmap (either id id) (runSplineT m a))\n--\n-- > -- either id id = id\n-- > SplineT (\\a -> fmap id (runSplineT m a))\n--\n-- > -- fmap id = id\n-- > SplineT (\\a -> runSplineT m a)\n--\n-- > -- Eta reduction\n-- > SplineT (runSplineT m)\n--\n-- > -- Newtype\n-- > m\n--\n-- ==Application\n-- > (m >>= f) >>= g = m >>= (\\x -> f x >>= g)\n\n-- TODO: Finish the rest of the hand proofs","function_tokens":["g","vf","sx","a","=","do","(","f",",","vf1",")","<-","runVarT","vf","a","flip","fmap","(","runSplineT","sx","(","f","a",")",")","$","\\","case","Left","c","->","Left","c","Right","(","b",",","sx1",")","->","Right","(","b",",","SplineT","$","g","vf1","sx1",")","--------------------------------------------------------------------------------","-- $proofs","-- ==Left Identity","-- > k =<< return c = k c","--","-- > -- Definition of =<<","-- > fix (\\f s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (k c) a","-- >       Right s' -> return (Right (fmap f s')))) (return c)","--","-- > -- Definition of fix","-- > (\\s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (k c) a","-- >       Right s' -> return (Right (fmap (k =<<) s')))) (return c)","--","-- > -- Application","-- > SplineT (\\a ->","-- >   runSplineT (return c) a >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Definition of return","-- > SplineT (\\a ->","-- >   runSplineT (SplineT (\\_ -> return (Left c))) a >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Newtype","-- > SplineT (\\a ->","-- >   (\\_ -> return (Left c)) a >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Application","-- > SplineT (\\a ->","-- >   return (Left c) >>= \\case","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- return x >>= f = f x","-- > SplineT (\\a ->","-- >   case (Left c) of","-- >     Left c -> runSplineT (k c) a","-- >     Right s' -> return (Right (fmap (k =<<) s')))","--","-- > -- Case evaluation","-- > SplineT (\\a -> runSplineT (k c) a)","--","-- > -- Eta reduction","-- > SplineT (runSplineT (k c))","--","-- > -- Newtype","-- > k c","--","-- ==Right Identity","-- > return =<< m = m","--","-- > -- Definition of =<<","-- > fix (\\f s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (return c) a","-- >       Right s' -> return (Right (fmap f s')))) m","--","-- > -- Definition of fix","-- > (\\s ->","-- >   SplineT (\\a ->","-- >     runSplineT s a >>= \\case","-- >       Left c -> runSplineT (return c) a","-- >       Right s' -> return (Right (fmap (return =<<) s')))) m","--","-- > -- Application","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> runSplineT (return c) a","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- Definition of return","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> runSplineT (SplineT (\\_ -> return (Left c))) a","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- Newtype","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> (\\_ -> return (Left c)) a","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- Application","-- > SplineT (\\a ->","-- >   runSplineT m a >>= \\case","-- >     Left c -> return (Left c)","-- >     Right s' -> return (Right (fmap (return =<<) s')))","--","-- > -- m >>= return . f = fmap f m","-- > SplineT (\\a -> fmap (either id (fmap (return =<<))) (runSplineT m a))","--","-- > -- Coinduction","-- > SplineT (\\a -> fmap (either id (fmap id)) (runSplineT m a))","--","-- > -- fmap id = id","-- > SplineT (\\a -> fmap (either id id) (runSplineT m a))","--","-- > -- either id id = id","-- > SplineT (\\a -> fmap id (runSplineT m a))","--","-- > -- fmap id = id","-- > SplineT (\\a -> runSplineT m a)","--","-- > -- Eta reduction","-- > SplineT (runSplineT m)","--","-- > -- Newtype","-- > m","--","-- ==Application","-- > (m >>= f) >>= g = m >>= (\\x -> f x >>= g)","-- TODO: Finish the rest of the hand proofs"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L390-L519","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"rType","parameters":"(RETURN_VALUE id _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rType (RETURN_VALUE id _) = Just (R_RETURN_VALUE id)","function_tokens":["rType","(","RETURN_VALUE","id","_",")","=","Just","(","R_RETURN_VALUE","id",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L58-L58","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"toRows","parameters":"","argument_list":"","return_statement":"","docstring":"O(m) Return the rows","docstring_summary":"O(m) Return the rows","docstring_tokens":["O","(","m",")","Return","the","rows"],"function":"toRows = MG.toRows","function_tokens":["toRows","=","MG","toRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L174-L174","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"fl","parameters":"d va","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fl d va = runSplineT va >=> \\case\n          Left c         -> r c d\n          Right (b, va1) -> return $ Right (b, SplineT $ fl d va1)","function_tokens":["fl","d","va","=","runSplineT","va",">=>","\\","case","Left","c","->","r","c","d","Right","(","b",",","va1",")","->","return","$","Right","(","b",",","SplineT","$","fl","d","va1",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L301-L305","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"openOn","parameters":"port id rq","argument_list":"","return_statement":"","docstring":"Open a Kademlia connection on specified port and return a corresponding KademliaHandle","docstring_summary":"Open a Kademlia connection on specified port and return a corresponding KademliaHandle","docstring_tokens":["Open","a","Kademlia","connection","on","specified","port","and","return","a","corresponding","KademliaHandle"],"function":"openOn port id rq = withSocketsDo $ do\n    -- Get addr to bind to\n    (serveraddr:_) <- getAddrInfo\n                 (Just (defaultHints {addrFlags = [AI_PASSIVE]}))\n                 Nothing (Just port)\n\n    -- Create socket and bind to it\n    sock <- socket (addrFamily serveraddr) Datagram defaultProtocol\n    bindSocket sock (addrAddress serveraddr)\n\n    chan <- newChan\n    tId <- forkIO . sendProcess sock id $ chan\n    mvar <- newEmptyMVar\n\n    -- Return the handle\n    return $ KH sock tId chan rq mvar","function_tokens":["openOn","port","id","rq","=","withSocketsDo","$","do","-- Get addr to bind to","(","serveraddr",":","_",")","<-","getAddrInfo","(","Just","(","defaultHints","{","addrFlags","=","[","AI_PASSIVE","]","}",")",")","Nothing","(","Just","port",")","-- Create socket and bind to it","sock","<-","socket","(","addrFamily","serveraddr",")","Datagram","defaultProtocol","bindSocket","sock","(","addrAddress","serveraddr",")","chan","<-","newChan","tId","<-","forkIO",".","sendProcess","sock","id","$","chan","mvar","<-","newEmptyMVar","-- Return the handle","return","$","KH","sock","tId","chan","rq","mvar"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L46-L63","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"f","parameters":"(l:ls)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f (l:ls) = (Just l, ls)","function_tokens":["f","(","l",":","ls",")","=","(","Just","l",",","ls",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L76-L76","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zip5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip5 = MG.zip5","function_tokens":["zip5","=","MG","zip5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L329-L329","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"follows","parameters":"(Block _ e1) (Block s2 _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"follows (Block _ e1) (Block s2 _) = e1 == s2 || e1 + 1 == s2","function_tokens":["follows","(","Block","_","e1",")","(","Block","s2","_",")","=","e1","==","s2","||","e1","+","1","==","s2"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L62-L62","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"fromList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromList = MG.fromList","function_tokens":["fromList","=","MG","fromList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L151-L151","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"fromColumns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromColumns = tr . MG.fromRows","function_tokens":["fromColumns","=","tr",".","MG","fromRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L182-L182","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"showHexLen","parameters":"d n","argument_list":"","return_statement":"","docstring":"^ showHex of n padded with leading zeros if necessary to fill d digits","docstring_summary":"^ showHex of n padded with leading zeros if necessary to fill d digits","docstring_tokens":["^","showHex","of","n","padded","with","leading","zeros","if","necessary","to","fill","d","digits"],"function":"showHexLen d n = showString (replicate (d - sigDigits n) '0') . showHex n  where\n  sigDigits 0 = 1\n  sigDigits n' = truncate (logBase 16 $ fromIntegral n' :: Double) + 1\n\n-- * Document","function_tokens":["showHexLen","d","n","=","showString","(","replicate","(","d","-","sigDigits","n",")","'0'",")",".","showHex","n","where","sigDigits","0","=","1","sigDigits","n'","=","truncate","(","logBase","16","$","fromIntegral","n'","::","Double",")","+","1","-- * Document"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L81-L87","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"isSymmetric","parameters":"m@(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSymmetric m@(Matrix r c _ _ _) | r \/= c = False\n                                 | otherwise = all f [0 .. r-1]\n  where\n    f i = all g [i + 1 .. c-1]\n      where g j = m MG.! (i,j) == m MG.! (j,i)","function_tokens":["isSymmetric","m","@","(","Matrix","r","c","_","_","_",")","|","r","\/=","c","=","False","|","otherwise","=","all","f","[","0","..","r","-","1","]","where","f","i","=","all","g","[","i","+","1","..","c","-","1","]","where","g","j","=","m","MG","!","(","i",",","j",")","==","m","MG","!","(","j",",","i",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L267-L272","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"parse","parameters":"","argument_list":"","return_statement":"","docstring":"Parse a module description, returning an error if unsuccessful.","docstring_summary":"Parse a module description, returning an error if unsuccessful.","docstring_tokens":["Parse","a","module","description","returning","an","error","if","unsuccessful","."],"function":"parse = runParser abcFile () \"\"","function_tokens":["parse","=","runParser","abcFile","(",")","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L49-L49","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"expect","parameters":"kh reg","argument_list":"","return_statement":"","docstring":"Register a handler channel for a Reply","docstring_summary":"Register a handler channel for a Reply","docstring_tokens":["Register","a","handler","channel","for","a","Reply"],"function":"expect kh reg = register reg . replyQueue $ kh","function_tokens":["expect","kh","reg","=","register","reg",".","replyQueue","$","kh"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L119-L119","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWithM","parameters":"f m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM f m1 m2\n    | MG.dim m1 \/= MG.dim m2 = error \"zipWithM: Dimensions don't match.\"\n    | otherwise = liftM (MG.fromVector $ MG.dim m1) $\n                  G.zipWithM f (MG.flatten m1) $ MG.flatten m2","function_tokens":["zipWithM","f","m1","m2","|","MG","dim","m1","\/=","MG","dim","m2","=","error","\"zipWithM: Dimensions don't match.\"","|","otherwise","=","liftM","(","MG","fromVector","$","MG","dim","m1",")","$","G","zipWithM","f","(","MG","flatten","m1",")","$","MG","flatten","m2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L523-L526","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"apply","parameters":"(Edits edits)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"apply (Edits edits) = case conflicts (Edits edits) of\n    c : _ -> error $ \"Language.Haskell.Stylish.Editor: \" ++ prettyConflict c\n    _     -> go 1 (editsFor 1)\n  where\n    editsFor i = fromMaybe [] $ M.lookup i edits\n\n    go _ _ [] = []\n    go i [] (l : ls) = l : go (i + 1) (editsFor $ i + 1) ls\n    go i (CInsert ls' : cs) ls = ls' ++ go i cs ls\n    go i (CBlock n f : _cs) ls =\n        let (domain, ls') = splitAt n ls in\n        f domain ++ go (i + n) (editsFor $ i + n) ls'\n    go i (CLine xstart xend x : cs) (l : ls) =\n        let l' = take (xstart - 1) l ++ x ++ drop (xend - 1) l in\n        go i (adjust xstart xend x <$> cs) (l' : ls)\n\n    adjust _ _ _ (CInsert xs) = CInsert xs\n    adjust _ _ _ (CBlock n f) = CBlock n f\n    adjust xstart xend x (CLine ystart yend y)\n        | ystart >= xend =\n            let offset = length x - (xend - xstart) in\n            CLine (ystart + offset) (yend + offset) y\n        | otherwise     = CLine ystart yend y","function_tokens":["apply","(","Edits","edits",")","=","case","conflicts","(","Edits","edits",")","of","c",":","_","->","error","$","\"Language.Haskell.Stylish.Editor: \"","++","prettyConflict","c","_","->","go","1","(","editsFor","1",")","where","editsFor","i","=","fromMaybe","[","]","$","M","lookup","i","edits","go","_","_","[","]","=","[","]","go","i","[","]","(","l",":","ls",")","=","l",":","go","(","i","+","1",")","(","editsFor","$","i","+","1",")","ls","go","i","(","CInsert","ls'",":","cs",")","ls","=","ls'","++","go","i","cs","ls","go","i","(","CBlock","n","f",":","_cs",")","ls","=","let","(","domain",",","ls'",")","=","splitAt","n","ls","in","f","domain","++","go","(","i","+","n",")","(","editsFor","$","i","+","n",")","ls'","go","i","(","CLine","xstart","xend","x",":","cs",")","(","l",":","ls",")","=","let","l'","=","take","(","xstart","-","1",")","l","++","x","++","drop","(","xend","-","1",")","l","in","go","i","(","adjust","xstart","xend","x","<$>","cs",")","(","l'",":","ls",")","adjust","_","_","_","(","CInsert","xs",")","=","CInsert","xs","adjust","_","_","_","(","CBlock","n","f",")","=","CBlock","n","f","adjust","xstart","xend","x","(","CLine","ystart","yend","y",")","|","ystart",">=","xend","=","let","offset","=","length","x","-","(","xend","-","xstart",")","in","CLine","(","ystart","+","offset",")","(","yend","+","offset",")","y","|","otherwise","=","CLine","ystart","yend","y"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L169-L191","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"_untilEvent_","parameters":"v ve","argument_list":"","return_statement":"","docstring":"A variant of 'untilEvent' that discards both the output and event values.","docstring_summary":"A variant of 'untilEvent' that discards both the output and event values.","docstring_tokens":["A","variant","of","untilEvent","that","discards","both","the","output","and","event","values","."],"function":"_untilEvent_ v ve = void $ _untilEvent v ve","function_tokens":["_untilEvent_","v","ve","=","void","$","_untilEvent","v","ve"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L224-L224","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val x   = valList [x]","function_tokens":["val","x","=","valList","[","x","]"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L273-L273","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Uuid x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Uuid x) = Just x","function_tokens":["cast'","(","Uuid","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L300-L300","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"izipWith4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith4 = MG.izipWith4","function_tokens":["izipWith4","=","MG","izipWith4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L296-L296","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"lspace","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lspace = whiteSpace lexer","function_tokens":["lspace","=","whiteSpace","lexer"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L133-L133","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"err","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"err = error $ \"expected (\" ++ show k ++ \" :: \" ++ show (typeOf result) ++ \") in \" ++ show doc","function_tokens":["err","=","error","$","\"expected (\"","++","show","k","++","\" :: \"","++","show","(","typeOf","result",")","++","\") in \"","++","show","doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L113-L113","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"timeoutThread","parameters":"reg rq","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"timeoutThread reg rq = forkIO $ do\n    -- Wait 5 seconds\n    threadDelay 5000000\n\n    -- Remove the ReplyRegistration from the ReplyQueue\n    myTId <- myThreadId\n\n    -- Send Timeout signal\n    writeChan (timeoutChan rq) . Timeout $ reg\n\n-- | Dispatch a reply over a registered handler. If there is no handler,\n--   dispatch it to the default one.","function_tokens":["timeoutThread","reg","rq","=","forkIO","$","do","-- Wait 5 seconds","threadDelay","5000000","-- Remove the ReplyRegistration from the ReplyQueue","myTId","<-","myThreadId","-- Send Timeout signal","writeChan","(","timeoutChan","rq",")",".","Timeout","$","reg","-- | Dispatch a reply over a registered handler. If there is no handler,","--   dispatch it to the default one."],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L94-L106","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"a (Bucket b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go a (Bucket b) = f (map fst . fst $ b) a","function_tokens":["go","a","(","Bucket","b",")","=","f","(","map","fst",".","fst","$","b",")","a"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L231-L231","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unsafeFromVector","parameters":"(r,c)","argument_list":"","return_statement":"","docstring":"O(1) Create matrix from vector.","docstring_summary":"O(1) Create matrix from vector.","docstring_tokens":["O","(","1",")","Create","matrix","from","vector","."],"function":"unsafeFromVector (r,c) = Matrix r c c 0","function_tokens":["unsafeFromVector","(","r",",","c",")","=","Matrix","r","c","c","0"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L150-L150","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"notFound","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"notFound = fail $ \"expected \" ++ show k ++ \" in \" ++ show doc","function_tokens":["notFound","=","fail","$","\"expected \"","++","show","k","++","\" in \"","++","show","doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L98-L98","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/State\/Labelled.hs","language":"haskell","identifier":"state","parameters":"f","argument_list":"","return_statement":"","docstring":"Compute a new state and a value in a single step.  @ 'state' f = 'gets' f '>>=' \\\\ (s, a) -> 'put' s '>>' 'pure' a @  @since 1.0.2.0","docstring_summary":"Compute a new state and a value in a single step.","docstring_tokens":["Compute","a","new","state","and","a","value","in","a","single","step","."],"function":"state f = runUnderLabel @label (S.state f)","function_tokens":["state","f","=","runUnderLabel","@","label","(","S","state","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/State\/Labelled.hs#L94-L94","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/State\/Labelled.hs","hash_val":51637,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zip3","parameters":"m1 m2 m3","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip3 m1 m2 m3\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 = error \"zip3: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zip3 (MG.flatten m1) (MG.flatten m2) $ MG.flatten m3","function_tokens":["zip3","m1","m2","m3","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","=","error","\"zip3: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zip3","(","MG","flatten","m1",")","(","MG","flatten","m2",")","$","MG","flatten","m3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L474-L478","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/IORef.hs","language":"haskell","identifier":"execState","parameters":"s","argument_list":"","return_statement":"","docstring":"Run a 'State' effect, yielding the final state and discarding the return value.  @ 'execState' s m = 'fmap' 'fst' ('runState' s m) @  @since 1.1.2.0","docstring_summary":"Run a 'State' effect, yielding the final state and discarding the return value.","docstring_tokens":["Run","a","State","effect","yielding","the","final","state","and","discarding","the","return","value","."],"function":"execState s = fmap fst . runState s","function_tokens":["execState","s","=","fmap","fst",".","runState","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/IORef.hs#L92-L92","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/IORef.hs","hash_val":53014,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (True:ts) (Split left right) n","argument_list":"","return_statement":"","docstring":"Take the closest nodes from the right child first, if those aren't enough, take the rest from the left","docstring_summary":"Take the closest nodes from the right child first, if those aren't enough, take the rest from the left","docstring_tokens":["Take","the","closest","nodes","from","the","right","child","first","if","those","aren","t","enough","take","the","rest","from","the","left"],"function":"go (i:is) (True:ts) (Split left right) n =\n            let result = go is ts right n\n            in if length result == n\n                then result\n                else result ++ go is ts left n","function_tokens":["go","(","i",":","is",")","(","True",":","ts",")","(","Split","left","right",")","n","=","let","result","=","go","is","ts","right","n","in","if","length","result","==","n","then","result","else","result","++","go","is","ts","left","n"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L207-L211","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"^ A BSON document is a list of 'Field's Recursively lookup a nested field in a Document.","docstring_summary":"^ A BSON document is a list of 'Field's Recursively lookup a nested field in a Document.","docstring_tokens":["^","A","BSON","document","is","a","list","of","Field","s","Recursively","lookup","a","nested","field","in","a","Document","."],"function":"doc !? l = foldM (flip lookup) doc (init chunks) >>= lookup (last chunks)\n  where chunks = T.split (== '.') l","function_tokens":["doc","!?","l","=","foldM","(","flip","lookup",")","doc","(","init","chunks",")",">>=","lookup","(","last","chunks",")","where","chunks","=","T","split","(","==","'.'",")","l"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L92-L95","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Lift.hs","language":"haskell","identifier":"liftWith","parameters":"with","argument_list":"","return_statement":"","docstring":"Run actions in an outer context.  This can be used to provide interoperation with @base@ functionality like @\"Control.Exception\".'Control.Exception.catch'@:  @ 'liftWith' $ \\\\ hdl ctx -> 'Control.Exception.catch' (hdl (m <$ ctx)) (hdl . (<$ ctx) . h) @  The higher-order function takes both an initial context, and a handler phrased as a distributive law (as described in the documentation for 'Handler'). This handler takes actions lifted into a context functor, which can be either the initial context, or the derived context produced by handling a previous action.  As with @MonadBaseControl@, care must be taken when lifting functions like @\"Control.Exception\".'Control.Exception.finally'@ which don\u2019t use the return value of one of their actions, as this can lead to dropped effects.  @since 1.0.0.0","docstring_summary":"Run actions in an outer context.  This can be used to provide interoperation with","docstring_tokens":["Run","actions","in","an","outer","context",".","This","can","be","used","to","provide","interoperation","with"],"function":"liftWith with = send (LiftWith with)","function_tokens":["liftWith","with","=","send","(","LiftWith","with",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Lift.hs#L67-L67","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Lift.hs","hash_val":53563,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"checkChanges","parameters":"_ (CLine _ _ _ : _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkChanges _ (CLine _ _ _ : _) = []","function_tokens":["checkChanges","_","(","CLine","_","_","_",":","_",")","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L164-L164","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show","parameters":"(DynamicallySorted _ a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (DynamicallySorted _ a) = show a","function_tokens":["show","(","DynamicallySorted","_","a",")","=","show","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L102-L102","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"go","parameters":"xs       []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go xs       []       = xs","function_tokens":["go","xs","[","]","=","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L71-L71","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"replaceRealSrcSpan","parameters":"rss repl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"replaceRealSrcSpan rss repl\n    | GHC.srcSpanStartLine rss \/= GHC.srcSpanEndLine rss = mempty\n    | otherwise                                          = replace\n        (GHC.srcSpanStartLine rss)\n        (GHC.srcSpanStartCol rss)\n        (GHC.srcSpanEndCol rss)\n        repl","function_tokens":["replaceRealSrcSpan","rss","repl","|","GHC","srcSpanStartLine","rss","\/=","GHC","srcSpanEndLine","rss","=","mempty","|","otherwise","=","replace","(","GHC","srcSpanStartLine","rss",")","(","GHC","srcSpanStartCol","rss",")","(","GHC","srcSpanEndCol","rss",")","repl"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L100-L106","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"takeDiag","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeDiag = MG.takeDiag","function_tokens":["takeDiag","=","MG","takeDiag"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L138-L138","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _         = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L380-L380","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = StateC $ \\ _ _ -> empty","function_tokens":["empty","=","StateC","$","\\","_","_","->","empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L96-L96","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Interpret.hs","language":"haskell","identifier":"modLoop","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modLoop i = for_ [1..i] (modify . (+))","function_tokens":["modLoop","i","=","for_","[","1","..","i","]","(","modify",".","(","+",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Interpret.hs#L46-L46","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Interpret.hs","hash_val":54530,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"insertLines","parameters":"line ls","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"insertLines line ls = Edits $ M.singleton line [CInsert ls]","function_tokens":["insertLines","line","ls","=","Edits","$","M","singleton","line","[","CInsert","ls","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L132-L132","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"applyAt","parameters":"(NodeTree idStruct elem) id f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"applyAt (NodeTree idStruct elem) id f =\n    let targetStruct = toByteStruct id\n    in go idStruct targetStruct 0 True elem\n    where -- This function is partial for the same reason as in modifyAt\n          --\n          -- Apply the function\n          go _ _ depth valid (Bucket b) = f depth valid b\n          -- If the bit is a 0, go left\n          go (i:is) (False:ts) depth valid (Split left _) =\n               go is ts (depth + 1) (valid && not i) left\n          -- Otherwise, continue to the right\n          go (i:is) (True:ts) depth valid (Split _ right) =\n               go is ts (depth + 1) (valid && i) right\n\n-- | Create a NodeTree corresponding to the id","function_tokens":["applyAt","(","NodeTree","idStruct","elem",")","id","f","=","let","targetStruct","=","toByteStruct","id","in","go","idStruct","targetStruct","0","True","elem","where","-- This function is partial for the same reason as in modifyAt","--","-- Apply the function","go","_","_","depth","valid","(","Bucket","b",")","=","f","depth","valid","b","-- If the bit is a 0, go left","go","(","i",":","is",")","(","False",":","ts",")","depth","valid","(","Split","left","_",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left","-- Otherwise, continue to the right","go","(","i",":","is",")","(","True",":","ts",")","depth","valid","(","Split","_","right",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right","-- | Create a NodeTree corresponding to the id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L84-L99","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"sequence_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sequence_ = MG.sequence_","function_tokens":["sequence_","=","MG","sequence_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L376-L376","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"f","parameters":"vve a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f vve a = do t <-runVarT vve a\n                     return $ case t of\n                       ((b, Nothing), vve1) -> Right (b, SplineT $ f vve1)\n                       ((b, Just c),    _)  -> Left (b, c)\n\n-- | A variant of 'untilEvent' that results in the last known output value.","function_tokens":["f","vve","a","=","do","t","<-","runVarT","vve","a","return","$","case","t","of","(","(","b",",","Nothing",")",",","vve1",")","->","Right","(","b",",","SplineT","$","f","vve1",")","(","(","b",",","Just","c",")",",","_",")","->","Left","(","b",",","c",")","-- | A variant of 'untilEvent' that results in the last known output value."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L206-L212","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"boolean","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"boolean = liftA2 (+) (L.get @'True) (L.get @'False)","function_tokens":["boolean","=","liftA2","(","+",")","(","L","get","@","'","True",")","(","L","get","@","'","False",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L61-L61","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"collectLogMessages","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"collectLogMessages = execWriter . runCollectLogMessagesC","function_tokens":["collectLogMessages","=","execWriter",".","runCollectLogMessagesC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L154-L154","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"vec","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vec = MG.flatten x","function_tokens":["vec","=","MG","flatten","x"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L255-L255","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"foldl","parameters":"f acc m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldl f acc m = G.foldl f acc . MG.flatten $ m","function_tokens":["foldl","f","acc","m","=","G","foldl","f","acc",".","MG","flatten","$","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L289-L289","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"f","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f [] = (Nothing, [])","function_tokens":["f","[","]","=","(","Nothing",",","[","]",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L75-L75","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"ssortToSort","parameters":"SBooleanSort","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ssortToSort SBooleanSort     = BooleanSort","function_tokens":["ssortToSort","SBooleanSort","=","BooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L73-L73","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Float x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Float x) = Just (round x)","function_tokens":["cast'","(","Float","x",")","=","Just","(","round","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L379-L379","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = MG.dim m","function_tokens":["d","=","MG","dim","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L575-L575","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"liftA2","parameters":"f (ReaderC a) (ReaderC b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftA2 f (ReaderC a) (ReaderC b) = ReaderC $ \\ r ->\n    liftA2 f (a r) (b r)","function_tokens":["liftA2","f","(","ReaderC","a",")","(","ReaderC","b",")","=","ReaderC","$","\\","r","->","liftA2","f","(","a","r",")","(","b","r",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L57-L58","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val             = Stamp","function_tokens":["val","=","Stamp"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L383-L383","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"notType","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"notType = fail $ \"expected \" ++ show (typeOf $ unMaybe castingResult) ++ \": \" ++ show v","function_tokens":["notType","=","fail","$","\"expected \"","++","show","(","typeOf","$","unMaybe","castingResult",")","++","\": \"","++","show","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L238-L238","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"matrix","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix construction","docstring_summary":"O(m*n) Matrix construction","docstring_tokens":["O","(","m","*","n",")","Matrix","construction"],"function":"matrix = MG.matrix","function_tokens":["matrix","=","MG","matrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L148-L148","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"ints","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ints = [blockStart b .. blockEnd b]","function_tokens":["ints","=","[","blockStart","b","..","blockEnd","b","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L76-L76","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show'","parameters":"BooleanSort","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show' BooleanSort     = \"bool\"","function_tokens":["show'","BooleanSort","=","\"bool\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L63-L63","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"lift","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift f = SplineT $ const $ Left <$> f","function_tokens":["lift","f","=","SplineT","$","const","$","Left","<$>","f"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L132-L132","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Errors.hs","language":"haskell","identifier":"alErrors","parameters":"","argument_list":"","return_statement":"","docstring":"OpenAL detects only a subset of those conditions that could be considered errors. This is because in many cases error checking would adversely impact the performance of an error-free program. The state variable 'alErrors' is used to obtain error information. When an error is detected by AL, a flag is set and the error code is recorded. Further errors, if they occur, do not affect this recorded code. When 'alErrors' is read, the error is returned and the flag is cleared, so that a further error will again record its code. If reading 'alErrors' returns @\\[\\]@ then there has been no detectable error since the last time 'alErrors' (or since the AL was initialized).  When an error flag is set, results of AL operations are undefined only if 'ALOutOfMemory' has occurred. In other cases, the command generating the error is ignored so that it has no effect on AL state or output buffer contents. If the error generating command returns a value, it returns zero. If the generating command modifies values through a pointer argument, no change is made to these values. These error semantics apply only to AL errors, not to system errors such as memory access errors.","docstring_summary":"OpenAL detects only a subset of those conditions that could be considered errors. This is because in many cases error checking would adversely impact the performance of an error-free program. The state variable 'alErrors' is used to obtain error information. When an error is detected by AL, a flag is set and the error code is recorded. Further errors, if they occur, do not affect this recorded code. When 'alErrors' is read, the error is returned and the flag is cleared, so that a further error will again record its code. If reading 'alErrors' returns","docstring_tokens":["OpenAL","detects","only","a","subset","of","those","conditions","that","could","be","considered","errors",".","This","is","because","in","many","cases","error","checking","would","adversely","impact","the","performance","of","an","error","-","free","program",".","The","state","variable","alErrors","is","used","to","obtain","error","information",".","When","an","error","is","detected","by","AL","a","flag","is","set","and","the","error","code","is","recorded",".","Further","errors","if","they","occur","do","not","affect","this","recorded","code",".","When","alErrors","is","read","the","error","is","returned","and","the","flag","is","cleared","so","that","a","further","error","will","again","record","its","code",".","If","reading","alErrors","returns"],"function":"alErrors =\n   makeGettableStateVar $ do\n      c <- alGetError\n      if c == al_NO_ERROR\n         then return []\n         else do\n            s <- getString (ALErrorCategory c)\n            return [ ALError (unmarshalALErrorCategory c) s ]","function_tokens":["alErrors","=","makeGettableStateVar","$","do","c","<-","alGetError","if","c","==","al_NO_ERROR","then","return","[","]","else","do","s","<-","getString","(","ALErrorCategory","c",")","return","[","ALError","(","unmarshalALErrorCategory","c",")","s","]"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Errors.hs#L82-L91","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Errors.hs","hash_val":54514,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unzip6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip6 = MG.unzip6","function_tokens":["unzip6","=","MG","unzip6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L369-L369","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"f","parameters":"ys (v:vs) b a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f ys (v:vs) b a = v a >>= \\case\n          Left c -> return $ Left c\n          Right (b1, s) -> f (ys ++ [runSplineT s]) vs (b <> b1) a\n\n-- | Run two splines in parallel, combining their output. Once both splines\n-- have concluded, return the results of each in a tuple.\n--\n-- >>> :{\n-- let s1 = pure \"hey \"   `_untilEvent` (1 >>> after 3)\n--     s2 = pure \"there!\" `_untilEvent` (1 >>> after 2)\n--     s  = do tuple <- merge (++) s1 s2\n--             step $ show tuple\n--     v  = outputStream s \"\"\n-- in testVarOver v [(),(),()]\n-- >>> :}\n-- \"hey there!\"\n-- \"hey \"\n-- \"(3,2)\"","function_tokens":["f","ys","(","v",":","vs",")","b","a","=","v","a",">>=","\\","case","Left","c","->","return","$","Left","c","Right","(","b1",",","s",")","->","f","(","ys","++","[","runSplineT","s","]",")","vs","(","b","<>","b1",")","a","-- | Run two splines in parallel, combining their output. Once both splines","-- have concluded, return the results of each in a tuple.","--","-- >>> :{","-- let s1 = pure \"hey \"   `_untilEvent` (1 >>> after 3)","--     s2 = pure \"there!\" `_untilEvent` (1 >>> after 2)","--     s  = do tuple <- merge (++) s1 s2","--             step $ show tuple","--     v  = outputStream s \"\"","-- in testVarOver v [(),(),()]","-- >>> :}","-- \"hey there!\"","-- \"hey \"","-- \"(3,2)\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L272-L290","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC a >>= f = StateC $ \\ k -> a (\\ s -> runState k s . f)","function_tokens":["StateC","a",">>=","f","=","StateC","$","\\","k","->","a","(","\\","s","->","runState","k","s",".","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L103-L103","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Reader.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = ReaderC $ \\ r -> case sig of\n    L Ask         -> pure (r <$ ctx)\n    L (Local f m) -> runReader (f r) (hdl (m <$ ctx))\n    R other       -> alg (runReader r . hdl) other ctx","function_tokens":["alg","hdl","sig","ctx","=","ReaderC","$","\\","r","->","case","sig","of","L","Ask","->","pure","(","r","<$","ctx",")","L","(","Local","f","m",")","->","runReader","(","f","r",")","(","hdl","(","m","<$","ctx",")",")","R","other","->","alg","(","runReader","r",".","hdl",")","other","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Reader.hs#L97-L101","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Reader.hs","hash_val":47105,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"getProcessID","parameters":"","argument_list":"","return_statement":"","docstring":"^ Get the current process id.","docstring_summary":"^ Get the current process id.","docstring_tokens":["^","Get","the","current","process","id","."],"function":"getProcessID = c_getpid","function_tokens":["getProcessID","=","c_getpid"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L65-L65","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Md5 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Md5 x) = Just x","function_tokens":["cast'","(","Md5","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L305-L305","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"f","parameters":"doc (k := v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f doc (k := v) = case findIndex ((k ==) . label) doc of\n                          Nothing -> doc ++ [k := v]\n                          Just i -> let (x, _ : y) = splitAt i doc in x ++ [k := v] ++ y\n\n-- * Field","function_tokens":["f","doc","(","k",":=","v",")","=","case","findIndex","(","(","k","==",")",".","label",")","doc","of","Nothing","->","doc","++","[","k",":=","v","]","Just","i","->","let","(","x",",","_",":","y",")","=","splitAt","i","doc","in","x","++","[","k",":=","v","]","++","y","-- * Field"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L126-L132","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/Setup.hs#L2-L2","hash_key":"fused-effects\/fused-effects:Setup.hs","hash_val":52564,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"sampleS","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sampleS = liftA2 (+) (runUnderLabel @\"fore\" get) (runUnderLabel @\"aft\" get)","function_tokens":["sampleS","=","liftA2","(","+",")","(","runUnderLabel","@","\"fore\"","get",")","(","runUnderLabel","@","\"aft\"","get",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L49-L49","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"maxDepth","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maxDepth = (length . toByteStruct . nodeId $ node) - 1","function_tokens":["maxDepth","=","(","length",".","toByteStruct",".","nodeId","$","node",")","-","1"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L149-L149","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"a'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a' = go a left","function_tokens":["a'","=","go","a","left"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L230-L230","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _                = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L259-L259","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unzip5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip5 = MG.unzip5","function_tokens":["unzip5","=","MG","unzip5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L363-L363","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"matchRegistrations","parameters":"(RR rtsA idA) (RR rtsB idB)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchRegistrations (RR rtsA idA) (RR rtsB idB) =\n    idA == idB && (all (`elem` rtsA) rtsB || all (`elem` rtsB) rtsA)","function_tokens":["matchRegistrations","(","RR","rtsA","idA",")","(","RR","rtsB","idB",")","=","idA","==","idB","&&","(","all","(","`","elem","`","rtsA",")","rtsB","||","all","(","`","elem","`","rtsB",")","rtsA",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L64-L65","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotPNG.hs","language":"haskell","identifier":"mkMap","parameters":"filepath map","argument_list":"","return_statement":"","docstring":"Given a `Map` write it to file, where the format is determined by the extension.","docstring_summary":"Given a `Map` write it to file, where the format is determined by the extension.","docstring_tokens":["Given","a","Map","write","it","to","file","where","the","format","is","determined","by","the","extension","."],"function":"mkMap filepath map = case getExt filepath of\n    \"png\" -> mkMapPng filepath map\n    \"svg\" -> mkMapSVG filepath map\n\n-- | Given a `Map` write it to file, where the format is determined by the\n-- extension.","function_tokens":["mkMap","filepath","map","=","case","getExt","filepath","of","\"png\"","->","mkMapPng","filepath","map","\"svg\"","->","mkMapSVG","filepath","map","-- | Given a `Map` write it to file, where the format is determined by the","-- extension."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotPNG.hs#L31-L37","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotPNG.hs","hash_val":49940,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"split","parameters":"tree splitId","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"split tree splitId = modifyAt tree splitId f\n    where f depth _ (nodes, cache) =\n            let (leftNodes, rightNodes) = splitBucket depth fst nodes\n                (leftCache, rightCache) = splitBucket depth id cache\n            in  Split\n                   (Bucket (leftNodes, leftCache))\n                   (Bucket (rightNodes, rightCache))\n\n          -- Recursivly split the nodes into two buckets\n          splitBucket _ _ []     = ([], [])\n          splitBucket i f (n:ns) = let bs = toByteStruct . nodeId . f $ n\n                                       bit = bs !! i\n                                       (left, right) = splitBucket i f ns\n                                   in if bit\n                                      then (left, n:right)\n                                      else (n:left, right)\n\n-- | Find the k closest Nodes to a given Id","function_tokens":["split","tree","splitId","=","modifyAt","tree","splitId","f","where","f","depth","_","(","nodes",",","cache",")","=","let","(","leftNodes",",","rightNodes",")","=","splitBucket","depth","fst","nodes","(","leftCache",",","rightCache",")","=","splitBucket","depth","id","cache","in","Split","(","Bucket","(","leftNodes",",","leftCache",")",")","(","Bucket","(","rightNodes",",","rightCache",")",")","-- Recursivly split the nodes into two buckets","splitBucket","_","_","[","]","=","(","[","]",",","[","]",")","splitBucket","i","f","(","n",":","ns",")","=","let","bs","=","toByteStruct",".","nodeId",".","f","$","n","bit","=","bs","!!","i","(","left",",","right",")","=","splitBucket","i","f","ns","in","if","bit","then","(","left",",","n",":","right",")","else","(","n",":","left",",","right",")","-- | Find the k closest Nodes to a given Id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L170-L188","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/State\/Labelled.hs","language":"haskell","identifier":"put","parameters":"s","argument_list":"","return_statement":"","docstring":"Replace the state value with a new value.  @ runState a ('runLabelled' @label ('put' @label b) '>>' m) = runState b m @  @since 1.0.2.0","docstring_summary":"Replace the state value with a new value.","docstring_tokens":["Replace","the","state","value","with","a","new","value","."],"function":"put s = runUnderLabel @label (S.put s)","function_tokens":["put","s","=","runUnderLabel","@","label","(","S","put","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/State\/Labelled.hs#L59-L59","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/State\/Labelled.hs","hash_val":51637,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"toDynamicallySorted","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toDynamicallySorted = DynamicallySorted (sing :: Sing s)","function_tokens":["toDynamicallySorted","=","DynamicallySorted","(","sing","::","Sing","s",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L113-L113","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"isSymmetric","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSymmetric = MG.isSymmetric","function_tokens":["isSymmetric","=","MG","isSymmetric"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L223-L223","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unzip4","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip4 m = ( MG.fromVector d v1\n           , MG.fromVector d v2\n           , MG.fromVector d v3\n           , MG.fromVector d v4\n           )\n  where\n    d = MG.dim m\n    (v1, v2, v3, v4) = G.unzip4 $ MG.flatten m","function_tokens":["unzip4","m","=","(","MG","fromVector","d","v1",",","MG","fromVector","d","v2",",","MG","fromVector","d","v3",",","MG","fromVector","d","v4",")","where","d","=","MG","dim","m","(","v1",",","v2",",","v3",",","v4",")","=","G","unzip4","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L554-L562","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unsafeThaw","parameters":"(Matrix r c tda offset v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeThaw (Matrix r c tda offset v) = MMatrix r c tda offset `liftM` G.unsafeThaw v","function_tokens":["unsafeThaw","(","Matrix","r","c","tda","offset","v",")","=","MMatrix","r","c","tda","offset","`","liftM","`","G","unsafeThaw","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L169-L169","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = MG.empty","function_tokens":["empty","=","MG","empty"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L167-L167","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' v = cast'List v >>= safeHead\n    where safeHead list = case list of\n                           x:_ -> Just x\n                           _   -> Nothing","function_tokens":["cast'","v","=","cast'List","v",">>=","safeHead","where","safeHead","list","=","case","list","of","x",":","_","->","Just","x","_","->","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L264-L268","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _        = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L321-L321","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"Retrieve the actual value from the result.  When the result is 'SomeException' the exception is thrown.","docstring_summary":"Retrieve the actual value from the result.  When the result is 'SomeException' the exception is thrown.","docstring_tokens":["Retrieve","the","actual","value","from","the","result",".","When","the","result","is","SomeException","the","exception","is","thrown","."],"function":"result = either throwIO return","function_tokens":["result","=","either","throwIO","return"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L146-L146","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'Maybe","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'Maybe v    = fmap Just (cast' v)","function_tokens":["cast'Maybe","v","=","fmap","Just","(","cast'","v",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L229-L229","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"raceAny","parameters":"ss","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"raceAny ss = SplineT $ f [] (map runSplineT ss) mempty\n  where f ys []     b _    = return $ Right (b, SplineT $ f [] ys mempty)\n        f ys (v:vs) b a = v a >>= \\case\n          Left c -> return $ Left c\n          Right (b1, s) -> f (ys ++ [runSplineT s]) vs (b <> b1) a\n\n-- | Run two splines in parallel, combining their output. Once both splines\n-- have concluded, return the results of each in a tuple.\n--\n-- >>> :{\n-- let s1 = pure \"hey \"   `_untilEvent` (1 >>> after 3)\n--     s2 = pure \"there!\" `_untilEvent` (1 >>> after 2)\n--     s  = do tuple <- merge (++) s1 s2\n--             step $ show tuple\n--     v  = outputStream s \"\"\n-- in testVarOver v [(),(),()]\n-- >>> :}\n-- \"hey there!\"\n-- \"hey \"\n-- \"(3,2)\"","function_tokens":["raceAny","ss","=","SplineT","$","f","[","]","(","map","runSplineT","ss",")","mempty","where","f","ys","[","]","b","_","=","return","$","Right","(","b",",","SplineT","$","f","[","]","ys","mempty",")","f","ys","(","v",":","vs",")","b","a","=","v","a",">>=","\\","case","Left","c","->","return","$","Left","c","Right","(","b1",",","s",")","->","f","(","ys","++","[","runSplineT","s","]",")","vs","(","b","<>","b1",")","a","-- | Run two splines in parallel, combining their output. Once both splines","-- have concluded, return the results of each in a tuple.","--","-- >>> :{","-- let s1 = pure \"hey \"   `_untilEvent` (1 >>> after 3)","--     s2 = pure \"there!\" `_untilEvent` (1 >>> after 2)","--     s  = do tuple <- merge (++) s1 s2","--             step $ show tuple","--     v  = outputStream s \"\"","-- in testVarOver v [(),(),()]","-- >>> :}","-- \"hey there!\"","-- \"hey \"","-- \"(3,2)\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L270-L290","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWith5","parameters":"f m1 m2 m3 m4 m5","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith5 f m1 m2 m3 m4 m5\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 ||\n      MG.dim m4 \/= MG.dim m5 = error \"zipWith5: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zipWith5 f (MG.flatten m1) (MG.flatten m2)\n                  (MG.flatten m3) (MG.flatten m4) $ MG.flatten m5","function_tokens":["zipWith5","f","m1","m2","m3","m4","m5","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","||","MG","dim","m4","\/=","MG","dim","m5","=","error","\"zipWith5: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zipWith5","f","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","(","MG","flatten","m4",")","$","MG","flatten","m5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L363-L370","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"fileHeader","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fileHeader = fmap (uncurry FileHeader . partitionEithers) $ many1 $ mzero \n    <|> fmap Left informationField \n    <|> fmap Right styleSheetDirective","function_tokens":["fileHeader","=","fmap","(","uncurry","FileHeader",".","partitionEithers",")","$","many1","$","mzero","<|>","fmap","Left","informationField","<|>","fmap","Right","styleSheetDirective"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L65-L67","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"thaw","parameters":"(Matrix r c tda offset v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thaw (Matrix r c tda offset v) = MMatrix r c tda offset `liftM` G.thaw v","function_tokens":["thaw","(","Matrix","r","c","tda","offset","v",")","=","MMatrix","r","c","tda","offset","`","liftM","`","G","thaw","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L166-L166","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"genObjectId","parameters":"","argument_list":"","return_statement":"","docstring":"^ Create a fresh ObjectId","docstring_summary":"^ Create a fresh ObjectId","docstring_tokens":["^","Create","a","fresh","ObjectId"],"function":"genObjectId = do\n  time <- truncate <$> getPOSIXTime\n  pid <- fromIntegral <$> getProcessID\n  inc <- nextCount\n  return $ Oid time (composite machineId pid inc)\n where\n  machineId :: Word24\n  machineId = unsafePerformIO (makeWord24 . S.unpack . S.take 3 . MD5.hash . SC.pack <$> getHostName)\n  {-# NOINLINE machineId #-}\n  counter :: IORef Word24\n  counter = unsafePerformIO (newIORef 0)\n  {-# NOINLINE counter #-}\n  nextCount :: IO Word24\n  nextCount = atomicModifyIORef counter $ \\n -> (wrap24 (n + 1), n)","function_tokens":["genObjectId","=","do","time","<-","truncate","<$>","getPOSIXTime","pid","<-","fromIntegral","<$>","getProcessID","inc","<-","nextCount","return","$","Oid","time","(","composite","machineId","pid","inc",")","where","machineId","::","Word24","machineId","=","unsafePerformIO","(","makeWord24",".","S","unpack",".","S","take","3",".","MD5","hash",".","SC","pack","<$>","getHostName",")","{-# NOINLINE machineId #-}","counter","::","IORef","Word24","counter","=","unsafePerformIO","(","newIORef","0",")","{-# NOINLINE counter #-}","nextCount","::","IO","Word24","nextCount","=","atomicModifyIORef","counter","$","\\","n","->","(","wrap24","(","n","+","1",")",",","n",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L456-L471","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' = cast'Maybe","function_tokens":["cast'","=","cast'Maybe"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L335-L335","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"fval","parameters":"f v","argument_list":"","return_statement":"","docstring":"^ Apply generic function to typed value","docstring_summary":"^ Apply generic function to typed value","docstring_tokens":["^","Apply","generic","function","to","typed","value"],"function":"fval f v = case v of\n            Float x   -> f x\n            String x  -> f x\n            Doc x     -> f x\n            Array x   -> f x\n            Bin x     -> f x\n            Fun x     -> f x\n            Uuid x    -> f x\n            Md5 x     -> f x\n            UserDef x -> f x\n            ObjId x   -> f x\n            Bool x    -> f x\n            UTC x     -> f x\n            Null      -> f (Nothing :: Maybe Value)\n            RegEx x   -> f x\n            JavaScr x -> f x\n            Sym x     -> f x\n            Int32 x   -> f x\n            Int64 x   -> f x\n            Stamp x   -> f x\n            MinMax x  -> f x\n\n-- * Value conversion","function_tokens":["fval","f","v","=","case","v","of","Float","x","->","f","x","String","x","->","f","x","Doc","x","->","f","x","Array","x","->","f","x","Bin","x","->","f","x","Fun","x","->","f","x","Uuid","x","->","f","x","Md5","x","->","f","x","UserDef","x","->","f","x","ObjId","x","->","f","x","Bool","x","->","f","x","UTC","x","->","f","x","Null","->","f","(","Nothing","::","Maybe","Value",")","RegEx","x","->","f","x","JavaScr","x","->","f","x","Sym","x","->","f","x","Int32","x","->","f","x","Int64","x","->","f","x","Stamp","x","->","f","x","MinMax","x","->","f","x","-- * Value conversion"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L181-L205","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"sequence","parameters":"(Matrix r c tda offset vec)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sequence (Matrix r c tda offset vec) = liftM (Matrix r c tda offset) . G.sequence $ vec","function_tokens":["sequence","(","Matrix","r","c","tda","offset","vec",")","=","liftM","(","Matrix","r","c","tda","offset",")",".","G","sequence","$","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L597-L597","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L441-L441","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"fold","parameters":"f init (NodeTree _ elems)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fold f init (NodeTree _ elems) = go init elems\n    where go a (Split left right) = let a' = go a left in go a' right\n          go a (Bucket b) = f (map fst . fst $ b) a","function_tokens":["fold","f","init","(","NodeTree","_","elems",")","=","go","init","elems","where","go","a","(","Split","left","right",")","=","let","a'","=","go","a","left","in","go","a'","right","go","a","(","Bucket","b",")","=","f","(","map","fst",".","fst","$","b",")","a"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L229-L231","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"louispan\/glazier-pipes","sha":"ebd15c98cea28ad2e15786512ba8607bb5b6434e","path":"src\/Glazier\/Pipes\/Ui.hs","language":"haskell","identifier":"runUi","parameters":"refreshDelay render appSignal","argument_list":"","return_statement":"","docstring":"This is similar to part of the Elm startApp. This is responsible for running the Glazier Gadget update tick until it quits. This is also responsible for rendering the frame. This function is only required if you are not using another application framework which already takes care of rendering and processing user input.","docstring_summary":"This is similar to part of the Elm startApp. This is responsible for running the Glazier Gadget update tick until it quits. This is also responsible for rendering the frame. This function is only required if you are not using another application framework which already takes care of rendering and processing user input.","docstring_tokens":["This","is","similar","to","part","of","the","Elm","startApp",".","This","is","responsible","for","running","the","Glazier","Gadget","update","tick","until","it","quits",".","This","is","also","responsible","for","rendering","the","frame",".","This","function","is","only","required","if","you","are","not","using","another","application","framework","which","already","takes","care","of","rendering","and","processing","user","input","."],"function":"runUi refreshDelay render appSignal = do\n    -- framerate thread\n    -- TMVar to indicate that the render thread can render, start non empty so we can render straight away.\n    triggerRender <- liftIO $ newTMVarIO ()\n    frameRateThread <-\n        liftIO $\n        forkIO . void . forever $\n        -- The will ensure a refreshDelay in between times when value in canRender is taken.\n        -- wait until canRender is empty (ie taken by the render thread)\n         do\n            atomically $ STE.waitTillEmptyTMVar triggerRender ()\n            -- if empty, then wait delay before filling TMVar with next canRender value\n            threadDelay refreshDelay\n            atomically $ putTMVar triggerRender ()\n\n    -- render thread\n    enableRenderThread <- liftIO $ newTMVarIO ()\n    finishedRenderThread <- liftIO newEmptyTMVarIO\n    latestState <- liftIO newEmptyTMVarIO\n    void . liftIO $\n        forkFinally\n            (void . runMaybeT . forever $\n              -- check if we can start render\n              do\n                 liftIO . atomically . void $ takeTMVar triggerRender\n                 -- to allow rendering of last frame before quitting\n                 -- if there is no state to render, check if rendering is disabled\n                 s <-\n                     MaybeT . liftIO . atomically $\n                     (Just <$> takeTMVar latestState) `orElse` do\n                         r <- tryReadTMVar enableRenderThread\n                         case r of\n                             Nothing -> pure Nothing -- breaks (runMaybeT . forever) loop\n                             Just _ -> retry\n                 lift $ render s)\n            (const . atomically $ putTMVar finishedRenderThread ())\n\n    -- application run\n    s' <- P.runEffect $\n        appSignal P.>-> PP.mapM\n            (liftIO . atomically . void . STE.forceSwapTMVar latestState) P.>-> PP.drain\n\n    -- cleanup\n    -- allow rendering of the frame one last time\n    liftIO . atomically $ takeTMVar enableRenderThread\n    -- wait for render thread to finish before exiting\n    liftIO . atomically $ takeTMVar finishedRenderThread\n    -- kill frameRateThread only after render thread has finished\n    -- since renderThread waits on triggers from frameRateThread\n    liftIO $ killThread frameRateThread\n    -- return final state\n    liftIO $ pure s'","function_tokens":["runUi","refreshDelay","render","appSignal","=","do","-- framerate thread","-- TMVar to indicate that the render thread can render, start non empty so we can render straight away.","triggerRender","<-","liftIO","$","newTMVarIO","(",")","frameRateThread","<-","liftIO","$","forkIO",".","void",".","forever","$","-- The will ensure a refreshDelay in between times when value in canRender is taken.","-- wait until canRender is empty (ie taken by the render thread)","do","atomically","$","STE","waitTillEmptyTMVar","triggerRender","(",")","-- if empty, then wait delay before filling TMVar with next canRender value","threadDelay","refreshDelay","atomically","$","putTMVar","triggerRender","(",")","-- render thread","enableRenderThread","<-","liftIO","$","newTMVarIO","(",")","finishedRenderThread","<-","liftIO","newEmptyTMVarIO","latestState","<-","liftIO","newEmptyTMVarIO","void",".","liftIO","$","forkFinally","(","void",".","runMaybeT",".","forever","$","-- check if we can start render","do","liftIO",".","atomically",".","void","$","takeTMVar","triggerRender","-- to allow rendering of last frame before quitting","-- if there is no state to render, check if rendering is disabled","s","<-","MaybeT",".","liftIO",".","atomically","$","(","Just","<$>","takeTMVar","latestState",")","`","orElse","`","do","r","<-","tryReadTMVar","enableRenderThread","case","r","of","Nothing","->","pure","Nothing","-- breaks (runMaybeT . forever) loop","Just","_","->","retry","lift","$","render","s",")","(","const",".","atomically","$","putTMVar","finishedRenderThread","(",")",")","-- application run","s'","<-","P","runEffect","$","appSignal","P",">->","PP","mapM","(","liftIO",".","atomically",".","void",".","STE","forceSwapTMVar","latestState",")","P",">->","PP","drain","-- cleanup","-- allow rendering of the frame one last time","liftIO",".","atomically","$","takeTMVar","enableRenderThread","-- wait for render thread to finish before exiting","liftIO",".","atomically","$","takeTMVar","finishedRenderThread","-- kill frameRateThread only after render thread has finished","-- since renderThread waits on triggers from frameRateThread","liftIO","$","killThread","frameRateThread","-- return final state","liftIO","$","pure","s'"],"url":"https:\/\/github.com\/louispan\/glazier-pipes\/blob\/ebd15c98cea28ad2e15786512ba8607bb5b6434e\/src\/Glazier\/Pipes\/Ui.hs#L25-L76","hash_key":"louispan\/glazier-pipes:src\/Glazier\/Pipes\/Ui.hs","hash_val":53273,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"timestamp","parameters":"(Oid time _)","argument_list":"","return_statement":"","docstring":"^ Time when objectId was created","docstring_summary":"^ Time when objectId was created","docstring_tokens":["^","Time","when","objectId","was","created"],"function":"timestamp (Oid time _) = posixSecondsToUTCTime (fromIntegral time)","function_tokens":["timestamp","(","Oid","time","_",")","=","posixSecondsToUTCTime","(","fromIntegral","time",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L452-L452","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fail\/Either.hs","language":"haskell","identifier":"fail","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail = send . Fail","function_tokens":["fail","=","send",".","Fail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fail\/Either.hs#L47-L47","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fail\/Either.hs","hash_val":46921,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"hsTyReplacements","parameters":"(GHC.HsQualTy _ (Just ctx) _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hsTyReplacements (GHC.HsQualTy _ (Just ctx) _)\n    | Just arrow <- GHC.ac_darrow . GHC.anns . GHC.ann $ GHC.getLoc ctx\n    , (GHC.NormalSyntax, GHC.EpaSpan loc) <- arrow =\n        Editor.replaceRealSrcSpan loc \"\u21d2\"","function_tokens":["hsTyReplacements","(","GHC","HsQualTy","_","(","Just","ctx",")","_",")","|","Just","arrow","<-","GHC","ac_darrow",".","GHC","anns",".","GHC","ann","$","GHC","getLoc","ctx",",","(","GHC","NormalSyntax",",","GHC","EpaSpan","loc",")","<-","arrow","=","Editor","replaceRealSrcSpan","loc","\"\u21d2\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L26-L29","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(m, n) = (sum *** maximum) . Prelude.unzip . Prelude.map ((maximum *** sum) .\n                Prelude.unzip . Prelude.map (MG.rows &&& MG.cols)) $ ms","function_tokens":["(","m",",","n",")","=","(","sum","***","maximum",")",".","Prelude","unzip",".","Prelude","map","(","(","maximum","***","sum",")",".","Prelude","unzip",".","Prelude","map","(","MG","rows","&&&","MG","cols",")",")","$","ms"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L262-L263","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zip","parameters":"m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip m1 m2\n    | MG.dim m1 \/= MG.dim m2 = error \"zip: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zip (MG.flatten m1) $ MG.flatten m2","function_tokens":["zip","m1","m2","|","MG","dim","m1","\/=","MG","dim","m2","=","error","\"zip: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zip","(","MG","flatten","m1",")","$","MG","flatten","m2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L466-L469","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f","parameters":"!i x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f !i x = GM.unsafeWrite v (i*(c'+1)) x >> return (i+1)","function_tokens":["f","i","x","=","GM","unsafeWrite","v","(","i","*","(","c'","+","1",")",")","x",">>","return","(","i","+","1",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L238-L238","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"startRecvProcess","parameters":"kh","argument_list":"","return_statement":"","docstring":"Dispatch the receiving process  Receive a signal and first try to dispatch it via the ReplyQueue. If that fails, send it to the supplied default channel instead.  This throws an exception if called a second time.","docstring_summary":"Dispatch the receiving process  Receive a signal and first try to dispatch it via the ReplyQueue. If that fails, send it to the supplied default channel instead.  This throws an exception if called a second time.","docstring_tokens":["Dispatch","the","receiving","process","Receive","a","signal","and","first","try","to","dispatch","it","via","the","ReplyQueue",".","If","that","fails","send","it","to","the","supplied","default","channel","instead",".","This","throws","an","exception","if","called","a","second","time","."],"function":"startRecvProcess kh = do\n    tId <- forkIO $ (withSocketsDo . forever $ do\n        -- Read from socket\n        (received, addr) <- S.recvFrom (kSock kh) 1500\n        -- Try to create peer\n        peer <- toPeer addr\n        case peer of\n            Nothing -> return ()\n            Just p  ->\n                -- Try parsing the signal\n                case parse p received of\n                    Left _    -> return ()\n                    Right sig ->\n                        -- Send the signal to the receivng process of instance\n                        writeChan (timeoutChan . replyQueue $ kh) $ Answer sig)\n\n            -- Send Closed reply to all handlers\n            `finally` do\n                flush . replyQueue $ kh\n                writeChan (timeoutChan . replyQueue $ kh) Closed\n\n    success <- tryPutMVar (recvThread kh) tId\n    unless success . ioError . userError $ \"Receiving process already running\"\n\n-- | Send a Signal to a Peer over the connection corresponding to the\n--   KademliaHandle","function_tokens":["startRecvProcess","kh","=","do","tId","<-","forkIO","$","(","withSocketsDo",".","forever","$","do","-- Read from socket","(","received",",","addr",")","<-","S","recvFrom","(","kSock","kh",")","1500","-- Try to create peer","peer","<-","toPeer","addr","case","peer","of","Nothing","->","return","(",")","Just","p","->","-- Try parsing the signal","case","parse","p","received","of","Left","_","->","return","(",")","Right","sig","->","-- Send the signal to the receivng process of instance","writeChan","(","timeoutChan",".","replyQueue","$","kh",")","$","Answer","sig",")","-- Send Closed reply to all handlers","`","finally","`","do","flush",".","replyQueue","$","kh","writeChan","(","timeoutChan",".","replyQueue","$","kh",")","Closed","success","<-","tryPutMVar","(","recvThread","kh",")","tId","unless","success",".","ioError",".","userError","$","\"Receiving process already running\"","-- | Send a Signal to a Peer over the connection corresponding to the","--   KademliaHandle"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L86-L112","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"array'","parameters":"(DynamicSort i) (DynamicSort e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"array' (DynamicSort i) (DynamicSort e) = DynamicSort (SArraySort i e)","function_tokens":["array'","(","DynamicSort","i",")","(","DynamicSort","e",")","=","DynamicSort","(","SArraySort","i","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L133-L133","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"changeLines","parameters":"(Block start end) f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changeLines (Block start end) f =\n    Edits $ M.singleton start [CBlock (end - start + 1) f]","function_tokens":["changeLines","(","Block","start","end",")","f","=","Edits","$","M","singleton","start","[","CBlock","(","end","-","start","+","1",")","f","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L126-L127","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"ident","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create an identity matrix","docstring_summary":"O(m*n) Create an identity matrix","docstring_tokens":["O","(","m","*","n",")","Create","an","identity","matrix"],"function":"ident = MG.ident","function_tokens":["ident","=","MG","ident"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L200-L200","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f'","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' i = f (i `divMod` c)","function_tokens":["f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L317-L317","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int64 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int64 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int64","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L252-L252","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"notSupported","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"notSupported x = error $ \"Not supported yet: \" ++ x","function_tokens":["notSupported","x","=","error","$","\"Not supported yet: \"","++","x"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L140-L140","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"step'","parameters":"alp lg ls modu","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"step' alp lg ls modu = Editor.apply edits ls\n  where\n    edits =\n        foldMap hsTyReplacements (everything modu) <>\n        foldMap hsSigReplacements (everything modu) <>\n        (if alp then addLanguagePragma lg \"UnicodeSyntax\" modu else mempty)","function_tokens":["step'","alp","lg","ls","modu","=","Editor","apply","edits","ls","where","edits","=","foldMap","hsTyReplacements","(","everything","modu",")","<>","foldMap","hsSigReplacements","(","everything","modu",")","<>","(","if","alp","then","addLanguagePragma","lg","\"UnicodeSyntax\"","modu","else","mempty",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L49-L54","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"g","parameters":"sa sb i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g sa sb i = runSplineT sa i >>= \\case\n          Left d -> return $ Left $ Left d\n          Right (a, sa1) -> runSplineT sb i >>= \\case\n            Left e -> return $ Left $ Right e\n            Right (b, sb1) -> return $ Right (f a b, SplineT $ g sa1 sb1)\n\n-- | Run many splines in parallel, combining their output with 'mappend'.\n-- Returns the result of the spline that concludes first. If any conclude at the\n-- same time the leftmost result will be returned.\n--\n-- >>> :{\n-- let ss = [ pure \"hey \"   `_untilEvent` (1 >>> after 5)\n--          , pure \"there\"  `_untilEvent` (1 >>> after 3)\n--          , pure \"!\"      `_untilEvent` (1 >>> after 2)\n--          ]\n--     s = do winner <- raceAny ss\n--            step $ show winner\n--     v = outputStream s \"\"\n-- in testVarOver v [(),()]\n-- >>> :}\n-- \"hey there!\"\n-- \"2\"","function_tokens":["g","sa","sb","i","=","runSplineT","sa","i",">>=","\\","case","Left","d","->","return","$","Left","$","Left","d","Right","(","a",",","sa1",")","->","runSplineT","sb","i",">>=","\\","case","Left","e","->","return","$","Left","$","Right","e","Right","(","b",",","sb1",")","->","return","$","Right","(","f","a","b",",","SplineT","$","g","sa1","sb1",")","-- | Run many splines in parallel, combining their output with 'mappend'.","-- Returns the result of the spline that concludes first. If any conclude at the","-- same time the leftmost result will be returned.","--","-- >>> :{","-- let ss = [ pure \"hey \"   `_untilEvent` (1 >>> after 5)","--          , pure \"there\"  `_untilEvent` (1 >>> after 3)","--          , pure \"!\"      `_untilEvent` (1 >>> after 2)","--          ]","--     s = do winner <- raceAny ss","--            step $ show winner","--     v = outputStream s \"\"","-- in testVarOver v [(),()]","-- >>> :}","-- \"hey there!\"","-- \"2\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L245-L267","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"reinterpretLog","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reinterpretLog f = runReader f . runReinterpretLogC","function_tokens":["reinterpretLog","f","=","runReader","f",".","runReinterpretLogC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L132-L132","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"checkChanges","parameters":"i (c1@(CBlock _ _) : c2 : _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkChanges i (c1@(CBlock _ _) : c2 : _) = [Conflict i c1 i c2]","function_tokens":["checkChanges","i","(","c1","@","(","CBlock","_","_",")",":","c2",":","_",")","=","[","Conflict","i","c1","i","c2","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L154-L154","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zipWithM_","parameters":"f m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM_ f m1 m2\n    | MG.dim m1 \/= MG.dim m2 = error \"zipWithM_: Dimensions don't match.\"\n    | otherwise = G.zipWithM_ f (MG.flatten m1) $ MG.flatten m2","function_tokens":["zipWithM_","f","m1","m2","|","MG","dim","m1","\/=","MG","dim","m2","=","error","\"zipWithM_: Dimensions don't match.\"","|","otherwise","=","G","zipWithM_","f","(","MG","flatten","m1",")","$","MG","flatten","m2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L531-L533","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/Setup.hs#L2-L2","hash_key":"HeinrichApfelmus\/vault:Setup.hs","hash_val":54308,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"example","parameters":"","argument_list":"","return_statement":"","docstring":"Test spec.","docstring_summary":"Test spec.","docstring_tokens":["Test","spec","."],"function":"example = testGroup \"reinterpret log\"\n  [ testProperty \"reinterprets logs\" . property $ do\n      a <- liftIO . collectLogMessages . reinterpretLog renderLogMessage $ do\n        log (Debug \"foo\")\n        log (Info \"bar\")\n      a === [\"[debug] foo\", \"[info] bar\"]\n  ]","function_tokens":["example","=","testGroup","\"reinterpret log\"","[","testProperty","\"reinterprets logs\"",".","property","$","do","a","<-","liftIO",".","collectLogMessages",".","reinterpretLog","renderLogMessage","$","do","log","(","Debug","\"foo\"",")","log","(","Info","\"bar\"",")","a","===","[","\"[debug] foo\"",",","\"[info] bar\"","]","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L159-L165","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"valueAt","parameters":"k","argument_list":"","return_statement":"","docstring":"^ Value of field in document. Error if missing.","docstring_summary":"^ Value of field in document. Error if missing.","docstring_tokens":["^","Value","of","field","in","document",".","Error","if","missing","."],"function":"valueAt k = fromJust . look k","function_tokens":["valueAt","k","=","fromJust",".","look","k"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L106-L106","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"parse","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parse = parseFromNumberedLines . zip [1..] . lines","function_tokens":["parse","=","parseFromNumberedLines",".","zip","[","1","..","]",".","lines"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L125-L125","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Int32 x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Int32 x) = Just (fromIntegral x)","function_tokens":["cast'","(","Int32","x",")","=","Just","(","fromIntegral","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L244-L244","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"return","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"return = SplineT . const . return . Left","function_tokens":["return","=","SplineT",".","const",".","return",".","Left"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L93-L93","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(i:is) (False:ts) depth valid (Split left _)","argument_list":"","return_statement":"","docstring":"If the bit is a 0, go left","docstring_summary":"If the bit is a 0, go left","docstring_tokens":["If","the","bit","is","a","0","go","left"],"function":"go (i:is) (False:ts) depth valid (Split left _) =\n               go is ts (depth + 1) (valid && not i) left","function_tokens":["go","(","i",":","is",")","(","False",":","ts",")","depth","valid","(","Split","left","_",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L92-L93","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unsafeIndex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeIndex = MG.unsafeIndex","function_tokens":["unsafeIndex","=","MG","unsafeIndex"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L126-L126","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"thaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thaw = MG.thaw","function_tokens":["thaw","=","MG","thaw"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L382-L382","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(ObjId x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (ObjId x) = Just x","function_tokens":["cast'","(","ObjId","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L315-L315","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"imapM_","parameters":"f m@(Matrix _ c _ _ _)","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","ignoring","the","results","."],"function":"imapM_ f m@(Matrix _ c _ _ _) = G.imapM_ f' $ MG.flatten m\n  where\n    f' i = f (i `divMod` c)","function_tokens":["imapM_","f","m","@","(","Matrix","_","c","_","_","_",")","=","G","imapM_","f'","$","MG","flatten","m","where","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L315-L318","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"showsPrec","parameters":"d (k := v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsPrec d (k := v) = showParen (d > 0) $ showString (' ' : T.unpack k) . showString \": \" . showsPrec 1 v","function_tokens":["showsPrec","d","(","k",":=","v",")","=","showParen","(","d",">","0",")","$","showString","(","' '",":","T","unpack","k",")",".","showString","\": \"",".","showsPrec","1","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L146-L146","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Float x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Float x) = Just x","function_tokens":["cast'","(","Float","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L243-L243","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(v1, v2, v3) = G.unzip3 $ MG.flatten m","function_tokens":["(","v1",",","v2",",","v3",")","=","G","unzip3","$","MG","flatten","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L549-L549","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Networking.hs","language":"haskell","identifier":"sig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sig = serialize id cmd","function_tokens":["sig","=","serialize","id","cmd"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Networking.hs#L73-L73","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Networking.hs","hash_val":49926,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"look","parameters":"k doc","argument_list":"","return_statement":"","docstring":"^ Value of field in document, or fail (Nothing) if field not found","docstring_summary":"^ Value of field in document, or fail (Nothing) if field not found","docstring_tokens":["^","Value","of","field","in","document","or","fail","(","Nothing",")","if","field","not","found"],"function":"look k doc = maybe notFound (return . value) (find ((k ==) . label) doc)\n  where notFound = fail $ \"expected \" ++ show k ++ \" in \" ++ show doc","function_tokens":["look","k","doc","=","maybe","notFound","(","return",".","value",")","(","find","(","(","k","==",")",".","label",")","doc",")","where","notFound","=","fail","$","\"expected \"","++","show","k","++","\" in \"","++","show","doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L97-L100","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"pure","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure = return","function_tokens":["pure","=","return"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L114-L114","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"_ _ depth valid (Bucket b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ _ depth valid (Bucket b) = f depth valid b","function_tokens":["go","_","_","depth","valid","(","Bucket","b",")","=","f","depth","valid","b"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L72-L72","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val n           = maybe (maybe err Int64 $ fitInt n) Int32 (fitInt n)\n    where err = error $ show n ++ \" is too large for Bson Int Value\"","function_tokens":["val","n","=","maybe","(","maybe","err","Int64","$","fitInt","n",")","Int32","(","fitInt","n",")","where","err","=","error","$","show","n","++","\" is too large for Bson Int Value\""],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L375-L377","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"valList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"valList = Array . map val","function_tokens":["valList","=","Array",".","map","val"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L219-L219","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"at","parameters":"k doc","argument_list":"","return_statement":"","docstring":"^ Typed value of field in document. Error if missing or wrong type.","docstring_summary":"^ Typed value of field in document. Error if missing or wrong type.","docstring_tokens":["^","Typed","value","of","field","in","document",".","Error","if","missing","or","wrong","type","."],"function":"at k doc = result\n  where\n   result = fromMaybe err (lookup k doc)\n   err = error $ \"expected (\" ++ show k ++ \" :: \" ++ show (typeOf result) ++ \") in \" ++ show doc","function_tokens":["at","k","doc","=","result","where","result","=","fromMaybe","err","(","lookup","k","doc",")","err","=","error","$","\"expected (\"","++","show","k","++","\" :: \"","++","show","(","typeOf","result",")","++","\") in \"","++","show","doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L110-L115","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"f","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f i = all g [i + 1 .. c-1]\n      where g j = m MG.! (i,j) == m MG.! (j,i)","function_tokens":["f","i","=","all","g","[","i","+","1","..","c","-","1","]","where","g","j","=","m","MG","!","(","i",",","j",")","==","m","MG","!","(","j",",","i",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L270-L272","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Fun x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Fun x) = Just x","function_tokens":["cast'","(","Fun","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L295-L295","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"tr","parameters":"(Matrix r c tda offset vec)","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix transpose","docstring_summary":"O(m*n) Matrix transpose","docstring_tokens":["O","(","m","*","n",")","Matrix","transpose"],"function":"tr (Matrix r c tda offset vec) = MG.fromVector (c,r) $ G.generate (r*c) f\n  where\n    f i = vec G.! (offset + i `mod` r * tda + i `div` r)","function_tokens":["tr","(","Matrix","r","c","tda","offset","vec",")","=","MG","fromVector","(","c",",","r",")","$","G","generate","(","r","*","c",")","f","where","f","i","=","vec","G","!","(","offset","+","i","`","mod","`","r","*","tda","+","i","`","div","`","r",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L210-L213","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Interpret.hs","language":"haskell","identifier":"benchmark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark = bgroup \"Interpret\"\n  [ bgroup \"Identity\"\n    [ bench \"InterpretC\" $\n      whnf (\\ n -> run $ execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnf (\\ n -> fst . run $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnf (run . execState @Int 0 . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"InterpretC\" $\n      whnfAppIO (\\ n -> execState @Int 0 $ runInterpret (\\ _ (sig :: State Int m k) ctx -> case sig of\n        Get   -> gets @Int (<$ ctx)\n        Put s -> ctx <$ put s) $ modLoop n) n\n    , bench \"InterpretStateC\" $\n      whnfAppIO (\\ n -> fmap fst $ runInterpretState (\\ _ (sig :: State Int m k) (s :: Int) ctx -> case sig of\n        Get   -> pure (s, s <$ ctx)\n        Put s -> pure (s, ctx)) 0 $ modLoop n) n\n    , bench \"StateC\" $\n      whnfAppIO (execState @Int 0 . modLoop) n\n    ]\n  ]\n  where\n  n = 100000","function_tokens":["benchmark","=","bgroup","\"Interpret\"","[","bgroup","\"Identity\"","[","bench","\"InterpretC\"","$","whnf","(","\\","n","->","run","$","execState","@","Int","0","$","runInterpret","(","\\","_","(","sig","::","State","Int","m","k",")","ctx","->","case","sig","of","Get","->","gets","@","Int","(","<$","ctx",")","Put","s","->","ctx","<$","put","s",")","$","modLoop","n",")","n",",","bench","\"InterpretStateC\"","$","whnf","(","\\","n","->","fst",".","run","$","runInterpretState","(","\\","_","(","sig","::","State","Int","m","k",")","(","s","::","Int",")","ctx","->","case","sig","of","Get","->","pure","(","s",",","s","<$","ctx",")","Put","s","->","pure","(","s",",","ctx",")",")","0","$","modLoop","n",")","n",",","bench","\"StateC\"","$","whnf","(","run",".","execState","@","Int","0",".","modLoop",")","n","]",",","bgroup","\"IO\"","[","bench","\"InterpretC\"","$","whnfAppIO","(","\\","n","->","execState","@","Int","0","$","runInterpret","(","\\","_","(","sig","::","State","Int","m","k",")","ctx","->","case","sig","of","Get","->","gets","@","Int","(","<$","ctx",")","Put","s","->","ctx","<$","put","s",")","$","modLoop","n",")","n",",","bench","\"InterpretStateC\"","$","whnfAppIO","(","\\","n","->","fmap","fst","$","runInterpretState","(","\\","_","(","sig","::","State","Int","m","k",")","(","s","::","Int",")","ctx","->","case","sig","of","Get","->","pure","(","s",",","s","<$","ctx",")","Put","s","->","pure","(","s",",","ctx",")",")","0","$","modLoop","n",")","n",",","bench","\"StateC\"","$","whnfAppIO","(","execState","@","Int","0",".","modLoop",")","n","]","]","where","n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Interpret.hs#L16-L45","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Interpret.hs","hash_val":54530,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"fromVector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromVector = MG.fromVector","function_tokens":["fromVector","=","MG","fromVector"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L144-L144","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = MG.dim m","function_tokens":["d","=","MG","dim","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L548-L548","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"prettyChange","parameters":"l (CLine start end x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyChange l (CLine start end x) =\n    show l ++ \":\" ++ show start ++ \"-\" ++ show end ++ \" replace by \" ++ show x","function_tokens":["prettyChange","l","(","CLine","start","end","x",")","=","show","l","++","\":\"","++","show","start","++","\"-\"","++","show","end","++","\" replace by \"","++","show","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L61-L62","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"hsSigReplacements","parameters":"(GHC.TypeSig ann _ _)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"hsSigReplacements (GHC.TypeSig ann _ _)\n    | GHC.AddEpAnn GHC.AnnDcolon epaLoc <- GHC.asDcolon $ GHC.anns ann\n    , GHC.EpaSpan loc <- epaLoc =\n        Editor.replaceRealSrcSpan loc \"\u2237\"","function_tokens":["hsSigReplacements","(","GHC","TypeSig","ann","_","_",")","|","GHC","AddEpAnn","GHC","AnnDcolon","epaLoc","<-","GHC","asDcolon","$","GHC","anns","ann",",","GHC","EpaSpan","loc","<-","epaLoc","=","Editor","replaceRealSrcSpan","loc","\"\u2237\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L35-L38","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = MG.cols m1","function_tokens":["c","=","MG","cols","m1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L440-L440","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"unsafeIndex","parameters":"(Matrix _ _ tda offset vec) (i,j)","argument_list":"","return_statement":"","docstring":"O(1) Unsafe indexing without bound check.","docstring_summary":"O(1) Unsafe indexing without bound check.","docstring_tokens":["O","(","1",")","Unsafe","indexing","without","bound","check","."],"function":"unsafeIndex (Matrix _ _ tda offset vec) (i,j) = vec `G.unsafeIndex` idx\n      where\n        idx = offset + i * tda + j","function_tokens":["unsafeIndex","(","Matrix","_","_","tda","offset","vec",")","(","i",",","j",")","=","vec","`","G","unsafeIndex","`","idx","where","idx","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L144-L147","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"showsPrec","parameters":"d","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsPrec d = fval (showsPrec d)","function_tokens":["showsPrec","d","=","fval","(","showsPrec","d",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L177-L177","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"origin","parameters":"sig","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"origin sig = nodeId . source $ sig","function_tokens":["origin","sig","=","nodeId",".","source","$","sig"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L54-L54","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"zip5","parameters":"m1 m2 m3 m4 m5","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip5 m1 m2 m3 m4 m5\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 ||\n      MG.dim m4 \/= MG.dim m5 = error \"zip5: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.zip5 (MG.flatten m1) (MG.flatten m2)\n                  (MG.flatten m3) (MG.flatten m4) $ MG.flatten m5","function_tokens":["zip5","m1","m2","m3","m4","m5","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","||","MG","dim","m4","\/=","MG","dim","m5","=","error","\"zip5: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","zip5","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","(","MG","flatten","m4",")","$","MG","flatten","m5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L496-L503","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"a (Split left right)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go a (Split left right) = let a' = go a left in go a' right","function_tokens":["go","a","(","Split","left","right",")","=","let","a'","=","go","a","left","in","go","a'","right"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L230-L230","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"beforeChange","parameters":"(CBlock _ _)  _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"beforeChange (CBlock _ _)  _             = True","function_tokens":["beforeChange","(","CBlock","_","_",")","_","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L51-L51","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"chunks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"chunks = T.split (== '.') l","function_tokens":["chunks","=","T","split","(","==","'.'",")","l"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L93-L93","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"g","parameters":"s a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g s a = do e <- s a\n                     case e of\n                       Left  c               -> runSplineT (f c) a\n                       Right (b, SplineT s1) -> return $ Right (b, SplineT $ g s1)\n\n\n-- | A spline responds to 'pure' by returning a spline that never produces an\n-- output value and immediately returns the argument. It responds to '<*>' by\n-- applying the left arguments result value (the function) to the right\n-- arguments result value (the argument), sequencing them both in serial.\n--\n-- @\n-- pure = return\n-- sf <*> sx = do\n--   f <- sf\n--   x <- sx\n--   return $ f x\n-- @","function_tokens":["g","s","a","=","do","e","<-","s","a","case","e","of","Left","c","->","runSplineT","(","f","c",")","a","Right","(","b",",","SplineT","s1",")","->","return","$","Right","(","b",",","SplineT","$","g","s1",")","-- | A spline responds to 'pure' by returning a spline that never produces an","-- output value and immediately returns the argument. It responds to '<*>' by","-- applying the left arguments result value (the function) to the right","-- arguments result value (the argument), sequencing them both in serial.","--","-- @","-- pure = return","-- sf <*> sx = do","--   f <- sf","--   x <- sx","--   return $ f x","-- @"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L95-L113","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"fromBlocks","parameters":"d ms","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromBlocks d ms = MG.fromVector (m,n) $ G.create $ GM.replicate (m*n) d >>= go n ms\n  where\n    go n' xss v = foldM_ f 0 xss >> return v\n      where\n        f !cr xs = do (r', _) <- foldM g (0, 0) xs\n                      return $ cr + r'\n          where\n            g (!maxR, !cc) x = do\n                let (r,c) = MG.dim x\n                    vec = MG.flatten x\n                    step i u = do\n                        GM.unsafeWrite v ((cr + i `div` c) * n' + i `mod` c + cc) u\n                        return (i+1)\n                G.foldM'_ step (0::Int) vec\n                return (max maxR r, cc + c)\n    -- figure out the dimension of the new matrix\n    (m, n) = (sum *** maximum) . Prelude.unzip . Prelude.map ((maximum *** sum) .\n                Prelude.unzip . Prelude.map (MG.rows &&& MG.cols)) $ ms","function_tokens":["fromBlocks","d","ms","=","MG","fromVector","(","m",",","n",")","$","G","create","$","GM","replicate","(","m","*","n",")","d",">>=","go","n","ms","where","go","n'","xss","v","=","foldM_","f","0","xss",">>","return","v","where","f","cr","xs","=","do","(","r'",",","_",")","<-","foldM","g","(","0",",","0",")","xs","return","$","cr","+","r'","where","g","(","maxR",",","cc",")","x","=","do","let","(","r",",","c",")","=","MG","dim","x","vec","=","MG","flatten","x","step","i","u","=","do","GM","unsafeWrite","v","(","(","cr","+","i","`","div","`","c",")","*","n'","+","i","`","mod","`","c","+","cc",")","u","return","(","i","+","1",")","G","foldM'_","step","(","0","::","Int",")","vec","return","(","max","maxR","r",",","cc","+","c",")","-- figure out the dimension of the new matrix","(","m",",","n",")","=","(","sum","***","maximum",")",".","Prelude","unzip",".","Prelude","map","(","(","maximum","***","sum",")",".","Prelude","unzip",".","Prelude","map","(","MG","rows","&&&","MG","cols",")",")","$","ms"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L246-L264","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"go","parameters":"(Bucket b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Bucket b) = map fst . fst $ b","function_tokens":["go","(","Bucket","b",")","=","map","fst",".","fst","$","b"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L225-L225","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ k w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        k w'' ctx\n      Listen   m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w w'\n        k w'' ((,) w' <$> a)) (hdl (m <$ ctx))\n      Censor f m -> runWriter (\\ w' a -> do\n        let !w'' = mappend w (f w')\n        k w'' a) (hdl (m <$ ctx))\n    R other  -> alg (runWriterC . hdl) (R other) ctx","function_tokens":["alg","hdl","sig","ctx","=","WriterC","$","case","sig","of","L","writer","->","StateC","$","\\","k","w","->","case","writer","of","Tell","w'","->","do","let","w''","=","mappend","w","w'","k","w''","ctx","Listen","m","->","runWriter","(","\\","w'","a","->","do","let","w''","=","mappend","w","w'","k","w''","(","(",",",")","w'","<$>","a",")",")","(","hdl","(","m","<$","ctx",")",")","Censor","f","m","->","runWriter","(","\\","w'","a","->","do","let","w''","=","mappend","w","(","f","w'",")","k","w''","a",")","(","hdl","(","m","<$","ctx",")",")","R","other","->","alg","(","runWriterC",".","hdl",")","(","R","other",")","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Church.hs#L70-L82","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Church.hs","hash_val":47515,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zip","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip = MG.zip","function_tokens":["zip","=","MG","zip"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L313-L313","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val   = valMaybe","function_tokens":["val","=","valMaybe"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L334-L334","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Conflict.hs","language":"haskell","identifier":"readHead","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readHead = state f\n    where\n        f [] = (Nothing, [])\n        f (l:ls) = (Just l, ls)","function_tokens":["readHead","=","state","f","where","f","[","]","=","(","Nothing",",","[","]",")","f","(","l",":","ls",")","=","(","Just","l",",","ls",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Conflict.hs#L73-L78","hash_key":"Peaker\/git-mediate:src\/Conflict.hs","hash_val":48563,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Stamp x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Stamp x) = Just x","function_tokens":["cast'","(","Stamp","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L384-L384","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"merge","parameters":"es docInitial","argument_list":"","return_statement":"","docstring":"^ Merge documents with preference given to first one when both have the same label. I.e. for every (k := v) in first argument, if k exists in second argument then replace its value with v, otherwise add (k := v) to second argument.","docstring_summary":"^ Merge documents with preference given to first one when both have the same label. I.e. for every (k := v) in first argument, if k exists in second argument then replace its value with v, otherwise add (k := v) to second argument.","docstring_tokens":["^","Merge","documents","with","preference","given","to","first","one","when","both","have","the","same","label",".","I",".","e",".","for","every","(","k",":","=","v",")","in","first","argument","if","k","exists","in","second","argument","then","replace","its","value","with","v","otherwise","add","(","k",":","=","v",")","to","second","argument","."],"function":"merge es docInitial = foldl f docInitial es\n  where f doc (k := v) = case findIndex ((k ==) . label) doc of\n                          Nothing -> doc ++ [k := v]\n                          Just i -> let (x, _ : y) = splitAt i doc in x ++ [k := v] ++ y\n\n-- * Field","function_tokens":["merge","es","docInitial","=","foldl","f","docInitial","es","where","f","doc","(","k",":=","v",")","=","case","findIndex","(","(","k","==",")",".","label",")","doc","of","Nothing","->","doc","++","[","k",":=","v","]","Just","i","->","let","(","x",",","_",":","y",")","=","splitAt","i","doc","in","x","++","[","k",":=","v","]","++","y","-- * Field"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L125-L132","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"merge","parameters":"(Block s1 e1) (Block s2 e2)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge (Block s1 e1) (Block s2 e2) = Block (min s1 s2) (max e1 e2)","function_tokens":["merge","(","Block","s1","e1",")","(","Block","s2","e2",")","=","Block","(","min","s1","s2",")","(","max","e1","e2",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L67-L67","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"m'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m' = i' - i + 1","function_tokens":["m'","=","i'","-","i","+","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L203-L203","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"readPrec","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readPrec = do\n    [(x, \"\")] <- readHex <$> R.lift (R.count 8 R.get)\n    y <- R.readS_to_Prec $ const readHex\n    return (Oid x y)","function_tokens":["readPrec","=","do","[","(","x",",","\"\"",")","]","<-","readHex","<$>","R","lift","(","R","count","8","R","get",")","y","<-","R","readS_to_Prec","$","const","readHex","return","(","Oid","x","y",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L445-L450","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' _       = Nothing","function_tokens":["cast'","_","=","Nothing"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L306-L306","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Tree.hs","language":"haskell","identifier":"bothAt","parameters":"(NodeTree idStruct elem) id f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bothAt (NodeTree idStruct elem) id f =\n    let targetStruct    = toByteStruct id\n        (newElems, val) = go idStruct targetStruct 0 True elem\n    in  (NodeTree idStruct newElems, val)\n    where -- This function is partial, but we know that there will alwasys be a\n          -- bucket at the end. Therefore, we don't have to check for empty\n          -- ByteStructs\n          --\n          -- Apply the function to the position of the bucket\n          go _ _ depth valid (Bucket b) = f depth valid b\n          -- If the bit is a 0, go left\n          go (i:is) (False:ts) depth valid (Split left right) =\n               let (new, val) = go is ts (depth + 1) (valid && not i) left\n               in  (Split new right, val)\n          -- Otherwise, continue to the right\n          go (i:is) (True:ts) depth valid (Split left right) =\n               let (new, val) = go is ts (depth + 1) (valid && i) right\n               in  (Split left new, val)\n\n-- | Apply a function to the bucket the supplied id would be located in","function_tokens":["bothAt","(","NodeTree","idStruct","elem",")","id","f","=","let","targetStruct","=","toByteStruct","id","(","newElems",",","val",")","=","go","idStruct","targetStruct","0","True","elem","in","(","NodeTree","idStruct","newElems",",","val",")","where","-- This function is partial, but we know that there will alwasys be a","-- bucket at the end. Therefore, we don't have to check for empty","-- ByteStructs","--","-- Apply the function to the position of the bucket","go","_","_","depth","valid","(","Bucket","b",")","=","f","depth","valid","b","-- If the bit is a 0, go left","go","(","i",":","is",")","(","False",":","ts",")","depth","valid","(","Split","left","right",")","=","let","(","new",",","val",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","not","i",")","left","in","(","Split","new","right",",","val",")","-- Otherwise, continue to the right","go","(","i",":","is",")","(","True",":","ts",")","depth","valid","(","Split","left","right",")","=","let","(","new",",","val",")","=","go","is","ts","(","depth","+","1",")","(","valid","&&","i",")","right","in","(","Split","left","new",",","val",")","-- | Apply a function to the bucket the supplied id would be located in"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Tree.hs#L63-L83","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Tree.hs","hash_val":50459,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"typeSetText","parameters":"","argument_list":"","return_statement":"","docstring":"Not parsed, see Limitations","docstring_summary":"Not parsed, see Limitations","docstring_tokens":["Not","parsed","see","Limitations"],"function":"typeSetText = mzero","function_tokens":["typeSetText","=","mzero"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L103-L103","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Float x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Float x) = Just (round x)","function_tokens":["cast'","(","Float","x",")","=","Just","(","round","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L357-L357","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = MG.dim m","function_tokens":["d","=","MG","dim","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L540-L540","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"val","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"val              = Sym","function_tokens":["val","=","Sym"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L348-L348","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"flatten","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten = MG.flatten","function_tokens":["flatten","=","MG","flatten"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L170-L170","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"scanSpline","parameters":"s b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"scanSpline s b = fmap fst <$> scanVar (outputStream s b)","function_tokens":["scanSpline","s","b","=","fmap","fst","<$>","scanVar","(","outputStream","s","b",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L175-L175","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"checkChanges","parameters":"i (CInsert _ : cs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkChanges i (CInsert _ : cs) = checkChanges i cs","function_tokens":["checkChanges","i","(","CInsert","_",":","cs",")","=","checkChanges","i","cs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L153-L153","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"fitInt","parameters":"n","argument_list":"","return_statement":"","docstring":"^ If number fits in type m then cast to m, otherwise Nothing","docstring_summary":"^ If number fits in type m then cast to m, otherwise Nothing","docstring_tokens":["^","If","number","fits","in","type","m","then","cast","to","m","otherwise","Nothing"],"function":"fitInt n =\n  if fromIntegral (minBound `asTypeOf` result) <= n && n <= fromIntegral (maxBound `asTypeOf` result)\n  then Just result\n  else Nothing\n    where result = fromIntegral n\n\n-- * Haskell types corresponding to special Bson value types\n\n-- ** Binary types","function_tokens":["fitInt","n","=","if","fromIntegral","(","minBound","`","asTypeOf","`","result",")","<=","n","&&","n","<=","fromIntegral","(","maxBound","`","asTypeOf","`","result",")","then","Just","result","else","Nothing","where","result","=","fromIntegral","n","-- * Haskell types corresponding to special Bson value types","-- ** Binary types"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L394-L404","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"imap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap = MG.imap","function_tokens":["imap","=","MG","imap"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L235-L235","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show = show . ssortToSort","function_tokens":["show","=","show",".","ssortToSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L78-L78","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"force","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"force = MG.force","function_tokens":["force","=","MG","force"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L226-L226","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"liftIO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO = lift . liftIO","function_tokens":["liftIO","=","lift",".","liftIO"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L137-L137","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"bench\/Main.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = seq x x","function_tokens":["n","=","seq","x","x"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/bench\/Main.hs#L27-L27","hash_key":"schell\/varying:bench\/Main.hs","hash_val":49067,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC l <|> StateC r = StateC $ \\ k s -> l k s <|> r k s","function_tokens":["StateC","l","<|>","StateC","r","=","StateC","$","\\","k","s","->","l","k","s","<|>","r","k","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Church.hs#L99-L99","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Church.hs","hash_val":55025,"partition":"valid"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc\/Parser.hs","language":"haskell","identifier":"single","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"single x = [x]","function_tokens":["single","x","=","[","x","]"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc\/Parser.hs#L138-L138","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc\/Parser.hs","hash_val":48970,"partition":"valid"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Spline.hs","language":"haskell","identifier":"_untilEvent","parameters":"v ve","argument_list":"","return_statement":"","docstring":"A variant of 'untilEvent' that results in the event steam's event value.","docstring_summary":"A variant of 'untilEvent' that results in the event steam's event value.","docstring_tokens":["A","variant","of","untilEvent","that","results","in","the","event","steam","s","event","value","."],"function":"_untilEvent v ve = snd <$> untilEvent v ve","function_tokens":["_untilEvent","v","ve","=","snd","<$>","untilEvent","v","ve"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Spline.hs#L219-L219","hash_key":"schell\/varying:src\/Control\/Varying\/Spline.hs","hash_val":46348,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/ReinterpretLog.hs","language":"haskell","identifier":"log","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"log x = send (Log x)","function_tokens":["log","x","=","send","(","Log","x",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/ReinterpretLog.hs#L84-L84","hash_key":"fused-effects\/fused-effects:examples\/ReinterpretLog.hs","hash_val":55356,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = MG.cols m1","function_tokens":["c","=","MG","cols","m1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L395-L395","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Labelled.hs","language":"haskell","identifier":"withHelpers","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withHelpers = liftA2 (+) (L.ask @\"fore\") (L.ask @\"aft\")","function_tokens":["withHelpers","=","liftA2","(","+",")","(","L","ask","@","\"fore\"",")","(","L","ask","@","\"aft\"",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Labelled.hs#L27-L27","hash_key":"fused-effects\/fused-effects:examples\/Labelled.hs","hash_val":49496,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"(Bin x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' (Bin x) = Just x","function_tokens":["cast'","(","Bin","x",")","=","Just","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L290-L290","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Sort.hs","language":"haskell","identifier":"show'","parameters":"IntegralSort","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show' IntegralSort    = \"int\"","function_tokens":["show'","IntegralSort","=","\"int\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Sort.hs#L64-L64","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Sort.hs","hash_val":49208,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"izipWith4","parameters":"f m1 m2 m3 m4","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith4 f m1 m2 m3 m4\n    | MG.dim m1 \/= MG.dim m2 ||\n      MG.dim m2 \/= MG.dim m3 ||\n      MG.dim m3 \/= MG.dim m4 = error \"izipWith4: Dimensions don't match.\"\n    | otherwise = MG.fromVector (MG.dim m1) $\n                  G.izipWith4 f' (MG.flatten m1) (MG.flatten m2)\n                  (MG.flatten m3) $ MG.flatten m4\n  where\n    c = MG.cols m1\n    f' i = f (i `divMod` c)","function_tokens":["izipWith4","f","m1","m2","m3","m4","|","MG","dim","m1","\/=","MG","dim","m2","||","MG","dim","m2","\/=","MG","dim","m3","||","MG","dim","m3","\/=","MG","dim","m4","=","error","\"izipWith4: Dimensions don't match.\"","|","otherwise","=","MG","fromVector","(","MG","dim","m1",")","$","G","izipWith4","f'","(","MG","flatten","m1",")","(","MG","flatten","m2",")","(","MG","flatten","m3",")","$","MG","flatten","m4","where","c","=","MG","cols","m1","f'","i","=","f","(","i","`","divMod","`","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L415-L425","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast' = cast","function_tokens":["cast'","=","cast"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L223-L223","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/ReplyQueue.hs","language":"haskell","identifier":"dispatch","parameters":"reply rq","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dispatch reply rq = do\n    -- Try to find a registration matching the reply\n    result <- atomically $ do\n        rQueue <- readTVar . queue $ rq\n        case toRegistration reply of\n            Just repReg -> case find (matches repReg) rQueue of\n                Just registration -> do\n                    -- Remove registration from queue\n                    writeTVar (queue rq) $ delete registration rQueue\n                    return . Just $ registration\n\n                Nothing -> return Nothing\n            Nothing -> return Nothing\n\n    case result of\n        Just (_, chan, tId) -> do\n            -- Kill the timeout thread\n            killThread tId\n\n            -- Send the reply\n            writeChan chan reply\n\n        -- Send the reply over the default channel\n        Nothing -> writeChan (defaultChan rq) reply\n\n    where matches regA (regB, _, _) = matchRegistrations regA regB\n\n-- | Send Closed signal to all handlers and empty ReplyQueue","function_tokens":["dispatch","reply","rq","=","do","-- Try to find a registration matching the reply","result","<-","atomically","$","do","rQueue","<-","readTVar",".","queue","$","rq","case","toRegistration","reply","of","Just","repReg","->","case","find","(","matches","repReg",")","rQueue","of","Just","registration","->","do","-- Remove registration from queue","writeTVar","(","queue","rq",")","$","delete","registration","rQueue","return",".","Just","$","registration","Nothing","->","return","Nothing","Nothing","->","return","Nothing","case","result","of","Just","(","_",",","chan",",","tId",")","->","do","-- Kill the timeout thread","killThread","tId","-- Send the reply","writeChan","chan","reply","-- Send the reply over the default channel","Nothing","->","writeChan","(","defaultChan","rq",")","reply","where","matches","regA","(","regB",",","_",",","_",")","=","matchRegistrations","regA","regB","-- | Send Closed signal to all handlers and empty ReplyQueue"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/ReplyQueue.hs#L107-L135","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/ReplyQueue.hs","hash_val":46047,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zip4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip4 = MG.zip4","function_tokens":["zip4","=","MG","zip4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L323-L323","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!w'' = mappend w w'","function_tokens":["w''","=","mappend","w","w'"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Church.hs#L76-L76","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Church.hs","hash_val":47515,"partition":"valid"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Except.hs","language":"haskell","identifier":"exceptionHandlers","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exceptionHandlers =\n  [ Handler (\\(err :: IOException) -> explainError . show $ err)\n  , Handler (\\(err :: HSInstallException) -> explainError $ show err)\n  ]","function_tokens":["exceptionHandlers","=","[","Handler","(","\\","(","err","::","IOException",")","->","explainError",".","show","$","err",")",",","Handler","(","\\","(","err","::","HSInstallException",")","->","explainError","$","show","err",")","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Except.hs#L36-L39","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Except.hs","hash_val":50331,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"flatten","parameters":"(Matrix r c tda offset vec)","argument_list":"","return_statement":"","docstring":"Create a vector by concatenating rows.","docstring_summary":"Create a vector by concatenating rows.","docstring_tokens":["Create","a","vector","by","concatenating","rows","."],"function":"flatten (Matrix r c tda offset vec)\n        | c == tda = G.slice offset (r*c) vec\n        | otherwise = G.generate (r*c) $ \\i ->\n            vec `G.unsafeIndex` (offset + (i `div` c) * tda + (i `mod` c))","function_tokens":["flatten","(","Matrix","r","c","tda","offset","vec",")","|","c","==","tda","=","G","slice","offset","(","r","*","c",")","vec","|","otherwise","=","G","generate","(","r","*","c",")","$","\\","i","->","vec","`","G","unsafeIndex","`","(","offset","+","(","i","`","div","`","c",")","*","tda","+","(","i","`","mod","`","c",")",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L160-L163","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Block.hs","language":"haskell","identifier":"realSrcSpanToLineBlock","parameters":"s","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"realSrcSpanToLineBlock s = Block (GHC.srcSpanStartLine s) (GHC.srcSpanEndLine s)","function_tokens":["realSrcSpanToLineBlock","s","=","Block","(","GHC","srcSpanStartLine","s",")","(","GHC","srcSpanEndLine","s",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Block.hs#L45-L45","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Block.hs","hash_val":49805,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"foldl","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldl = MG.foldl","function_tokens":["foldl","=","MG","foldl"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L229-L229","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unsafeFreeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFreeze = MG.unsafeFreeze","function_tokens":["unsafeFreeze","=","MG","unsafeFreeze"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L391-L391","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"cast'List","parameters":"(String x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cast'List (String x)       = Just $ T.unpack x","function_tokens":["cast'List","(","String","x",")","=","Just","$","T","unpack","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L268-L268","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread.hs","language":"haskell","identifier":"forkWithUnmask","parameters":"doForkWithUnmask","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forkWithUnmask doForkWithUnmask = \\f -> do\n  res <- newEmptyMVar\n  tid <- mask $ \\restore ->\n           doForkWithUnmask $ \\unmask ->\n             try (restore $ f unmask) >>= putMVar res\n  return (tid, readMVar res)\n\n\n--------------------------------------------------------------------------------\n-- Results\n--------------------------------------------------------------------------------\n\n-- | A result of a thread is either some exception that was thrown in the thread\n-- and wasn't catched or the actual value that was returned by the thread.","function_tokens":["forkWithUnmask","doForkWithUnmask","=","\\","f","->","do","res","<-","newEmptyMVar","tid","<-","mask","$","\\","restore","->","doForkWithUnmask","$","\\","unmask","->","try","(","restore","$","f","unmask",")",">>=","putMVar","res","return","(","tid",",","readMVar","res",")","--------------------------------------------------------------------------------","-- Results","--------------------------------------------------------------------------------","-- | A result of a thread is either some exception that was thrown in the thread","-- and wasn't catched or the actual value that was returned by the thread."],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread.hs#L126-L140","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread.hs","hash_val":55150,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","language":"haskell","identifier":"step","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"step = (makeStep \"UnicodeSyntax\" .) . step'","function_tokens":["step","=","(","makeStep","\"UnicodeSyntax\"",".",")",".","step'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs#L44-L44","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/UnicodeSyntax.hs","hash_val":51484,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"freeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeze = MG.freeze","function_tokens":["freeze","=","MG","freeze"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L388-L388","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"unzip","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip = MG.unzip","function_tokens":["unzip","=","MG","unzip"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L347-L347","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = r * c","function_tokens":["n","=","r","*","c"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L239-L239","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix.hs","language":"haskell","identifier":"zipWithM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM_ = MG.zipWithM_","function_tokens":["zipWithM_","=","MG","zipWithM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix.hs#L343-L343","hash_key":"kaizhang\/matrices:src\/Data\/Matrix.hs","hash_val":54777,"partition":"valid"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic.hs","language":"haskell","identifier":"dim","parameters":"(Matrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"O(1) Return the size of matrix.","docstring_summary":"O(1) Return the size of matrix.","docstring_tokens":["O","(","1",")","Return","the","size","of","matrix","."],"function":"dim (Matrix r c _ _ _) = (r,c)","function_tokens":["dim","(","Matrix","r","c","_","_","_",")","=","(","r",",","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic.hs#L140-L140","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic.hs","hash_val":52955,"partition":"valid"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson.hs","language":"haskell","identifier":"valList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"valList = Doc","function_tokens":["valList","=","Doc"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson.hs#L274-L274","hash_key":"mongodb-haskell\/bson:Data\/Bson.hs","hash_val":54825,"partition":"valid"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Editor.hs","language":"haskell","identifier":"l'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"l' = take (xstart - 1) l ++ x ++ drop (xend - 1) l","function_tokens":["l'","=","take","(","xstart","-","1",")","l","++","x","++","drop","(","xend","-","1",")","l"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Editor.hs#L182-L182","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Editor.hs","hash_val":53865,"partition":"valid"}
