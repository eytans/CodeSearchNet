{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"benchmarks\/benchmarks.hs","language":"haskell","identifier":"largeMatrix","parameters":"","argument_list":"","return_statement":"","docstring":"a 110 by 100 matrix","docstring_summary":"a 110 by 100 matrix","docstring_tokens":["a","110","by","100","matrix"],"function":"largeMatrix = M.matrix 100 [1 .. 110*100]","function_tokens":["largeMatrix","=","M","matrix","100","[","1","..","110","*","100","]"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/benchmarks\/benchmarks.hs#L10-L10","hash_key":"kaizhang\/matrices:benchmarks\/benchmarks.hs","hash_val":19425,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"or","parameters":"os","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"or os  = foldr (.|.) false os","function_tokens":["or","os","=","foldr","(",".|.",")","false","os"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L516-L516","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Transcription _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Transcription _)        = (True, True, False, False)","function_tokens":["go","(","Transcription","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L395-L395","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"dosDate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dosDate = fromIntegral (day + shiftL month 5 + shiftL year 9)","function_tokens":["dosDate","=","fromIntegral","(","day","+","shiftL","month","5","+","shiftL","year","9",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1173-L1173","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"resAPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resAPtr   = F.castPtr (F.unsafeForeignPtrToPtr resAFptr )","function_tokens":["resAPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resAFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L55-L55","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"getFullName","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getFullName _ = Nothing","function_tokens":["getFullName","_","=","Nothing"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L224-L224","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(flush, current) = case mbCurrent of\n                    Just c  | adjacent (cgBlock c) b\n                            , nextThingItem next\n                            , following@(_ : _) <- cgFollowing c ->\n                        ([c {cgFollowing = []}], CommentGroup b following [] [])\n                    Just c  | adjacent (cgBlock c) b ->\n                        ([], c {cgBlock = cgBlock c <> b})\n                    _ -> (maybeToList mbCurrent, CommentGroup b [] [] [])","function_tokens":["(","flush",",","current",")","=","case","mbCurrent","of","Just","c","|","adjacent","(","cgBlock","c",")","b",",","nextThingItem","next",",","following","@","(","_",":","_",")","<-","cgFollowing","c","->","(","[","c","{","cgFollowing","=","[","]","}","]",",","CommentGroup","b","following","[","]","[","]",")","Just","c","|","adjacent","(","cgBlock","c",")","b","->","(","[","]",",","c","{","cgBlock","=","cgBlock","c","<>","b","}",")","_","->","(","maybeToList","mbCurrent",",","CommentGroup","b","[","]","[","]","[","]",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L75-L83","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getPoint","parameters":"","argument_list":"","return_statement":"","docstring":"Two doubles making up a point with two coordinates","docstring_summary":"Two doubles making up a point with two coordinates","docstring_tokens":["Two","doubles","making","up","a","point","with","two","coordinates"],"function":"getPoint = do x <- getFloat64le\n              y <- getFloat64le\n              return (x, y)\n\n-- | Get the increments between list values","function_tokens":["getPoint","=","do","x","<-","getFloat64le","y","<-","getFloat64le","return","(","x",",","y",")","-- | Get the increments between list values"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L46-L51","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"withCompression","parameters":"sink","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withCompression sink =\n        getZipSink $\n          (,,) <$> ZipSink sizeSink\n            <*> ZipSink crc32Sink\n            <*> ZipSink sink","function_tokens":["withCompression","sink","=","getZipSink","$","(",",",",",")","<$>","ZipSink","sizeSink","<*>","ZipSink","crc32Sink","<*>","ZipSink","sink"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L583-L587","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"wrapping","parameters":"p1 p2","argument_list":"","return_statement":"","docstring":"^ Result of either the first or the second printer","docstring_summary":"^ Result of either the first or the second printer","docstring_tokens":["^","Result","of","either","the","first","or","the","second","printer"],"function":"wrapping p1 p2 = do\n    maxCols <- asks columns\n    case maxCols of\n        -- No wrapping\n        Nothing -> p1\n        Just c  -> do\n            s0 <- get\n            x <- p1\n            s1 <- get\n            if length (currentLine s1) <= c\n                -- No need to wrap\n                then pure x\n                else do\n                    put s0\n                    y <- p2\n                    s2 <- get\n                    if length (currentLine s1) == length (currentLine s2)\n                        -- Wrapping didn't help!\n                        then put s1 >> pure x\n                        -- Wrapped\n                        else pure y","function_tokens":["wrapping","p1","p2","=","do","maxCols","<-","asks","columns","case","maxCols","of","-- No wrapping","Nothing","->","p1","Just","c","->","do","s0","<-","get","x","<-","p1","s1","<-","get","if","length","(","currentLine","s1",")","<=","c","-- No need to wrap","then","pure","x","else","do","put","s0","y","<-","p2","s2","<-","get","if","length","(","currentLine","s1",")","==","length","(","currentLine","s2",")","-- Wrapping didn't help!","then","put","s1",">>","pure","x","-- Wrapped","else","pure","y"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L334-L356","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"itraverse","parameters":"f (Add as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Add as)  = Add <$> traverse f as","function_tokens":["itraverse","f","(","Add","as",")","=","Add","<$>","traverse","f","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L90-L90","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"f","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f i = G.slice (i*(c+1)) (c-i) vec","function_tokens":["f","i","=","G","slice","(","i","*","(","c","+","1",")",")","(","c","-","i",")","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L60-L60","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"byteOffset","parameters":"","argument_list":"","return_statement":"","docstring":"'byteOffset' contains the playback position, expressed in bytes (the value will loop back to zero for looping sources). For a compressed format, this value may represent an approximate offset within the compressed data buffer.  When setting 'byteOffset' on a source which is already playing, the playback will jump to the new offset unless the new offset is out of range, in which case an 'ALInvalidValue' error is set. If the source is not playing, then the offset will be applied on the next 'play' call. A 'stop', 'rewind', or a second 'play' call will reset the offset to the beginning of the buffer.  The position is relative to the beginning of all the queued buffers for the source, and any queued buffers traversed by a set call will be marked as processed.","docstring_summary":"'byteOffset' contains the playback position, expressed in bytes (the value will loop back to zero for looping sources). For a compressed format, this value may represent an approximate offset within the compressed data buffer.  When setting 'byteOffset' on a source which is already playing, the playback will jump to the new offset unless the new offset is out of range, in which case an 'ALInvalidValue' error is set. If the source is not playing, then the offset will be applied on the next 'play' call. A 'stop', 'rewind', or a second 'play' call will reset the offset to the beginning of the buffer.  The position is relative to the beginning of all the queued buffers for the source, and any queued buffers traversed by a set call will be marked as processed.","docstring_tokens":["byteOffset","contains","the","playback","position","expressed","in","bytes","(","the","value","will","loop","back","to","zero","for","looping","sources",")",".","For","a","compressed","format","this","value","may","represent","an","approximate","offset","within","the","compressed","data","buffer",".","When","setting","byteOffset","on","a","source","which","is","already","playing","the","playback","will","jump","to","the","new","offset","unless","the","new","offset","is","out","of","range","in","which","case","an","ALInvalidValue","error","is","set",".","If","the","source","is","not","playing","then","the","offset","will","be","applied","on","the","next","play","call",".","A","stop","rewind","or","a","second","play","call","will","reset","the","offset","to","the","beginning","of","the","buffer",".","The","position","is","relative","to","the","beginning","of","all","the","queued","buffers","for","the","source","and","any","queued","buffers","traversed","by","a","set","call","will","be","marked","as","processed","."],"function":"byteOffset = makeSourceStateVar dictALint GetByteOffset","function_tokens":["byteOffset","=","makeSourceStateVar","dictALint","GetByteOffset"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L489-L489","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"firstTvar","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"firstTvar = listToMaybe $ GHC.hsq_explicit dataTypeVars","function_tokens":["firstTvar","=","listToMaybe","$","GHC","hsq_explicit","dataTypeVars"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L315-L315","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"handleFileResult","parameters":"colorEnable opts fileName (NewContent result newContent)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"handleFileResult colorEnable opts fileName (NewContent result newContent)\n    | successes == 0 && allGood =\n      do  putStrLn $ fileName ++ \": No conflicts, git-adding\"\n          gitAdd fileName\n    | successes == 0 && reductions == 0 =\n      do  putStrLn $ concat\n              [ fileName, \": Failed to resolve any of the \"\n              , show failures, \" conflicts\" ]\n          doDump\n    | successes == 0 =\n      do  putStrLn $ concat\n              [ fileName, \": Reduced \", show reductions, \" conflicts\"]\n          overwrite fileName newContent\n          doDump\n    | otherwise =\n      do  putStrLn $ concat\n              [ fileName, \": Successfully resolved \", show successes\n              , \" conflicts (failed to resolve \" ++ show (reductions + failures) ++ \" conflicts)\"\n              , if allGood then \", git adding\" else \"\"\n              ]\n          overwrite fileName newContent\n          if allGood\n              then gitAdd fileName\n              else doDump\n    where\n        allGood = Resolution.fullySuccessful result\n        doDump =\n            dumpAndOpenEditor colorEnable opts fileName\n            [ conflict | Right conflict <- Conflict.parse newContent ]\n        Result\n            { _resolvedSuccessfully = successes\n            , _reducedConflicts = reductions\n            , _failedToResolve = failures\n            } = result","function_tokens":["handleFileResult","colorEnable","opts","fileName","(","NewContent","result","newContent",")","|","successes","==","0","&&","allGood","=","do","putStrLn","$","fileName","++","\": No conflicts, git-adding\"","gitAdd","fileName","|","successes","==","0","&&","reductions","==","0","=","do","putStrLn","$","concat","[","fileName",",","\": Failed to resolve any of the \"",",","show","failures",",","\" conflicts\"","]","doDump","|","successes","==","0","=","do","putStrLn","$","concat","[","fileName",",","\": Reduced \"",",","show","reductions",",","\" conflicts\"","]","overwrite","fileName","newContent","doDump","|","otherwise","=","do","putStrLn","$","concat","[","fileName",",","\": Successfully resolved \"",",","show","successes",",","\" conflicts (failed to resolve \"","++","show","(","reductions","+","failures",")","++","\" conflicts)\"",",","if","allGood","then","\", git adding\"","else","\"\"","]","overwrite","fileName","newContent","if","allGood","then","gitAdd","fileName","else","doDump","where","allGood","=","Resolution","fullySuccessful","result","doDump","=","dumpAndOpenEditor","colorEnable","opts","fileName","[","conflict","|","Right","conflict","<-","Conflict","parse","newContent","]","Result","{","_resolvedSuccessfully","=","successes",",","_reducedConflicts","=","reductions",",","_failedToResolve","=","failures","}","=","result"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L83-L118","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified' _ = coerce True","function_tokens":["isQuantified'","_","=","coerce","True"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L621-L621","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"id","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"id = var id","function_tokens":["id","=","var","id"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L111-L111","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"constructDeploymentInfo'","parameters":"opts pkgId","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"constructDeploymentInfo' opts pkgId =\n  DeploymentInfo prefixDir' (BinDir binFp)\n    (DocDir $ shareFp <\/> \"doc\") (pkgVersion pkgId)\n\n  where\n    prefixDir'@(PrefixDir prefixFp) = computePrefixDir (optPrefix opts) (optBuildMode opts)\n    binFp = prefixFp <\/> \"bin\"\n    project = unPackageName . pkgName $ pkgId\n    shareFp = prefixFp <\/> \"share\" <\/> project","function_tokens":["constructDeploymentInfo'","opts","pkgId","=","DeploymentInfo","prefixDir'","(","BinDir","binFp",")","(","DocDir","$","shareFp","<\/>","\"doc\"",")","(","pkgVersion","pkgId",")","where","prefixDir'","@","(","PrefixDir","prefixFp",")","=","computePrefixDir","(","optPrefix","opts",")","(","optBuildMode","opts",")","binFp","=","prefixFp","<\/>","\"bin\"","project","=","unPackageName",".","pkgName","$","pkgId","shareFp","=","prefixFp","<\/>","\"share\"","<\/>","project"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L91-L102","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Common.hs","language":"haskell","identifier":"iconSourcePath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"iconSourcePath = shareDir <\/> \"resources\" <\/> iconFilename","function_tokens":["iconSourcePath","=","shareDir","<\/>","\"resources\"","<\/>","iconFilename"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Common.hs#L39-L39","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Common.hs","hash_val":33449,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"join","parameters":"p1 t1 p2 t2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"join p1 t1 p2 t2\n  | zero p1 m = bin_ p m t1 t2\n  | otherwise = bin_ p m t2 t1\n  where\n    m = branchMask p1 p2\n    p = mask p1 m\n\n\n\n{--------------------------------------------------------------------\n  Endian independent bit twiddling\n--------------------------------------------------------------------}","function_tokens":["join","p1","t1","p2","t2","|","zero","p1","m","=","bin_","p","m","t1","t2","|","otherwise","=","bin_","p","m","t2","t1","where","m","=","branchMask","p1","p2","p","=","mask","p1","m","{--------------------------------------------------------------------\n  Endian independent bit twiddling\n--------------------------------------------------------------------}"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L890-L902","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"cancel","parameters":"","argument_list":"","return_statement":"","docstring":"Return Nothing on lookup failure","docstring_summary":"Return Nothing on lookup failure","docstring_tokens":["Return","Nothing","on","lookup","failure"],"function":"cancel = return Nothing","function_tokens":["cancel","=","return","Nothing"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L40-L40","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_GAIN","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_GAIN                             = 0x100A","function_tokens":["al_GAIN","=","0x100A"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L67-L67","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"shapes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shapes = (map (getPolygon . fromJust . shpRecContents)) . shpRecs $ file","function_tokens":["shapes","=","(","map","(","getPolygon",".","fromJust",".","shpRecContents",")",")",".","shpRecs","$","file"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L70-L70","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"mzero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mzero = lift mzero","function_tokens":["mzero","=","lift","mzero"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L112-L112","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(l1,l2) = partition predicate l","function_tokens":["(","l1",",","l2",")","=","partition","predicate","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L512-L512","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"return","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"return = pure","function_tokens":["return","=","pure"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L128-L128","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Title _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Title _)                = (False, True{-second-}, True, False)","function_tokens":["go","(","Title","_",")","=","(","False",",","True","{-second-}",",","True",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L389-L389","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"res","parameters":"(InL _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"res (InL _) = Nothing","function_tokens":["res","(","InL","_",")","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L66-L66","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Remark","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Remark                   = \"r\"","function_tokens":["go","Remark","=","\"r\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L352-L352","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"isRedundant'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isRedundant'\n        | removeRedundant = isRedundant m\n        | otherwise       = const False","function_tokens":["isRedundant'","|","removeRedundant","=","isRedundant","m","|","otherwise","=","const","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L126-L128","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"seconds","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"seconds =\n      let (MkFixed x) = todSec tod\n       in fromIntegral (x `quot` 2000000000000)","function_tokens":["seconds","=","let","(","MkFixed","x",")","=","todSec","tod","in","fromIntegral","(","x","`","quot","`","2000000000000",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1174-L1176","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mappendTList","parameters":"Empty   a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappendTList Empty   a       = a","function_tokens":["mappendTList","Empty","a","=","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L315-L315","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Tempo_ (str, durs, bpm))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (Tempo_ (str, durs, bpm)) = \n        pretty str <+> (hsep (fmap pretty durs) <> \"=\" <> pretty bpm)","function_tokens":["pretty","(","Tempo_","(","str",",","durs",",","bpm",")",")","=","pretty","str","<+>","(","hsep","(","fmap","pretty","durs",")","<>","\"=\"","<>","pretty","bpm",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L546-L547","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"restrict","parameters":"","argument_list":"","return_statement":"","docstring":"Try to restrict a superset to a subset.","docstring_summary":"Try to restrict a superset to a subset.","docstring_tokens":["Try","to","restrict","a","superset","to","a","subset","."],"function":"restrict = fmap IFix . res <=< (itraverse restrict) . unIFix","function_tokens":["restrict","=","fmap","IFix",".","res","<=<","(","itraverse","restrict",")",".","unIFix"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L83-L83","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"bp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bp = stepToByteString s step","function_tokens":["bp","=","stepToByteString","s","step"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L94-L94","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putDeriving","parameters":"Config{..} lclause","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putDeriving Config{..} lclause = do\n    let clause@GHC.HsDerivingClause {..} = GHC.unLoc lclause\n        tys = (if cSortDeriving then sortBy compareOutputableCI else id) $\n            map (GHC.sig_body . GHC.unLoc) $\n            derivingClauseTypes clause\n        headTy = listToMaybe tys\n        tailTy = drop 1 tys\n\n    putText \"deriving\"\n\n    forM_ deriv_clause_strategy $ \\lstrat -> case GHC.unLoc lstrat of\n        GHC.StockStrategy    {} -> space >> putText \"stock\"\n        GHC.AnyclassStrategy {} -> space >> putText \"anyclass\"\n        GHC.NewtypeStrategy  {} -> space >> putText \"newtype\"\n        GHC.ViaStrategy      {} -> pure ()\n\n    putCond\n        withinColumns\n        do\n            space\n            putText \"(\"\n            sep\n                (comma >> space)\n                (fmap putOutputable tys)\n            putText \")\"\n        do\n            newline\n            spaces indentation\n            putText \"(\"\n\n            forM_ headTy \\t ->\n                space >> putOutputable t\n\n            forM_ tailTy \\t -> do\n                newline\n                spaces indentation\n                comma\n                space\n                putOutputable t\n\n            newline\n            spaces indentation\n            putText \")\"\n\n    forM_ deriv_clause_strategy $ \\lstrat -> case GHC.unLoc lstrat of\n        GHC.ViaStrategy tp -> do\n            case cVia of\n                SameLine -> space\n                Indent x -> newline >> spaces (x + cDeriving)\n\n            putText \"via\"\n            space\n            putType $ case tp of\n                GHC.XViaStrategyPs _ ty -> GHC.sig_body $ GHC.unLoc ty\n        _ -> pure ()\n\n    -- putEolComment pos\n  where\n    withinColumns PrinterState{currentLine} =\n      case cMaxColumns of\n        MaxColumns maxCols -> length currentLine <= maxCols\n        NoMaxColumns       -> True\n\n    indentation =\n      cDeriving + case cFirstField of\n        Indent x -> x\n        SameLine -> 0","function_tokens":["putDeriving","Config","{","..","}","lclause","=","do","let","clause","@","GHC","HsDerivingClause","{","..","}","=","GHC","unLoc","lclause","tys","=","(","if","cSortDeriving","then","sortBy","compareOutputableCI","else","id",")","$","map","(","GHC","sig_body",".","GHC","unLoc",")","$","derivingClauseTypes","clause","headTy","=","listToMaybe","tys","tailTy","=","drop","1","tys","putText","\"deriving\"","forM_","deriv_clause_strategy","$","\\","lstrat","->","case","GHC","unLoc","lstrat","of","GHC","StockStrategy","{","}","->","space",">>","putText","\"stock\"","GHC","AnyclassStrategy","{","}","->","space",">>","putText","\"anyclass\"","GHC","NewtypeStrategy","{","}","->","space",">>","putText","\"newtype\"","GHC","ViaStrategy","{","}","->","pure","(",")","putCond","withinColumns","do","space","putText","\"(\"","sep","(","comma",">>","space",")","(","fmap","putOutputable","tys",")","putText","\")\"","do","newline","spaces","indentation","putText","\"(\"","forM_","headTy","\\","t","->","space",">>","putOutputable","t","forM_","tailTy","\\","t","->","do","newline","spaces","indentation","comma","space","putOutputable","t","newline","spaces","indentation","putText","\")\"","forM_","deriv_clause_strategy","$","\\","lstrat","->","case","GHC","unLoc","lstrat","of","GHC","ViaStrategy","tp","->","do","case","cVia","of","SameLine","->","space","Indent","x","->","newline",">>","spaces","(","x","+","cDeriving",")","putText","\"via\"","space","putType","$","case","tp","of","GHC","XViaStrategyPs","_","ty","->","GHC","sig_body","$","GHC","unLoc","ty","_","->","pure","(",")","-- putEolComment pos","where","withinColumns","PrinterState","{","currentLine","}","=","case","cMaxColumns","of","MaxColumns","maxCols","->","length","currentLine","<=","maxCols","NoMaxColumns","->","True","indentation","=","cDeriving","+","case","cFirstField","of","Indent","x","->","x","SameLine","->","0"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L227-L295","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"izipWith6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith6 = MG.izipWith6","function_tokens":["izipWith6","=","MG","izipWith6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L305-L305","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"line","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"line          = if null pragmas' then 1 else firstLocation pragmas'","function_tokens":["line","=","if","null","pragmas'","then","1","else","firstLocation","pragmas'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L162-L162","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"coneOuterGain","parameters":"","argument_list":"","return_statement":"","docstring":"'coneOuterGain' contains the factor with which 'sourceGain' is multiplied to determine the effective gain outside the cone defined by the outer angle. The effective gain applied outside the outer cone is 'sourceGain' times 'coneOuterGain'. Changing 'sourceGain' affects all directions, i.e. the source is attenuated in all directions, for any position of the listener. The application has to change 'coneOuterGain' as well if a different behavior is desired.","docstring_summary":"'coneOuterGain' contains the factor with which 'sourceGain' is multiplied to determine the effective gain outside the cone defined by the outer angle. The effective gain applied outside the outer cone is 'sourceGain' times 'coneOuterGain'. Changing 'sourceGain' affects all directions, i.e. the source is attenuated in all directions, for any position of the listener. The application has to change 'coneOuterGain' as well if a different behavior is desired.","docstring_tokens":["coneOuterGain","contains","the","factor","with","which","sourceGain","is","multiplied","to","determine","the","effective","gain","outside","the","cone","defined","by","the","outer","angle",".","The","effective","gain","applied","outside","the","outer","cone","is","sourceGain","times","coneOuterGain",".","Changing","sourceGain","affects","all","directions","i",".","e",".","the","source","is","attenuated","in","all","directions","for","any","position","of","the","listener",".","The","application","has","to","change","coneOuterGain","as","well","if","a","different","behavior","is","desired","."],"function":"coneOuterGain = makeSourceStateVar dictALfloat GetConeOuterGain","function_tokens":["coneOuterGain","=","makeSourceStateVar","dictALfloat","GetConeOuterGain"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L434-L434","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureDeviceSpecifier","parameters":"device","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains the specifier string for the given capture device.","docstring_summary":"------------------------------------------------------------------------------ Contains the specifier string for the given capture device.","docstring_tokens":["------------------------------------------------------------------------------","Contains","the","specifier","string","for","the","given","capture","device","."],"function":"captureDeviceSpecifier device = makeGettableStateVar $\n   getString (Just device) CaptureDeviceSpecifier","function_tokens":["captureDeviceSpecifier","device","=","makeGettableStateVar","$","getString","(","Just","device",")","CaptureDeviceSpecifier"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L130-L131","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"runCullA","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.  @since 1.0.0.0","docstring_summary":"Run a 'Cull' effect, interpreting the result into an 'Alternative' functor. Choice is handled with '<|>', embedding with 'pure', and failure with 'empty'.","docstring_tokens":["Run","a","Cull","effect","interpreting","the","result","into","an","Alternative","functor",".","Choice","is","handled","with","<|",">","embedding","with","pure","and","failure","with","empty","."],"function":"runCullA = runCull (liftA2 (<|>)) (pure . pure) (pure empty)","function_tokens":["runCullA","=","runCull","(","liftA2","(","<|>",")",")","(","pure",".","pure",")","(","pure","empty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L53-L53","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"noWrapRest'","parameters":"ls ss []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"noWrapRest' ls ss []\n        | null ss = ls\n        | otherwise = ss:ls","function_tokens":["noWrapRest'","ls","ss","[","]","|","null","ss","=","ls","|","otherwise","=","ss",":","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L165-L167","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putTL","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putTL t = putTag t >> putLabel k","function_tokens":["putTL","t","=","putTag","t",">>","putLabel","k"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L75-L75","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"perimeterPolygon","parameters":"(x1:x2:points)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"perimeterPolygon (x1:x2:points) = perimeterPolygon (x2:points) + distance x1 x2","function_tokens":["perimeterPolygon","(","x1",":","x2",":","points",")","=","perimeterPolygon","(","x2",":","points",")","+","distance","x1","x2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L60-L60","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(a, _, w) = runRSS m r s","function_tokens":["(","a",",","_",",","w",")","=","runRSS","m","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L60-L60","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"thread","parameters":"hdl sig","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thread hdl sig = fmap getCompose . alg hdl sig . Compose","function_tokens":["thread","hdl","sig","=","fmap","getCompose",".","alg","hdl","sig",".","Compose"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L112-L112","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"getBuffer","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getBuffer = ConduitParser $ lift $ gets snd","function_tokens":["getBuffer","=","ConduitParser","$","lift","$","gets","snd"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L122-L122","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getCD","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getCD = M.fromList . catMaybes <$> many getCDHeader","function_tokens":["getCD","=","M","fromList",".","catMaybes","<$>","many","getCDHeader"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L669-L669","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"makeCr","parameters":"x@(_:_)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeCr x@(_:_) | last x == '\\r' = x","function_tokens":["makeCr","x","@","(","_",":","_",")","|","last","x","==","'\\r'","=","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L129-L129","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"itraverse","parameters":"f (c `Divides` a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (c `Divides` a)  = Divides c <$> f a","function_tokens":["itraverse","f","(","c","`","Divides","`","a",")","=","Divides","c","<$>","f","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L92-L92","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"byLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"byLine = map toList . groupByLine aLeft","function_tokens":["byLine","=","map","toList",".","groupByLine","aLeft"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L58-L58","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"freeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeze = MG.freeze","function_tokens":["freeze","=","MG","freeze"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L378-L378","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"next","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"next | ((<=) `on` informationOf . analysis) b1 b2 = (`h` b2) =<< step b1\n                      | otherwise = h b1 =<< step b2","function_tokens":["next","|","(","(","<=",")","`","on","`","informationOf",".","analysis",")","b1","b2","=","(","`","h","`","b2",")","=<<","step","b1","|","otherwise","=","h","b1","=<<","step","b2"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L325-L326","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"lens","parameters":"g m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lens g m = Lens (Point g m)","function_tokens":["lens","g","m","=","Lens","(","Point","g","m",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L55-L55","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"map","parameters":"f","argument_list":"","return_statement":"","docstring":"\/O(n*min(n,W))\/. @'map' f s@ is the set obtained by applying @f@ to each element of @s@.  It's worth noting that the size of the result may be smaller if, for some @(x,y)@, @x \\\/= y && f x == f y@","docstring_summary":"\/O(n*min(n,W))\/.","docstring_tokens":["\/","O","(","n","*","min","(","n","W","))","\/","."],"function":"map f = fromList . List.map f . toList","function_tokens":["map","f","=","fromList",".","List","map","f",".","toList"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L679-L679","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"sizeSink","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sizeSink = CL.fold (\\acc input -> fromIntegral (B.length input) + acc) 0","function_tokens":["sizeSink","=","CL","fold","(","\\","acc","input","->","fromIntegral","(","B","length","input",")","+","acc",")","0"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L579-L579","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs","language":"haskell","identifier":"addRecLabel","parameters":"sr labels","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"addRecLabel sr labels = sr { shpRecLabel = Just (labels) }","function_tokens":["addRecLabel","sr","labels","=","sr","{","shpRecLabel","=","Just","(","labels",")","}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs#L30-L30","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs","hash_val":12976,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"liftCatch","parameters":"catchE m h","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftCatch catchE m h =\n  RSST $ \\ r s -> runRSST' m r s `catchE` \\ e -> runRSST' (h e) r s","function_tokens":["liftCatch","catchE","m","h","=","RSST","$","\\","r","s","->","runRSST'","m","r","s","`","catchE","`","\\","e","->","runRSST'","(","h","e",")","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L212-L213","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"fail","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail = AccumC . const . Fail.fail","function_tokens":["fail","=","AccumC",".","const",".","Fail","fail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L119-L119","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"i","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"i = length curr + 1","function_tokens":["i","=","length","curr","+","1"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L42-L42","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"prune","parameters":"contexts allCons","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prune contexts allCons =\n  case contexts of\n    (Context _ _ con) : _\n       -> filter (unifiableCon con) allCons\n    [] -> []","function_tokens":["prune","contexts","allCons","=","case","contexts","of","(","Context","_","_","con",")",":","_","->","filter","(","unifiableCon","con",")","allCons","[","]","->","[","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L376-L382","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"idx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"idx = offset + i * tda + j","function_tokens":["idx","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L35-L35","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"unsafeWrite","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeWrite = MG.unsafeWrite","function_tokens":["unsafeWrite","=","MG","unsafeWrite"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L36-L36","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putClosure","parameters":"x y","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putClosure x y = let b = runPut (putString x >> putDocument y) in do\n  putInt32 $ (toEnum . fromEnum) (LC.length b + 4)  -- including this length field\n  putLazyByteString b","function_tokens":["putClosure","x","y","=","let","b","=","runPut","(","putString","x",">>","putDocument","y",")","in","do","putInt32","$","(","toEnum",".","fromEnum",")","(","LC","length","b","+","4",")","-- including this length field","putLazyByteString","b"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L236-L240","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"dim","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim = MG.dim","function_tokens":["dim","=","MG","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L114-L114","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"(RETURN_NODES _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandId (RETURN_NODES _ _) = 4","function_tokens":["commandId","(","RETURN_NODES","_","_",")","=","4"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L30-L30","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"identify","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identify i = go where\n    go (BApp f a) = App i f a\n    go (BLam v t e) = Lam i v t e\n    go (BPi v t e) = Pi i v t e\n    go (BSet n) = Set i n","function_tokens":["identify","i","=","go","where","go","(","BApp","f","a",")","=","App","i","f","a","go","(","BLam","v","t","e",")","=","Lam","i","v","t","e","go","(","BPi","v","t","e",")","=","Pi","i","v","t","e","go","(","BSet","n",")","=","Set","i","n"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L35-L40","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"askChar","parameters":"","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"askChar = Free.liftF . (`AskChar` id)","function_tokens":["askChar","=","Free","liftF",".","(","`","AskChar","`","id",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L68-L68","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<*>) = ap","function_tokens":["(","<*>",")","=","ap"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L147-L147","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"t","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t = identify (wid * i + r) bt","function_tokens":["t","=","identify","(","wid","*","i","+","r",")","bt"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L89-L89","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"store''","parameters":"(DynamicallySorted as@(SArraySort _ _) a)\n                 (DynamicallySorted is                  i)\n                 (DynamicallySorted es                  v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"store''  (DynamicallySorted as@(SArraySort _ _) a)\n                 (DynamicallySorted is                  i)\n                 (DynamicallySorted es                  v) = case as %~ SArraySort is es of\n            Proved Refl -> return . DynamicallySorted as $ inject (Store is es a i v)\n            Disproved _ -> fail \"ill-sorted store\"","function_tokens":["store''","(","DynamicallySorted","as","@","(","SArraySort","_","_",")","a",")","(","DynamicallySorted","is","i",")","(","DynamicallySorted","es","v",")","=","case","as","%~","SArraySort","is","es","of","Proved","Refl","->","return",".","DynamicallySorted","as","$","inject","(","Store","is","es","a","i","v",")","Disproved","_","->","fail","\"ill-sorted store\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L105-L110","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"replicate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"replicate = MG.replicate","function_tokens":["replicate","=","MG","replicate"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L49-L49","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"itraverse","parameters":"_ (Var n s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse _ (Var n s) = pure (Var n s)","function_tokens":["itraverse","_","(","Var","n","s",")","=","pure","(","Var","n","s",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L260-L260","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfc","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfc x \n    | x >= 0    = estimate\n    | otherwise = 2 - estimate\n    where\n        ax = abs x\n        estimate\n            | ax <= 1   = evalChebyshevSeries erfc_xlt1_cs (2 * ax - 1)\n            | ax <= 5   = \n                let t = 0.5 * (ax - 3)\n                in exp (negate x*x) * evalChebyshevSeries erfc_x15_cs t\n            | ax < 10   = \n                let t = (2 * ax - 15) \/ 5\n                in (exp (negate x*x) \/ ax) * evalChebyshevSeries erfc_x510_cs t\n            | otherwise = erfc8 ax","function_tokens":["erfc","x","|","x",">=","0","=","estimate","|","otherwise","=","2","-","estimate","where","ax","=","abs","x","estimate","|","ax","<=","1","=","evalChebyshevSeries","erfc_xlt1_cs","(","2","*","ax","-","1",")","|","ax","<=","5","=","let","t","=","0.5","*","(","ax","-","3",")","in","exp","(","negate","x","*","x",")","*","evalChebyshevSeries","erfc_x15_cs","t","|","ax","<","10","=","let","t","=","(","2","*","ax","-","15",")","\/","5","in","(","exp","(","negate","x","*","x",")","\/","ax",")","*","evalChebyshevSeries","erfc_x510_cs","t","|","otherwise","=","erfc8","ax"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L51-L66","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"deleteMax","parameters":"","argument_list":"","return_statement":"","docstring":"\/O(min(n,W))\/. Delete the maximal element.","docstring_summary":"\/O(min(n,W))\/. Delete the maximal element.","docstring_tokens":["\/","O","(","min","(","n","W","))","\/",".","Delete","the","maximal","element","."],"function":"deleteMax = maybe (error \"deleteMax: empty set has no maximal element\") snd . maxView","function_tokens":["deleteMax","=","maybe","(","error","\"deleteMax: empty set has no maximal element\"",")","snd",".","maxView"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L666-L666","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"compacticity","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compacticity = map (relativeCompactness . concat . getPolygon . fromJust . shpRecContents) . shpRecs $ file","function_tokens":["compacticity","=","map","(","relativeCompactness",".","concat",".","getPolygon",".","fromJust",".","shpRecContents",")",".","shpRecs","$","file"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L73-L73","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"unpackInto","parameters":"dir'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unpackInto dir' = do\n  selectors <- M.keysSet <$> getEntries\n  unless (null selectors) $ do\n    dir <- liftIO (makeAbsolute dir')\n    liftIO (createDirectoryIfMissing True dir)\n    let dirs = E.map (FP.takeDirectory . (dir <\/>) . unEntrySelector) selectors\n    forM_ dirs (liftIO . createDirectoryIfMissing True)\n    forM_ selectors $ \\s ->\n      saveEntry s (dir <\/> unEntrySelector s)\n\n-- | Get the archive comment.","function_tokens":["unpackInto","dir'","=","do","selectors","<-","M","keysSet","<$>","getEntries","unless","(","null","selectors",")","$","do","dir","<-","liftIO","(","makeAbsolute","dir'",")","liftIO","(","createDirectoryIfMissing","True","dir",")","let","dirs","=","E","map","(","FP","takeDirectory",".","(","dir","<\/>",")",".","unEntrySelector",")","selectors","forM_","dirs","(","liftIO",".","createDirectoryIfMissing","True",")","forM_","selectors","$","\\","s","->","saveEntry","s","(","dir","<\/>","unEntrySelector","s",")","-- | Get the archive comment."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L404-L415","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"nameLoc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nameLoc  = GHC.getLocA name","function_tokens":["nameLoc","=","GHC","getLocA","name"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L136-L136","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INVALID_OPERATION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INVALID_OPERATION                = 0xA004","function_tokens":["al_INVALID_OPERATION","=","0xA004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L35-L35","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"unmarshalBuffer","parameters":"b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalBuffer b =\n   if b == bufferID nullBuffer then Nothing else Just (Buffer b)","function_tokens":["unmarshalBuffer","b","=","if","b","==","bufferID","nullBuffer","then","Nothing","else","Just","(","Buffer","b",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L52-L53","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"runTeletypeRet","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"runTeletypeRet i = runWriter . runState i . runTeletypeRetC","function_tokens":["runTeletypeRet","i","=","runWriter",".","runState","i",".","runTeletypeRetC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L66-L66","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ifold","parameters":"(Exists _ b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Exists _ b) = b","function_tokens":["ifold","(","Exists","_","b",")","=","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L550-L550","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"go","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go []           = []","function_tokens":["go","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L211-L211","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = do\n        _ <- char '(' *> string \"ite\" *> space\n        i <- r\n        _ <- space\n        t <- r\n        _ <- space\n        e <- r\n        _ <- char ')'\n        ifThenElse i t e <?> \"IfThenElse\" where\n\n        ifThenElse :: DynamicallySortedFix f -> DynamicallySortedFix f -> DynamicallySortedFix f -> Parser (DynamicallySortedFix f)\n        ifThenElse (DynamicallySorted s1 i)\n                   (DynamicallySorted s2 t)\n                   (DynamicallySorted s3 e) = case s1 %~ SBooleanSort of\n            Proved Refl -> case s2 %~ s3 of\n                Proved Refl -> return . DynamicallySorted s2 $ inject (IfThenElse s2 i t e)\n                Disproved _ -> fail \"inconsistent sorts of then and else branches\"\n            Disproved _ -> fail \"branching on non-boolean expression\"\n\n-- | A smart constructor for an if-then-else expression","function_tokens":["parser","_","r","=","do","_","<-","char","'('","*>","string","\"ite\"","*>","space","i","<-","r","_","<-","space","t","<-","r","_","<-","space","e","<-","r","_","<-","char","')'","ifThenElse","i","t","e","<?>","\"IfThenElse\"","where","ifThenElse","::","DynamicallySortedFix","f","->","DynamicallySortedFix","f","->","DynamicallySortedFix","f","->","Parser","(","DynamicallySortedFix","f",")","ifThenElse","(","DynamicallySorted","s1","i",")","(","DynamicallySorted","s2","t",")","(","DynamicallySorted","s3","e",")","=","case","s1","%~","SBooleanSort","of","Proved","Refl","->","case","s2","%~","s3","of","Proved","Refl","->","return",".","DynamicallySorted","s2","$","inject","(","IfThenElse","s2","i","t","e",")","Disproved","_","->","fail","\"inconsistent sorts of then and else branches\"","Disproved","_","->","fail","\"branching on non-boolean expression\"","-- | A smart constructor for an if-then-else expression"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L62-L82","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"shiftRL","parameters":"(W# x) (I# i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shiftRL (W# x) (I# i) = W# (shiftRL# x i)","function_tokens":["shiftRL","(","W#","x",")","(","I#","i",")","=","W#","(","shiftRL#","x","i",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L146-L146","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"match","parameters":"base a b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"match base a b\n            | null base = lengthOfCommonPrefix a b\n            | otherwise = minimum $ map (lengthOfCommonPrefix base) [a, b]","function_tokens":["match","base","a","b","|","null","base","=","lengthOfCommonPrefix","a","b","|","otherwise","=","minimum","$","map","(","lengthOfCommonPrefix","base",")","[","a",",","b","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L42-L44","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getArchiveComment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getArchiveComment = adComment <$> getArchiveDescription","function_tokens":["getArchiveComment","=","adComment","<$>","getArchiveDescription"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L416-L416","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"bsA","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bsA = toByteStruct idA","function_tokens":["bsA","=","toByteStruct","idA"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L78-L78","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"newMax","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newMax | pos == position = (pos, mean ana)\n                         | mean ana > m = (position, mean ana)\n                         | otherwise = (pos, m)","function_tokens":["newMax","|","pos","==","position","=","(","pos",",","mean","ana",")","|","mean","ana",">","m","=","(","position",",","mean","ana",")","|","otherwise","=","(","pos",",","m",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L258-L260","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"index","parameters":"Mul      {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Mul      {} = SIntegralSort","function_tokens":["index","Mul","{","}","=","SIntegralSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L77-L77","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"deleteQuad","parameters":"c s p o l","argument_list":"","return_statement":"","docstring":"Delete the 'Quad' defined by the given subject, predicate, object and optional label.","docstring_summary":"Delete the 'Quad' defined by the given subject, predicate, object and optional label.","docstring_tokens":["Delete","the","Quad","defined","by","the","given","subject","predicate","object","and","optional","label","."],"function":"deleteQuad c s p o l =\n  deleteQuads c [Quad { subject = s, predicate = p, object = o, label = l }]","function_tokens":["deleteQuad","c","s","p","o","l","=","deleteQuads","c","[","Quad","{","subject","=","s",",","predicate","=","p",",","object","=","o",",","label","=","l","}","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L132-L133","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SOURCE_STATE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SOURCE_STATE                     = 0x1010","function_tokens":["al_SOURCE_STATE","=","0x1010"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L96-L96","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = peer node","function_tokens":["p","=","peer","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L162-L162","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"bps","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bps     = ibsToIndexByteStrings chunks","function_tokens":["bps","=","ibsToIndexByteStrings","chunks"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L40-L40","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","language":"haskell","identifier":"getDbfFieldDesc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getDbfFieldDesc = do\n  name     <- getString 11     -- Field name\n  fieldT   <- getCharVal       -- Field type\n  _        <- getIntLE         -- Field displacement (?)\n  len      <- getInt8          -- Field length\n  _        <- getByteString 15 -- Num decimal\/field flags\/autoincrement\n  return DbfFieldDesc { fieldName = name,\n                   fieldType = fieldT,\n                   fieldLen  = len }\n\n-- | Read a record. Not all record types are (meaningfully) implemented.","function_tokens":["getDbfFieldDesc","=","do","name","<-","getString","11","-- Field name","fieldT","<-","getCharVal","-- Field type","_","<-","getIntLE","-- Field displacement (?)","len","<-","getInt8","-- Field length","_","<-","getByteString","15","-- Num decimal\/field flags\/autoincrement","return","DbfFieldDesc","{","fieldName","=","name",",","fieldType","=","fieldT",",","fieldLen","=","len","}","-- | Read a record. Not all record types are (meaningfully) implemented."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs#L46-L57","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","hash_val":38792,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommandId","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommandId = do\n    bs <- lift get\n    case B.uncons bs of\n        Nothing         -> throwE \"uncons returned Nothing\"\n        Just (id, rest) -> do\n            lift . put $ rest\n            return $ fromIntegral id\n\n-- | Splits after a certain character","function_tokens":["parseCommandId","=","do","bs","<-","lift","get","case","B","uncons","bs","of","Nothing","->","throwE","\"uncons returned Nothing\"","Just","(","id",",","rest",")","->","do","lift",".","put","$","rest","return","$","fromIntegral","id","-- | Splits after a certain character"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L54-L63","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"ifold","parameters":"(Select _ _ a i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Select _ _ a i)   = coerce a <> coerce i","function_tokens":["ifold","(","Select","_","_","a","i",")","=","coerce","a","<>","coerce","i"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L67-L67","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars","parameters":"","argument_list":"","return_statement":"","docstring":"Collects a list of all free variables occurring in an expression.","docstring_summary":"Collects a list of all free variables occurring in an expression.","docstring_tokens":["Collects","a","list","of","all","free","variables","occurring","in","an","expression","."],"function":"freevars = nub . coerce . icata freevars'","function_tokens":["freevars","=","nub",".","coerce",".","icata","freevars'"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L648-L648","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"getEntryName","parameters":"","argument_list":"","return_statement":"","docstring":"Get an entry name in the from that is suitable for writing to file header, given an 'EntrySelector'.","docstring_summary":"Get an entry name in the from that is suitable for writing to file header, given an 'EntrySelector'.","docstring_tokens":["Get","an","entry","name","in","the","from","that","is","suitable","for","writing","to","file","header","given","an","EntrySelector","."],"function":"getEntryName =\n  T.pack . concat . NE.toList . NE.intersperse \"\/\" . fmap CI.original . unES","function_tokens":["getEntryName","=","T","pack",".","concat",".","NE","toList",".","NE","intersperse","\"\/\"",".","fmap","CI","original",".","unES"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L126-L127","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"index","parameters":"(Store  is es _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index (Store  is es _ _ _) = SArraySort is es","function_tokens":["index","(","Store","is","es","_","_","_",")","=","SArraySort","is","es"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L64-L64","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"go","parameters":"bpState bpvm","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go bpState bpvm = fmap fromIntegral . ST.unsafeIOToST $ do\n          let (outFptr, _, _) = DVSM.unsafeToForeignPtr bpvm\n\n          F.withForeignPtr outFptr $ \\outPtr ->\n            F.withForeignPtr isFptr $ \\isPtr ->\n              F.withForeignPtr asFptr $ \\asPtr ->\n                F.withForeignPtr zsFptr $ \\zsPtr ->\n                  F.withForeignPtr (bpStateP bpState) $ \\bpStatePtr -> do\n                    F.writeBpChunk\n                      (F.castPtr isPtr)\n                      (F.castPtr asPtr)\n                      (F.castPtr zsPtr)\n                      (fromIntegral (BS.length is))\n                      (F.castPtr bpStatePtr)\n                      (F.castPtr outPtr)","function_tokens":["go","bpState","bpvm","=","fmap","fromIntegral",".","ST","unsafeIOToST","$","do","let","(","outFptr",",","_",",","_",")","=","DVSM","unsafeToForeignPtr","bpvm","F","withForeignPtr","outFptr","$","\\","outPtr","->","F","withForeignPtr","isFptr","$","\\","isPtr","->","F","withForeignPtr","asFptr","$","\\","asPtr","->","F","withForeignPtr","zsFptr","$","\\","zsPtr","->","F","withForeignPtr","(","bpStateP","bpState",")","$","\\","bpStatePtr","->","do","F","writeBpChunk","(","F","castPtr","isPtr",")","(","F","castPtr","asPtr",")","(","F","castPtr","zsPtr",")","(","fromIntegral","(","BS","length","is",")",")","(","F","castPtr","bpStatePtr",")","(","F","castPtr","outPtr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L110-L125","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"consIndent","parameters":"eqIndent","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"consIndent eqIndent = newline >> case (cEquals, cFirstField) of\n        (SameLine, SameLine) -> spaces (eqIndent - 2)\n        (SameLine, Indent y) -> spaces (eqIndent + y - 4)\n        (Indent x, Indent _) -> spaces x\n        (Indent x, SameLine) -> spaces x","function_tokens":["consIndent","eqIndent","=","newline",">>","case","(","cEquals",",","cFirstField",")","of","(","SameLine",",","SameLine",")","->","spaces","(","eqIndent","-","2",")","(","SameLine",",","Indent","y",")","->","spaces","(","eqIndent","+","y","-","4",")","(","Indent","x",",","Indent","_",")","->","spaces","x","(","Indent","x",",","SameLine",")","->","spaces","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L213-L219","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union","parameters":"Nil t","argument_list":"","return_statement":"","docstring":"right bias","docstring_summary":"right bias","docstring_tokens":["right","bias"],"function":"union Nil t       = t","function_tokens":["union","Nil","t","=","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L378-L378","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_EXTENSIONS","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_EXTENSIONS                      = 0x1006","function_tokens":["alc_EXTENSIONS","=","0x1006"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L152-L152","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"(FIND_NODE id)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandArgs (FIND_NODE id)       = toBS id","function_tokens":["commandArgs","(","FIND_NODE","id",")","=","toBS","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L39-L39","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"wild","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wild = if total then [] else [match wildP (normalB [| Left $(nm) |]) []]","function_tokens":["wild","=","if","total","then","[","]","else","[","match","wildP","(","normalB","[","|"," Left $(nm) ","|]",")","[","]","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L498-L498","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"withTween","parameters":"ease from to dur f","argument_list":"","return_statement":"","docstring":"A version of 'tween' that maps its output using the given constant function.  @ withTween ease from to dur f = mapOutput (pure f) $ tween ease from to dur @","docstring_summary":"A version of 'tween' that maps its output using the given constant function.","docstring_tokens":["A","version","of","tween","that","maps","its","output","using","the","given","constant","function","."],"function":"withTween ease from to dur f =\n  TweenT\n    $ mapOutput (pure f)\n    $ unTweenT\n    $ tween ease from to dur","function_tokens":["withTween","ease","from","to","dur","f","=","TweenT","$","mapOutput","(","pure","f",")","$","unTweenT","$","tween","ease","from","to","dur"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L331-L335","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/Setup.hs#L2-L2","hash_key":"isovector\/do-notation:Setup.hs","hash_val":13423,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"false","parameters":"","argument_list":"","return_statement":"","docstring":"Logical contradiction","docstring_summary":"Logical contradiction","docstring_tokens":["Logical","contradiction"],"function":"false = inject $ Or []","function_tokens":["false","=","inject","$","Or","[","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L504-L504","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getEntryDesc","parameters":"s","argument_list":"","return_statement":"","docstring":"Get 'EntryDescription' for a specified entry. This is a simple shortcut defined as:  > getEntryDesc s = M.lookup s <$> getEntries","docstring_summary":"Get 'EntryDescription' for a specified entry. This is a simple shortcut defined as:  > getEntryDesc s = M.lookup s <$> getEntries","docstring_tokens":["Get","EntryDescription","for","a","specified","entry",".","This","is","a","simple","shortcut","defined","as",":",">","getEntryDesc","s","=","M",".","lookup","s","<$",">","getEntries"],"function":"getEntryDesc s = M.lookup s <$> getEntries","function_tokens":["getEntryDesc","s","=","M","lookup","s","<$>","getEntries"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L325-L325","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"finish","parameters":"_  t  Nada","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"finish _  t  Nada = t","function_tokens":["finish","_","t","Nada","=","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L756-L756","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"diag","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_summary":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_tokens":["O","(","m","*","n",")","Create","a","square","matrix","with","given","diagonal","other","entries","default","to","0"],"function":"diag = MG.diag","function_tokens":["diag","=","MG","diag"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L203-L203","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"var'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var' = parser (Proxy :: Proxy VarF) var'","function_tokens":["var'","=","parser","(","Proxy","::","Proxy","VarF",")","var'"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L567-L567","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(w, a) = hdl (m <$ ctx)","function_tokens":["(","w",",","a",")","=","hdl","(","m","<$","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L183-L183","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"unmarshalContext","parameters":"context","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalContext context =\n   if context == marshalContext nullContext then Nothing else Just (Context context)","function_tokens":["unmarshalContext","context","=","if","context","==","marshalContext","nullContext","then","Nothing","else","Just","(","Context","context",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L171-L172","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"wild","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wild = if total then [] else [match wildP (normalB [| Left $(nm) |]) []]","function_tokens":["wild","=","if","total","then","[","]","else","[","match","wildP","(","normalB","[","|"," Left $(nm) ","|]",")","[","]","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L526-L526","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"SymbolLine","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go SymbolLine               = (False, False, True, False)","function_tokens":["go","SymbolLine","=","(","False",",","False",",","True",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L388-L388","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(newTree, pingAgain) = T.handleTimeout tree id","function_tokens":["(","newTree",",","pingAgain",")","=","T","handleTimeout","tree","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L72-L72","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"tyO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tyO       = return fieldtype","function_tokens":["tyO","=","return","fieldtype"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L563-L563","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"deleteExtraField","parameters":"n s","argument_list":"","return_statement":"","docstring":"Delete an extra field by its type (tag). The specified entry may be missing, in that case this action has no effect.","docstring_summary":"Delete an extra field by its type (tag). The specified entry may be missing, in that case this action has no effect.","docstring_tokens":["Delete","an","extra","field","by","its","type","(","tag",")",".","The","specified","entry","may","be","missing","in","that","case","this","action","has","no","effect","."],"function":"deleteExtraField n s = addPending (I.DeleteExtraField n s)","function_tokens":["deleteExtraField","n","s","=","addPending","(","I","DeleteExtraField","n","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L590-L590","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    Ask       -> (<$ ctx)\n    Local f m -> hdl (m <$ ctx) . f","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","Ask","->","(","<$","ctx",")","Local","f","m","->","hdl","(","m","<$","ctx",")",".","f"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L168-L171","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"context","parameters":"(DynamicallySorted s v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"context (DynamicallySorted s v) = case match v of\n            Just (Var n _) -> (n, DynamicSort s)\n            _              -> error \"impossible error\"","function_tokens":["context","(","DynamicallySorted","s","v",")","=","case","match","v","of","Just","(","Var","n","_",")","->","(","n",",","DynamicSort","s",")","_","->","error","\"impossible error\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L608-L612","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Or  as `ieq1` Or  bs = foldr (&&) True $ zipWith ieq as bs","function_tokens":["Or","as","`","ieq1","`","Or","bs","=","foldr","(","&&",")","True","$","zipWith","ieq","as","bs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L346-L346","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DTip n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DTip n) = s `hashWithSalt` (1 :: Int) `hashWithSalt` n","function_tokens":["hashWithSalt","s","(","DTip","n",")","=","s","`","hashWithSalt","`","(","1","::","Int",")","`","hashWithSalt","`","n"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L216-L216","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(TuneHeader info)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (TuneHeader info) =\n        sepBy \"\\n\" (fmap pretty info)","function_tokens":["pretty","(","TuneHeader","info",")","=","sepBy","\"\\n\"","(","fmap","pretty","info",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L153-L154","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(ReferenceNumber _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (ReferenceNumber _)      = \"X\"","function_tokens":["go","(","ReferenceNumber","_",")","=","\"X\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L359-L359","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"totalPerimeter","parameters":"lines","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"totalPerimeter lines = sum $ fmap perimeterPolygon lines","function_tokens":["totalPerimeter","lines","=","sum","$","fmap","perimeterPolygon","lines"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L57-L57","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"doDeletions","parameters":"m CayleyConfig{..} qs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doDeletions m CayleyConfig{..} qs =\n      apiRequest\n        m (urlBase serverName apiVersion ++ \"\/delete\")\n        serverPort (toRequestBody qs)","function_tokens":["doDeletions","m","CayleyConfig","{","..","}","qs","=","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/delete\"",")","serverPort","(","toRequestBody","qs",")"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L158-L161","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = startLookup sendS cancel checkSignal","function_tokens":["go","=","startLookup","sendS","cancel","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L37-L37","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"vars1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vars1     = varE <$> fresh","function_tokens":["vars1","=","varE","<$>","fresh"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L548-L548","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"f","parameters":"x c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f x c\n            | x == c = x\n            | otherwise = Mixed","function_tokens":["f","x","c","|","x","==","c","=","x","|","otherwise","=","Mixed"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L108-L110","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!hdt = hash dt","function_tokens":["hdt","=","hash","dt"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L85-L85","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfc_xlt1_cs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfc_xlt1_cs =\n    [   1.06073416421769980345174155056 \/ 2\n    , -0.42582445804381043569204735291\n    ,  0.04955262679620434040357683080\n    ,  0.00449293488768382749558001242\n    , -0.00129194104658496953494224761\n    , -0.00001836389292149396270416979\n    ,  0.00002211114704099526291538556\n    , -5.23337485234257134673693179020e-7\n    , -2.78184788833537885382530989578e-7\n    ,  1.41158092748813114560316684249e-8\n    ,  2.72571296330561699984539141865e-9\n    , -2.06343904872070629406401492476e-10\n    , -2.14273991996785367924201401812e-11\n    ,  2.22990255539358204580285098119e-12\n    ,  1.36250074650698280575807934155e-13\n    , -1.95144010922293091898995913038e-14\n    , -6.85627169231704599442806370690e-16\n    ,  1.44506492869699938239521607493e-16\n    ,  2.45935306460536488037576200030e-18\n    , -9.29599561220523396007359328540e-19\n    ]","function_tokens":["erfc_xlt1_cs","=","[","1.06073416421769980345174155056","\/","2",",","-","0.42582445804381043569204735291",",","0.04955262679620434040357683080",",","0.00449293488768382749558001242",",","-","0.00129194104658496953494224761",",","-","0.00001836389292149396270416979",",","0.00002211114704099526291538556",",","-","5.23337485234257134673693179020e-7",",","-","2.78184788833537885382530989578e-7",",","1.41158092748813114560316684249e-8",",","2.72571296330561699984539141865e-9",",","-","2.06343904872070629406401492476e-10",",","-","2.14273991996785367924201401812e-11",",","2.22990255539358204580285098119e-12",",","1.36250074650698280575807934155e-13",",","-","1.95144010922293091898995913038e-14",",","-","6.85627169231704599442806370690e-16",",","1.44506492869699938239521607493e-16",",","2.45935306460536488037576200030e-18",",","-","9.29599561220523396007359328540e-19","]"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L97-L118","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"undoAll","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"undoAll = modifyActions (const S.empty)","function_tokens":["undoAll","=","modifyActions","(","const","S","empty",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L636-L636","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"AndrasKovacs\/singleton-nats","sha":"ec2cd4d2284111047cf1a26ba070f593faf9c96a","path":"Data\/Nat.hs","language":"haskell","identifier":"","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(==) _ _ = True","function_tokens":["(","==",")","_","_","=","True"],"url":"https:\/\/github.com\/AndrasKovacs\/singleton-nats\/blob\/ec2cd4d2284111047cf1a26ba070f593faf9c96a\/Data\/Nat.hs#L95-L95","hash_key":"AndrasKovacs\/singleton-nats:Data\/Nat.hs","hash_val":3829,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Throw.hs","language":"haskell","identifier":"throwError","parameters":"","argument_list":"","return_statement":"","docstring":"Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).  @ runThrow (throwError e >>= k) = runThrow (throwError e) @  @since 0.1.0.0","docstring_summary":"Throw an error, escaping the current computation up to the nearest 'Control.Effect.Catch.catchError' (if any).","docstring_tokens":["Throw","an","error","escaping","the","current","computation","up","to","the","nearest","Control",".","Effect",".","Catch",".","catchError","(","if","any",")","."],"function":"throwError = send . Throw","function_tokens":["throwError","=","send",".","Throw"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Throw.hs#L32-L32","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Throw.hs","hash_val":34342,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs","language":"haskell","identifier":"zTypes","parameters":"","argument_list":"","return_statement":"","docstring":"Types with Z values","docstring_summary":"Types with Z values","docstring_tokens":["Types","with","Z","values"],"function":"zTypes = [ShpPointZ, ShpPolyLineZ, ShpPolygonZ, ShpMultiPointZ]","function_tokens":["zTypes","=","[","ShpPointZ",",","ShpPolyLineZ",",","ShpPolygonZ",",","ShpMultiPointZ","]"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs#L51-L51","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs","hash_val":20255,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getSignature","parameters":"sig","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getSignature sig = do\n  x <- getWord32le -- grab 4-byte signature\n  unless (x == sig) . fail $\n    \"Expected signature \" ++ show sig ++ \", but got: \" ++ show x\n\n-- | Parse 'Zip64ExtraField' from its binary representation.","function_tokens":["getSignature","sig","=","do","x","<-","getWord32le","-- grab 4-byte signature","unless","(","x","==","sig",")",".","fail","$","\"Expected signature \"","++","show","sig","++","\", but got: \"","++","show","x","-- | Parse 'Zip64ExtraField' from its binary representation."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L749-L755","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putUTC","parameters":"x","argument_list":"","return_statement":"","docstring":"store milliseconds since Unix epoch","docstring_summary":"store milliseconds since Unix epoch","docstring_tokens":["store","milliseconds","since","Unix","epoch"],"function":"putUTC x = putInt64 $ round (utcTimeToPOSIXSeconds x * 1000)","function_tokens":["putUTC","x","=","putInt64","$","round","(","utcTimeToPOSIXSeconds","x","*","1000",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L229-L229","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DidFormat <> _ = DidFormat","function_tokens":["DidFormat","<>","_","=","DidFormat"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L137-L137","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"groupByLine","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"groupByLine f = go [] Nothing\n  where\n    go acc _ [] = ne acc\n    go acc mbCurrentLine (x:xs) =\n      let\n        lStart = GHC.srcSpanStartLine (f x)\n        lEnd = GHC.srcSpanEndLine (f x) in\n      case mbCurrentLine of\n        Just lPrevEnd | lPrevEnd + 1 < lStart\n          -> ne acc ++ go [x] (Just lEnd) xs\n        _ -> go (acc ++ [x]) (Just lEnd) xs\n\n    ne []       = []\n    ne (x : xs) = [x :| xs]\n\n-- | Merge two import declarations, keeping positions from the first\n--\n--   As alluded, this highlights an issue with merging imports. The GHC\n--   annotation comments aren't attached to any particular AST node. This\n--   means that right now, we're manually reconstructing the attachment. By\n--   merging two import declarations, we lose that mapping.\n--\n--   It's not really a big deal if we consider that people don't usually\n--   comment imports themselves. It _is_ however, systemic and it'd be better\n--   if we processed comments beforehand and attached them to all AST nodes in\n--   our own representation.","function_tokens":["groupByLine","f","=","go","[","]","Nothing","where","go","acc","_","[","]","=","ne","acc","go","acc","mbCurrentLine","(","x",":","xs",")","=","let","lStart","=","GHC","srcSpanStartLine","(","f","x",")","lEnd","=","GHC","srcSpanEndLine","(","f","x",")","in","case","mbCurrentLine","of","Just","lPrevEnd","|","lPrevEnd","+","1","<","lStart","->","ne","acc","++","go","[","x","]","(","Just","lEnd",")","xs","_","->","go","(","acc","++","[","x","]",")","(","Just","lEnd",")","xs","ne","[","]","=","[","]","ne","(","x",":","xs",")","=","[","x",":|","xs","]","-- | Merge two import declarations, keeping positions from the first","--","--   As alluded, this highlights an issue with merging imports. The GHC","--   annotation comments aren't attached to any particular AST node. This","--   means that right now, we're manually reconstructing the attachment. By","--   merging two import declarations, we lose that mapping.","--","--   It's not really a big deal if we consider that people don't usually","--   comment imports themselves. It _is_ however, systemic and it'd be better","--   if we processed comments beforehand and attached them to all AST nodes in","--   our own representation."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L90-L116","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = AccumC $ \\k w -> case sig of\n    L accum -> case accum of\n      Add w' -> k w' ctx\n      Look   -> k mempty $ w <$ ctx\n    R other  -> thread (uncurry (runAccum (curry pure)) ~<~ hdl) other (w, ctx) >>= uncurry k","function_tokens":["alg","hdl","sig","ctx","=","AccumC","$","\\","k","w","->","case","sig","of","L","accum","->","case","accum","of","Add","w'","->","k","w'","ctx","Look","->","k","mempty","$","w","<$","ctx","R","other","->","thread","(","uncurry","(","runAccum","(","curry","pure",")",")","~<~","hdl",")","other","(","w",",","ctx",")",">>=","uncurry","k"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L128-L133","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"imap","parameters":"f (And as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (And as) = And $ map f as","function_tokens":["imap","f","(","And","as",")","=","And","$","map","f","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L352-L352","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"zero","parameters":"i m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zero i m\n  = (natFromInt i) .&. (natFromInt m) == 0","function_tokens":["zero","i","m","=","(","natFromInt","i",")",".&.","(","natFromInt","m",")","==","0"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L903-L904","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"arr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"arr = var","function_tokens":["arr","=","var"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L153-L153","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"validate","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"validate s\n            | fmap toLower s == \"language\" = pure s\n            | otherwise = fail \"please provide a valid language prefix\"","function_tokens":["validate","s","|","fmap","toLower","s","==","\"language\"","=","pure","s","|","otherwise","=","fail","\"please provide a valid language prefix\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L352-L354","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"fieldAllowedInFileHeader","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldAllowedInFileHeader a = r where (r,_,_,_) = fieldAllowed a","function_tokens":["fieldAllowedInFileHeader","a","=","r","where","(","r",",","_",",","_",",","_",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L397-L398","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"Off On","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) Off On = On","function_tokens":["(","<>",")","Off","On","=","On"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L49-L49","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"fromList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromList = MG.fromList","function_tokens":["fromList","=","MG","fromList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L148-L148","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten''","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten'' e = case match e of\n        Just (Or os) -> os\n        _ -> [e]","function_tokens":["flatten''","e","=","case","match","e","of","Just","(","Or","os",")","->","os","_","->","[","e","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L471-L475","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"firstMatchingPrefix","parameters":"prefixes","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"firstMatchingPrefix prefixes =\n              fmap decode . asum . traverse unprefix prefixes","function_tokens":["firstMatchingPrefix","prefixes","=","fmap","decode",".","asum",".","traverse","unprefix","prefixes"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L225-L226","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"fromEventList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromEventList = foldr (mappend . phi) mempty\n    where phi e = TFun (tfmFromEvent e) (Single $ eventContent e)\n\n-- transformation\n-- it's a pair of (stretch factor, delay offset)","function_tokens":["fromEventList","=","foldr","(","mappend",".","phi",")","mempty","where","phi","e","=","TFun","(","tfmFromEvent","e",")","(","Single","$","eventContent","e",")","-- transformation","-- it's a pair of (stretch factor, delay offset)"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L346-L351","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"runCull","parameters":"fork leaf nil (CullC m)","argument_list":"","return_statement":"","docstring":"Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.  @ runCull fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil @ @ runCull fork leaf nil ('cull' ('pure' a '<|>' b)) = leaf a @  @since 1.0.0.0","docstring_summary":"Run a 'Cull' effect with continuations respectively interpreting '<|>', 'pure', and 'empty'. Branches outside of any 'cull' block will not be pruned.","docstring_tokens":["Run","a","Cull","effect","with","continuations","respectively","interpreting","<|",">","pure","and","empty",".","Branches","outside","of","any","cull","block","will","not","be","pruned","."],"function":"runCull fork leaf nil (CullC m) = runNonDet fork leaf nil (runReader False m)","function_tokens":["runCull","fork","leaf","nil","(","CullC","m",")","=","runNonDet","fork","leaf","nil","(","runReader","False","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L46-L46","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"reflect","parameters":"a","argument_list":"","return_statement":"","docstring":"Reversing the tracks","docstring_summary":"Reversing the tracks","docstring_tokens":["Reversing","the","tracks"],"function":"reflect a = mapEvents\n    (\\e -> e{ eventStart = d - (eventStart e + eventDur e) }) a\n    where d = dur a\n\n-- | Empty track that lasts for some time.","function_tokens":["reflect","a","=","mapEvents","(","\\","e","->","e","{","eventStart","=","d","-","(","eventStart","e","+","eventDur","e",")","}",")","a","where","d","=","dur","a","-- | Empty track that lasts for some time."],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L148-L153","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"fromRows","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from rows","docstring_summary":"O(m*n) Create matrix from rows","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","rows"],"function":"fromRows = MG.fromRows","function_tokens":["fromRows","=","MG","fromRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L157-L157","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"itraverse","parameters":"_ (Const c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse _ (Const c) = pure (Const c)","function_tokens":["itraverse","_","(","Const","c",")","=","pure","(","Const","c",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L89-L89","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"loadConfig","parameters":"verbose userSpecified","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loadConfig verbose userSpecified = do\n    mbFp <- configFilePath verbose userSpecified\n    verbose $ \"Loading configuration at \" ++ fromMaybe \"<embedded>\" mbFp\n    bytes <- maybe (return defaultConfigBytes) B.readFile mbFp\n    case decode1Strict bytes of\n        Left (pos, err)     -> error $ prettyPosWithSource pos (fromStrict bytes) (\"Language.Haskell.Stylish.Config.loadConfig: \" ++ err)\n        Right config -> do\n          cabalLanguageExtensions <- if configCabal config\n            then map show <$> Cabal.findLanguageExtensions verbose\n            else pure []\n\n          return $ config\n            { configLanguageExtensions = nub $\n                configLanguageExtensions config ++ cabalLanguageExtensions\n            }\n\n\n--------------------------------------------------------------------------------","function_tokens":["loadConfig","verbose","userSpecified","=","do","mbFp","<-","configFilePath","verbose","userSpecified","verbose","$","\"Loading configuration at \"","++","fromMaybe","\"<embedded>\"","mbFp","bytes","<-","maybe","(","return","defaultConfigBytes",")","B","readFile","mbFp","case","decode1Strict","bytes","of","Left","(","pos",",","err",")","->","error","$","prettyPosWithSource","pos","(","fromStrict","bytes",")","(","\"Language.Haskell.Stylish.Config.loadConfig: \"","++","err",")","Right","config","->","do","cabalLanguageExtensions","<-","if","configCabal","config","then","map","show","<$>","Cabal","findLanguageExtensions","verbose","else","pure","[","]","return","$","config","{","configLanguageExtensions","=","nub","$","configLanguageExtensions","config","++","cabalLanguageExtensions","}","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L118-L136","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"lift","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift m = RSST $ \\_ s -> do\n        a <- m\n        return (a, s)","function_tokens":["lift","m","=","RSST","$","\\","_","s","->","do","a","<-","m","return","(","a",",","s",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L161-L164","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"baseTmp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"baseTmp = cdup <\/> baseTmpRaw","function_tokens":["baseTmp","=","cdup","<\/>","baseTmpRaw"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L158-L158","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"fromByteStruct","parameters":"bs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromByteStruct bs = case fromBS s of\n                    (Right (converted, _)) -> converted\n                    (Left err) -> error $ \"Failed to convert from ByteStruct: \" ++ err\n    where s = B.pack . foldr (\\i ws -> createWord i : ws) [] $ indexes\n          indexes = [0..(length bs `div` 8) -1]\n          createWord i = let pos = i * 8\n                         in foldr changeBit zeroBits [pos..pos+7]\n\n          changeBit i w = if bs !! i\n                then setBit w (i `mod` 8)\n                else w\n\n-- Calculate the distance between two Ids, as specified in the Kademlia paper","function_tokens":["fromByteStruct","bs","=","case","fromBS","s","of","(","Right","(","converted",",","_",")",")","->","converted","(","Left","err",")","->","error","$","\"Failed to convert from ByteStruct: \"","++","err","where","s","=","B","pack",".","foldr","(","\\","i","ws","->","createWord","i",":","ws",")","[","]","$","indexes","indexes","=","[","0","..","(","length","bs","`","div","`","8",")","-","1","]","createWord","i","=","let","pos","=","i","*","8","in","foldr","changeBit","zeroBits","[","pos","..","pos","+","7","]","changeBit","i","w","=","if","bs","!!","i","then","setBit","w","(","i","`","mod","`","8",")","else","w","-- Calculate the distance between two Ids, as specified in the Kademlia paper"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L64-L77","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"getBufferi","parameters":"buffer query","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getBufferi buffer query =\n   alloca $ \\buf -> do\n      alGetBufferi buffer (marshalBufferQuery query) buf\n      peek1 fromIntegral buf","function_tokens":["getBufferi","buffer","query","=","alloca","$","\\","buf","->","do","alGetBufferi","buffer","(","marshalBufferQuery","query",")","buf","peek1","fromIntegral","buf"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L169-L174","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"bsPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bsPtr         = F.castPtr (F.unsafeForeignPtrToPtr bsFptr)","function_tokens":["bsPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","bsFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L80-L80","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"as","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge as  = inject $ And as","function_tokens":["merge","as","=","inject","$","And","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L458-L458","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/Setup.hs#L2-L2","hash_key":"kaizhang\/matrices:Setup.hs","hash_val":5751,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"generate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"generate = MG.generate","function_tokens":["generate","=","MG","generate"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L369-L369","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeOutCirc","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease out circular.","docstring_summary":"Ease out circular.","docstring_tokens":["Ease","out","circular","."],"function":"easeOutCirc c t b = let t' = (realToFrac t - 1)\n                        s  = sqrt (1 - t'*t')\n                    in c * s + b","function_tokens":["easeOutCirc","c","t","b","=","let","t'","=","(","realToFrac","t","-","1",")","s","=","sqrt","(","1","-","t'","*","t'",")","in","c","*","s","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L150-L152","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"partLengths","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"partLengths = steps $ partIndices ++ [nPoints]","function_tokens":["partLengths","=","steps","$","partIndices","++","[","nPoints","]"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L224-L224","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"show","parameters":"(ParsingFailed file msg)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (ParsingFailed file msg) =\n    \"Parsing of archive structure failed: \\n\" ++ msg ++ \"\\nin \" ++ show file","function_tokens":["show","(","ParsingFailed","file","msg",")","=","\"Parsing of archive structure failed: \\n\"","++","msg","++","\"\\nin \"","++","show","file"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L235-L236","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"withRSS","parameters":"","argument_list":"","return_statement":"","docstring":"and state modified by applying @f@.  * @'runRSS' ('withRSS' f m) r s = 'uncurry' ('runRSS' m) (f r s)@","docstring_summary":"and state modified by applying","docstring_tokens":["and","state","modified","by","applying"],"function":"withRSS = withRSST","function_tokens":["withRSS","=","withRSST"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L78-L78","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"insert","parameters":"key@(Key k _) x (Vault m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"insert key@(Key k _) x (Vault m) = Vault $ Map.insert k (lock key x) m","function_tokens":["insert","key","@","(","Key","k","_",")","x","(","Vault","m",")","=","Vault","$","Map","insert","k","(","lock","key","x",")","m"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L35-L35","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"renderInstructions","parameters":"mode","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderInstructions mode = \\case\n  Stylized m t -> renderMod mode (t, m)\n  StylizedList xs -> concatMap (renderInstructions mode) xs\n  where\n    renderMod :: RenderMode -> (Text, Modifier) -> [RenderInstruction]\n    renderMod mode (t, m) =\n      case mode of\n        Plain ->\n          -- Only render text, no modifiers.\n          [RenderText t]\n        Simple ->\n          -- Terminal supports basic 16 colors.\n          let color l c = case c of\n                Color.ColorCode ai ac -> ANSI.SetColor l ai ac\n                rgb -> ANSI.SetColor l ANSI.Dull (Color.colorAsANSI rgb)\n           in renderToSGR t m color\n        Term256 ->\n          -- Terminal supports the 256-color palette.\n          let color l = ANSI.SetPaletteColor l . Color.colorAsIndex256\n           in renderToSGR t m color\n        TermRGB ->\n          -- Super terminal!\n          let color l c = case Color.colorAsRGB c of\n                Left (ai,ac) -> ANSI.SetColor l ai ac\n                Right rgb -> ANSI.SetRGBColor l rgb\n           in renderToSGR t m color\n    renderToSGR ::\n      Text ->\n      Modifier ->\n      (ANSI.ConsoleLayer -> Color -> ANSI.SGR) ->\n      [RenderInstruction]\n    renderToSGR t m f =\n      [ RenderSGR (modToSGR m f),\n        RenderText t,\n        RenderSGR [ANSI.Reset]\n      ]\n\n-- | Convert a modifier into a series of ANSI.SGR codes.\n--\n-- @since 1.0.0.0","function_tokens":["renderInstructions","mode","=","\\","case","Stylized","m","t","->","renderMod","mode","(","t",",","m",")","StylizedList","xs","->","concatMap","(","renderInstructions","mode",")","xs","where","renderMod","::","RenderMode","->","(","Text",",","Modifier",")","->","[","RenderInstruction","]","renderMod","mode","(","t",",","m",")","=","case","mode","of","Plain","->","-- Only render text, no modifiers.","[","RenderText","t","]","Simple","->","-- Terminal supports basic 16 colors.","let","color","l","c","=","case","c","of","Color","ColorCode","ai","ac","->","ANSI","SetColor","l","ai","ac","rgb","->","ANSI","SetColor","l","ANSI","Dull","(","Color","colorAsANSI","rgb",")","in","renderToSGR","t","m","color","Term256","->","-- Terminal supports the 256-color palette.","let","color","l","=","ANSI","SetPaletteColor","l",".","Color","colorAsIndex256","in","renderToSGR","t","m","color","TermRGB","->","-- Super terminal!","let","color","l","c","=","case","Color","colorAsRGB","c","of","Left","(","ai",",","ac",")","->","ANSI","SetColor","l","ai","ac","Right","rgb","->","ANSI","SetRGBColor","l","rgb","in","renderToSGR","t","m","color","renderToSGR","::","Text","->","Modifier","->","(","ANSI","ConsoleLayer","->","Color","->","ANSI","SGR",")","->","[","RenderInstruction","]","renderToSGR","t","m","f","=","[","RenderSGR","(","modToSGR","m","f",")",",","RenderText","t",",","RenderSGR","[","ANSI","Reset","]","]","-- | Convert a modifier into a series of ANSI.SGR codes.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L179-L219","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"new","parameters":"(r,c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"new (r,c) = MMatrix r c c 0 `liftM` GM.new (r*c)","function_tokens":["new","(","r",",","c",")","=","MMatrix","r","c","c","0","`","liftM","`","GM","new","(","r","*","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L42-L42","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"openBracket","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"openBracket =\n        [ (\"same_line\", ModuleHeader.SameLine)\n        , (\"next_line\", ModuleHeader.NextLine)\n        ]","function_tokens":["openBracket","=","[","(","\"same_line\"",",","ModuleHeader","SameLine",")",",","(","\"next_line\"",",","ModuleHeader","NextLine",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L217-L220","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"write","parameters":"old new","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"write old new = case mfp of\n                Nothing -> putStrNewline new\n                Just _    | not (saInPlace sa) -> putStrNewline new\n                Just path | not (null new) && old \/= new  ->\n                    IO.withFile path IO.WriteMode $ \\h -> do\n                        setNewlineMode h\n                        IO.hPutStr h new\n                _ -> return ()","function_tokens":["write","old","new","=","case","mfp","of","Nothing","->","putStrNewline","new","Just","_","|","not","(","saInPlace","sa",")","->","putStrNewline","new","Just","path","|","not","(","null","new",")","&&","old","\/=","new","->","IO","withFile","path","IO","WriteMode","$","\\","h","->","do","setNewlineMode","h","IO","hPutStr","h","new","_","->","return","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L161-L169","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"bpVm","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bpVm = DVSM.unsafeFromForeignPtr (F.castForeignPtr bpFptr) 0 size","function_tokens":["bpVm","=","DVSM","unsafeFromForeignPtr","(","F","castForeignPtr","bpFptr",")","0","size"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L143-L143","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"step","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"step = makeStep \"Squash\" $ \\ls (module') ->\n    let changes =\n            foldMap squashFieldDecl (everything module') <>\n            foldMap squashMatch (everything module') in\n    Editor.apply changes ls","function_tokens":["step","=","makeStep","\"Squash\"","$","\\","ls","(","module'",")","->","let","changes","=","foldMap","squashFieldDecl","(","everything","module'",")","<>","foldMap","squashMatch","(","everything","module'",")","in","Editor","apply","changes","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L85-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"biasCorrection","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"biasCorrection\n          = 1\n          - 1\/(4*fromIntegral (samples a))\n          - 7\/(32*fromIntegral (samples a)**2)\n          - 19\/(128*fromIntegral (samples a)**3)","function_tokens":["biasCorrection","=","1","-","1","\/","(","4","*","fromIntegral","(","samples","a",")",")","-","7","\/","(","32","*","fromIntegral","(","samples","a",")","**","2",")","-","19","\/","(","128","*","fromIntegral","(","samples","a",")","**","3",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L184-L188","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/State.hs","language":"haskell","identifier":"benchmark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark = bgroup \"State\"\n  [ bgroup \"Identity\"\n    [ bench \"Church.StateC\" $ whnf (run . C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnf (run . C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnf (run . C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnf (run . flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnf (run . flip T.Strict.execStateT from . modLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.StateC\" $ whnfAppIO (C.Church.execState from . modLoop) n\n    , bench \"Lazy.StateC\"   $ whnfAppIO (C.Lazy.execState from . modLoop) n\n    , bench \"Strict.StateC\" $ whnfAppIO (C.Strict.execState from . modLoop) n\n    , bench \"Lazy.StateT\"   $ whnfAppIO (flip T.Lazy.execStateT from . modLoop) n\n    , bench \"Strict.StateT\" $ whnfAppIO (flip T.Strict.execStateT from . modLoop) n\n    ]\n  ]\n  where\n  from = 0 :: Int\n  n = 100000","function_tokens":["benchmark","=","bgroup","\"State\"","[","bgroup","\"Identity\"","[","bench","\"Church.StateC\"","$","whnf","(","run",".","C","Church","execState","from",".","modLoop",")","n",",","bench","\"Lazy.StateC\"","$","whnf","(","run",".","C","Lazy","execState","from",".","modLoop",")","n",",","bench","\"Strict.StateC\"","$","whnf","(","run",".","C","Strict","execState","from",".","modLoop",")","n",",","bench","\"Lazy.StateT\"","$","whnf","(","run",".","flip","T","Lazy","execStateT","from",".","modLoop",")","n",",","bench","\"Strict.StateT\"","$","whnf","(","run",".","flip","T","Strict","execStateT","from",".","modLoop",")","n","]",",","bgroup","\"IO\"","[","bench","\"Church.StateC\"","$","whnfAppIO","(","C","Church","execState","from",".","modLoop",")","n",",","bench","\"Lazy.StateC\"","$","whnfAppIO","(","C","Lazy","execState","from",".","modLoop",")","n",",","bench","\"Strict.StateC\"","$","whnfAppIO","(","C","Strict","execState","from",".","modLoop",")","n",",","bench","\"Lazy.StateT\"","$","whnfAppIO","(","flip","T","Lazy","execStateT","from",".","modLoop",")","n",",","bench","\"Strict.StateT\"","$","whnfAppIO","(","flip","T","Strict","execStateT","from",".","modLoop",")","n","]","]","where","from","=","0","::","Int","n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/State.hs#L14-L34","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/State.hs","hash_val":42170,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"sigmaLength","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sigmaLength = round (len * sd) - errorLength","function_tokens":["sigmaLength","=","round","(","len","*","sd",")","-","errorLength"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L416-L416","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"known'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"known' = xs' `S.union` known","function_tokens":["known'","=","xs'","`","S","union","`","known"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L113-L113","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Exit.hs","language":"haskell","identifier":"msg","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"msg =\n        mconcat\n          [ text name,\n            text \": \",\n            toStylizedText a,\n            text \"\\n\"\n          ]","function_tokens":["msg","=","mconcat","[","text","name",",","text","\": \"",",","toStylizedText","a",",","text","\"\\n\"","]"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Exit.hs#L56-L62","hash_key":"pjones\/byline:src\/Byline\/Exit.hs","hash_val":6289,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"askPassword","parameters":"prompt","argument_list":"","return_statement":"","docstring":"Read a password without echoing it to the terminal.  If a masking character is given it will replace each typed character.  @since 1.0.0.0","docstring_summary":"Read a password without echoing it to the terminal.  If a masking character is given it will replace each typed character.","docstring_tokens":["Read","a","password","without","echoing","it","to","the","terminal",".","If","a","masking","character","is","given","it","will","replace","each","typed","character","."],"function":"askPassword prompt =\n  Prim.askPassword (toStylizedText prompt)\n    >>> liftByline","function_tokens":["askPassword","prompt","=","Prim","askPassword","(","toStylizedText","prompt",")",">>>","liftByline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L133-L135","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"pick","parameters":"(Program (MapMaker outfile False projection) infile)","argument_list":"","return_statement":"","docstring":"Execute the program with parsed command-line input","docstring_summary":"Execute the program with parsed command-line input","docstring_tokens":["Execute","the","program","with","parsed","command","-","line","input"],"function":"pick (Program (MapMaker outfile False projection) infile) = let p = pickProjection projection in\n    mkMap outfile =<< districtToMapP p <$> getDistricts infile","function_tokens":["pick","(","Program","(","MapMaker","outfile","False","projection",")","infile",")","=","let","p","=","pickProjection","projection","in","mkMap","outfile","=<<","districtToMapP","p","<$>","getDistricts","infile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L34-L35","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = not' <?> \"Negation\" where\n        not' = do\n            _ <- char '(' *> string \"not\" *> space\n            n <- r\n            _ <- char ')'\n            not'' n\n\n        not'' n = case toStaticallySorted n of\n            Just n' -> return . toDynamicallySorted . not $ n'\n            Nothing -> fail \"not of non-boolean arguments\"\n\n-- | `literals` decomposes a boolean combination (formed with conjunctions and disjunctions, preferably in negation normal form) into its constituents.","function_tokens":["parser","_","r","=","not'","<?>","\"Negation\"","where","not'","=","do","_","<-","char","'('","*>","string","\"not\"","*>","space","n","<-","r","_","<-","char","')'","not''","n","not''","n","=","case","toStaticallySorted","n","of","Just","n'","->","return",".","toDynamicallySorted",".","not","$","n'","Nothing","->","fail","\"not of non-boolean arguments\"","-- | `literals` decomposes a boolean combination (formed with conjunctions and disjunctions, preferably in negation normal form) into its constituents."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L423-L435","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"coef'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"coef'   = coef * negate (x*x\/k)","function_tokens":["coef'","=","coef","*","negate","(","x","*","x","\/","k",")"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L45-L45","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"cyclicInc","parameters":"col","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cyclicInc col\n            | col >= size - 1 = 0\n            | otherwise = col + 1","function_tokens":["cyclicInc","col","|","col",">=","size","-","1","=","0","|","otherwise","=","col","+","1"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L85-L87","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"node","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"node           = \"+--\"","function_tokens":["node","=","\"+--\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L824-L824","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"prefixCheck","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prefixCheck i = input `Text.isPrefixOf` asText i","function_tokens":["prefixCheck","i","=","input","`","Text","isPrefixOf","`","asText","i"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L110-L110","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs","language":"haskell","identifier":"sse_4_2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sse_4_2 = U.unsafePerformIO F.enabled_sse_4_2 \/= 0","function_tokens":["sse_4_2","=","U","unsafePerformIO","F","enabled_sse_4_2","\/=","0"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs#L11-L11","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs","hash_val":30181,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"embed","parameters":"","argument_list":"","return_statement":"","docstring":"Embed a subset in a superset.","docstring_summary":"Embed a subset in a superset.","docstring_tokens":["Embed","a","subset","in","a","superset","."],"function":"embed = icata (IFix . emb)","function_tokens":["embed","=","icata","(","IFix",".","emb",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L79-L79","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Book _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Book _)                 = (True, True, False, False)","function_tokens":["go","(","Book","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L367-L367","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fsTys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fsTys = map (typeVariables . trd) (delete f fs)","function_tokens":["fsTys","=","map","(","typeVariables",".","trd",")","(","delete","f","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L341-L341","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"regs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"regs = case cmd of\n                    (FIND_NODE id)  -> RR [R_RETURN_NODES id] (nodeId node)\n                    (FIND_VALUE id) ->\n                        RR [R_RETURN_NODES id, R_RETURN_VALUE id] (nodeId node)","function_tokens":["regs","=","case","cmd","of","(","FIND_NODE","id",")","->","RR","[","R_RETURN_NODES","id","]","(","nodeId","node",")","(","FIND_VALUE","id",")","->","RR","[","R_RETURN_NODES","id",",","R_RETURN_VALUE","id","]","(","nodeId","node",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L347-L350","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showsPrec","parameters":"p xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsPrec p xs = showParen (p > 10) $\n    showString \"fromList \" . shows (toList xs)","function_tokens":["showsPrec","p","xs","=","showParen","(","p",">","10",")","$","showString","\"fromList \"",".","shows","(","toList","xs",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L862-L863","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"fromMsDosTime","parameters":"MsDosTime {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromMsDosTime MsDosTime {..} =\n  UTCTime\n    (fromGregorian year month day)\n    (secondsToDiffTime $ hours * 3600 + minutes * 60 + seconds)\n  where\n    seconds = fromIntegral $ 2 * (msDosTime .&. 0x1f)\n    minutes = fromIntegral (shiftR msDosTime 5 .&. 0x3f)\n    hours = fromIntegral (shiftR msDosTime 11 .&. 0x1f)\n    day = fromIntegral (msDosDate .&. 0x1f)\n    month = fromIntegral $ shiftR msDosDate 5 .&. 0x0f\n    year = 1980 + fromIntegral (shiftR msDosDate 9)\n\n-- We use the constants of the type 'Natural' instead of literals to protect\n-- ourselves from overflows on 32 bit systems.\n--\n-- If we're in the development mode, use lower values so the tests get a\n-- chance to check all cases (otherwise we would need to generate way too\n-- big archives on CI).","function_tokens":["fromMsDosTime","MsDosTime","{","..","}","=","UTCTime","(","fromGregorian","year","month","day",")","(","secondsToDiffTime","$","hours","*","3600","+","minutes","*","60","+","seconds",")","where","seconds","=","fromIntegral","$","2","*","(","msDosTime",".&.","0x1f",")","minutes","=","fromIntegral","(","shiftR","msDosTime","5",".&.","0x3f",")","hours","=","fromIntegral","(","shiftR","msDosTime","11",".&.","0x1f",")","day","=","fromIntegral","(","msDosDate",".&.","0x1f",")","month","=","fromIntegral","$","shiftR","msDosDate","5",".&.","0x0f","year","=","1980","+","fromIntegral","(","shiftR","msDosDate","9",")","-- We use the constants of the type 'Natural' instead of literals to protect","-- ourselves from overflows on 32 bit systems.","--","-- If we're in the development mode, use lower values so the tests get a","-- chance to check all cases (otherwise we would need to generate way too","-- big archives on CI)."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1185-L1204","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"imapM_","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","ignoring","the","results","."],"function":"imapM_ = MG.imapM_","function_tokens":["imapM_","=","MG","imapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L248-L248","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Macro","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Macro                    = \"\"","function_tokens":["go","Macro","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L416-L416","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"mLocalTmp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mLocalTmp = maybePath localTmpRaw","function_tokens":["mLocalTmp","=","maybePath","localTmpRaw"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L156-L156","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtToMapP","parameters":"p","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"districtToMapP p = projectMap p . districtToMap","function_tokens":["districtToMapP","p","=","projectMap","p",".","districtToMap"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L41-L41","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"fieldAllowedInTuneHeader","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldAllowedInTuneHeader a = r where (_,r,_,_) = fieldAllowed a","function_tokens":["fieldAllowedInTuneHeader","a","=","r","where","(","_",",","r",",","_",",","_",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L398-L399","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"renderTList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderTList = ($[]) . foldMap (:) . eventList","function_tokens":["renderTList","=","(","$","[","]",")",".","foldMap","(",":",")",".","eventList"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L334-L334","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"steps","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"steps         [] = []","function_tokens":["steps","[","]","=","[","]"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L52-L52","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(DeleteExtraField _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (DeleteExtraField _ s) = Just s","function_tokens":["targetEntry","(","DeleteExtraField","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1062-L1062","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"harT","parameters":"xs","argument_list":"","return_statement":"","docstring":"Turncating parallel composition on list of tracks.","docstring_summary":"Turncating parallel composition on list of tracks.","docstring_tokens":["Turncating","parallel","composition","on","list","of","tracks","."],"function":"harT xs = slice 0 (minimum $ dur <$> xs) $ har xs","function_tokens":["harT","xs","=","slice","0","(","minimum","$","dur","<$>","xs",")","$","har","xs"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L129-L129","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"pad","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pad\n      | align = padRight longest\n      | otherwise = id","function_tokens":["pad","|","align","=","padRight","longest","|","otherwise","=","id"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L66-L68","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"show","parameters":"(NextItem i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (NextItem i) = \"NextItem \" ++ showOutputable i","function_tokens":["show","(","NextItem","i",")","=","\"NextItem \"","++","showOutputable","i"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L123-L123","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"quantify","parameters":"_ s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"quantify _ s = quantify (Proxy :: Proxy f) s <|> quantify (Proxy :: Proxy g) s","function_tokens":["quantify","_","s","=","quantify","(","Proxy","::","Proxy","f",")","s","<|>","quantify","(","Proxy","::","Proxy","g",")","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L892-L892","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"shorter","parameters":"m1 m2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shorter m1 m2\n  = (natFromInt m1) > (natFromInt m2)","function_tokens":["shorter","m1","m2","=","(","natFromInt","m1",")",">","(","natFromInt","m2",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L930-L931","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/PPDiff.hs","language":"haskell","identifier":"wrap","parameters":"DisableColor _ str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrap DisableColor _ str = str","function_tokens":["wrap","DisableColor","_","str","=","str"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/PPDiff.hs#L12-L12","hash_key":"Peaker\/git-mediate:src\/PPDiff.hs","hash_val":5685,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"a'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a' = flatten a","function_tokens":["a'","=","flatten","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L928-L928","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"forM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM_ = MG.forM_","function_tokens":["forM_","=","MG","forM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L254-L254","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseLink","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseLink _            = fail \"Link expected\"","function_tokens":["parseLink","_","=","fail","\"Link expected\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L120-L120","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!dt = describe bt","function_tokens":["dt","=","describe","bt"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L84-L84","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Utils.hs","language":"haskell","identifier":"getExt","parameters":"","argument_list":"","return_statement":"","docstring":"Get extension given a filepath","docstring_summary":"Get extension given a filepath","docstring_tokens":["Get","extension","given","a","filepath"],"function":"getExt = fmap toLower . reverse . (takeWhile (\/='.')) . reverse","function_tokens":["getExt","=","fmap","toLower",".","reverse",".","(","takeWhile","(","\/=","'.'",")",")",".","reverse"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Utils.hs#L12-L12","hash_key":"vmchale\/hgis:src\/GIS\/Utils.hs","hash_val":20401,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"go","parameters":"adir","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go adir = do\n      let cdir = path <\/> adir\n      raw <- listDirectory cdir\n      fmap mconcat . forM raw $ \\case\n        \"\" -> return mempty\n        \".\" -> return mempty\n        \"..\" -> return mempty\n        x -> do\n          let fullx = cdir <\/> x\n              adir' = adir <\/> x\n          isFile <- doesFileExist fullx\n          isDir <- doesDirectoryExist fullx\n          if isFile\n            then return (DList.singleton adir')\n            else\n              if isDir\n                then go adir'\n                else return mempty\n\n-- | Perform an action ignoring IO exceptions it may throw.","function_tokens":["go","adir","=","do","let","cdir","=","path","<\/>","adir","raw","<-","listDirectory","cdir","fmap","mconcat",".","forM","raw","$","\\","case","\"\"","->","return","mempty","\".\"","->","return","mempty","\"..\"","->","return","mempty","x","->","do","let","fullx","=","cdir","<\/>","x","adir'","=","adir","<\/>","x","isFile","<-","doesFileExist","fullx","isDir","<-","doesDirectoryExist","fullx","if","isFile","then","return","(","DList","singleton","adir'",")","else","if","isDir","then","go","adir'","else","return","mempty","-- | Perform an action ignoring IO exceptions it may throw."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L692-L712","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"show","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show = show . unEntrySelector","function_tokens":["show","=","show",".","unEntrySelector"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L81-L81","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"itraverse","parameters":"f (Equals s a b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Equals s a b) = Equals s <$> f a <*> f b","function_tokens":["itraverse","f","(","Equals","s","a","b",")","=","Equals","s","<$>","f","a","<*>","f","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L54-L54","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"imap","parameters":"f (IfThenElse s i t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (IfThenElse s i t e) = IfThenElse s (f i) (f t) (f e)","function_tokens":["imap","f","(","IfThenElse","s","i","t","e",")","=","IfThenElse","s","(","f","i",")","(","f","t",")","(","f","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L48-L48","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Utils.hs","language":"haskell","identifier":"sinc","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sinc x = sin x \/ x","function_tokens":["sinc","x","=","sin","x","\/","x"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Utils.hs#L8-L8","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Utils.hs","hash_val":44272,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"map","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"map = MG.map","function_tokens":["map","=","MG","map"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L229-L229","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putType'","parameters":"cfg lty","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putType' cfg lty = case GHC.unLoc lty of\n    GHC.HsForAllTy GHC.NoExtField tele tp -> do\n        putText \"forall\"\n        space\n        sep space $ case tele of\n            GHC.HsForAllVis   {..} -> putOutputable . GHC.unLoc <$> hsf_vis_bndrs\n            GHC.HsForAllInvis {..} -> putOutputable . GHC.unLoc <$> hsf_invis_bndrs\n        case tele of\n            GHC.HsForAllVis   {} -> space >> putText \"->\"\n            GHC.HsForAllInvis {} -> putText \".\"\n        space\n        putType' cfg tp\n    GHC.HsQualTy GHC.NoExtField ctx tp -> do\n        forM_ ctx $ putContext cfg\n        putType' cfg tp\n    _ -> putType lty","function_tokens":["putType'","cfg","lty","=","case","GHC","unLoc","lty","of","GHC","HsForAllTy","GHC","NoExtField","tele","tp","->","do","putText","\"forall\"","space","sep","space","$","case","tele","of","GHC","HsForAllVis","{","..","}","->","putOutputable",".","GHC","unLoc","<$>","hsf_vis_bndrs","GHC","HsForAllInvis","{","..","}","->","putOutputable",".","GHC","unLoc","<$>","hsf_invis_bndrs","case","tele","of","GHC","HsForAllVis","{","}","->","space",">>","putText","\"->\"","GHC","HsForAllInvis","{","}","->","putText","\".\"","space","putType'","cfg","tp","GHC","HsQualTy","GHC","NoExtField","ctx","tp","->","do","forM_","ctx","$","putContext","cfg","putType'","cfg","tp","_","->","putType","lty"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L504-L521","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zip4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip4 = MG.zip4","function_tokens":["zip4","=","MG","zip4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L320-L320","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Accum.hs","language":"haskell","identifier":"add","parameters":"w","argument_list":"","return_statement":"","docstring":"Write a value to the log.  @ 'runAccum' w0 ('add' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' 'runAccum' w0 m 'runAccum' w0 ('add' w '>>' m) = runAccum (w0 <> w) m @  @since 1.1.2.0","docstring_summary":"Write a value to the log.","docstring_tokens":["Write","a","value","to","the","log","."],"function":"add w = send (Add w)","function_tokens":["add","w","=","send","(","Add","w",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Accum.hs#L42-L42","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Accum.hs","hash_val":45199,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars'","parameters":"(Var n s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freevars' (Var n s) = coerce [dynvar n s :: DynamicallySorted Var]","function_tokens":["freevars'","(","Var","n","s",")","=","coerce","[","dynvar","n","s","::","DynamicallySorted","Var","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L618-L618","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"cat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cat     = varT (mkName \"cat\")","function_tokens":["cat","=","varT","(","mkName","\"cat\"",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L432-L432","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"putCD","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putCD m = forM_ (M.keys m) $ \\s ->\n  putHeader CentralDirHeader s (m ! s)","function_tokens":["putCD","m","=","forM_","(","M","keys","m",")","$","\\","s","->","putHeader","CentralDirHeader","s","(","m","!","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L799-L800","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"On Off","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) On Off = On","function_tokens":["(","<>",")","On","Off","=","On"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L51-L51","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"stylishHaskell","parameters":"sa","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"stylishHaskell sa = do\n    unless (saNoUtf8 sa) $\n        mapM_ (`IO.hSetEncoding` IO.utf8) [IO.stdin, IO.stdout]\n    if saVersion sa then\n        putStrLn stylishHaskellVersion\n\n        else if saDefaults sa then do\n            verbose' \"Dumping embedded config...\"\n            BC8.putStr defaultConfigBytes\n\n        else do\n            conf <- loadConfig verbose' (saConfig sa)\n            filesR <- case (saRecursive sa) of\n              True -> findHaskellFiles (saVerbose sa) (saFiles sa)\n              _    -> return $ saFiles sa\n            let steps = configSteps conf\n            forM_ steps $ \\s -> verbose' $ \"Enabled \" ++ stepName s ++ \" step\"\n            verbose' $ \"Extra language extensions: \" ++\n                show (configLanguageExtensions conf)\n            res <- foldMap (file sa conf) (files' filesR)\n\n            verbose' $ \"Exit code behavior: \" ++ show (configExitCode conf)\n            when (configExitCode conf == ErrorOnFormatExitBehavior && res == DidFormat) exitFailure\n  where\n    verbose' = makeVerbose (saVerbose sa)\n    files' x = case (saRecursive sa, null x) of\n      (True,True) -> []         -- No file to format and recursive enabled.\n      (_,True)    -> [Nothing]  -- Involving IO.stdin.\n      (_,False)   -> map Just x -- Process available files.","function_tokens":["stylishHaskell","sa","=","do","unless","(","saNoUtf8","sa",")","$","mapM_","(","`","IO","hSetEncoding","`","IO","utf8",")","[","IO","stdin",",","IO","stdout","]","if","saVersion","sa","then","putStrLn","stylishHaskellVersion","else","if","saDefaults","sa","then","do","verbose'","\"Dumping embedded config...\"","BC8","putStr","defaultConfigBytes","else","do","conf","<-","loadConfig","verbose'","(","saConfig","sa",")","filesR","<-","case","(","saRecursive","sa",")","of","True","->","findHaskellFiles","(","saVerbose","sa",")","(","saFiles","sa",")","_","->","return","$","saFiles","sa","let","steps","=","configSteps","conf","forM_","steps","$","\\","s","->","verbose'","$","\"Enabled \"","++","stepName","s","++","\" step\"","verbose'","$","\"Extra language extensions: \"","++","show","(","configLanguageExtensions","conf",")","res","<-","foldMap","(","file","sa","conf",")","(","files'","filesR",")","verbose'","$","\"Exit code behavior: \"","++","show","(","configExitCode","conf",")","when","(","configExitCode","conf","==","ErrorOnFormatExitBehavior","&&","res","==","DidFormat",")","exitFailure","where","verbose'","=","makeVerbose","(","saVerbose","sa",")","files'","x","=","case","(","saRecursive","sa",",","null","x",")","of","(","True",",","True",")","->","[","]","-- No file to format and recursive enabled.","(","_",",","True",")","->","[","Nothing","]","-- Involving IO.stdin.","(","_",",","False",")","->","map","Just","x","-- Process available files."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L100-L130","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"prettyPragmas","parameters":"lp _    longest align Vertical","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"prettyPragmas lp _    longest align Vertical        = verticalPragmas lp longest align","function_tokens":["prettyPragmas","lp","_","longest","align","Vertical","=","verticalPragmas","lp","longest","align"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L93-L93","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"fileExtensions","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fileExtensions = mapMaybe\n            (stripPrefix \"-X\" >=> GHCEx.readExtension)\n            fileOptions","function_tokens":["fileExtensions","=","mapMaybe","(","stripPrefix","\"-X\"",">=>","GHCEx","readExtension",")","fileOptions"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L74-L76","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \\\/ b = a .|. b","function_tokens":["a","\\\/","b","=","a",".|.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L211-L211","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"quoteScanner","parameters":"quote ScanState {..} input","argument_list":"","return_statement":"","docstring":"A scanning function that looks for a terminating quote.","docstring_summary":"A scanning function that looks for a terminating quote.","docstring_tokens":["A","scanning","function","that","looks","for","a","terminating","quote","."],"function":"quoteScanner quote ScanState {..} input\n  | scanEscape = Just (ScanState (input : scanResult) False)\n  | input == '\\\\' = Just (ScanState scanResult True)\n  | input == quote = Nothing\n  | otherwise = Just (ScanState (input : scanResult) False)","function_tokens":["quoteScanner","quote","ScanState","{","..","}","input","|","scanEscape","=","Just","(","ScanState","(","input",":","scanResult",")","False",")","|","input","==","'\\\\'","=","Just","(","ScanState","scanResult","True",")","|","input","==","quote","=","Nothing","|","otherwise","=","Just","(","ScanState","(","input",":","scanResult",")","False",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L217-L221","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"input","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"input = Text.strip t","function_tokens":["input","=","Text","strip","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L142-L142","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"compareMeans","parameters":"cfg a1 a2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compareMeans cfg a1 a2\n  | f a1 a2 = LT\n  | f a2 a1 = GT\n  | otherwise = EQ\n  where f x y = fromRational (mean x) + confidence cfg*standardError x < fromRational (mean y) - confidence cfg*standardError y","function_tokens":["compareMeans","cfg","a1","a2","|","f","a1","a2","=","LT","|","f","a2","a1","=","GT","|","otherwise","=","EQ","where","f","x","y","=","fromRational","(","mean","x",")","+","confidence","cfg","*","standardError","x","<","fromRational","(","mean","y",")","-","confidence","cfg","*","standardError","y"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L333-L339","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"traceOutputable","parameters":"title x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"traceOutputable title x =\n    trace (title ++ \": \" ++ (showOutputable x))","function_tokens":["traceOutputable","title","x","=","trace","(","title","++","\": \"","++","(","showOutputable","x",")",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L216-L217","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_LOOPING","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_LOOPING                          = 0x1007","function_tokens":["al_LOOPING","=","0x1007"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L79-L79","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect = symbolVal","function_tokens":["reflect","=","symbolVal"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L389-L389","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"validCP437","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"validCP437 x = ord x <= 127","function_tokens":["validCP437","x","=","ord","x","<=","127"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1087-L1087","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"find","parameters":"Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"find Nil                = error \"findMin Nil\"","function_tokens":["find","Nil","=","error","\"findMin Nil\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L646-L646","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"r","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r =\n                ( BSI.fromForeignPtr resIbFptr 0 resLen\n                , BSI.fromForeignPtr resAFptr  0 resLen\n                , BSI.fromForeignPtr resBFptr  0 resLen\n                )","function_tokens":["r","=","(","BSI","fromForeignPtr","resIbFptr","0","resLen",",","BSI","fromForeignPtr","resAFptr","0","resLen",",","BSI","fromForeignPtr","resBFptr","0","resLen",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L75-L79","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"","parameters":"(Lens (Point f _)) Id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(>-) (Lens (Point f _)) Id       = Point id (app . first (arr (f .)))","function_tokens":["(",">-",")","(","Lens","(","Point","f","_",")",")","Id","=","Point","id","(","app",".","first","(","arr","(","f",".",")",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L103-L103","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(-) = liftA2 (-)","function_tokens":["(","-",")","=","liftA2","(","-",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L232-L232","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"year","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"year = 1980 + fromIntegral (shiftR msDosDate 9)","function_tokens":["year","=","1980","+","fromIntegral","(","shiftR","msDosDate","9",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1195-L1195","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference","parameters":"t (Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"difference t (Tip _ x) = delete x t","function_tokens":["difference","t","(","Tip","_","x",")","=","delete","x","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L406-L406","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"weightOf","parameters":"Analysis{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"weightOf Analysis{..} = fromIntegral . max 1 . min samples . round . recip $ (fromRational mean :: Double) ** 0.7","function_tokens":["weightOf","Analysis","{","..","}","=","fromIntegral",".","max","1",".","min","samples",".","round",".","recip","$","(","fromRational","mean","::","Double",")","**","0.7"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L374-L374","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"pad","parameters":"n","argument_list":"","return_statement":"","docstring":"Indent to a given number of spaces.  If the current line already exceeds that number in length, nothing happens.","docstring_summary":"Indent to a given number of spaces.  If the current line already exceeds that number in length, nothing happens.","docstring_tokens":["Indent","to","a","given","number","of","spaces",".","If","the","current","line","already","exceeds","that","number","in","length","nothing","happens","."],"function":"pad n = do\n    len <- length <$> getCurrentLine\n    spaces $ n - len\n\n-- | Get current line","function_tokens":["pad","n","=","do","len","<-","length","<$>","getCurrentLine","spaces","$","n","-","len","-- | Get current line"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L313-L318","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pats1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pats1 = varP <$> fresh","function_tokens":["pats1","=","varP","<$>","fresh"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L516-L516","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"runBylineT","parameters":"","argument_list":"","return_statement":"","docstring":"Discharge the 'MonadByline' effect by running all operations and returning the result in the base monad.  The result is wrapped in a 'Maybe' where a 'Nothing' value indicates that an end-of-file (EOF) signal was received while reading user input.  @since 1.0.0.0","docstring_summary":"Discharge the 'MonadByline' effect by running all operations and returning the result in the base monad.  The result is wrapped in a 'Maybe' where a 'Nothing' value indicates that an end-of-file (EOF) signal was received while reading user input.","docstring_tokens":["Discharge","the","MonadByline","effect","by","running","all","operations","and","returning","the","result","in","the","base","monad",".","The","result","is","wrapped","in","a","Maybe","where","a","Nothing","value","indicates","that","an","end","-","of","-","file","(","EOF",")","signal","was","received","while","reading","user","input","."],"function":"runBylineT = runBylineT' defaultBylineSettings","function_tokens":["runBylineT","=","runBylineT'","defaultBylineSettings"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L104-L104","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"finish","parameters":"px tx (Push py ty stk)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"finish px tx (Push py ty stk) = finish p (join py ty px tx) stk\n        where m = branchMask px py\n              p = mask px m","function_tokens":["finish","px","tx","(","Push","py","ty","stk",")","=","finish","p","(","join","py","ty","px","tx",")","stk","where","m","=","branchMask","px","py","p","=","mask","px","m"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L757-L761","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"top","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"top = true","function_tokens":["top","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L220-L220","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"fs c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one fs c = let s = take (length fs) in (conP c (s pats), var)","function_tokens":["one","fs","c","=","let","s","=","take","(","length","fs",")","in","(","conP","c","(","s","pats",")",",","var",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L519-L519","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getPointList","parameters":"numPoints","argument_list":"","return_statement":"","docstring":"List of points of length `numPoints`","docstring_summary":"List of points of length `numPoints`","docstring_tokens":["List","of","points","of","length","numPoints"],"function":"getPointList numPoints = replicateM numPoints getPoint","function_tokens":["getPointList","numPoints","=","replicateM","numPoints","getPoint"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L58-L58","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"displayException","parameters":"(NamedParserException t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"displayException (NamedParserException t e) = \"While parsing \" ++ unpack t ++ \":\\n\" ++ displayException e","function_tokens":["displayException","(","NamedParserException","t","e",")","=","\"While parsing \"","++","unpack","t","++","\":\\n\"","++","displayException","e"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L200-L200","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"minT","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"minT = minimum $ eventStart <$> es","function_tokens":["minT","=","minimum","$","eventStart","<$>","es"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L270-L270","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"nameAnnAdornment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nameAnnAdornment = \\case\n    GHC.NameAnn {..}       -> fromAdornment nann_adornment\n    GHC.NameAnnCommas {..} -> fromAdornment nann_adornment\n    GHC.NameAnnOnly {..}   -> fromAdornment nann_adornment\n    GHC.NameAnnRArrow {}   -> (mempty, mempty)\n    GHC.NameAnnQuote {}    -> (\"'\", mempty)\n    GHC.NameAnnTrailing {} -> (mempty, mempty)\n  where\n    fromAdornment GHC.NameParens     = (\"(\", \")\")\n    fromAdornment GHC.NameBackquotes = (\"`\", \"`\")\n    fromAdornment GHC.NameParensHash = (\"#(\", \"#)\")\n    fromAdornment GHC.NameSquare     = (\"[\", \"]\")\n\n-- | Print module name","function_tokens":["nameAnnAdornment","=","\\","case","GHC","NameAnn","{","..","}","->","fromAdornment","nann_adornment","GHC","NameAnnCommas","{","..","}","->","fromAdornment","nann_adornment","GHC","NameAnnOnly","{","..","}","->","fromAdornment","nann_adornment","GHC","NameAnnRArrow","{","}","->","(","mempty",",","mempty",")","GHC","NameAnnQuote","{","}","->","(","\"'\"",",","mempty",")","GHC","NameAnnTrailing","{","}","->","(","mempty",",","mempty",")","where","fromAdornment","GHC","NameParens","=","(","\"(\"",",","\")\"",")","fromAdornment","GHC","NameBackquotes","=","(","\"`\"",",","\"`\"",")","fromAdornment","GHC","NameParensHash","=","(","\"#(\"",",","\"#)\"",")","fromAdornment","GHC","NameSquare","=","(","\"[\"",",","\"]\"",")","-- | Print module name"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L176-L190","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictVertex3ALfloat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictVertex3ALfloat = Dictionary {\n   alGetter  = alGetSourcefv,\n   alSetter  = alSourcefv,\n   size      = 3,\n   peekSize  = peek3 Vertex3,\n   marshal   = id }","function_tokens":["dictVertex3ALfloat","=","Dictionary","{","alGetter","=","alGetSourcefv",",","alSetter","=","alSourcefv",",","size","=","3",",","peekSize","=","peek3","Vertex3",",","marshal","=","id","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L555-L560","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result, rest) = C.span (\/=c) bs","function_tokens":["(","result",",","rest",")","=","C","span","(","\/=","c",")","bs"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L69-L69","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"rght","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rght = if total then id else appE [| Right |]","function_tokens":["rght","=","if","total","then","id","else","appE","[","|"," Right ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L527-L527","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"contentTypeH","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"contentTypeH =\n              fromMaybe \"application\/octet-stream\" $ lookup hContentType hdrs","function_tokens":["contentTypeH","=","fromMaybe","\"application\/octet-stream\"","$","lookup","hContentType","hdrs"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L293-L294","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"hdrs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hdrs = requestHeaders req","function_tokens":["hdrs","=","requestHeaders","req"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L292-L292","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printExports","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printExports = \\case\n        []     -> pure ()\n        [e]    -> putExport conf e\n        (e:es) -> putExport conf e >> comma >> space >> printExports es","function_tokens":["printExports","=","\\","case","[","]","->","pure","(",")","[","e","]","->","putExport","conf","e","(","e",":","es",")","->","putExport","conf","e",">>","comma",">>","space",">>","printExports","es"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L184-L189","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"commands","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commands =\n      fromList $\n        concat $\n          O.mapParser\n            (const nameAndFlags)\n            (O.infoParser $ shellInfo shell)\n      where\n        nameAndFlags opt =\n          case O.optMain opt of\n            O.CmdReader _ cmds p -> (`map` cmds) $ \\cmd ->\n              ( toText cmd,\n                maybe\n                  []\n                  ( O.infoParser\n                      >>> O.mapParser (const optnames)\n                      >>> concat\n                  )\n                  (p cmd)\n              )\n            _ -> mempty\n        optnames opt =\n          case O.optMain opt of\n            O.OptReader ns _ _ -> ns\n            O.FlagReader ns _ -> ns\n            _ -> mempty\n\n-- | Internal function to split user input into words similar to what\n-- a POSIX shell does.","function_tokens":["commands","=","fromList","$","concat","$","O","mapParser","(","const","nameAndFlags",")","(","O","infoParser","$","shellInfo","shell",")","where","nameAndFlags","opt","=","case","O","optMain","opt","of","O","CmdReader","_","cmds","p","->","(","`","map","`","cmds",")","$","\\","cmd","->","(","toText","cmd",",","maybe","[","]","(","O","infoParser",">>>","O","mapParser","(","const","optnames",")",">>>","concat",")","(","p","cmd",")",")","_","->","mempty","optnames","opt","=","case","O","optMain","opt","of","O","OptReader","ns","_","_","->","ns","O","FlagReader","ns","_","->","ns","_","->","mempty","-- | Internal function to split user input into words similar to what","-- a POSIX shell does."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L112-L140","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Book a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Book a)                 = a","function_tokens":["go","(","Book","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L406-L406","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"allSame","parameters":"(x:y:rest)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allSame (x:y:rest) = x == y && allSame (y:rest)","function_tokens":["allSame","(","x",":","y",":","rest",")","=","x","==","y","&&","allSame","(","y",":","rest",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L113-L113","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"matchEvent","parameters":"e name","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchEvent e name\n  | toStrict (encode e) == name' = Just e\n  | otherwise = Nothing\n  where name' = \"\\\"\" <> name <> \"\\\"\"","function_tokens":["matchEvent","e","name","|","toStrict","(","encode","e",")","==","name'","=","Just","e","|","otherwise","=","Nothing","where","name'","=","\"\\\"\"","<>","name","<>","\"\\\"\""],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L497-L500","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"DoubleFlat","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go DoubleFlat   = \"__\"","function_tokens":["go","DoubleFlat","=","\"__\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L458-L458","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"index","parameters":"(Var _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index (Var _ s)  = s","function_tokens":["index","(","Var","_","s",")","=","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L254-L254","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mf <*> ma = AccumC $ \\w -> do\n    (w' , f) <- runAccumC mf w\n    (w'', a) <- runAccumC ma $ mappend w w'\n    return (mappend w' w'', f a)","function_tokens":["mf","<*>","ma","=","AccumC","$","\\","w","->","do","(","w'",",","f",")","<-","runAccumC","mf","w","(","w''",",","a",")","<-","runAccumC","ma","$","mappend","w","w'","return","(","mappend","w'","w''",",","f","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L91-L95","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result,t') = minViewUnsigned l","function_tokens":["(","result",",","t'",")","=","minViewUnsigned","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L620-L620","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"findMin","parameters":"(Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findMin (Tip _ x) = x","function_tokens":["findMin","(","Tip","_","x",")","=","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L640-L640","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"imports","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"imports = Imports.step","function_tokens":["imports","=","Imports","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L61-L61","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printHeader","parameters":"conf mbName mbExps _ mbModuleComment mbWhereComment","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printHeader conf mbName mbExps _ mbModuleComment mbWhereComment = do\n    forM_ mbName $ \\name -> do\n        putText \"module\"\n        space\n        putText (showOutputable name)\n\n    case mbExps of\n        Nothing -> do\n            when (isJust mbName) $ case breakWhere conf of\n                Always -> do\n                    attachModuleComment\n                    newline\n                    spaces (indent conf)\n                _      -> space\n            putText \"where\"\n        Just exports -> case breakWhere conf of\n            Single  | [] <- exports -> do\n                printSingleLineExportList conf []\n                attachModuleComment\n            Single  | [egroup] <- exports\n                    , not (commentGroupHasComments egroup)\n                    , [(export, _)] <- (cgItems egroup) -> do\n                printSingleLineExportList conf [export]\n                attachModuleComment\n            Inline  | [] <- exports -> do\n                printSingleLineExportList conf []\n                attachModuleComment\n            Inline  | [egroup] <- exports, not (commentGroupHasComments egroup) -> do\n                wrapping\n                    (printSingleLineExportList conf $ map fst $ cgItems egroup)\n                    (do\n                        attachOpenBracket\n                        attachModuleComment\n                        printMultiLineExportList conf exports)\n            _ -> do\n                attachOpenBracket\n                attachModuleComment\n                printMultiLineExportList conf exports\n\n    putMaybeLineComment $ GHC.unLoc <$> mbWhereComment\n  where\n    attachModuleComment = putMaybeLineComment $ GHC.unLoc <$> mbModuleComment\n\n    attachOpenBracket\n        | openBracket conf == SameLine = putText \" (\"\n        | otherwise                    = pure ()","function_tokens":["printHeader","conf","mbName","mbExps","_","mbModuleComment","mbWhereComment","=","do","forM_","mbName","$","\\","name","->","do","putText","\"module\"","space","putText","(","showOutputable","name",")","case","mbExps","of","Nothing","->","do","when","(","isJust","mbName",")","$","case","breakWhere","conf","of","Always","->","do","attachModuleComment","newline","spaces","(","indent","conf",")","_","->","space","putText","\"where\"","Just","exports","->","case","breakWhere","conf","of","Single","|","[","]","<-","exports","->","do","printSingleLineExportList","conf","[","]","attachModuleComment","Single","|","[","egroup","]","<-","exports",",","not","(","commentGroupHasComments","egroup",")",",","[","(","export",",","_",")","]","<-","(","cgItems","egroup",")","->","do","printSingleLineExportList","conf","[","export","]","attachModuleComment","Inline","|","[","]","<-","exports","->","do","printSingleLineExportList","conf","[","]","attachModuleComment","Inline","|","[","egroup","]","<-","exports",",","not","(","commentGroupHasComments","egroup",")","->","do","wrapping","(","printSingleLineExportList","conf","$","map","fst","$","cgItems","egroup",")","(","do","attachOpenBracket","attachModuleComment","printMultiLineExportList","conf","exports",")","_","->","do","attachOpenBracket","attachModuleComment","printMultiLineExportList","conf","exports","putMaybeLineComment","$","GHC","unLoc","<$>","mbWhereComment","where","attachModuleComment","=","putMaybeLineComment","$","GHC","unLoc","<$>","mbModuleComment","attachOpenBracket","|","openBracket","conf","==","SameLine","=","putText","\" (\"","|","otherwise","=","pure","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L129-L176","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"unsafeFreeze","parameters":"(SymMMatrix n v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFreeze (SymMMatrix n v) = SymMatrix n `liftM` G.unsafeFreeze v","function_tokens":["unsafeFreeze","(","SymMMatrix","n","v",")","=","SymMatrix","n","`","liftM","`","G","unsafeFreeze","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L73-L73","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"rewind","parameters":"","argument_list":"","return_statement":"","docstring":"'rewind' applied to an 'Initial' source is a legal NOP. 'rewind' applied to a 'Playing' source will change its state to 'Stopped' then 'Initial'. The source is exempt from processing: its current state is preserved, with the exception of the sampling offset, which is reset to the beginning.  'rewind' applied to a 'Paused' source will change its state to 'Initial', with the same consequences as on a 'Playing' source.  'rewind' applied to an 'Stopped' source promotes the source to 'Initial', resetting the sampling offset to the beginning.","docstring_summary":"'rewind' applied to an 'Initial' source is a legal NOP. 'rewind' applied to a 'Playing' source will change its state to 'Stopped' then 'Initial'. The source is exempt from processing: its current state is preserved, with the exception of the sampling offset, which is reset to the beginning.  'rewind' applied to a 'Paused' source will change its state to 'Initial', with the same consequences as on a 'Playing' source.  'rewind' applied to an 'Stopped' source promotes the source to 'Initial', resetting the sampling offset to the beginning.","docstring_tokens":["rewind","applied","to","an","Initial","source","is","a","legal","NOP",".","rewind","applied","to","a","Playing","source","will","change","its","state","to","Stopped","then","Initial",".","The","source","is","exempt","from","processing",":","its","current","state","is","preserved","with","the","exception","of","the","sampling","offset","which","is","reset","to","the","beginning",".","rewind","applied","to","a","Paused","source","will","change","its","state","to","Initial","with","the","same","consequences","as","on","a","Playing","source",".","rewind","applied","to","an","Stopped","source","promotes","the","source","to","Initial","resetting","the","sampling","offset","to","the","beginning","."],"function":"rewind = withArraySizei alSourceRewindv","function_tokens":["rewind","=","withArraySizei","alSourceRewindv"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L772-L772","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withLast","parameters":"_ []","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"withLast _ []       = []","function_tokens":["withLast","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L181-L181","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"t'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t' = (realToFrac t - 1)","function_tokens":["t'","=","(","realToFrac","t","-","1",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L150-L150","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"acosh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"acosh = fmap acosh","function_tokens":["acosh","=","fmap","acosh"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L250-L250","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"maxViewUnsigned","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maxViewUnsigned t\n    = case t of\n        Bin _ _ p m l r -> let (result,t') = maxViewUnsigned r in (result, bin p m l t')\n        Tip _ y -> (y, Nil)\n        Nil -> error \"maxViewUnsigned Nil\"\n\n-- | \/O(min(n,W))\/. Retrieves the minimal key of the set, and the set\n-- stripped of that element, or 'Nothing' if passed an empty set.","function_tokens":["maxViewUnsigned","t","=","case","t","of","Bin","_","_","p","m","l","r","->","let","(","result",",","t'",")","=","maxViewUnsigned","r","in","(","result",",","bin","p","m","l","t'",")","Tip","_","y","->","(","y",",","Nil",")","Nil","->","error","\"maxViewUnsigned Nil\"","-- | \/O(min(n,W))\/. Retrieves the minimal key of the set, and the set","-- stripped of that element, or 'Nothing' if passed an empty set."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L601-L609","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"f","parameters":"1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f 1 = mempty","function_tokens":["f","1","=","mempty"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L360-L360","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putOutputable","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putOutputable = putText . showOutputable","function_tokens":["putOutputable","=","putText",".","showOutputable"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L120-L120","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fresh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fresh     = mkName <$> delete \"f\" (delete \"v\" freshNames)","function_tokens":["fresh","=","mkName","<$>","delete","\"f\"","(","delete","\"v\"","freshNames",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L545-L545","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bin\/Main.hs","language":"haskell","identifier":"arguments","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"arguments\n  = liftA2 (,) (configParser Config)\n  $ liftA2 (:)\n  ( argument str (metavar \"COMMAND\"))\n  ( many (argument str (metavar \"COMMAND\")))","function_tokens":["arguments","=","liftA2","(",",",")","(","configParser","Config",")","$","liftA2","(",":",")","(","argument","str","(","metavar","\"COMMAND\"",")",")","(","many","(","argument","str","(","metavar","\"COMMAND\"",")",")",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bin\/Main.hs#L18-L22","hash_key":"knupfer\/chronos:bin\/Main.hs","hash_val":24460,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a ==> b = nnf (not a \\\/ b)","function_tokens":["a","==>","b","=","nnf","(","not","a","\\\/","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L233-L233","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(b', s') = f a s","function_tokens":["(","b'",",","s'",")","=","f","a","s"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L313-L313","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"r0","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r0 = rp `U.unsafeIndex` i","function_tokens":["r0","=","rp","`","U","unsafeIndex","`","i"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L114-L114","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_TRUE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_TRUE                            = 0x0001","function_tokens":["alc_TRUE","=","0x0001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L128-L128","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getInt32","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getInt32 = fromIntegral <$> getWord32le","function_tokens":["getInt32","=","fromIntegral","<$>","getWord32le"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L128-L128","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"execRSS","parameters":"m r s","argument_list":"","return_statement":"","docstring":"^final state and output","docstring_summary":"^final state and output","docstring_tokens":["^final","state","and","output"],"function":"execRSS m r s = let\n    (_, s', w) = runRSS m r s\n    in (s', w)","function_tokens":["execRSS","m","r","s","=","let","(","_",",","s'",",","w",")","=","runRSS","m","r","s","in","(","s'",",","w",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L70-L72","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = Atto.many1 (bare <|> quoted) <* expectEndOfInput","function_tokens":["go","=","Atto","many1","(","bare","<|>","quoted",")","<*","expectEndOfInput"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L153-L153","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"runConduitParser","parameters":"(ConduitParser p)","argument_list":"","return_statement":"","docstring":"Run a 'ConduitParser'. Any parsing failure will be thrown as an exception.","docstring_summary":"Run a 'ConduitParser'. Any parsing failure will be thrown as an exception.","docstring_tokens":["Run","a","ConduitParser",".","Any","parsing","failure","will","be","thrown","as","an","exception","."],"function":"runConduitParser (ConduitParser p) = either throwM return . fst =<< runStateT (runExceptT p) (mempty, mempty)","function_tokens":["runConduitParser","(","ConduitParser","p",")","=","either","throwM","return",".","fst","=<<","runStateT","(","runExceptT","p",")","(","mempty",",","mempty",")"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L105-L105","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"pause","parameters":"","argument_list":"","return_statement":"","docstring":"'pause' applied to an 'Initial' source is a legal NOP. 'pause' applied to a 'Playing' source will change its state to 'Paused'. The source is exempt from processing, its current state is preserved. 'pause' applied to a 'Paused' source is a legal NOP. 'pause' applied to a 'Stopped' source is a legal NOP.","docstring_summary":"'pause' applied to an 'Initial' source is a legal NOP. 'pause' applied to a 'Playing' source will change its state to 'Paused'. The source is exempt from processing, its current state is preserved. 'pause' applied to a 'Paused' source is a legal NOP. 'pause' applied to a 'Stopped' source is a legal NOP.","docstring_tokens":["pause","applied","to","an","Initial","source","is","a","legal","NOP",".","pause","applied","to","a","Playing","source","will","change","its","state","to","Paused",".","The","source","is","exempt","from","processing","its","current","state","is","preserved",".","pause","applied","to","a","Paused","source","is","a","legal","NOP",".","pause","applied","to","a","Stopped","source","is","a","legal","NOP","."],"function":"pause = withArraySizei alSourcePausev","function_tokens":["pause","=","withArraySizei","alSourcePausev"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L745-L745","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeOutCubic","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease out cubic.","docstring_summary":"Ease out cubic.","docstring_tokens":["Ease","out","cubic","."],"function":"easeOutCubic c t b =  let t' = realToFrac t - 1 in c * (t'*t'*t' + 1) + b","function_tokens":["easeOutCubic","c","t","b","=","let","t'","=","realToFrac","t","-","1","in","c","*","(","t'","*","t'","*","t'","+","1",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L108-L108","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"withSaturation","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withSaturation x =\n  if (fromIntegral x :: Integer) > (fromIntegral bound :: Integer)\n    then bound\n    else fromIntegral x\n  where\n    bound = maxBound :: b\n\n-- | Determine the target entry of an action.","function_tokens":["withSaturation","x","=","if","(","fromIntegral","x","::","Integer",")",">","(","fromIntegral","bound","::","Integer",")","then","bound","else","fromIntegral","x","where","bound","=","maxBound","::","b","-- | Determine the target entry of an action."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1044-L1052","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"moveToAmsterdam'","parameters":"person","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moveToAmsterdam' person = person{_place = (_place person){_city = \"Amsterdam\"}}","function_tokens":["moveToAmsterdam'","person","=","person","{","_place","=","(","_place","person",")","{","_city","=","\"Amsterdam\"","}","}"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L33-L33","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"pick","parameters":"(Program (MapMaker outfile True projection) infile)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pick (Program (MapMaker outfile True projection) infile) = let p = pickProjection projection in\n    makeFoldersSVG =<< districtToMapFilesP p <$> getDistricts infile","function_tokens":["pick","(","Program","(","MapMaker","outfile","True","projection",")","infile",")","=","let","p","=","pickProjection","projection","in","makeFoldersSVG","=<<","districtToMapFilesP","p","<$>","getDistricts","infile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L22-L23","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"completeLastWord","parameters":"(left, right)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"completeLastWord (left, right) =\n      let word = Text.takeWhileEnd (isSpace >>> not) left\n          prefix = Text.dropEnd (Text.length word) left\n       in go (word, right) <&> first (const prefix)","function_tokens":["completeLastWord","(","left",",","right",")","=","let","word","=","Text","takeWhileEnd","(","isSpace",">>>","not",")","left","prefix","=","Text","dropEnd","(","Text","length","word",")","left","in","go","(","word",",","right",")","<&>","first","(","const","prefix",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L94-L97","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = Result 0 0 0","function_tokens":["mempty","=","Result","0","0","0"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L67-L67","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_CAPTURE_SAMPLES","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_CAPTURE_SAMPLES                 = 0x0312","function_tokens":["alc_CAPTURE_SAMPLES","=","0x0312"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L162-L162","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"fromBlocks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromBlocks = MG.fromBlocks","function_tokens":["fromBlocks","=","MG","fromBlocks"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L217-L217","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"mUnless","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mUnless t = mWhen (not t)","function_tokens":["mUnless","t","=","mWhen","(","not","t",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L227-L227","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"parseComments","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseComments = \n  alexScanTokens >>> unzip >>> (concat *** concatMap maybeToList)","function_tokens":["parseComments","=","alexScanTokens",">>>","unzip",">>>","(","concat","***","concatMap","maybeToList",")"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L22-L23","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfc_x15_cs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfc_x15_cs =\n    [  0.44045832024338111077637466616 \/ 2\n    , -0.143958836762168335790826895326\n    ,  0.044786499817939267247056666937\n    , -0.013343124200271211203618353102\n    ,  0.003824682739750469767692372556\n    , -0.001058699227195126547306482530\n    ,  0.000283859419210073742736310108\n    , -0.000073906170662206760483959432\n    ,  0.000018725312521489179015872934\n    , -4.62530981164919445131297264430e-6\n    ,  1.11558657244432857487884006422e-6\n    , -2.63098662650834130067808832725e-7\n    ,  6.07462122724551777372119408710e-8\n    , -1.37460865539865444777251011793e-8\n    ,  3.05157051905475145520096717210e-9\n    , -6.65174789720310713757307724790e-10\n    ,  1.42483346273207784489792999706e-10\n    , -3.00141127395323902092018744545e-11\n    ,  6.22171792645348091472914001250e-12\n    , -1.26994639225668496876152836555e-12\n    ,  2.55385883033257575402681845385e-13\n    , -5.06258237507038698392265499770e-14\n    ,  9.89705409478327321641264227110e-15\n    , -1.90685978789192181051961024995e-15\n    ,  3.50826648032737849245113757340e-16\n    ]","function_tokens":["erfc_x15_cs","=","[","0.44045832024338111077637466616","\/","2",",","-","0.143958836762168335790826895326",",","0.044786499817939267247056666937",",","-","0.013343124200271211203618353102",",","0.003824682739750469767692372556",",","-","0.001058699227195126547306482530",",","0.000283859419210073742736310108",",","-","0.000073906170662206760483959432",",","0.000018725312521489179015872934",",","-","4.62530981164919445131297264430e-6",",","1.11558657244432857487884006422e-6",",","-","2.63098662650834130067808832725e-7",",","6.07462122724551777372119408710e-8",",","-","1.37460865539865444777251011793e-8",",","3.05157051905475145520096717210e-9",",","-","6.65174789720310713757307724790e-10",",","1.42483346273207784489792999706e-10",",","-","3.00141127395323902092018744545e-11",",","6.22171792645348091472914001250e-12",",","-","1.26994639225668496876152836555e-12",",","2.55385883033257575402681845385e-13",",","-","5.06258237507038698392265499770e-14",",","9.89705409478327321641264227110e-15",",","-","1.90685978789192181051961024995e-15",",","3.50826648032737849245113757340e-16","]"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L119-L145","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"getChildren","parameters":"path'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getChildren path' =  (\\\\ [\".\", \"..\"]) <$> getDirectoryContents path'","function_tokens":["getChildren","path'","=","(","\\\\","[","\".\"",",","\"..\"","]",")","<$>","getDirectoryContents","path'"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L39-L39","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"imapM","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","yielding","a","matrix","of","results","."],"function":"imapM = MG.imapM","function_tokens":["imapM","=","MG","imapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L240-L240","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = \\case\n      Say s k ->\n        liftIO (render renderMode outputHandle s) >> k\n      AskLn s d k -> do\n        let prompt =\n              renderText renderMode $\n                maybe s (\\d' -> s <> text \"[\" <> text d' <> text \"] \") d\n        liftHaskeline (Haskeline.getInputLine (toString prompt)) >>= \\case\n          Nothing -> EvalT empty\n          Just answer\n            | null answer -> k (fromMaybe mempty d)\n            | otherwise -> k (toText answer)\n      AskChar s k -> do\n        let prompt = toString (renderText renderMode s)\n        liftHaskeline (Haskeline.getInputChar prompt) >>= \\case\n          Nothing -> EvalT empty\n          Just c -> k c\n      AskPassword s m k -> do\n        let prompt = toString (renderText renderMode s)\n        liftHaskeline (Haskeline.getPassword m prompt) >>= \\case\n          Nothing -> EvalT empty\n          Just str -> k (toText str)\n      PushCompFunc f k ->\n        modifyIORef' compRef (f :) >> k\n      PopCompFunc k ->\n        modifyIORef'\n          compRef\n          ( \\case\n              [] -> []\n              (_ : fs) -> fs\n          )\n          >> k","function_tokens":["go","=","\\","case","Say","s","k","->","liftIO","(","render","renderMode","outputHandle","s",")",">>","k","AskLn","s","d","k","->","do","let","prompt","=","renderText","renderMode","$","maybe","s","(","\\","d'","->","s","<>","text","\"[\"","<>","text","d'","<>","text","\"] \"",")","d","liftHaskeline","(","Haskeline","getInputLine","(","toString","prompt",")",")",">>=","\\","case","Nothing","->","EvalT","empty","Just","answer","|","null","answer","->","k","(","fromMaybe","mempty","d",")","|","otherwise","->","k","(","toText","answer",")","AskChar","s","k","->","do","let","prompt","=","toString","(","renderText","renderMode","s",")","liftHaskeline","(","Haskeline","getInputChar","prompt",")",">>=","\\","case","Nothing","->","EvalT","empty","Just","c","->","k","c","AskPassword","s","m","k","->","do","let","prompt","=","toString","(","renderText","renderMode","s",")","liftHaskeline","(","Haskeline","getPassword","m","prompt",")",">>=","\\","case","Nothing","->","EvalT","empty","Just","str","->","k","(","toText","str",")","PushCompFunc","f","k","->","modifyIORef'","compRef","(","f",":",")",">>","k","PopCompFunc","k","->","modifyIORef'","compRef","(","\\","case","[","]","->","[","]","(","_",":","fs",")","->","fs",")",">>","k"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L199-L231","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrRemBits","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits","function_tokens":["ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L82-L82","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"takeT","parameters":"t1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeT t1 = slice 0 t1","function_tokens":["takeT","t1","=","slice","0","t1"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L170-L170","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Tip i _         == Tip j _         = i == j","function_tokens":["Tip","i","_","==","Tip","j","_","=","i","==","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L837-L837","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"marshalContext","parameters":"(Context context)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalContext (Context context) = context","function_tokens":["marshalContext","(","Context","context",")","=","context"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L168-L168","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mono","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mono      = forcedMono || isMonomorphic fieldtype dtBinders","function_tokens":["mono","=","forcedMono","||","isMonomorphic","fieldtype","dtBinders"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L570-L570","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"lengthOfCommonPrefix","parameters":"x y","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lengthOfCommonPrefix x y = length $ takeWhile id $ zipWith (==) x y","function_tokens":["lengthOfCommonPrefix","x","y","=","length","$","takeWhile","id","$","zipWith","(","==",")","x","y"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L53-L53","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"mat (i,j)","argument_list":"","return_statement":"","docstring":"Indexing","docstring_summary":"Indexing","docstring_tokens":["Indexing"],"function":"(!) mat (i,j) | i < 0 || i >= r || j < 0 || j >= c =\n                error \"Index out of bounds\"\n              | otherwise = unsafeIndex mat (i,j)\n  where\n    (r,c) = dim mat","function_tokens":["(","!",")","mat","(","i",",","j",")","|","i","<","0","||","i",">=","r","||","j","<","0","||","j",">=","c","=","error","\"Index out of bounds\"","|","otherwise","=","unsafeIndex","mat","(","i",",","j",")","where","(","r",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L101-L106","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"peek","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"peek                  = peek1 Buffer . castPtr","function_tokens":["peek","=","peek1","Buffer",".","castPtr"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L58-L58","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"wait","parameters":"","argument_list":"","return_statement":"","docstring":"Block until all threads in the group have terminated.  Note that: @wait = 'waitN' 1@.","docstring_summary":"Block until all threads in the group have terminated.  Note that:","docstring_tokens":["Block","until","all","threads","in","the","group","have","terminated",".","Note","that",":"],"function":"wait = waitN 1","function_tokens":["wait","=","waitN","1"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L130-L130","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Lydian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Lydian       = \"lydian\"","function_tokens":["go","Lydian","=","\"lydian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L533-L533","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"c (i, f@(_, ty))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one c (i, f@(_, ty)) = Field Nothing mono ty (Context i c con, mkSubst vs resTy)\n              where fsTys = map (typeVariables . snd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["one","c","(","i",",","f","@","(","_",",","ty",")",")","=","Field","Nothing","mono","ty","(","Context","i","c","con",",","mkSubst","vs","resTy",")","where","fsTys","=","map","(","typeVariables",".","snd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L359-L362","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"withColumns","parameters":"c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withColumns c = local $ \\pc -> pc {columns = c}","function_tokens":["withColumns","c","=","local","$","\\","pc","->","pc","{","columns","=","c","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L357-L357","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"lineBreakFix","parameters":"c@Conflict{cBodies}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lineBreakFix c@Conflict{cBodies}\n    | any null (toList cBodies)\n    || allSame (toList endings) = c\n    | otherwise =\n        case resolveGen endings of\n        Just LF -> Conflict.setStrings removeCr c\n        Just CRLF -> Conflict.setStrings makeCr c\n        _ -> c\n    where\n        endings = fmap lineEndings cBodies\n        removeCr x@(_:_) | last x == '\\r' = init x\n        removeCr x = x\n        makeCr x@(_:_) | last x == '\\r' = x\n        makeCr x = x <> \"\\r\"","function_tokens":["lineBreakFix","c","@","Conflict","{","cBodies","}","|","any","null","(","toList","cBodies",")","||","allSame","(","toList","endings",")","=","c","|","otherwise","=","case","resolveGen","endings","of","Just","LF","->","Conflict","setStrings","removeCr","c","Just","CRLF","->","Conflict","setStrings","makeCr","c","_","->","c","where","endings","=","fmap","lineEndings","cBodies","removeCr","x","@","(","_",":","_",")","|","last","x","==","'\\r'","=","init","x","removeCr","x","=","x","makeCr","x","@","(","_",":","_",")","|","last","x","==","'\\r'","=","x","makeCr","x","=","x","<>","\"\\r\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L117-L132","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"method","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"method        = opts ^. L.method","function_tokens":["method","=","opts","^.","L","method"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L31-L31","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"lift","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift m = ChooseC (\\ _ leaf -> m >>= leaf)","function_tokens":["lift","m","=","ChooseC","(","\\","_","leaf","->","m",">>=","leaf",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L96-L96","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWith4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith4 = MG.zipWith4","function_tokens":["zipWith4","=","MG","zipWith4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L268-L268","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"pairs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pairs = fmap (flatten . (over _1 (shittyCentroid . concat))) points","function_tokens":["pairs","=","fmap","(","flatten",".","(","over","_1","(","shittyCentroid",".","concat",")",")",")","points"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L47-L47","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"work","parameters":"x []     stk","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"work x []     stk = finish x (tip x) stk","function_tokens":["work","x","[","]","stk","=","finish","x","(","tip","x",")","stk"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L745-L745","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"c (i, f@(n, _, ty))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one c (i, f@(n, _, ty)) = Field (Just n) mono ty (Context i c con, mkSubst vs resTy)\n              where fsTys = map (typeVariables . trd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["one","c","(","i",",","f","@","(","n",",","_",",","ty",")",")","=","Field","(","Just","n",")","mono","ty","(","Context","i","c","con",",","mkSubst","vs","resTy",")","where","fsTys","=","map","(","typeVariables",".","trd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L363-L367","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference","parameters":"t1@(Bin _ _ p1 m1 l1 r1) t2@(Bin _ _ p2 m2 l2 r2)","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nDifference\n------------------------------------------------------------------} \/O(n+m)\/. Difference between two sets.","docstring_summary":"{--------------------------------------------------------------------\nDifference\n------------------------------------------------------------------} \/O(n+m)\/. Difference between two sets.","docstring_tokens":["{","--------------------------------------------------------------------","Difference","------------------------------------------------------------------","}","\/","O","(","n","+","m",")","\/",".","Difference","between","two","sets","."],"function":"difference t1@(Bin _ _ p1 m1 l1 r1) t2@(Bin _ _ p2 m2 l2 r2)\n  | shorter m1 m2  = difference1\n  | shorter m2 m1  = difference2\n  | p1 == p2       = bin p1 m1 (difference l1 l2) (difference r1 r2)\n  | otherwise      = t1\n  where\n    difference1 | nomatch p2 p1 m1  = t1\n                | zero p2 m1        = bin p1 m1 (difference l1 t2) r1\n                | otherwise         = bin p1 m1 l1 (difference r1 t2)\n\n    difference2 | nomatch p1 p2 m2  = t1\n                | zero p1 m2        = difference t1 l2\n                | otherwise         = difference t1 r2","function_tokens":["difference","t1","@","(","Bin","_","_","p1","m1","l1","r1",")","t2","@","(","Bin","_","_","p2","m2","l2","r2",")","|","shorter","m1","m2","=","difference1","|","shorter","m2","m1","=","difference2","|","p1","==","p2","=","bin","p1","m1","(","difference","l1","l2",")","(","difference","r1","r2",")","|","otherwise","=","t1","where","difference1","|","nomatch","p2","p1","m1","=","t1","|","zero","p2","m1","=","bin","p1","m1","(","difference","l1","t2",")","r1","|","otherwise","=","bin","p1","m1","l1","(","difference","r1","t2",")","difference2","|","nomatch","p1","p2","m2","=","t1","|","zero","p1","m2","=","difference","t1","l2","|","otherwise","=","difference","t1","r2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L387-L401","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"cos'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cos' = cos (realToFrac t * (pi \/ 2))","function_tokens":["cos'","=","cos","(","realToFrac","t","*","(","pi","\/","2",")",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L129-L129","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"f","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f = S.filter ((\/= Just s) . I.targetEntry)","function_tokens":["f","=","S","filter","(","(","\/=","Just","s",")",".","I","targetEntry",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L626-L626","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_MONO_SOURCES","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_MONO_SOURCES                    = 0x1010","function_tokens":["alc_MONO_SOURCES","=","0x1010"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L135-L135","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Minor","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Minor        = \"minor\"","function_tokens":["go","Minor","=","\"minor\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L529-L529","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"resBpPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resBpPtr      = F.castPtr (F.unsafeForeignPtrToPtr resBpFptr  )","function_tokens":["resBpPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBpFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L60-L60","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"minViewUnsigned","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"minViewUnsigned t\n    = case t of\n        Bin _ _ p m l r -> let (result,t') = minViewUnsigned l in (result, bin p m t' r)\n        Tip _ y -> (y, Nil)\n        Nil -> error \"minViewUnsigned Nil\"\n\n-- | \/O(min(n,W))\/. Delete and find the minimal element.\n--\n-- > deleteFindMin set = (findMin set, deleteMin set)","function_tokens":["minViewUnsigned","t","=","case","t","of","Bin","_","_","p","m","l","r","->","let","(","result",",","t'",")","=","minViewUnsigned","l","in","(","result",",","bin","p","m","t'","r",")","Tip","_","y","->","(","y",",","Nil",")","Nil","->","error","\"minViewUnsigned Nil\"","-- | \/O(min(n,W))\/. Delete and find the minimal element.","--","-- > deleteFindMin set = (findMin set, deleteMin set)"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L618-L627","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"prj","parameters":"(InL a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prj (InL a) = Just a","function_tokens":["prj","(","InL","a",")","=","Just","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L48-L48","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/SideDiff.hs","language":"haskell","identifier":"getConflictDiffs","parameters":"Conflict{cMarkers, cMarkerEnd, cBodies}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getConflictDiffs Conflict{cMarkers, cMarkerEnd, cBodies} =\n    [ (A, markerA, getDiff bodyBase bodyA)\n    | not (null bodyA) ] ++\n    [ (B, (fst markerB, snd cMarkerEnd), getDiff bodyBase bodyB)\n    | not (null bodyB) ]\n    where\n        Sides markerA _ markerB = cMarkers\n        Sides bodyA bodyBase bodyB = cBodies","function_tokens":["getConflictDiffs","Conflict","{","cMarkers",",","cMarkerEnd",",","cBodies","}","=","[","(","A",",","markerA",",","getDiff","bodyBase","bodyA",")","|","not","(","null","bodyA",")","]","++","[","(","B",",","(","fst","markerB",",","snd","cMarkerEnd",")",",","getDiff","bodyBase","bodyB",")","|","not","(","null","bodyB",")","]","where","Sides","markerA","_","markerB","=","cMarkers","Sides","bodyA","bodyBase","bodyB","=","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/SideDiff.hs#L19-L28","hash_key":"Peaker\/git-mediate:src\/SideDiff.hs","hash_val":4146,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"helpDisplay","parameters":"","argument_list":"","return_statement":"","docstring":"display help if user enters e.g.  > hgis --help wrongcommand","docstring_summary":"display help if user enters e.g.  > hgis --help wrongcommand","docstring_tokens":["display","help","if","user","enters","e",".","g",".",">","hgis","--","help","wrongcommand"],"function":"helpDisplay = info ( program <**> helper)\n    ( fullDesc\n    <> progDesc \"GIS for Haskell. Can make maps, compute areas\/perimeters for shapefiles.\"\n    <> header \"hgis - GIS in Haskell\" )","function_tokens":["helpDisplay","=","info","(","program","<**>","helper",")","(","fullDesc","<>","progDesc","\"GIS for Haskell. Can make maps, compute areas\/perimeters for shapefiles.\"","<>","header","\"hgis - GIS in Haskell\"",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L86-L89","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"newImportNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newImportNames =\n      case (ideclHiding i0, ideclHiding i1) of\n        (Just (b, L p imps0), Just (_, L _ imps1)) -> Just (b, L p (imps0 `merge` imps1))\n        (Nothing, Nothing) -> Nothing\n        (Just x, Nothing) -> Just x\n        (Nothing, Just x) -> Just x","function_tokens":["newImportNames","=","case","(","ideclHiding","i0",",","ideclHiding","i1",")","of","(","Just","(","b",",","L","p","imps0",")",",","Just","(","_",",","L","_","imps1",")",")","->","Just","(","b",",","L","p","(","imps0","`","merge","`","imps1",")",")","(","Nothing",",","Nothing",")","->","Nothing","(","Just","x",",","Nothing",")","->","Just","x","(","Nothing",",","Just","x",")","->","Just","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L122-L128","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(==) = (==) `on` position &&& analysis . benchmark","function_tokens":["(","==",")","=","(","==",")","`","on","`","position","&&&","analysis",".","benchmark"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L65-L65","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"marshalLoopingMode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalLoopingMode = (== Looping)","function_tokens":["marshalLoopingMode","=","(","==","Looping",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L250-L250","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"name'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"name' = \"\\\"\" <> name <> \"\\\"\"","function_tokens":["name'","=","\"\\\"\"","<>","name","<>","\"\\\"\""],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L500-L500","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(\/) = liftA2 (\/)","function_tokens":["(","\/",")","=","liftA2","(","\/",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L261-L261","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Error\/Either.hs","language":"haskell","identifier":"runError","parameters":"(ErrorC m)","argument_list":"","return_statement":"","docstring":"Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.  @ 'runError' ('pure' a) = 'pure' ('Right' a) @ @ 'runError' ('throwError' e) = 'pure' ('Left' e) @ @ 'runError' ('throwError' e \\`'catchError'\\` 'pure') = 'pure' ('Right' e) @  @since 0.1.0.0","docstring_summary":"Run an 'Error' effect, returning uncaught errors in 'Left' and successful computations\u2019 values in 'Right'.","docstring_tokens":["Run","an","Error","effect","returning","uncaught","errors","in","Left","and","successful","computations\u2019","values","in","Right","."],"function":"runError (ErrorC m) = runExceptT m","function_tokens":["runError","(","ErrorC","m",")","=","runExceptT","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Error\/Either.hs#L42-L42","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Error\/Either.hs","hash_val":17343,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"har","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"har = mconcat","function_tokens":["har","=","mconcat"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L122-L122","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"unmarshalSourceType","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalSourceType x\n   | x == al_UNDETERMINED = Undetermined\n   | x == al_STATIC = Static\n   | x == al_STREAMING = Streaming\n   | otherwise = error (\"unmarshalSourceType: illegal value \" ++ show x)","function_tokens":["unmarshalSourceType","x","|","x","==","al_UNDETERMINED","=","Undetermined","|","x","==","al_STATIC","=","Static","|","x","==","al_STREAMING","=","Streaming","|","otherwise","=","error","(","\"unmarshalSourceType: illegal value \"","++","show","x",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L227-L231","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"create","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"create = MG.create","function_tokens":["create","=","MG","create"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L384-L384","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"itraverse","parameters":"f (a `LessThan` b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (a `LessThan` b) = LessThan <$> f a <*> f b","function_tokens":["itraverse","f","(","a","`","LessThan","`","b",")","=","LessThan","<$>","f","a","<*>","f","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L93-L93","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a +:+ b = a <> del (dur a) b","function_tokens":["a","+:+","b","=","a","<>","del","(","dur","a",")","b"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L119-L119","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"tabs","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"tabs = Tabs.step","function_tokens":["tabs","=","Tabs","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L77-L77","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"itraverse","parameters":"f (Mul ms)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Mul ms)  = Mul <$> traverse f ms","function_tokens":["itraverse","f","(","Mul","ms",")","=","Mul","<$>","traverse","f","ms"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L91-L91","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"handleCommand","parameters":"(FIND_NODE id) peer inst","argument_list":"","return_statement":"","docstring":"Return a KBucket with the closest Nodes","docstring_summary":"Return a KBucket with the closest Nodes","docstring_tokens":["Return","a","KBucket","with","the","closest","Nodes"],"function":"handleCommand (FIND_NODE id) peer inst = returnNodes peer id inst","function_tokens":["handleCommand","(","FIND_NODE","id",")","peer","inst","=","returnNodes","peer","id","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L268-L268","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_VELOCITY","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_VELOCITY                         = 0x1006","function_tokens":["al_VELOCITY","=","0x1006"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L66-L66","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"fmap","parameters":"f (Buffer (Just a))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f (Buffer (Just a)) = Buffer $ Just $ fmap f a","function_tokens":["fmap","f","(","Buffer","(","Just","a",")",")","=","Buffer","$","Just","$","fmap","f","a"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L145-L145","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"str","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"str = toText prefix <> toText (reverse scanResult)","function_tokens":["str","=","toText","prefix","<>","toText","(","reverse","scanResult",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L179-L179","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"refineAnalysis","parameters":"ana@Analysis{..} (Time begin) (Time end)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"refineAnalysis ana@Analysis{..} (Time begin) (Time end) = Analysis newSamples newSquaredWeights newMean newQFactor\n  where\n    newSamples = samples + weight\n    newSquaredWeights = squaredWeights + weight*weight\n    newMean = mean + diffWeight \/ fromIntegral newSamples\n    newQFactor = qFactor + diffWeight * (time - newMean)\n    diffWeight = fromIntegral weight * (time - mean)\n    time = (fromIntegral (end - begin) \/ 1e9) \/ fromIntegral weight\n    weight = weightOf ana","function_tokens":["refineAnalysis","ana","@","Analysis","{","..","}","(","Time","begin",")","(","Time","end",")","=","Analysis","newSamples","newSquaredWeights","newMean","newQFactor","where","newSamples","=","samples","+","weight","newSquaredWeights","=","squaredWeights","+","weight","*","weight","newMean","=","mean","+","diffWeight","\/","fromIntegral","newSamples","newQFactor","=","qFactor","+","diffWeight","*","(","time","-","newMean",")","diffWeight","=","fromIntegral","weight","*","(","time","-","mean",")","time","=","(","fromIntegral","(","end","-","begin",")","\/","1e9",")","\/","fromIntegral","weight","weight","=","weightOf","ana"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L377-L387","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"unexpected","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unexpected = throwError . Unexpected . pack","function_tokens":["unexpected","=","throwError",".","Unexpected",".","pack"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L86-L86","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = choice [ select', store' ] <?> \"Array\" where\n        select' = do\n            _ <- char '(' *> string \"select\" *> space\n            a <- r\n            _ <- space\n            i <- r\n            _ <- char ')'\n            select'' a i\n        store' = do\n            _ <- char '(' *> string \"store\"  *> space\n            a <- r\n            _ <- space\n            i <- r\n            _ <- space\n            v <- r\n            _ <- char ')'\n            store'' a i v\n\n        select'' :: DynamicallySortedFix f -> DynamicallySortedFix f -> Parser (DynamicallySortedFix f)\n        select'' (DynamicallySorted (SArraySort is1 es) a)\n                 (DynamicallySorted is2                 i) = case is1 %~ is2 of\n            Proved Refl -> return . DynamicallySorted es $ inject (Select is1 es a i)\n            Disproved _ -> fail \"ill-sorted select\"\n        select'' _ _ = fail \"selecting from non-array\"\n\n        store'' :: DynamicallySortedFix f -> DynamicallySortedFix f -> DynamicallySortedFix f -> Parser (DynamicallySortedFix f)\n        store''  (DynamicallySorted as@(SArraySort _ _) a)\n                 (DynamicallySorted is                  i)\n                 (DynamicallySorted es                  v) = case as %~ SArraySort is es of\n            Proved Refl -> return . DynamicallySorted as $ inject (Store is es a i v)\n            Disproved _ -> fail \"ill-sorted store\"\n        store'' _ _ _ = fail \"storing to non-array\"\n\n-- | A smart constructor for select","function_tokens":["parser","_","r","=","choice","[","select'",",","store'","]","<?>","\"Array\"","where","select'","=","do","_","<-","char","'('","*>","string","\"select\"","*>","space","a","<-","r","_","<-","space","i","<-","r","_","<-","char","')'","select''","a","i","store'","=","do","_","<-","char","'('","*>","string","\"store\"","*>","space","a","<-","r","_","<-","space","i","<-","r","_","<-","space","v","<-","r","_","<-","char","')'","store''","a","i","v","select''","::","DynamicallySortedFix","f","->","DynamicallySortedFix","f","->","Parser","(","DynamicallySortedFix","f",")","select''","(","DynamicallySorted","(","SArraySort","is1","es",")","a",")","(","DynamicallySorted","is2","i",")","=","case","is1","%~","is2","of","Proved","Refl","->","return",".","DynamicallySorted","es","$","inject","(","Select","is1","es","a","i",")","Disproved","_","->","fail","\"ill-sorted select\"","select''","_","_","=","fail","\"selecting from non-array\"","store''","::","DynamicallySortedFix","f","->","DynamicallySortedFix","f","->","DynamicallySortedFix","f","->","Parser","(","DynamicallySortedFix","f",")","store''","(","DynamicallySorted","as","@","(","SArraySort","_","_",")","a",")","(","DynamicallySorted","is","i",")","(","DynamicallySorted","es","v",")","=","case","as","%~","SArraySort","is","es","of","Proved","Refl","->","return",".","DynamicallySorted","as","$","inject","(","Store","is","es","a","i","v",")","Disproved","_","->","fail","\"ill-sorted store\"","store''","_","_","_","=","fail","\"storing to non-array\"","-- | A smart constructor for select"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L79-L113","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"everything","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"everything = G.everything (++) (maybeToList . cast)","function_tokens":["everything","=","G","everything","(","++",")","(","maybeToList",".","cast",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L66-L66","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"many","parameters":"a","argument_list":"","return_statement":"","docstring":"Zero or more.  @ 'many' m = 'some' m '<|>' 'pure' [] @  @since 1.0.0.0","docstring_summary":"Zero or more.","docstring_tokens":["Zero","or","more","."],"function":"many a = go where go = (:) <$> a <*> go <|> pure []","function_tokens":["many","a","=","go","where","go","=","(",":",")","<$>","a","<*>","go","<|>","pure","[","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L91-L92","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"go","parameters":"wb ws fptrState fptrRemBits fptrRemBitsLen (bs:bss)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go wb ws fptrState fptrRemBits fptrRemBitsLen (bs:bss) = do\n          let (!bsFptr, !bsOff, !bsLen) = BSI.toForeignPtr bs\n          let !idxByteLen = (bsLen + 7) `div` 8\n          resIbFptr  <- F.mallocForeignPtrBytes idxByteLen\n          resBpFptr  <- F.mallocForeignPtrBytes idxByteLen\n          let resIbPtr      = F.castPtr (F.unsafeForeignPtrToPtr resIbFptr  )\n          let resBpPtr      = F.castPtr (F.unsafeForeignPtrToPtr resBpFptr  )\n          let bsPtr         = F.castPtr (F.unsafeForeignPtrToPtr bsFptr)\n          let ptrState      = F.unsafeForeignPtrToPtr fptrState\n          let ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits\n          let ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen\n          s :: Word8 <- fromIntegral <$> F.peek ptrState\n          void $ F.smProcessChunk\n            (F.plusPtr bsPtr bsOff) -- in_buffer:   Ptr UInt8\n            (fromIntegral bsLen)    -- in_length:   Size\n            ptrState                -- work state:  Ptr UInt32\n            (workBuffersP wb)       -- result_phi:  Ptr UInt8\n          void $ F.smMakeIbOpClChunks\n            (fromIntegral s)          -- state\n            (workBuffersP wb)         -- in_phis\n            (fromIntegral bsLen)      -- phi_length\n            resIbPtr                  -- out_ibs\n            (workBuffersO wb)         -- out_ops\n            (workBuffersC wb)         -- out_cls\n          bpByteLen <- F.smWriteBpChunk\n            (workBuffersO wb)         -- result_op\n            (workBuffersC wb)         -- result_cl\n            (fromIntegral idxByteLen) -- ib_bytes\n            ptrRemBits                -- remaining_bp_bits\n            ptrRemBitsLen             -- remaning_bp_bits_len\n            resBpPtr                  -- out_buffer\n          let !r =\n                ( BSI.fromForeignPtr resIbFptr 0 idxByteLen\n                , BSI.fromForeignPtr resBpFptr 0 (fromIntegral bpByteLen * 8)\n                )\n          rs <- IO.unsafeInterleaveIO $ go wb ws fptrState fptrRemBits fptrRemBitsLen bss\n          return (r:rs)","function_tokens":["go","wb","ws","fptrState","fptrRemBits","fptrRemBitsLen","(","bs",":","bss",")","=","do","let","(","bsFptr",",","bsOff",",","bsLen",")","=","BSI","toForeignPtr","bs","let","idxByteLen","=","(","bsLen","+","7",")","`","div","`","8","resIbFptr","<-","F","mallocForeignPtrBytes","idxByteLen","resBpFptr","<-","F","mallocForeignPtrBytes","idxByteLen","let","resIbPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resIbFptr",")","let","resBpPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBpFptr",")","let","bsPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","bsFptr",")","let","ptrState","=","F","unsafeForeignPtrToPtr","fptrState","let","ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits","let","ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen","s","::","Word8","<-","fromIntegral","<$>","F","peek","ptrState","void","$","F","smProcessChunk","(","F","plusPtr","bsPtr","bsOff",")","-- in_buffer:   Ptr UInt8","(","fromIntegral","bsLen",")","-- in_length:   Size","ptrState","-- work state:  Ptr UInt32","(","workBuffersP","wb",")","-- result_phi:  Ptr UInt8","void","$","F","smMakeIbOpClChunks","(","fromIntegral","s",")","-- state","(","workBuffersP","wb",")","-- in_phis","(","fromIntegral","bsLen",")","-- phi_length","resIbPtr","-- out_ibs","(","workBuffersO","wb",")","-- out_ops","(","workBuffersC","wb",")","-- out_cls","bpByteLen","<-","F","smWriteBpChunk","(","workBuffersO","wb",")","-- result_op","(","workBuffersC","wb",")","-- result_cl","(","fromIntegral","idxByteLen",")","-- ib_bytes","ptrRemBits","-- remaining_bp_bits","ptrRemBitsLen","-- remaning_bp_bits_len","resBpPtr","-- out_buffer","let","r","=","(","BSI","fromForeignPtr","resIbFptr","0","idxByteLen",",","BSI","fromForeignPtr","resBpFptr","0","(","fromIntegral","bpByteLen","*","8",")",")","rs","<-","IO","unsafeInterleaveIO","$","go","wb","ws","fptrState","fptrRemBits","fptrRemBitsLen","bss","return","(","r",":","rs",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L73-L111","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"run","parameters":"","argument_list":"","return_statement":"","docstring":"Run an action exhausted of effects to produce its final result value.  @since 1.0.0.0","docstring_summary":"Run an action exhausted of effects to produce its final result value.","docstring_tokens":["Run","an","action","exhausted","of","effects","to","produce","its","final","result","value","."],"function":"run = runIdentity","function_tokens":["run","=","runIdentity"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L120-L120","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"go","parameters":"(Left line)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Left line) = NewContent mempty (unlines [line])","function_tokens":["go","(","Left","line",")","=","NewContent","mempty","(","unlines","[","line","]",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L137-L137","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = NonDetC (\\ _ leaf _ -> leaf a)","function_tokens":["pure","a","=","NonDetC","(","\\","_","leaf","_","->","leaf","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L82-L82","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"allSame","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allSame _ = True","function_tokens":["allSame","_","=","True"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L114-L114","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfcf","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfcf = realToFrac . erfc . realToFrac","function_tokens":["erfcf","=","realToFrac",".","erfc",".","realToFrac"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L30-L30","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"renameEntry","parameters":"old new","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renameEntry old new = addPending (I.RenameEntry old new)","function_tokens":["renameEntry","old","new","=","addPending","(","I","RenameEntry","old","new",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L527-L527","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(zsFptr, _, _) = BSI.toForeignPtr zs","function_tokens":["(","zsFptr",",","_",",","_",")","=","BSI","toForeignPtr","zs"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L106-L106","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"constant","parameters":"value duration","argument_list":"","return_statement":"","docstring":"Creates a tween that performs no interpolation over the duration.","docstring_summary":"Creates a tween that performs no interpolation over the duration.","docstring_tokens":["Creates","a","tween","that","performs","no","interpolation","over","the","duration","."],"function":"constant value duration =\n  TweenT\n    $ pure value `untilEvent_` after duration","function_tokens":["constant","value","duration","=","TweenT","$","pure","value","`","untilEvent_","`","after","duration"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L345-L347","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"id","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"id = replyOrigin registration","function_tokens":["id","=","replyOrigin","registration"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L252-L252","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"unifiableCon","parameters":"a b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unifiableCon a b = and (zipWith unifiable (indices a) (indices b))\n  where indices con =\n          case con of\n            NormalC {}      -> []\n            RecC    {}      -> []\n            InfixC  {}      -> []\n#if MIN_VERSION_template_haskell(2,11,0)\n            ForallC _ _ ty  -> indices ty\n#elif MIN_VERSION_template_haskell(2,10,0)\n            ForallC _ x _   -> [ c | AppT (AppT EqualityT _) c <- x ]\n#else\n            ForallC _ x _   -> [ c | EqualP _ c <- x ]\n#endif\n#if MIN_VERSION_template_haskell(2,11,0)\n            GadtC _ _ ty    -> conIndices ty\n            RecGadtC _ _ ty -> conIndices ty\n         where\n           conIndices (AppT (ConT _) ty) = [ty]\n           conIndices (AppT rest     ty) = conIndices rest ++ [ty]\n           conIndices _                  = fclError \"Non-AppT in conIndices. Please report this as a bug for fclabels.\"\n#endif","function_tokens":["unifiableCon","a","b","=","and","(","zipWith","unifiable","(","indices","a",")","(","indices","b",")",")","where","indices","con","=","case","con","of","NormalC","{","}","->","[","]","RecC","{","}","->","[","]","InfixC","{","}","->","[","]","#if MIN_VERSION_template_haskell(2,11,0)","ForallC","_","_","ty","->","indices","ty","#elif MIN_VERSION_template_haskell(2,10,0)\n            ForallC _ x _   -> [ c | AppT (AppT EqualityT _) c <- x ]\n#else\n            ForallC _ x _   -> [ c | EqualP _ c <- x ]\n","#endif","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","_","_","ty","->","conIndices","ty","RecGadtC","_","_","ty","->","conIndices","ty","where","conIndices","(","AppT","(","ConT","_",")","ty",")","=","[","ty","]","conIndices","(","AppT","rest","ty",")","=","conIndices","rest","++","[","ty","]","conIndices","_","=","fclError","\"Non-AppT in conIndices. Please report this as a bug for fclabels.\"","#endif"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L383-L405","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"nodes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nodes = T.findClosest tree id 7","function_tokens":["nodes","=","T","findClosest","tree","id","7"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L286-L286","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"signum","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"signum = fmap signum","function_tokens":["signum","=","fmap","signum"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L235-L235","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"go","parameters":"shell","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go shell = do\n      sayLn (text \"Starting shell, use ^D to exit\")\n      pushCompletionFunction (shellCompletion shell)\n      (`evalStateT` shell) $ forever (get >>= runShell dispatch)","function_tokens":["go","shell","=","do","sayLn","(","text","\"Starting shell, use ^D to exit\"",")","pushCompletionFunction","(","shellCompletion","shell",")","(","`","evalStateT","`","shell",")","$","forever","(","get",">>=","runShell","dispatch",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L82-L85","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putText","parameters":"txt","argument_list":"","return_statement":"","docstring":"Print text","docstring_summary":"Print text","docstring_tokens":["Print","text"],"function":"putText txt = do\n  l <- gets currentLine\n  modify \\s -> s { currentLine = l <> txt }\n\n-- | Check condition post action, and use fallback if false","function_tokens":["putText","txt","=","do","l","<-","gets","currentLine","modify","\\","s","->","s","{","currentLine","=","l","<>","txt","}","-- | Check condition post action, and use fallback if false"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L105-L110","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"takeColumn","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeColumn = MG.takeColumn","function_tokens":["takeColumn","=","MG","takeColumn"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L132-L132","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"stretchEvent","parameters":"d e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stretchEvent d e = e{ eventStart = eventStart e * d,\n                      eventDur   = eventDur   e * d }","function_tokens":["stretchEvent","d","e","=","e","{","eventStart","=","eventStart","e","*","d",",","eventDur","=","eventDur","e","*","d","}"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L215-L216","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"zip64","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip64 = sig == 0x06064b50","function_tokens":["zip64","=","sig","==","0x06064b50"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L900-L900","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"prettyNatural","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyNatural = go . fromIntegral\n  where\n    go x = case divMod x 1000 of\n             (a,b) | a == 0 -> B.wordDec b\n                   | b > 99 -> go a <> B.char7 ',' <> B.wordDec b\n                   | b >  9 -> go a <> B.char7 ',' <> B.char7 '0' <> B.wordDec b\n                   | otherwise -> go a <> B.char7 ',' <> B.char7 '0' <> B.char7 '0' <> B.wordDec b","function_tokens":["prettyNatural","=","go",".","fromIntegral","where","go","x","=","case","divMod","x","1000","of","(","a",",","b",")","|","a","==","0","->","B","wordDec","b","|","b",">","99","->","go","a","<>","B","char7","','","<>","B","wordDec","b","|","b",">","9","->","go","a","<>","B","char7","','","<>","B","char7","'0'","<>","B","wordDec","b","|","otherwise","->","go","a","<>","B","char7","','","<>","B","char7","'0'","<>","B","char7","'0'","<>","B","wordDec","b"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L340-L348","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"referenceDistance","parameters":"","argument_list":"","return_statement":"","docstring":"'referenceDistance' is used for distance attenuation calculations based on inverse distance with rolloff. Depending on the distance model it will also act as a distance threshold below which gain is clamped. See \"Sound.OpenAL.AL.Attenuation\" for details. The initial value is 1.","docstring_summary":"'referenceDistance' is used for distance attenuation calculations based on inverse distance with rolloff. Depending on the distance model it will also act as a distance threshold below which gain is clamped. See \"Sound.OpenAL.AL.Attenuation\" for details. The initial value is 1.","docstring_tokens":["referenceDistance","is","used","for","distance","attenuation","calculations","based","on","inverse","distance","with","rolloff",".","Depending","on","the","distance","model","it","will","also","act","as","a","distance","threshold","below","which","gain","is","clamped",".","See","Sound",".","OpenAL",".","AL",".","Attenuation","for","details",".","The","initial","value","is","1","."],"function":"referenceDistance = makeSourceStateVar dictALfloat GetReferenceDistance","function_tokens":["referenceDistance","=","makeSourceStateVar","dictALfloat","GetReferenceDistance"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L344-L344","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","language":"haskell","identifier":"ws","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ws = WorkState\n        { workStateState      = ptr `F.plusPtr`  0\n        , workStateRemBits    = ptr `F.plusPtr`  8\n        , workStateRemBitsLen = ptr `F.plusPtr`  16\n        , workStateFptr       = fptr\n        }","function_tokens":["ws","=","WorkState","{","workStateState","=","ptr","`","F","plusPtr","`","0",",","workStateRemBits","=","ptr","`","F","plusPtr","`","8",",","workStateRemBitsLen","=","ptr","`","F","plusPtr","`","16",",","workStateFptr","=","fptr","}"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs#L45-L50","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","hash_val":16990,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl (LiftWith with)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl (LiftWith with) = with hdl","function_tokens":["alg","hdl","(","LiftWith","with",")","=","with","hdl"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L150-L150","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars'","parameters":"(InR fb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freevars' (InR fb) = freevars' fb","function_tokens":["freevars'","(","InR","fb",")","=","freevars'","fb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L632-L632","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/StrUtils.hs","language":"haskell","identifier":"unprefix","parameters":"prefix str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unprefix prefix str\n    | prefix `isPrefixOf` str = Just (drop (length prefix) str)\n    | otherwise = Nothing","function_tokens":["unprefix","prefix","str","|","prefix","`","isPrefixOf","`","str","=","Just","(","drop","(","length","prefix",")","str",")","|","otherwise","=","Nothing"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/StrUtils.hs#L25-L27","hash_key":"Peaker\/git-mediate:src\/StrUtils.hs","hash_val":9940,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = [ 2.97886562639399288862\n            , 7.409740605964741794425\n            , 6.1602098531096305440906\n            , 5.019049726784267463450058\n            , 1.275366644729965952479585264\n            , 0.5641895835477550741253201704\n            ]","function_tokens":["p","=","[","2.97886562639399288862",",","7.409740605964741794425",",","6.1602098531096305440906",",","5.019049726784267463450058",",","1.275366644729965952479585264",",","0.5641895835477550741253201704","]"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L74-L80","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"squashFieldDecl","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"squashFieldDecl _ = mempty","function_tokens":["squashFieldDecl","_","=","mempty"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L44-L44","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Throw.hs","language":"haskell","identifier":"liftEither","parameters":"","argument_list":"","return_statement":"","docstring":"Lifts an @'Either' e@ into Monad m with effect @'Throw' e@  @since 1.1.0.0","docstring_summary":"Lifts an","docstring_tokens":["Lifts","an"],"function":"liftEither = either throwError return","function_tokens":["liftEither","=","either","throwError","return"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Throw.hs#L39-L39","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Throw.hs","hash_val":34342,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putModuleName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putModuleName = putText . GHC.moduleNameString","function_tokens":["putModuleName","=","putText",".","GHC","moduleNameString"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L191-L191","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(=.) = modify","function_tokens":["(","=.",")","=","modify"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L54-L54","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Nil `compare` Nil = EQ","function_tokens":["Nil","`","compare","`","Nil","=","EQ"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L847-L847","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"(RETURN_VALUE id v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandArgs (RETURN_VALUE id v)  = toBS id `B.append` toBS v","function_tokens":["commandArgs","(","RETURN_VALUE","id","v",")","=","toBS","id","`","B","append","`","toBS","v"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L41-L41","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getCDHeader","parameters":"","argument_list":"","return_statement":"","docstring":"Parse a single central directory file header. If it's a directory or file compressed with unsupported compression method, 'Nothing' is returned.","docstring_summary":"Parse a single central directory file header. If it's a directory or file compressed with unsupported compression method, 'Nothing' is returned.","docstring_tokens":["Parse","a","single","central","directory","file","header",".","If","it","s","a","directory","or","file","compressed","with","unsupported","compression","method","Nothing","is","returned","."],"function":"getCDHeader = do\n  getSignature 0x02014b50 -- central file header signature\n  versionMadeBy <- toVersion <$> getWord16le -- version made by\n  versionNeeded <- toVersion <$> getWord16le -- version needed to extract\n  when (versionNeeded > zipVersion) . fail $\n    \"Version required to extract the archive is \"\n      ++ showVersion versionNeeded\n      ++ \" (can do \"\n      ++ showVersion zipVersion\n      ++ \")\"\n  bitFlag <- getWord16le -- general purpose bit flag\n  when (any (testBit bitFlag) [0, 6, 13]) . fail $\n    \"Encrypted archives are not supported\"\n  let needUnicode = testBit bitFlag 11\n  mcompression <- toCompressionMethod <$> getWord16le -- compression method\n  modTime <- getWord16le -- last mod file time\n  modDate <- getWord16le -- last mod file date\n  crc32 <- getWord32le -- CRC32 check sum\n  compressed <- fromIntegral <$> getWord32le -- compressed size\n  uncompressed <- fromIntegral <$> getWord32le -- uncompressed size\n  fileNameSize <- getWord16le -- file name length\n  extraFieldSize <- getWord16le -- extra field length\n  commentSize <- getWord16le -- file comment size\n  skip 4 -- disk number start, internal file attributes\n  externalFileAttrs <- getWord32le -- external file attributes\n  offset <- fromIntegral <$> getWord32le -- offset of local header\n  fileName <-\n    decodeText needUnicode\n      <$> getBytes (fromIntegral fileNameSize) -- file name\n  extraField <-\n    M.fromList\n      <$> isolate (fromIntegral extraFieldSize) (many getExtraField)\n  -- \u2191 extra fields in their raw form\n  comment <- decodeText needUnicode <$> getBytes (fromIntegral commentSize)\n  -- \u2191 file comment\n  let dfltZip64 =\n        Zip64ExtraField\n          { z64efUncompressedSize = uncompressed,\n            z64efCompressedSize = compressed,\n            z64efOffset = offset\n          }\n      z64ef = case M.lookup 1 extraField of\n        Nothing -> dfltZip64\n        Just b -> parseZip64ExtraField dfltZip64 b\n  case mcompression of\n    Nothing -> return Nothing\n    Just compression ->\n      let desc =\n            EntryDescription\n              { edVersionMadeBy = versionMadeBy,\n                edVersionNeeded = versionNeeded,\n                edCompression = compression,\n                edModTime = fromMsDosTime (MsDosTime modDate modTime),\n                edCRC32 = crc32,\n                edCompressedSize = z64efCompressedSize z64ef,\n                edUncompressedSize = z64efUncompressedSize z64ef,\n                edOffset = z64efOffset z64ef,\n                edComment = if commentSize == 0 then Nothing else comment,\n                edExtraField = extraField,\n                edExternalFileAttrs = externalFileAttrs\n              }\n       in return $ (,desc) <$> (fileName >>= mkEntrySelector . T.unpack)\n\n-- | Parse an extra-field.","function_tokens":["getCDHeader","=","do","getSignature","0x02014b50","-- central file header signature","versionMadeBy","<-","toVersion","<$>","getWord16le","-- version made by","versionNeeded","<-","toVersion","<$>","getWord16le","-- version needed to extract","when","(","versionNeeded",">","zipVersion",")",".","fail","$","\"Version required to extract the archive is \"","++","showVersion","versionNeeded","++","\" (can do \"","++","showVersion","zipVersion","++","\")\"","bitFlag","<-","getWord16le","-- general purpose bit flag","when","(","any","(","testBit","bitFlag",")","[","0",",","6",",","13","]",")",".","fail","$","\"Encrypted archives are not supported\"","let","needUnicode","=","testBit","bitFlag","11","mcompression","<-","toCompressionMethod","<$>","getWord16le","-- compression method","modTime","<-","getWord16le","-- last mod file time","modDate","<-","getWord16le","-- last mod file date","crc32","<-","getWord32le","-- CRC32 check sum","compressed","<-","fromIntegral","<$>","getWord32le","-- compressed size","uncompressed","<-","fromIntegral","<$>","getWord32le","-- uncompressed size","fileNameSize","<-","getWord16le","-- file name length","extraFieldSize","<-","getWord16le","-- extra field length","commentSize","<-","getWord16le","-- file comment size","skip","4","-- disk number start, internal file attributes","externalFileAttrs","<-","getWord32le","-- external file attributes","offset","<-","fromIntegral","<$>","getWord32le","-- offset of local header","fileName","<-","decodeText","needUnicode","<$>","getBytes","(","fromIntegral","fileNameSize",")","-- file name","extraField","<-","M","fromList","<$>","isolate","(","fromIntegral","extraFieldSize",")","(","many","getExtraField",")","-- \u2191 extra fields in their raw form","comment","<-","decodeText","needUnicode","<$>","getBytes","(","fromIntegral","commentSize",")","-- \u2191 file comment","let","dfltZip64","=","Zip64ExtraField","{","z64efUncompressedSize","=","uncompressed",",","z64efCompressedSize","=","compressed",",","z64efOffset","=","offset","}","z64ef","=","case","M","lookup","1","extraField","of","Nothing","->","dfltZip64","Just","b","->","parseZip64ExtraField","dfltZip64","b","case","mcompression","of","Nothing","->","return","Nothing","Just","compression","->","let","desc","=","EntryDescription","{","edVersionMadeBy","=","versionMadeBy",",","edVersionNeeded","=","versionNeeded",",","edCompression","=","compression",",","edModTime","=","fromMsDosTime","(","MsDosTime","modDate","modTime",")",",","edCRC32","=","crc32",",","edCompressedSize","=","z64efCompressedSize","z64ef",",","edUncompressedSize","=","z64efUncompressedSize","z64ef",",","edOffset","=","z64efOffset","z64ef",",","edComment","=","if","commentSize","==","0","then","Nothing","else","comment",",","edExtraField","=","extraField",",","edExternalFileAttrs","=","externalFileAttrs","}","in","return","$","(",",","desc",")","<$>","(","fileName",">>=","mkEntrySelector",".","T","unpack",")","-- | Parse an extra-field."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L675-L739","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapRestMaybe","parameters":"(Just maxWidth)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapRestMaybe (Just maxWidth) = wrapRest maxWidth","function_tokens":["wrapRestMaybe","(","Just","maxWidth",")","=","wrapRest","maxWidth"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L155-L155","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"plotLabels","parameters":"points","argument_list":"","return_statement":"","docstring":"Helper function to plot labels on a map. The ordinate will be plotted at the centroid of the abscissa, which may be outside the polygon if it is concave.","docstring_summary":"Helper function to plot labels on a map. The ordinate will be plotted at the centroid of the abscissa, which may be outside the polygon if it is concave.","docstring_tokens":["Helper","function","to","plot","labels","on","a","map",".","The","ordinate","will","be","plotted","at","the","centroid","of","the","abscissa","which","may","be","outside","the","polygon","if","it","is","concave","."],"function":"plotLabels points = toPlot texts\n    where pairs = fmap (flatten . (over _1 (shittyCentroid . concat))) points\n          fontStyle = font_size .~ 15 $ font_weight .~ FontWeightBold $ def\n          texts = plot_annotation_values .~ pairs $ plot_annotation_style .~ fontStyle $ def","function_tokens":["plotLabels","points","=","toPlot","texts","where","pairs","=","fmap","(","flatten",".","(","over","_1","(","shittyCentroid",".","concat",")",")",")","points","fontStyle","=","font_size",".~","15","$","font_weight",".~","FontWeightBold","$","def","texts","=","plot_annotation_values",".~","pairs","$","plot_annotation_style",".~","fontStyle","$","def"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L46-L49","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"r","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r = hdt `mod` wid","function_tokens":["r","=","hdt","`","mod","`","wid"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L87-L87","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printExport","parameters":"(CommentGroup {..}, firstGroup, _lastGroup)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printExport (CommentGroup {..}, firstGroup, _lastGroup) = do\n        forM_ (flagEnds cgPrior) $ \\(cmt, start, _end) -> do\n            unless (firstGroup && start) $ space >> space\n            putComment $ GHC.unLoc cmt\n            newline >> doIndent\n\n        forM_ (flagEnds cgItems) $ \\((export, mbComment), start, _end) -> do\n            if firstGroup && start then\n                unless (null cgPrior) $ space >> space\n            else\n                comma >> space\n            putExport conf export\n            putMaybeLineComment $ GHC.unLoc <$> mbComment\n            newline >> doIndent","function_tokens":["printExport","(","CommentGroup","{","..","}",",","firstGroup",",","_lastGroup",")","=","do","forM_","(","flagEnds","cgPrior",")","$","\\","(","cmt",",","start",",","_end",")","->","do","unless","(","firstGroup","&&","start",")","$","space",">>","space","putComment","$","GHC","unLoc","cmt","newline",">>","doIndent","forM_","(","flagEnds","cgItems",")","$","\\","(","(","export",",","mbComment",")",",","start",",","_end",")","->","do","if","firstGroup","&&","start","then","unless","(","null","cgPrior",")","$","space",">>","space","else","comma",">>","space","putExport","conf","export","putMaybeLineComment","$","GHC","unLoc","<$>","mbComment","newline",">>","doIndent"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L200-L215","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Interpret.hs","language":"haskell","identifier":"alg","parameters":"hdl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl = \\case\n    L eff   -> runInterpreter (getConst (reflect @s)) hdl eff\n    R other -> InterpretC . alg (runInterpretC . hdl) other","function_tokens":["alg","hdl","=","\\","case","L","eff","->","runInterpreter","(","getConst","(","reflect","@","s",")",")","hdl","eff","R","other","->","InterpretC",".","alg","(","runInterpretC",".","hdl",")","other"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Interpret.hs#L98-L101","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Interpret.hs","hash_val":29980,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"rows","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rows = MG.rows","function_tokens":["rows","=","MG","rows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L117-L117","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"AndrasKovacs\/singleton-nats","sha":"ec2cd4d2284111047cf1a26ba070f593faf9c96a","path":"Data\/Nat.hs","language":"haskell","identifier":"compare","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compare _ _ = EQ","function_tokens":["compare","_","_","=","EQ"],"url":"https:\/\/github.com\/AndrasKovacs\/singleton-nats\/blob\/ec2cd4d2284111047cf1a26ba070f593faf9c96a\/Data\/Nat.hs#L98-L98","hash_key":"AndrasKovacs\/singleton-nats:Data\/Nat.hs","hash_val":3829,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"dur","parameters":"(Track d _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dur (Track d _) = d","function_tokens":["dur","(","Track","d","_",")","=","d"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L101-L101","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands.hs","language":"haskell","identifier":"commandsGeneral","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandsGeneral = subparser $ mempty\n  <>  commandGroup \"Commands:\"\n  <>  cmdCapabilities\n  <>  cmdCreateIndex","function_tokens":["commandsGeneral","=","subparser","$","mempty","<>","commandGroup","\"Commands:\"","<>","cmdCapabilities","<>","cmdCreateIndex"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands.hs#L11-L14","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands.hs","hash_val":4562,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"fail","parameters":"msg","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail msg = AccumC $ const $ const $ Fail.fail msg","function_tokens":["fail","msg","=","AccumC","$","const","$","const","$","Fail","fail","msg"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L116-L116","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"menuFromChoiceFunc","parameters":"f m","argument_list":"","return_statement":"","docstring":"Change the 'FromChoice' function.  The function should compare the user's input to the menu items and their assigned prefix values and return a 'Choice'.  @since 1.0.0.0","docstring_summary":"Change the 'FromChoice' function.  The function should compare the user's input to the menu items and their assigned prefix values and return a 'Choice'.","docstring_tokens":["Change","the","FromChoice","function",".","The","function","should","compare","the","user","s","input","to","the","menu","items","and","their","assigned","prefix","values","and","return","a","Choice","."],"function":"menuFromChoiceFunc f m = m {_menuItemFromChoiceFunc = f}","function_tokens":["menuFromChoiceFunc","f","m","=","m","{","_menuItemFromChoiceFunc","=","f","}"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L195-L195","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"fromLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_summary":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","list","of","lists","it","doesn","t","check","if","the","list","of","list","is","a","valid","matrix"],"function":"fromLists = MG.fromLists","function_tokens":["fromLists","=","MG","fromLists"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L153-L153","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"bin","parameters":"_ _ Nil r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bin _ _ Nil r = r","function_tokens":["bin","_","_","Nil","r","=","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L185-L185","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"bench\/bench.hs","language":"haskell","identifier":"actions","parameters":"cnv","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"actions cnv = [ (\"RSS.Lazy\"  , RSSL.runRSS (testActions (tell . cnv)) ())\n              , (\"RSS.Strict\", RSSS.runRSS (testActions (tell . cnv)) ())\n              , (\"RWS.Lazy\"  , RWSL.runRWS (testActions (tell . cnv)) ())\n              , (\"RWS.Strict\", RWSS.runRWS (testActions (tell . cnv)) ())\n              ]","function_tokens":["actions","cnv","=","[","(","\"RSS.Lazy\"",",","RSSL","runRSS","(","testActions","(","tell",".","cnv",")",")","(",")",")",",","(","\"RSS.Strict\"",",","RSSS","runRSS","(","testActions","(","tell",".","cnv",")",")","(",")",")",",","(","\"RWS.Lazy\"",",","RWSL","runRWS","(","testActions","(","tell",".","cnv",")",")","(",")",")",",","(","\"RWS.Strict\"",",","RWSS","runRWS","(","testActions","(","tell",".","cnv",")",")","(",")",")","]"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/bench\/bench.hs#L32-L36","hash_key":"bartavelle\/stateWriter:bench\/bench.hs","hash_val":16621,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getMongoStamp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getMongoStamp = MongoStamp <$> getInt64","function_tokens":["getMongoStamp","=","MongoStamp","<$>","getInt64"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L219-L219","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"withArraySizei","parameters":"f xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withArraySizei f xs = liftIO $ withArrayLen xs $ f . fromIntegral","function_tokens":["withArraySizei","f","xs","=","liftIO","$","withArrayLen","xs","$","f",".","fromIntegral"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L667-L667","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"ite","parameters":"i t e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ite i t e = inject (IfThenElse (sing :: Sing s) i t e)","function_tokens":["ite","i","t","e","=","inject","(","IfThenElse","(","sing","::","Sing","s",")","i","t","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L83-L83","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_,_,r,_) = fieldAllowed a","function_tokens":["(","_",",","_",",","r",",","_",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L399-L399","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"matchToAlignable","parameters":"(GHC.L _ (Hs.Match _ _ _ _))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchToAlignable (GHC.L _ (Hs.Match _ _ _ _)) = Nothing","function_tokens":["matchToAlignable","(","GHC","L","_","(","Hs","Match","_","_","_","_",")",")","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L148-L148","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"LessThan a c `ieq1` LessThan b d = a `ieq` b && c `ieq` d","function_tokens":["LessThan","a","c","`","ieq1","`","LessThan","b","d","=","a","`","ieq","`","b","&&","c","`","ieq","`","d"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L64-L64","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"mappend","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappend = union","function_tokens":["mappend","=","union"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L239-L239","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mergeR","parameters":"d c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeR d c = merge (\\x y -> inject $ y `LessThan` x) d c","function_tokens":["mergeR","d","c","=","merge","(","\\","x","y","->","inject","$","y","`","LessThan","`","x",")","d","c"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L223-L223","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Attenuation.hs","language":"haskell","identifier":"marshalDistanceModel","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalDistanceModel x = case x of\n   NoAttenuation -> al_NONE\n   InverseDistance -> al_INVERSE_DISTANCE\n   InverseDistanceClamped -> al_INVERSE_DISTANCE_CLAMPED\n   LinearDistance -> al_LINEAR_DISTANCE\n   LinearDistanceClamped -> al_LINEAR_DISTANCE_CLAMPED\n   ExponentDistance -> al_EXPONENT_DISTANCE\n   ExponentDistanceClamped -> al_EXPONENT_DISTANCE_CLAMPED","function_tokens":["marshalDistanceModel","x","=","case","x","of","NoAttenuation","->","al_NONE","InverseDistance","->","al_INVERSE_DISTANCE","InverseDistanceClamped","->","al_INVERSE_DISTANCE_CLAMPED","LinearDistance","->","al_LINEAR_DISTANCE","LinearDistanceClamped","->","al_LINEAR_DISTANCE_CLAMPED","ExponentDistance","->","al_EXPONENT_DISTANCE","ExponentDistanceClamped","->","al_EXPONENT_DISTANCE_CLAMPED"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Attenuation.hs#L178-L187","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Attenuation.hs","hash_val":13566,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Notes _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Notes _)                = (True, True, True, True)","function_tokens":["go","(","Notes","_",")","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L379-L379","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"mkLanguage","parameters":"o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkLanguage o = do\n    lang <- o A..:? \"language_prefix\"\n    maybe (pure \"LANGUAGE\") validate lang\n    where\n        validate :: String -> A.Parser String\n        validate s\n            | fmap toLower s == \"language\" = pure s\n            | otherwise = fail \"please provide a valid language prefix\"\n\n\n--------------------------------------------------------------------------------","function_tokens":["mkLanguage","o","=","do","lang","<-","o","A",".:?","\"language_prefix\"","maybe","(","pure","\"LANGUAGE\"",")","validate","lang","where","validate","::","String","->","A","Parser","String","validate","s","|","fmap","toLower","s","==","\"language\"","=","pure","s","|","otherwise","=","fail","\"please provide a valid language prefix\"","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L347-L358","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class\/Mutable.hs","language":"haskell","identifier":"write","parameters":"mat (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"write mat (i,j)\n    | i < 0 || i >= r || j < 0 || j >= c = error \"write: Index out of bounds\"\n    | otherwise = unsafeWrite mat (i,j)\n  where\n    (r,c) = dim mat","function_tokens":["write","mat","(","i",",","j",")","|","i","<","0","||","i",">=","r","||","j","<","0","||","j",">=","c","=","error","\"write: Index out of bounds\"","|","otherwise","=","unsafeWrite","mat","(","i",",","j",")","where","(","r",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class\/Mutable.hs#L32-L37","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class\/Mutable.hs","hash_val":20157,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_INVALID_OPERATION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_INVALID_OPERATION               = 0xA006","function_tokens":["alc_INVALID_OPERATION","=","0xA006"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L145-L145","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"nextThingItem","parameters":"(NextComment _)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"nextThingItem (NextComment _)           = False","function_tokens":["nextThingItem","(","NextComment","_",")","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L130-L130","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"both","parameters":"Both{}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"both Both{} = True","function_tokens":["both","Both","{","}","=","True"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L47-L47","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"prettyTonic","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyTonic a = case a of\n                0 -> \"C\"","function_tokens":["prettyTonic","a","=","case","a","of","0","->","\"C\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L510-L513","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Interpret.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = InterpretC","function_tokens":["lift","=","InterpretC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Interpret.hs#L94-L94","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Interpret.hs","hash_val":29980,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Device.hs","language":"haskell","identifier":"deviceSpecifier","parameters":"device","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains the specifier string for the given device.","docstring_summary":"------------------------------------------------------------------------------ Contains the specifier string for the given device.","docstring_tokens":["------------------------------------------------------------------------------","Contains","the","specifier","string","for","the","given","device","."],"function":"deviceSpecifier device = makeGettableStateVar $\n   getString (Just device) DeviceSpecifier","function_tokens":["deviceSpecifier","device","=","makeGettableStateVar","$","getString","(","Just","device",")","DeviceSpecifier"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Device.hs#L210-L211","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Device.hs","hash_val":14318,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"unpack","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unpack = map fst","function_tokens":["unpack","=","map","fst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L47-L47","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"dir","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dir = topdir <\/> x","function_tokens":["dir","=","topdir","<\/>","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L146-L146","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"dispatch","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dispatch = \\case\n  Help -> do\n    shell <- get\n    shellHelp shell\n  Echo ts ->\n    sayLn (text $ Text.intercalate \" \" ts)\n  SetPrompt prompt ->\n    modify' (\\s -> s {shellPrompt = text prompt})","function_tokens":["dispatch","=","\\","case","Help","->","do","shell","<-","get","shellHelp","shell","Echo","ts","->","sayLn","(","text","$","Text","intercalate","\" \"","ts",")","SetPrompt","prompt","->","modify'","(","\\","s","->","s","{","shellPrompt","=","text","prompt","}",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L62-L71","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"conjuncts","parameters":"e","argument_list":"","return_statement":"","docstring":"`conjuncts` decomposes a conjunction into conjuncts.","docstring_summary":"`conjuncts` decomposes a conjunction into conjuncts.","docstring_tokens":["conjuncts","decomposes","a","conjunction","into","conjuncts","."],"function":"conjuncts  e = fromMaybe [e] (conjuncts' e)","function_tokens":["conjuncts","e","=","fromMaybe","[","e","]","(","conjuncts'","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L447-L447","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mul''","parameters":"ms","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mul'' ms = case mapM toStaticallySorted ms of\n            Just ms' -> return . toDynamicallySorted . mul $ ms'\n            Nothing  -> fail \"mul of non-integral arguments\"","function_tokens":["mul''","ms","=","case","mapM","toStaticallySorted","ms","of","Just","ms'","->","return",".","toDynamicallySorted",".","mul","$","ms'","Nothing","->","fail","\"mul of non-integral arguments\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L138-L142","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"parserInfo","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"parserInfo = OA.info (OA.helper <*> parseStylishArgs) $\n    OA.fullDesc <>\n    OA.header stylishHaskellVersion","function_tokens":["parserInfo","=","OA","info","(","OA","helper","<*>","parseStylishArgs",")","$","OA","fullDesc","<>","OA","header","stylishHaskellVersion"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L88-L90","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"lookupNode","parameters":"inst id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookupNode inst id = runLookup go inst id\n    where go = startLookup sendS end checkSignal\n\n          -- Return Nothing on lookup failure\n          end = return Nothing\n\n          -- Check wether the Node we are looking for was found. If so, return\n          -- it, otherwise continue the lookup.\n          checkSignal (Signal _ (RETURN_NODES _ nodes)) =\n                case find (\\(Node _ nId) -> nId == id) nodes of\n                    Just node -> return . Just $ node\n                    _ -> continueLookup nodes sendS continue end\n\n          -- Continuing always means waiting for the next signal\n          continue = waitForReply end checkSignal\n\n          -- Send a FIND_NODE command looking for the Node corresponding to the\n          -- id\n          sendS = sendSignal (FIND_NODE id)\n\n-- | The state of a lookup","function_tokens":["lookupNode","inst","id","=","runLookup","go","inst","id","where","go","=","startLookup","sendS","end","checkSignal","-- Return Nothing on lookup failure","end","=","return","Nothing","-- Check wether the Node we are looking for was found. If so, return","-- it, otherwise continue the lookup.","checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","case","find","(","\\","(","Node","_","nId",")","->","nId","==","id",")","nodes","of","Just","node","->","return",".","Just","$","node","_","->","continueLookup","nodes","sendS","continue","end","-- Continuing always means waiting for the next signal","continue","=","waitForReply","end","checkSignal","-- Send a FIND_NODE command looking for the Node corresponding to the","-- id","sendS","=","sendSignal","(","FIND_NODE","id",")","-- | The state of a lookup"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L162-L183","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"put","parameters":"ns","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"put ns = RSST $ \\_ (_,w) -> return ((),(ns,w))","function_tokens":["put","ns","=","RSST","$","\\","_","(","_",",","w",")","->","return","(","(",")",",","(","ns",",","w",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L173-L173","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"enabledMakeStandardJsonIbBps","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"enabledMakeStandardJsonIbBps = C.avx_2 && C.sse_4_2 && C.bmi_2","function_tokens":["enabledMakeStandardJsonIbBps","=","C","avx_2","&&","C","sse_4_2","&&","C","bmi_2"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L112-L112","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"readShpFile","parameters":"fp","argument_list":"","return_statement":"","docstring":"Read shapefile at `fp` to resident data structure `ShpData`","docstring_summary":"Read shapefile at `fp` to resident data structure `ShpData`","docstring_tokens":["Read","shapefile","at","fp","to","resident","data","structure","ShpData"],"function":"readShpFile fp = readShpData <$> BL.readFile fp","function_tokens":["readShpFile","fp","=","readShpData","<$>","BL","readFile","fp"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L24-L24","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"newKnown","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newKnown = take 7 . filter (`notElem` polled) $ nodes ++ known","function_tokens":["newKnown","=","take","7",".","filter","(","`","notElem","`","polled",")","$","nodes","++","known"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L288-L288","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Doppler.hs","language":"haskell","identifier":"makeDopplerVar","parameters":"p apiEntryName","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"makeDopplerVar p apiEntryName =\n   makeStateVar\n      (alGetFloat (marshalGetPName p))\n      (\\value -> do\n         -- ToDo: Should we check alcVersion or alIsExtensionPresent here?\n         funPtr <- get (alProcAddress apiEntryName)\n         invokeWithFloat funPtr value)","function_tokens":["makeDopplerVar","p","apiEntryName","=","makeStateVar","(","alGetFloat","(","marshalGetPName","p",")",")","(","\\","value","->","do","-- ToDo: Should we check alcVersion or alIsExtensionPresent here?","funPtr","<-","get","(","alProcAddress","apiEntryName",")","invokeWithFloat","funPtr","value",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Doppler.hs#L66-L72","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Doppler.hs","hash_val":10218,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"keyIndex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"keyIndex = reflect (Proxy :: Proxy key)","function_tokens":["keyIndex","=","reflect","(","Proxy","::","Proxy","key",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L288-L288","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"errorLength","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"errorLength = round $ len * stdErr","function_tokens":["errorLength","=","round","$","len","*","stdErr"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L415-L415","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"diffWeight","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"diffWeight = fromIntegral weight * (time - mean)","function_tokens":["diffWeight","=","fromIntegral","weight","*","(","time","-","mean",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L383-L383","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Environment.hs","language":"haskell","identifier":"openEditor","parameters":"opts path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"openEditor opts path\n    | shouldUseEditor opts =\n        do  editor <- getEnv \"EDITOR\"\n            callProcess editor [path]\n    | otherwise = pure ()","function_tokens":["openEditor","opts","path","|","shouldUseEditor","opts","=","do","editor","<-","getEnv","\"EDITOR\"","callProcess","editor","[","path","]","|","otherwise","=","pure","(",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Environment.hs#L61-L65","hash_key":"Peaker\/git-mediate:src\/Environment.hs","hash_val":17949,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"nameFromBinder","parameters":"(KindedTV n _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nameFromBinder (KindedTV n _ _) = n","function_tokens":["nameFromBinder","(","KindedTV","n","_","_",")","=","n"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L673-L673","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"clean","parameters":"Cabal","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"clean Cabal = callProcess \"cabal\" [\"v2-clean\"]","function_tokens":["clean","Cabal","=","callProcess","\"cabal\"","[","\"v2-clean\"","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L34-L34","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"curry","parameters":"m i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"curry m i = m . (const i &&& id)","function_tokens":["curry","m","i","=","m",".","(","const","i","&&&","id",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L163-L163","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mergeConstMul","parameters":"e (acc, r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeConstMul e (acc, r) = case match e of\n    Just (Const c) -> (acc * c, r)\n    _              -> (acc, e : r)\n\n-- | A smart constructor for a binary multiplication","function_tokens":["mergeConstMul","e","(","acc",",","r",")","=","case","match","e","of","Just","(","Const","c",")","->","(","acc","*","c",",","r",")","_","->","(","acc",",","e",":","r",")","-- | A smart constructor for a binary multiplication"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L180-L185","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"compressed","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compressed = case o of\n        GenericOrigin -> Store\n        Borrowed ed -> edCompression ed","function_tokens":["compressed","=","case","o","of","GenericOrigin","->","Store","Borrowed","ed","->","edCompression","ed"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L495-L498","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"partition","parameters":"predicate t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"partition predicate t\n  = case t of\n      Bin _ _ p m l r\n        -> let (l1,l2) = partition predicate l\n               (r1,r2) = partition predicate r\n           in (bin p m l1 r1, bin p m l2 r2)\n      Tip _ x\n        | predicate x -> (t,Nil)\n        | otherwise   -> (Nil,t)\n      Nil -> (Nil,Nil)\n\n\n-- | \/O(min(n,W))\/. The expression (@'split' x set@) is a pair @(set1,set2)@\n-- where @set1@ comprises the elements of @set@ less than @x@ and @set2@\n-- comprises the elements of @set@ greater than @x@.\n--\n-- > split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])","function_tokens":["partition","predicate","t","=","case","t","of","Bin","_","_","p","m","l","r","->","let","(","l1",",","l2",")","=","partition","predicate","l","(","r1",",","r2",")","=","partition","predicate","r","in","(","bin","p","m","l1","r1",",","bin","p","m","l2","r2",")","Tip","_","x","|","predicate","x","->","(","t",",","Nil",")","|","otherwise","->","(","Nil",",","t",")","Nil","->","(","Nil",",","Nil",")","-- | \/O(min(n,W))\/. The expression (@'split' x set@) is a pair @(set1,set2)@","-- where @set1@ comprises the elements of @set@ less than @x@ and @set2@","-- comprises the elements of @set@ greater than @x@.","--","-- > split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L509-L526","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"chunks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"chunks = makeSimpleJsonIbBpsUnsafe contents","function_tokens":["chunks","=","makeSimpleJsonIbBpsUnsafe","contents"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L37-L37","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"showE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showE = fix go\n  where go f n | n < 0 = B.charUtf8 '\u207b' <> f (abs n)\n               | n < 10 = B.charUtf8 $ \"\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\" !! fromIntegral n\n               | otherwise = uncurry ((<>) `on` f) $ divMod n 10","function_tokens":["showE","=","fix","go","where","go","f","n","|","n","<","0","=","B","charUtf8","'\u207b' <"," f","(","b","s n","","","|","n","<","10","=","B","charUtf8","$","\"\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\" !! fromIntegral ","","","","|","otherwise","=","uncurry","(","(","<>",")","`","on","`","f",")","$","divMod","n","10"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L365-L370","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = do\n  let shell =\n        Shell\n          { shellPrefs = O.defaultPrefs,\n            shellInfo = O.info parser (O.progDesc \"Simple shell\"),\n            shellPrompt = \"byline> \"\n          }\n  void $ runBylineT (go shell)\n  where\n    go :: MonadByline m => Shell Command -> m ()\n    go shell = do\n      sayLn (text \"Starting shell, use ^D to exit\")\n      pushCompletionFunction (shellCompletion shell)\n      (`evalStateT` shell) $ forever (get >>= runShell dispatch)","function_tokens":["main","=","do","let","shell","=","Shell","{","shellPrefs","=","O","defaultPrefs",",","shellInfo","=","O","info","parser","(","O","progDesc","\"Simple shell\"",")",",","shellPrompt","=","\"byline> \"","}","void","$","runBylineT","(","go","shell",")","where","go","::","MonadByline","m","=>","Shell","Command","->","m","(",")","go","shell","=","do","sayLn","(","text","\"Starting shell, use ^D to exit\"",")","pushCompletionFunction","(","shellCompletion","shell",")","(","`","evalStateT","`","shell",")","$","forever","(","get",">>=","runShell","dispatch",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L72-L85","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"bin","parameters":"_ _ l Nil","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\n@bin@ assures that we never have empty trees within a tree.\n------------------------------------------------------------------}","docstring_summary":"{--------------------------------------------------------------------","docstring_tokens":["{","--------------------------------------------------------------------"],"function":"bin _ _ l Nil = l","function_tokens":["bin","_","_","l","Nil","=","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L184-L184","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"s'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s' = \"\\\"\" <> s <> \"\\\"\"","function_tokens":["s'","=","\"\\\"\"","<>","s","<>","\"\\\"\""],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L496-L496","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"makeSimpleJsonIbBpsUnsafe","parameters":"lbs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeSimpleJsonIbBpsUnsafe lbs = L.zipPadded BS.empty BS.empty ibs bps\n  where chunks  = makeIbs lbs\n        ibs     = fmap (\\(a, _, _) -> a) chunks\n        bps     = ibsToIndexByteStrings chunks","function_tokens":["makeSimpleJsonIbBpsUnsafe","lbs","=","L","zipPadded","BS","empty","BS","empty","ibs","bps","where","chunks","=","makeIbs","lbs","ibs","=","fmap","(","\\","(","a",",","_",",","_",")","->","a",")","chunks","bps","=","ibsToIndexByteStrings","chunks"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L37-L42","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Chord_ (pitches, dur))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (Chord_ (pitches, dur))  =\n        brackets (sepBy \"\" (fmap pretty pitches)) <> pretty dur","function_tokens":["pretty","(","Chord_","(","pitches",",","dur",")",")","=","brackets","(","sepBy","\"\"","(","fmap","pretty","pitches",")",")","<>","pretty","dur"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L216-L217","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"sendS","parameters":"","argument_list":"","return_statement":"","docstring":"Send a FIND_NODE command, looking for the node corresponding to the key","docstring_summary":"Send a FIND_NODE command, looking for the node corresponding to the key","docstring_tokens":["Send","a","FIND_NODE","command","looking","for","the","node","corresponding","to","the","key"],"function":"sendS = sendSignal (FIND_NODE key)","function_tokens":["sendS","=","sendSignal","(","FIND_NODE","key",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L103-L103","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"x","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x = var n","function_tokens":["x","=","var","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L763-L763","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = dur a","function_tokens":["d","=","dur","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L150-L150","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtToMap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"districtToMap = districtToMapLens districtLabel","function_tokens":["districtToMap","=","districtToMapLens","districtLabel"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L54-L54","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_BUFFER","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_BUFFER                           = 0x1009","function_tokens":["al_BUFFER","=","0x1009"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L80-L80","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Empty\/Maybe.hs","language":"haskell","identifier":"evalEmpty","parameters":"","argument_list":"","return_statement":"","docstring":"Run an 'Empty' effect, discarding its result.  This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.  @ 'evalEmpty' = 'void' '.' 'runEmpty' @  @since 1.1.0.0","docstring_summary":"Run an 'Empty' effect, discarding its result.  This is convenient for using 'empty' to signal early returns without needing to know whether control exited normally or not.","docstring_tokens":["Run","an","Empty","effect","discarding","its","result",".","This","is","convenient","for","using","empty","to","signal","early","returns","without","needing","to","know","whether","control","exited","normally","or","not","."],"function":"evalEmpty = void . runEmpty","function_tokens":["evalEmpty","=","void",".","runEmpty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Empty\/Maybe.hs#L58-L58","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Empty\/Maybe.hs","hash_val":35180,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"within","parameters":"t0 t1 e","argument_list":"","return_statement":"","docstring":"Tests if given 'Event' happens between two time stamps.","docstring_summary":"Tests if given 'Event' happens between two time stamps.","docstring_tokens":["Tests","if","given","Event","happens","between","two","time","stamps","."],"function":"within t0 t1 e = within' t0 t1 (eventStart e) && within' t0 t1 (eventEnd e)\n    where within' a b x = x >= a && x <= b\n\n-- | General mapping. Maps not only values but events.","function_tokens":["within","t0","t1","e","=","within'","t0","t1","(","eventStart","e",")","&&","within'","t0","t1","(","eventEnd","e",")","where","within'","a","b","x","=","x",">=","a","&&","x","<=","b","-- | General mapping. Maps not only values but events."],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L220-L224","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"rss","parameters":"f","argument_list":"","return_statement":"","docstring":"Construct an RSS computation from a function. (The inverse of 'runRSS'.)","docstring_summary":"Construct an RSS computation from a function. (The inverse of 'runRSS'.)","docstring_tokens":["Construct","an","RSS","computation","from","a","function",".","(","The","inverse","of","runRSS",".",")"],"function":"rss f = RSST $ \\r (s,w) -> let (a,s',w') = f r s\n                           in  Identity (a, (s', w <> w'))","function_tokens":["rss","f","=","RSST","$","\\","r","(","s",",","w",")","->","let","(","a",",","s'",",","w'",")","=","f","r","s","in","Identity","(","a",",","(","s'",",","w","<>","w'",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L44-L45","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class\/Mutable.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,c) = dim mat","function_tokens":["(","r",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class\/Mutable.hs#L36-L36","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class\/Mutable.hs","hash_val":20157,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unsafeFromVector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFromVector = MG.unsafeFromVector","function_tokens":["unsafeFromVector","=","MG","unsafeFromVector"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L138-L138","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"writer","parameters":"(a,w)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"writer (a,w) = tell w >> return a","function_tokens":["writer","(","a",",","w",")","=","tell","w",">>","return","a"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L188-L188","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(AddExtraField _ _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (AddExtraField _ _ s) = Just s","function_tokens":["targetEntry","(","AddExtraField","_","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1061-L1061","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"fromCompressionMethod","parameters":"Store","argument_list":"","return_statement":"","docstring":"Convert 'CompressionMethod' to its numeric representation as per the .ZIP specification.","docstring_summary":"Convert 'CompressionMethod' to its numeric representation as per the .ZIP specification.","docstring_tokens":["Convert","CompressionMethod","to","its","numeric","representation","as","per","the",".","ZIP","specification","."],"function":"fromCompressionMethod Store = 0","function_tokens":["fromCompressionMethod","Store","=","0"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1118-L1118","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"toBinary","parameters":"","argument_list":"","return_statement":"","docstring":"Converts a Word16 into a two character ByteString","docstring_summary":"Converts a Word16 into a two character ByteString","docstring_tokens":["Converts","a","Word16","into","a","two","character","ByteString"],"function":"toBinary = B.concat . L.toChunks . toLazyByteString . word16BE","function_tokens":["toBinary","=","B","concat",".","L","toChunks",".","toLazyByteString",".","word16BE"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L51-L51","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"backtrack","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"backtrack = mapM_ leftover =<< withBuffer resetBuffer","function_tokens":["backtrack","=","mapM_","leftover","=<<","withBuffer","resetBuffer"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L134-L134","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"and","parameters":"as","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"and as  = foldr (.&.) true as","function_tokens":["and","as","=","foldr","(",".&.",")","true","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L510-L510","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unsafeFromVector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFromVector = MG.unsafeFromVector","function_tokens":["unsafeFromVector","=","MG","unsafeFromVector"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L138-L138","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_OUT_OF_MEMORY","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_OUT_OF_MEMORY                    = 0xA005","function_tokens":["al_OUT_OF_MEMORY","=","0xA005"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L36-L36","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"noWrap'","parameters":"ss (str:strs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"noWrap' ss (str:strs) = noWrap' (ss ++ \" \" ++ str) strs","function_tokens":["noWrap'","ss","(","str",":","strs",")","=","noWrap'","(","ss","++","\" \"","++","str",")","strs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L129-L129","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"makeFoldersSVG","parameters":"maps","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeFoldersSVG maps = do\n    createDirectoryIfMissing False \"maps\"\n    mapM_ (\\m -> mkMapSVG (\"maps\/\" <> (view title m) <> \".svg\") m) maps","function_tokens":["makeFoldersSVG","maps","=","do","createDirectoryIfMissing","False","\"maps\"","mapM_","(","\\","m","->","mkMapSVG","(","\"maps\/\"","<>","(","view","title","m",")","<>","\".svg\"",")","m",")","maps"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L31-L33","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/Setup.hs#L2-L2","hash_key":"spell-music\/temporal-media:Setup.hs","hash_val":25118,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"readPrec","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readPrec = parens $ prec 10 $ do\n    Ident \"fromList\" <- lexP\n    xs <- readPrec\n    return (fromList xs)","function_tokens":["readPrec","=","parens","$","prec","10","$","do","Ident","\"fromList\"","<-","lexP","xs","<-","readPrec","return","(","fromList","xs",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L875-L880","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"distA","parameters":"(District _ label _ area _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"distA (District _ label _ area _) = (label, sum area)","function_tokens":["distA","(","District","_","label","_","area","_",")","=","(","label",",","sum","area",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L27-L27","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for implication (an abbreviation for @not a .|. b@)","docstring_summary":"A smart constructor for implication (an abbreviation for","docstring_tokens":["A","smart","constructor","for","implication","(","an","abbreviation","for"],"function":"a .->. b = not a .|. b","function_tokens":["a",".->.","b","=","not","a",".|.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L478-L478","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_ == _ = False","function_tokens":["_","==","_","=","False"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L839-L839","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"(RETURN_NODES id kb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandArgs (RETURN_NODES id kb) = toBS id `B.append`\n                                   foldl' B.append B.empty (fmap nodeToArg kb)","function_tokens":["commandArgs","(","RETURN_NODES","id","kb",")","=","toBS","id","`","B","append","`","foldl'","B","append","B","empty","(","fmap","nodeToArg","kb",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L42-L43","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Accum.hs","language":"haskell","identifier":"look","parameters":"","argument_list":"","return_statement":"","docstring":"Look up the previous accumulation  @ 'runAccum' w 'look' = 'return' (w, w) 'runAccum' w ('look' >>= continuation) = 'runAccum' w (continuation w) @  @since 1.1.2.0","docstring_summary":"Look up the previous accumulation","docstring_tokens":["Look","up","the","previous","accumulation"],"function":"look = send Look","function_tokens":["look","=","send","Look"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Accum.hs#L54-L54","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Accum.hs","hash_val":45199,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putObjectId","parameters":"(Oid x y)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putObjectId (Oid x y) = putWord32be x >> putWord64be y","function_tokens":["putObjectId","(","Oid","x","y",")","=","putWord32be","x",">>","putWord64be","y"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L221-L221","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Opts.hs","language":"haskell","identifier":"parser","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser =\n    O.flag' CmdVersion (O.long \"version\" <> O.help \"Print the version and quit\")\n    <|> CmdOptions\n        <$> ( Options\n            <$> O.switch\n                ( O.long \"editor\" <> O.short 'e'\n                  <> O.help \"Execute $EDITOR for each conflicted file that remains conflicted\"\n                )\n            <*> O.switch\n                ( O.long \"diff\" <> O.short 'd'\n                  <> O.help \"Dump the left\/right diffs from base in each conflict remaining\"\n                )\n            <*> O.switch\n                ( O.long \"diff2\" <> O.short '2'\n                  <> O.help \"Dump the diff between left and right in each conflict remaining\"\n                )\n            <*> ( O.flag' (Just EnableColor)\n                  (O.long \"color\" <> O.short 'c' <> O.help \"Enable color\")\n                  <|> O.flag' (Just DisableColor)\n                      (O.long \"no-color\" <> O.short 'C' <> O.help \"Disable color\")\n                  <|> pure Nothing\n                )\n            <*> O.switch\n                ( O.long \"style\" <> O.short 's'\n                  <> O.help \"Configure git's global merge.conflictstyle to diff3 if needed\"\n                )\n            <*> O.optional\n                ( O.option O.auto\n                    ( O.long \"untabify\" <> O.metavar \"TABSIZE\"\n                        <> O.help \"Convert tabs to the spaces at the tab stops for the given tab size\"\n                    )\n                )\n            <*> O.optional\n                ( O.strOption\n                    ( O.long \"merge-file\" <> O.short 'f' <> O.help \"Merge a specific file\")\n                )\n            <*> O.option O.auto\n                (O.long \"context\" <> O.short 'U' <> O.metavar \"LINECOUNT\" <> O.showDefault <> O.value 3\n                    <> O.help \"Number of context lines around dumped diffs\"\n                )\n            )","function_tokens":["parser","=","O","flag'","CmdVersion","(","O","long","\"version\"","<>","O","help","\"Print the version and quit\"",")","<|>","CmdOptions","<$>","(","Options","<$>","O","switch","(","O","long","\"editor\"","<>","O","short","'e'","<>","O","help","\"Execute $EDITOR for each conflicted file that remains conflicted\"",")","<*>","O","switch","(","O","long","\"diff\"","<>","O","short","'d'","<>","O","help","\"Dump the left\/right diffs from base in each conflict remaining\"",")","<*>","O","switch","(","O","long","\"diff2\"","<>","O","short","'2'","<>","O","help","\"Dump the diff between left and right in each conflict remaining\"",")","<*>","(","O","flag'","(","Just","EnableColor",")","(","O","long","\"color\"","<>","O","short","'c'","<>","O","help","\"Enable color\"",")","<|>","O","flag'","(","Just","DisableColor",")","(","O","long","\"no-color\"","<>","O","short","'C'","<>","O","help","\"Disable color\"",")","<|>","pure","Nothing",")","<*>","O","switch","(","O","long","\"style\"","<>","O","short","'s'","<>","O","help","\"Configure git's global merge.conflictstyle to diff3 if needed\"",")","<*>","O","optional","(","O","option","O","auto","(","O","long","\"untabify\"","<>","O","metavar","\"TABSIZE\"","<>","O","help","\"Convert tabs to the spaces at the tab stops for the given tab size\"",")",")","<*>","O","optional","(","O","strOption","(","O","long","\"merge-file\"","<>","O","short","'f'","<>","O","help","\"Merge a specific file\"",")",")","<*>","O","option","O","auto","(","O","long","\"context\"","<>","O","short","'U'","<>","O","metavar","\"LINECOUNT\"","<>","O","showDefault","<>","O","value","3","<>","O","help","\"Number of context lines around dumped diffs\"",")",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Opts.hs#L29-L69","hash_key":"Peaker\/git-mediate:src\/Opts.hs","hash_val":22726,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmp","parameters":"(Tip _ x) t","argument_list":"","return_statement":"","docstring":"disjoint","docstring_summary":"disjoint","docstring_tokens":["disjoint"],"function":"subsetCmp (Tip _ x) t\n  | member x t = LT\n  | otherwise  = GT","function_tokens":["subsetCmp","(","Tip","_","x",")","t","|","member","x","t","=","LT","|","otherwise","=","GT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L473-L475","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"getColor","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getColor f = unOne (f mod)","function_tokens":["getColor","f","=","unOne","(","f","mod",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L236-L236","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"go","parameters":"((pos,m), s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go ((pos,m), s) = handleJust (\\e -> if e == UserInterrupt then Just s else Nothing) pure $\n        let (BenchmarkMeta{..}, s') = S.deleteFindMin s in do\n              ana <- analysis <$> step benchmark\n              let newMax | pos == position = (pos, mean ana)\n                         | mean ana > m = (position, mean ana)\n                         | otherwise = (pos, m)\n                  new = BenchmarkMeta (informationOf ana) (snd newMax) position benchmark{analysis = ana}\n                  set = S.insert new s'\n              mask_ $ pp new set\n\n              timeup <- case timeout cfg of\n                Just to -> do\n                  Time end <- now\n                  pure $ fromIntegral (end - start) \/ 1e9 >= to\n                Nothing -> pure False\n\n              if terminates set || timeup\n                 then pure set\n                 else go (newMax, set)","function_tokens":["go","(","(","pos",",","m",")",",","s",")","=","handleJust","(","\\","e","->","if","e","==","UserInterrupt","then","Just","s","else","Nothing",")","pure","$","let","(","BenchmarkMeta","{","..","}",",","s'",")","=","S","deleteFindMin","s","in","do","ana","<-","analysis","<$>","step","benchmark","let","newMax","|","pos","==","position","=","(","pos",",","mean","ana",")","|","mean","ana",">","m","=","(","position",",","mean","ana",")","|","otherwise","=","(","pos",",","m",")","new","=","BenchmarkMeta","(","informationOf","ana",")","(","snd","newMax",")","position","benchmark","{","analysis","=","ana","}","set","=","S","insert","new","s'","mask_","$","pp","new","set","timeup","<-","case","timeout","cfg","of","Just","to","->","do","Time","end","<-","now","pure","$","fromIntegral","(","end","-","start",")","\/","1e9",">=","to","Nothing","->","pure","False","if","terminates","set","||","timeup","then","pure","set","else","go","(","newMax",",","set",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L255-L275","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseTrailingWhitespace","parameters":"_ _","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"parseTrailingWhitespace _ _ = return TrailingWhitespace.step","function_tokens":["parseTrailingWhitespace","_","_","=","return","TrailingWhitespace","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L365-L365","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"zip64ef","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip64ef =\n        makeZip64ExtraField\n          headerType\n          Zip64ExtraField\n            { z64efUncompressedSize = edUncompressedSize,\n              z64efCompressedSize = edCompressedSize,\n              z64efOffset = edOffset\n            }","function_tokens":["zip64ef","=","makeZip64ExtraField","headerType","Zip64ExtraField","{","z64efUncompressedSize","=","edUncompressedSize",",","z64efCompressedSize","=","edCompressedSize",",","z64efOffset","=","edOffset","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L835-L842","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"mantissa","parameters":"(d:ds)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mantissa (d:ds) = B.intDec d <> B.char7 '.' <> foldMap B.intDec ds","function_tokens":["mantissa","(","d",":","ds",")","=","B","intDec","d","<>","B","char7","'.'","<>","foldMap","B","intDec","ds"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L358-L358","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"getter","parameters":"failing total (Field mn _ _ (cons, _))","argument_list":"","return_statement":"","docstring":"-----------------------------------------------------------------------------","docstring_summary":"-----------------------------------------------------------------------------","docstring_tokens":["-----------------------------------------------------------------------------"],"function":"getter failing total (Field mn _ _ (cons, _)) =\n  do let pt = mkName \"f\"\n         nm = maybe (tupE []) (litE . StringL . nameBase) (guard failing >> mn)\n         wild = if total then [] else [match wildP (normalB [| Left $(nm) |]) []]\n         rght = if total then id else appE [| Right |]\n         mkCase (Context i _ c) = map (\\(pat, var) -> match pat (normalB (rght var)) []) (case1 i c)\n     lamE [varP pt]\n          (caseE (varE pt) (concatMap mkCase cons ++ wild))\n  where\n  case1 :: Int -> Con -> [(Q Pat, Q Exp)]\n  case1 i con =\n    case con of\n      NormalC  c  fs   -> [one fs c]\n      RecC     c  fs   -> [one fs c]\n      InfixC   _  c  _ -> [(infixP (pats !! 0) c (pats !! 1), var)]\n      ForallC  _  _  c -> case1 i c\n#if MIN_VERSION_template_haskell(2,11,0)\n      GadtC    cs fs _ -> map (one fs) cs\n      RecGadtC cs fs _ -> map (one fs) cs\n#endif\n    where fresh = mkName <$> delete \"f\" freshNames\n          pats1 = varP <$> fresh\n          pats  = replicate i wildP ++ [pats1 !! i] ++ repeat wildP\n          var   = varE (fresh !! i)\n          one fs c = let s = take (length fs) in (conP c (s pats), var)","function_tokens":["getter","failing","total","(","Field","mn","_","_","(","cons",",","_",")",")","=","do","let","pt","=","mkName","\"f\"","nm","=","maybe","(","tupE","[","]",")","(","litE",".","StringL",".","nameBase",")","(","guard","failing",">>","mn",")","wild","=","if","total","then","[","]","else","[","match","wildP","(","normalB","[","|"," Left $(nm) ","|]",")","[","]","]","rght","=","if","total","then","id","else","appE","[","|"," Right ","|]","mkCase","(","Context","i","_","c",")","=","map","(","\\","(","pat",",","var",")","->","match","pat","(","normalB","(","rght","var",")",")","[","]",")","(","case1","i","c",")","lamE","[","varP","pt","]","(","caseE","(","varE","pt",")","(","concatMap","mkCase","cons","++","wild",")",")","where","case1","::","Int","->","Con","->","[","(","Q","Pat",",","Q","Exp",")","]","case1","i","con","=","case","con","of","NormalC","c","fs","->","[","one","fs","c","]","RecC","c","fs","->","[","one","fs","c","]","InfixC","_","c","_","->","[","(","infixP","(","pats","!!","0",")","c","(","pats","!!","1",")",",","var",")","]","ForallC","_","_","c","->","case1","i","c","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","cs","fs","_","->","map","(","one","fs",")","cs","RecGadtC","cs","fs","_","->","map","(","one","fs",")","cs","#endif","where","fresh","=","mkName","<$>","delete","\"f\"","freshNames","pats1","=","varP","<$>","fresh","pats","=","replicate","i","wildP","++","[","pats1","!!","i","]","++","repeat","wildP","var","=","varE","(","fresh","!!","i",")","one","fs","c","=","let","s","=","take","(","length","fs",")","in","(","conP","c","(","s","pats",")",",","var",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L495-L521","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = AccumC $ \\w -> case sig of\n    L accum -> case accum of\n      Add w' -> pure (w', ctx)\n      Look   -> pure (mempty, w <$ ctx)\n    R other  -> thread (uncurry runAccum ~<~ hdl) other (w, ctx)","function_tokens":["alg","hdl","sig","ctx","=","AccumC","$","\\","w","->","case","sig","of","L","accum","->","case","accum","of","Add","w'","->","pure","(","w'",",","ctx",")","Look","->","pure","(","mempty",",","w","<$","ctx",")","R","other","->","thread","(","uncurry","runAccum","~<~","hdl",")","other","(","w",",","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L131-L136","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"dst","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))","function_tokens":["dst","=","run",".","runChoose","(","liftA2","(","liftA2","(","<|>",")",")",")","(","pure",".","runChoose","(","liftA2","(","<|>",")",")","(","pure",".","pure",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L105-L105","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"itraverse","parameters":"f (Not n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Not n) = Not <$> f n","function_tokens":["itraverse","f","(","Not","n",")","=","Not","<$>","f","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L381-L381","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"firstChar","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"firstChar = case openBracket conf of\n        SameLine -> \" \"\n        NextLine -> \"(\"","function_tokens":["firstChar","=","case","openBracket","conf","of","SameLine","->","\" \"","NextLine","->","\"(\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L215-L219","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"copyItem","parameters":"chatty baseSourcePath baseTargetPath (isDir, relativePath)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"copyItem chatty baseSourcePath baseTargetPath (isDir, relativePath) = do\n  let sourcePath = baseSourcePath <\/> relativePath\n  let targetPath = baseTargetPath <\/> relativePath\n\n  when chatty $\n    printf \"Copying %s to %s\\n\" sourcePath targetPath\n\n  if isDir\n    then createDirectoryIfMissing False targetPath\n    else copyFile sourcePath targetPath","function_tokens":["copyItem","chatty","baseSourcePath","baseTargetPath","(","isDir",",","relativePath",")","=","do","let","sourcePath","=","baseSourcePath","<\/>","relativePath","let","targetPath","=","baseTargetPath","<\/>","relativePath","when","chatty","$","printf","\"Copying %s to %s\\n\"","sourcePath","targetPath","if","isDir","then","createDirectoryIfMissing","False","targetPath","else","copyFile","sourcePath","targetPath"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L50-L59","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrRemBits","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits","function_tokens":["ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L61-L61","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"lessThan''","parameters":"a b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lessThan'' a b = case mapM toStaticallySorted [a, b] of\n            Just [a', b'] -> return . toDynamicallySorted $ a' .<. b'\n            _             -> fail \"less-than of non-integral arguments\"\n\n-- | A smart constructor for integer constants","function_tokens":["lessThan''","a","b","=","case","mapM","toStaticallySorted","[","a",",","b","]","of","Just","[","a'",",","b'","]","->","return",".","toDynamicallySorted","$","a'",".<.","b'","_","->","fail","\"less-than of non-integral arguments\"","-- | A smart constructor for integer constants"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L146-L151","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"origin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"origin = replyOrigin registration","function_tokens":["origin","=","replyOrigin","registration"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L128-L128","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ChooseC a >>= f = ChooseC $ \\ fork leaf ->\n    a fork (runChoose fork leaf . f)","function_tokens":["ChooseC","a",">>=","f","=","ChooseC","$","\\","fork","leaf","->","a","fork","(","runChoose","fork","leaf",".","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L72-L73","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"nameFromBinder","parameters":"(PlainTV  n  _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nameFromBinder (PlainTV  n  _) = n","function_tokens":["nameFromBinder","(","PlainTV","n","_",")","=","n"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L672-L672","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Extensions.hs","language":"haskell","identifier":"alProcAddress","parameters":"funcName","argument_list":"","return_statement":"","docstring":"To retrieving function entry addresses, applications can use 'alProcAddress'. It contains 'nullFunPtr' if no entry point with the given name can be found. Implementations are free to use 'nullFunPtr' if an entry point is present, but not applicable for the current context. However the specification does not guarantee this behavior. Applications can use 'alProcAddress' to obtain core API entry points, not just extensions. This is the recommended way to dynamically load and unload OpenAL DLLs as sound drivers.","docstring_summary":"To retrieving function entry addresses, applications can use 'alProcAddress'. It contains 'nullFunPtr' if no entry point with the given name can be found. Implementations are free to use 'nullFunPtr' if an entry point is present, but not applicable for the current context. However the specification does not guarantee this behavior. Applications can use 'alProcAddress' to obtain core API entry points, not just extensions. This is the recommended way to dynamically load and unload OpenAL DLLs as sound drivers.","docstring_tokens":["To","retrieving","function","entry","addresses","applications","can","use","alProcAddress",".","It","contains","nullFunPtr","if","no","entry","point","with","the","given","name","can","be","found",".","Implementations","are","free","to","use","nullFunPtr","if","an","entry","point","is","present","but","not","applicable","for","the","current","context",".","However","the","specification","does","not","guarantee","this","behavior",".","Applications","can","use","alProcAddress","to","obtain","core","API","entry","points","not","just","extensions",".","This","is","the","recommended","way","to","dynamically","load","and","unload","OpenAL","DLLs","as","sound","drivers","."],"function":"alProcAddress funcName = makeGettableStateVar $\n   withALString funcName alGetProcAddress","function_tokens":["alProcAddress","funcName","=","makeGettableStateVar","$","withALString","funcName","alGetProcAddress"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Extensions.hs#L85-L86","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Extensions.hs","hash_val":40318,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"injLabelled","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"injLabelled = id","function_tokens":["injLabelled","=","id"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L85-L85","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseUnicodeSyntax","parameters":"_ o","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"parseUnicodeSyntax _ o = UnicodeSyntax.step\n    <$> o A..:? \"add_language_pragma\" A..!= True\n    <*> mkLanguage o","function_tokens":["parseUnicodeSyntax","_","o","=","UnicodeSyntax","step","<$>","o","A",".:?","\"add_language_pragma\"","A",".!=","True","<*>","mkLanguage","o"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L370-L372","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"show","parameters":"(NextItemWithComment i c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (NextItemWithComment i c) =\n        \"NextItemWithComment \" ++ showOutputable i ++ \" \" ++ showOutputable c","function_tokens":["show","(","NextItemWithComment","i","c",")","=","\"NextItemWithComment \"","++","showOutputable","i","++","\" \"","++","showOutputable","c"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L124-L125","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"mWhen","parameters":"t x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mWhen t x = if t then x else mempty","function_tokens":["mWhen","t","x","=","if","t","then","x","else","mempty"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L230-L230","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"flatten","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten e = case match e of\n        Just (Const 1) -> []\n        Just (Mul ms)  -> ms\n        _              -> [e]\n\n-- | A smart constructor for a variadic addition","function_tokens":["flatten","e","=","case","match","e","of","Just","(","Const","1",")","->","[","]","Just","(","Mul","ms",")","->","ms","_","->","[","e","]","-- | A smart constructor for a variadic addition"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L191-L197","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"alignment","parameters":"~(Buffer b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alignment ~(Buffer b) = alignment b","function_tokens":["alignment","~","(","Buffer","b",")","=","alignment","b"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L57-L57","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' = return . inject","function_tokens":["flatten'","=","return",".","inject"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L867-L867","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"askUntil","parameters":"prompt def confirm","argument_list":"","return_statement":"","docstring":"Continue to prompt for a response until a confirmation function returns a valid result.  @since 1.0.0.0","docstring_summary":"Continue to prompt for a response until a confirmation function returns a valid result.","docstring_tokens":["Continue","to","prompt","for","a","response","until","a","confirmation","function","returns","a","valid","result","."],"function":"askUntil prompt def confirm = go\n  where\n    go = do\n      answer <- askLn prompt def\n      confirm answer >>= \\case\n        Left msg -> sayLn msg >> go\n        Right res -> pure res\n\n-- $use\n--\n--  Byline provides a monad transformer that allows you to compose\n-- interactive terminal actions.  When producing output,\n-- these actions accept stylized text that can include\n-- foreground and background colors, underlined text, and\n-- bold text.\n--\n-- Stylized text can be constructed with string literals\n-- (using the @OverloadedStrings@ extension) or using the\n-- 'text' function.  Attributes such as color can be changed\n-- using modifier functions and the 'Semigroup' @(<>)@ operator.\n--\n-- Actions that read user input can work with completion\n-- functions which are activated when the user presses the\n-- tab key.  Most input actions also support default values\n-- that will be returned when the user presses the enter key\n-- without providing any input.\n--\n-- Example:\n--\n-- @\n-- {-\\# LANGUAGE OverloadedStrings \\#-}\n--\n-- example :: MonadByline m => m Text\n-- example = do\n--   sayLn (\"Hey, I like \" <> (\"Haskell\" <> fg magenta) <> \"!\")\n--\n--   let question =\n--         \"What's \"\n--           <> (\"your\" <> bold)\n--           <> \" favorite \"\n--           <> (\"language\" <> fg green <> underline)\n--           <> \"? \"\n--\n--   askLn question (Just \"Haskell\")\n-- @\n--\n-- More complete examples can be found in the @examples@\n-- directory of the distribution tarball or in the\n-- repository.","function_tokens":["askUntil","prompt","def","confirm","=","go","where","go","=","do","answer","<-","askLn","prompt","def","confirm","answer",">>=","\\","case","Left","msg","->","sayLn","msg",">>","go","Right","res","->","pure","res","-- $use","--","--  Byline provides a monad transformer that allows you to compose","-- interactive terminal actions.  When producing output,","-- these actions accept stylized text that can include","-- foreground and background colors, underlined text, and","-- bold text.","--","-- Stylized text can be constructed with string literals","-- (using the @OverloadedStrings@ extension) or using the","-- 'text' function.  Attributes such as color can be changed","-- using modifier functions and the 'Semigroup' @(<>)@ operator.","--","-- Actions that read user input can work with completion","-- functions which are activated when the user presses the","-- tab key.  Most input actions also support default values","-- that will be returned when the user presses the enter key","-- without providing any input.","--","-- Example:","--","-- @","-- {-\\# LANGUAGE OverloadedStrings \\#-}","--","-- example :: MonadByline m => m Text","-- example = do","--   sayLn (\"Hey, I like \" <> (\"Haskell\" <> fg magenta) <> \"!\")","--","--   let question =","--         \"What's \"","--           <> (\"your\" <> bold)","--           <> \" favorite \"","--           <> (\"language\" <> fg green <> underline)","--           <> \"? \"","--","--   askLn question (Just \"Haskell\")","-- @","--","-- More complete examples can be found in the @examples@","-- directory of the distribution tarball or in the","-- repository."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L154-L202","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"md","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"md = mkName \"v\"","function_tokens":["md","=","mkName","\"v\""],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L524-L524","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeOutExpo","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease out exponential.","docstring_summary":"Ease out exponential.","docstring_tokens":["Ease","out","exponential","."],"function":"easeOutExpo c t b =  let e = -10 * realToFrac t in c * (-(2**e) + 1) + b","function_tokens":["easeOutExpo","c","t","b","=","let","e","=","-","10","*","realToFrac","t","in","c","*","(","-","(","2","**","e",")","+","1",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L142-L142","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/hsinstall.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"( BinDir (..)\n  , DeploymentInfo (binDir, docDir, prefixDir)\n  , DocDir (..)\n  , PrefixDir (..)\n  , constructDeploymentInfo\n  )\nimport HSInstall.Except ( withExceptionHandling )\nimport HSInstall.Opts\n  ( BuildMode (AppImageExe, Project)\n  , CleanSwitch (..), DumpIconSwitch (..)\n  , Options (..)\n  , parseOpts\n  )\nimport HSInstall.System.Directory ( copyTree )\n\n\nmain :: IO ()\nmain = do\n  mapM_ (flip hSetBuffering NoBuffering) [ stdout, stderr ]\n  withExceptionHandling $ do\n    opts <- parseOpts\n\n    buildTool <- determineBuildTool\n    putStrLn $ \"Build tool detected: \" <> show buildTool\n\n    when (op DumpIconSwitch . optDumpIcon $ opts) $ dumpStockIcon Nothing >> exitSuccess\n\n    di <- constructDeploymentInfo buildTool opts\n\n    when (op CleanSwitch . optClean $ opts) $ clean buildTool\n    deployApplication buildTool (optBuildMode opts) di\n    case optBuildMode opts of\n      AppImageExe exePath -> prepAppImageFiles exePath >>= mkAppImage exePath di\n      Project             -> return ()","function_tokens":["(","BinDir","(","..",")",",","DeploymentInfo","(","binDir",",","docDir",",","prefixDir",")",",","DocDir","(","..",")",",","PrefixDir","(","..",")",",","constructDeploymentInfo",")","import","HSInstall","Except","(",")","import","HSInstall","Opts","(","(",",",")",",","(","..",")",",","(","..",")",",","(","..",")",",",")","import","HSInstall","System","Directory","(",")","::","(",")","=","do","mapM_","(","flip","hSetBuffering","NoBuffering",")","[","stdout",",","stderr","]","withExceptionHandling","$","do","opts","<-","parseOpts","buildTool","<-","determineBuildTool","putStrLn","$","\"Build tool detected: \"","<>","show","buildTool","when","(","op","DumpIconSwitch",".","optDumpIcon","$","opts",")","$","dumpStockIcon","Nothing",">>","exitSuccess","di","<-","constructDeploymentInfo","buildTool","opts","when","(","op","CleanSwitch",".","optClean","$","opts",")","$","clean","buildTool","deployApplication","buildTool","(","optBuildMode","opts",")","di","case","optBuildMode","opts","of","AppImageExe","exePath","->","prepAppImageFiles","exePath",">>=","mkAppImage","exePath","di","Project","->","return","(",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/hsinstall.hs#L17-L53","hash_key":"dino-\/hsinstall:src\/app\/hsinstall.hs","hash_val":1203,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"typeVariables","parameters":"","argument_list":"","return_statement":"","docstring":"----------------------------------------------------------------------------- Generic helper functions dealing with Template Haskell","docstring_summary":"----------------------------------------------------------------------------- Generic helper functions dealing with Template Haskell","docstring_tokens":["-----------------------------------------------------------------------------","Generic","helper","functions","dealing","with","Template","Haskell"],"function":"typeVariables = map nameFromBinder . binderFromType","function_tokens":["typeVariables","=","map","nameFromBinder",".","binderFromType"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L607-L607","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DApp f a     == DApp f' a'    = f == f' && a == a'","function_tokens":["DApp","f","a","==","DApp","f'","a'","=","f","==","f'","&&","a","==","a'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L59-L59","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"catchError","parameters":"(ConduitParser f) handler","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"catchError (ConduitParser f) handler = do\n    buffer <- withBuffer resetBuffer\n    withBuffer $ setEnabled True\n\n    result <- ConduitParser $ (Right <$> f) `catchError` (return . Left)\n\n    case result of\n      Left e  -> backtrack >> setBuffer buffer >> handler e\n      Right a -> withBuffer (prependBuffer buffer) >> return a\n\n-- | Parsers can be combined with ('<|>'), 'some', 'many', 'optional', 'choice'.\n--\n-- The use of 'guard' is not recommended as it generates unhelpful error messages.\n-- Please consider using 'throwError' or 'unexpected' instead.","function_tokens":["catchError","(","ConduitParser","f",")","handler","=","do","buffer","<-","withBuffer","resetBuffer","withBuffer","$","setEnabled","True","result","<-","ConduitParser","$","(","Right","<$>","f",")","`","catchError","`","(","return",".","Left",")","case","result","of","Left","e","->","backtrack",">>","setBuffer","buffer",">>","handler","e","Right","a","->","withBuffer","(","prependBuffer","buffer",")",">>","return","a","-- | Parsers can be combined with ('<|>'), 'some', 'many', 'optional', 'choice'.","--","-- The use of 'guard' is not recommended as it generates unhelpful error messages.","-- Please consider using 'throwError' or 'unexpected' instead."],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L55-L69","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"withBuffer","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withBuffer f = do\n  buffer <- ConduitParser $ lift $ gets snd\n  ConduitParser $ lift $ modify (second f)\n  return buffer","function_tokens":["withBuffer","f","=","do","buffer","<-","ConduitParser","$","lift","$","gets","snd","ConduitParser","$","lift","$","modify","(","second","f",")","return","buffer"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L128-L133","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"handleCommand","parameters":"_ _ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"handleCommand _ _ _ = return ()","function_tokens":["handleCommand","_","_","_","=","return","(",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L279-L279","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mul","parameters":"ms","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mul ms  = foldr (.*.) (cnst 1) ms","function_tokens":["mul","ms","=","foldr","(",".*.",")","(","cnst","1",")","ms"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L206-L206","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"loadEntry","parameters":"t s path","argument_list":"","return_statement":"","docstring":"Load an entry from a given file.","docstring_summary":"Load an entry from a given file.","docstring_tokens":["Load","an","entry","from","a","given","file","."],"function":"loadEntry t s path = do\n  apath <- liftIO (canonicalizePath path)\n  modTime <- liftIO (getModificationTime path)\n  let src = CB.sourceFile apath\n  addPending (I.SinkEntry t src s)\n  addPending (I.SetModTime modTime s)\n\n#ifndef mingw32_HOST_OS\n  status <- liftIO $ Unix.getFileStatus path\n  setExternalFileAttrs (Unix.fromFileMode (Unix.fileMode status)) s\n#endif\n\n-- | Copy an entry \u201cas is\u201d from another zip archive. If the entry does not\n-- exist in that archive, 'EntryDoesNotExist' will be thrown.","function_tokens":["loadEntry","t","s","path","=","do","apath","<-","liftIO","(","canonicalizePath","path",")","modTime","<-","liftIO","(","getModificationTime","path",")","let","src","=","CB","sourceFile","apath","addPending","(","I","SinkEntry","t","src","s",")","addPending","(","I","SetModTime","modTime","s",")","#ifndef mingw32_HOST_OS","status","<-","liftIO","$","Unix","getFileStatus","path","setExternalFileAttrs","(","Unix","fromFileMode","(","Unix","fileMode","status",")",")","s","#endif","-- | Copy an entry \u201cas is\u201d from another zip archive. If the entry does not","-- exist in that archive, 'EntryDoesNotExist' will be thrown."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L456-L470","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"mxy","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mxy = branchMask px py","function_tokens":["mxy","=","branchMask","px","py"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L750-L750","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseJSON","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseJSON = parseConfig","function_tokens":["parseJSON","=","parseConfig"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L84-L84","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putCString","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putCString x = do\n  putByteString $ TE.encodeUtf8 x\n  putWord8 0","function_tokens":["putCString","x","=","do","putByteString","$","TE","encodeUtf8","x","putWord8","0"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L137-L141","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"freeze","parameters":"(SymMMatrix n v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeze (SymMMatrix n v) = SymMatrix n `liftM` G.freeze v","function_tokens":["freeze","(","SymMMatrix","n","v",")","=","SymMatrix","n","`","liftM","`","G","freeze","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L70-L70","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"(i, (_, ty))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one (i, (_, ty)) = Field Nothing mono ty (Context i c con, [])\n              where fsTys = map (typeVariables . snd) [a, b]\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["one","(","i",",","(","_",",","ty",")",")","=","Field","Nothing","mono","ty","(","Context","i","c","con",",","[","]",")","where","fsTys","=","map","(","typeVariables",".","snd",")","[","a",",","b","]","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L345-L349","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getZData","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getZData = getMData","function_tokens":["getZData","=","getMData"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L237-L237","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"toList","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a list by concatenating rows","docstring_summary":"O(m*n) Create a list by concatenating rows","docstring_tokens":["O","(","m","*","n",")","Create","a","list","by","concatenating","rows"],"function":"toList = MG.toList","function_tokens":["toList","=","MG","toList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L178-L178","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"lift","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift m = StateC (\\ s -> (,) s <$> m)","function_tokens":["lift","m","=","StateC","(","\\","s","->","(",",",")","s","<$>","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L119-L119","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/simple.hs","language":"haskell","identifier":"question","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"question =\n          \"What's your favorite \"\n            <> (\"language\" & bold & fg green)\n            <> \"? \"","function_tokens":["question","=","\"What's your favorite \"","<>","(","\"language\"","&","bold","&","fg","green",")","<>","\"? \""],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/simple.hs#L35-L38","hash_key":"pjones\/byline:examples\/simple.hs","hash_val":16333,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"dataDefns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dataDefns       = map Hs.tcdDataDefn dataDecls","function_tokens":["dataDefns","=","map","Hs","tcdDataDefn","dataDecls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L71-L71","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"parseModule","parameters":"externalExts0 fp string","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Abstraction over GHC lib's parsing","docstring_summary":"------------------------------------------------------------------------------ Abstraction over GHC lib's parsing","docstring_tokens":["------------------------------------------------------------------------------","Abstraction","over","GHC","lib","s","parsing"],"function":"parseModule externalExts0 fp string = do\n    -- Parse extensions.\n    externalExts1 <- for externalExts0 $ \\s -> case GHCEx.readExtension s of\n        Nothing -> Left $ \"Unknown extension: \" ++ show s\n        Just e  -> Right e\n\n    -- Build first dynflags.\n    let dynFlags0 = foldl' turnOn baseDynFlags externalExts1\n\n    -- Parse options from file\n    let fileOptions = fmap GHC.unLoc $ GHC.getOptions dynFlags0\n            (GHC.stringToStringBuffer string)\n            (fromMaybe \"-\" fp)\n        fileExtensions = mapMaybe\n            (stripPrefix \"-X\" >=> GHCEx.readExtension)\n            fileOptions\n\n    -- Set further dynflags.\n    let dynFlags1 = foldl' turnOn dynFlags0 fileExtensions\n            `GHC.gopt_set` GHC.Opt_KeepRawTokenStream\n\n    -- Possibly strip CPP.\n    let removeCpp s = if GHC.xopt LangExt.Cpp dynFlags1 then unCpp s else s\n        input = removeCpp $ dropBom string\n\n    -- Actual parse.\n    case GHCEx.parseModule input dynFlags1 of\n        GHC.POk _ m -> Right m\n        GHC.PFailed ps -> Left . withFileName . GHC.showSDoc dynFlags1 .\n            GHC.vcat . GHC.pprMsgEnvelopeBagWithLoc . fmap GHC.pprError . snd $\n            GHC.getMessages ps\n  where\n    withFileName x = maybe \"\" (<> \": \") fp <> x\n\n    turnOn dynFlags ext = foldl'\n        turnOn\n        (GHC.xopt_set dynFlags ext)\n        [rhs | (lhs, True, rhs) <- GHC.impliedXFlags, lhs == ext]","function_tokens":["parseModule","externalExts0","fp","string","=","do","-- Parse extensions.","externalExts1","<-","for","externalExts0","$","\\","s","->","case","GHCEx","readExtension","s","of","Nothing","->","Left","$","\"Unknown extension: \"","++","show","s","Just","e","->","Right","e","-- Build first dynflags.","let","dynFlags0","=","foldl'","turnOn","baseDynFlags","externalExts1","-- Parse options from file","let","fileOptions","=","fmap","GHC","unLoc","$","GHC","getOptions","dynFlags0","(","GHC","stringToStringBuffer","string",")","(","fromMaybe","\"-\"","fp",")","fileExtensions","=","mapMaybe","(","stripPrefix","\"-X\"",">=>","GHCEx","readExtension",")","fileOptions","-- Set further dynflags.","let","dynFlags1","=","foldl'","turnOn","dynFlags0","fileExtensions","`","GHC","gopt_set","`","GHC","Opt_KeepRawTokenStream","-- Possibly strip CPP.","let","removeCpp","s","=","if","GHC","xopt","LangExt","Cpp","dynFlags1","then","unCpp","s","else","s","input","=","removeCpp","$","dropBom","string","-- Actual parse.","case","GHCEx","parseModule","input","dynFlags1","of","GHC","POk","_","m","->","Right","m","GHC","PFailed","ps","->","Left",".","withFileName",".","GHC","showSDoc","dynFlags1",".","GHC","vcat",".","GHC","pprMsgEnvelopeBagWithLoc",".","fmap","GHC","pprError",".","snd","$","GHC","getMessages","ps","where","withFileName","x","=","maybe","\"\"","(","<>","\": \"",")","fp","<>","x","turnOn","dynFlags","ext","=","foldl'","turnOn","(","GHC","xopt_set","dynFlags","ext",")","[","rhs","|","(","lhs",",","True",",","rhs",")","<-","GHC","impliedXFlags",",","lhs","==","ext","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L61-L98","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureCloseDevice","parameters":"device","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"captureCloseDevice device = liftIO $ do\n   funPtr <- getCaptureFunc \"alcCaptureCloseDevice\"\n   fmap unmarshalALCboolean .\n      invokeCaptureCloseDevice funPtr . marshalDevice $ device","function_tokens":["captureCloseDevice","device","=","liftIO","$","do","funPtr","<-","getCaptureFunc","\"alcCaptureCloseDevice\"","fmap","unmarshalALCboolean",".","invokeCaptureCloseDevice","funPtr",".","marshalDevice","$","device"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L109-L114","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"nullDevice","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nullDevice = Device (ALCdevice nullPtr)","function_tokens":["nullDevice","=","Device","(","ALCdevice","nullPtr",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L129-L129","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"resolveContent","parameters":"(Untabify mUntabifySize)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resolveContent (Untabify mUntabifySize) =\n    foldMap go\n    where\n        untabified = maybe id untabify mUntabifySize\n        go (Left line) = NewContent mempty (unlines [line])\n        go (Right conflict) =\n            case (resolveConflict . lineBreakFix . untabified) conflict of\n            NoResolution               -> NewContent (Result 0 0 1)\n                                          (Conflict.pretty (untabified conflict))\n            Resolution trivialLines    -> NewContent (Result 1 0 0) trivialLines\n            PartialResolution newLines -> NewContent (Result 0 1 0) newLines","function_tokens":["resolveContent","(","Untabify","mUntabifySize",")","=","foldMap","go","where","untabified","=","maybe","id","untabify","mUntabifySize","go","(","Left","line",")","=","NewContent","mempty","(","unlines","[","line","]",")","go","(","Right","conflict",")","=","case","(","resolveConflict",".","lineBreakFix",".","untabified",")","conflict","of","NoResolution","->","NewContent","(","Result","0","0","1",")","(","Conflict","pretty","(","untabified","conflict",")",")","Resolution","trivialLines","->","NewContent","(","Result","1","0","0",")","trivialLines","PartialResolution","newLines","->","NewContent","(","Result","0","1","0",")","newLines"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L133-L143","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Opts.hs","language":"haskell","identifier":"parseOpts","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseOpts = do\n  pn <- getProgName\n  execParser $ info (parser <**> helper <**> versionHelper pn)\n    (  header (printf \"%s - Pack a haskell project into a deployable directory structure\" pn)\n    <> footer'\n    )","function_tokens":["parseOpts","=","do","pn","<-","getProgName","execParser","$","info","(","parser","<**>","helper","<**>","versionHelper","pn",")","(","header","(","printf","\"%s - Pack a haskell project into a deployable directory structure\"","pn",")","<>","footer'",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Opts.hs#L93-L101","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Opts.hs","hash_val":22933,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"dt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dt = realToFrac $ diffUTCTime thisT lastT","function_tokens":["dt","=","realToFrac","$","diffUTCTime","thisT","lastT"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L66-L66","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"t'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t' = realToFrac t - 1","function_tokens":["t'","=","realToFrac","t","-","1"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L117-L117","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"abs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"abs = fmap abs","function_tokens":["abs","=","fmap","abs"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L234-L234","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"adjust","parameters":"f key@(Key k _) (Vault m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"adjust f key@(Key k _) (Vault m) = Vault $ Map.update f' k m\n    where f' = fmap (lock key . f) . unlock key","function_tokens":["adjust","f","key","@","(","Key","k","_",")","(","Vault","m",")","=","Vault","$","Map","update","f'","k","m","where","f'","=","fmap","(","lock","key",".","f",")",".","unlock","key"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L37-L40","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"swap","parameters":"","argument_list":"","return_statement":"","docstring":"Polymorphic lens that swaps the components of a tuple. (Total and polymorphic)","docstring_summary":"Polymorphic lens that swaps the components of a tuple. (Total and polymorphic)","docstring_tokens":["Polymorphic","lens","that","swaps","the","components","of","a","tuple",".","(","Total","and","polymorphic",")"],"function":"swap = let io = Iso (arr Tuple.swap) (arr Tuple.swap) in Poly.iso io io","function_tokens":["swap","=","let","io","=","Iso","(","arr","Tuple","swap",")","(","arr","Tuple","swap",")","in","Poly","iso","io","io"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L94-L94","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"go","parameters":"s []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go s [] = return [stepToByteString s indexStepFinal]","function_tokens":["go","s","[","]","=","return","[","stepToByteString","s","indexStepFinal","]"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L97-L97","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"matchSeparator","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchSeparator _ = Nothing","function_tokens":["matchSeparator","_","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L80-L80","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/NonDet.hs","language":"haskell","identifier":"","parameters":"_","argument_list":"","return_statement":"","docstring":"Compose a function operationally equivalent to 'id' on the left.  cf https:\/\/github.com\/fused-effects\/diffused-effects\/pull\/1#discussion_r323560758","docstring_summary":"Compose a function operationally equivalent to 'id' on the left.  cf https:\/\/github.com\/fused-effects\/diffused-effects\/pull\/1#discussion_r323560758","docstring_tokens":["Compose","a","function","operationally","equivalent","to","id","on","the","left",".","cf","https",":","\/\/","github",".","com","\/","fused","-","effects","\/","diffused","-","effects","\/","pull","\/","1#discussion_r323560758"],"function":"(#.) _ = coerce","function_tokens":["(","#.",")","_","=","coerce"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/NonDet.hs#L69-L69","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/NonDet.hs","hash_val":29874,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(outFptr, _, _) = DVSM.unsafeToForeignPtr bpvm","function_tokens":["(","outFptr",",","_",",","_",")","=","DVSM","unsafeToForeignPtr","bpvm"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L133-L133","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"render","parameters":"(Track d es)","argument_list":"","return_statement":"","docstring":"Get all events on recordered on the track.","docstring_summary":"Get all events on recordered on the track.","docstring_tokens":["Get","all","events","on","recordered","on","the","track","."],"function":"render (Track d es) = renderTList es","function_tokens":["render","(","Track","d","es",")","=","renderTList","es"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L193-L193","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"lookupN","parameters":"k t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookupN k t\n  = case t of\n      Bin _ _ _ m l r\n        | zeroN k (natFromInt m) -> lookupN k l\n        | otherwise              -> lookupN k r\n      Tip _ kx\n        | (k == natFromInt kx)  -> Just kx\n        | otherwise             -> Nothing\n      Nil -> Nothing\n\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n-- | \/O(1)\/. The empty set.","function_tokens":["lookupN","k","t","=","case","t","of","Bin","_","_","_","m","l","r","|","zeroN","k","(","natFromInt","m",")","->","lookupN","k","l","|","otherwise","->","lookupN","k","r","Tip","_","kx","|","(","k","==","natFromInt","kx",")","->","Just","kx","|","otherwise","->","Nothing","Nil","->","Nothing","{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}","-- | \/O(1)\/. The empty set."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L282-L297","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intersection2 | nomatch p1 p2 m2  = Nil\n                  | zero p1 m2        = intersection t1 l2\n                  | otherwise         = intersection t1 r2","function_tokens":["intersection2","|","nomatch","p1","p2","m2","=","Nil","|","zero","p1","m2","=","intersection","t1","l2","|","otherwise","=","intersection","t1","r2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L426-L428","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(UnitNoteLength _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (UnitNoteLength _)       = (True, True, True, True)","function_tokens":["go","(","UnitNoteLength","_",")","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L376-L376","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictALint","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictALint = Dictionary {\n   alGetter  = alGetSourceiv,\n   alSetter  = alSourceiv,\n   size      = 1,\n   peekSize  = peek1 id,\n   marshal   = id }","function_tokens":["dictALint","=","Dictionary","{","alGetter","=","alGetSourceiv",",","alSetter","=","alSourceiv",",","size","=","1",",","peekSize","=","peek1","id",",","marshal","=","id","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L507-L512","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"easeMiddle","parameters":"start end t","argument_list":"","return_statement":"","docstring":"A novel, start-stop tween.","docstring_summary":"A novel, start-stop tween.","docstring_tokens":["A","novel","start","-","stop","tween","."],"function":"easeMiddle start end t = do\n  let change = end - start\n  tween_ easeOutExpo start              (start + change\/2) $ t\/2\n  tween_ easeInExpo  (start + change\/2) end                $ t\/2\n\n-- An exponential tween back and forth from 0 to 50 over 1 seconds that\n-- loops forever. This spline takes float values of delta time as input,\n-- outputs the current x value at every step.","function_tokens":["easeMiddle","start","end","t","=","do","let","change","=","end","-","start","tween_","easeOutExpo","start","(","start","+","change","\/","2",")","$","t","\/","2","tween_","easeInExpo","(","start","+","change","\/","2",")","end","$","t","\/","2","-- An exponential tween back and forth from 0 to 50 over 1 seconds that","-- loops forever. This spline takes float values of delta time as input,","-- outputs the current x value at every step."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L22-L30","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"deleteFindMax","parameters":"","argument_list":"","return_statement":"","docstring":"\/O(min(n,W))\/. Delete and find the maximal element.  > deleteFindMax set = (findMax set, deleteMax set)","docstring_summary":"\/O(min(n,W))\/. Delete and find the maximal element.  > deleteFindMax set = (findMax set, deleteMax set)","docstring_tokens":["\/","O","(","min","(","n","W","))","\/",".","Delete","and","find","the","maximal","element",".",">","deleteFindMax","set","=","(","findMax","set","deleteMax","set",")"],"function":"deleteFindMax = fromMaybe (error \"deleteFindMax: empty set has no maximal element\") . maxView","function_tokens":["deleteFindMax","=","fromMaybe","(","error","\"deleteFindMax: empty set has no maximal element\"",")",".","maxView"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L634-L634","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"sourcePath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sourcePath = baseSourcePath <\/> relativePath","function_tokens":["sourcePath","=","baseSourcePath","<\/>","relativePath"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L51-L51","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"index","parameters":"LessThan {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index LessThan {} = SBooleanSort","function_tokens":["index","LessThan","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L79-L79","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Not a  `ieq1` Not b  = a `ieq` b","function_tokens":["Not","a","`","ieq1","`","Not","b","=","a","`","ieq","`","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L349-L349","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"fromAdornment","parameters":"GHC.NameBackquotes","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromAdornment GHC.NameBackquotes = (\"`\", \"`\")","function_tokens":["fromAdornment","GHC","NameBackquotes","=","(","\"`\"",",","\"`\"",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L185-L185","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"dim","parameters":"(MMatrix r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim (MMatrix r c _ _ _) = (r,c)","function_tokens":["dim","(","MMatrix","r","c","_","_","_",")","=","(","r",",","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L31-L31","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"minutes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"minutes = todMin tod","function_tokens":["minutes","=","todMin","tod"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1177-L1177","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Divides  c a `ieq1` Divides  d b = a `ieq` b && c == d","function_tokens":["Divides","c","a","`","ieq1","`","Divides","d","b","=","a","`","ieq","`","b","&&","c","==","d"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L63-L63","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"Nothing m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge Nothing m = m","function_tokens":["merge","Nothing","m","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L789-L789","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"marshalBufferQuery","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalBufferQuery x = case x of\n   Frequency -> al_FREQUENCY\n   Size -> al_SIZE\n   Bits -> al_BITS\n   Channels -> al_CHANNELS\n\n--------------------------------------------------------------------------------","function_tokens":["marshalBufferQuery","x","=","case","x","of","Frequency","->","al_FREQUENCY","Size","->","al_SIZE","Bits","->","al_BITS","Channels","->","al_CHANNELS","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L160-L168","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"exec","parameters":"","argument_list":"","return_statement":"","docstring":"Main executable; parses command line options and runs program","docstring_summary":"Main executable; parses command line options and runs program","docstring_tokens":["Main","executable",";","parses","command","line","options","and","runs","program"],"function":"exec = pick =<< execParser helpDisplay","function_tokens":["exec","=","pick","=<<","execParser","helpDisplay"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L30-L30","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"comment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"comment = predictComment adComment xs","function_tokens":["comment","=","predictComment","adComment","xs"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L277-L277","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"zip64ver","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip64ver = makeVersion (if zip64 then [4, 5] else [2, 0])","function_tokens":["zip64ver","=","makeVersion","(","if","zip64","then","[","4",",","5","]","else","[","2",",","0","]",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1135-L1135","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union","parameters":"t Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"union t Nil       = t","function_tokens":["union","t","Nil","=","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L379-L379","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toCompressionMethod","parameters":"12","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toCompressionMethod 12 = Just BZip2","function_tokens":["toCompressionMethod","12","=","Just","BZip2"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1111-L1111","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"bound","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bound = maxBound :: b","function_tokens":["bound","=","maxBound","::","b"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1049-L1049","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(n, ns') = runCoiter ns","function_tokens":["(","n",",","ns'",")","=","runCoiter","ns"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L779-L779","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"forM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM_ = MG.forM_","function_tokens":["forM_","=","MG","forM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L254-L254","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"tweeny","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tweeny = do\n    easeMiddle 50 0 dur\n    easeMiddle 0 50 dur\n    tweeny\n\n-- | Our Point value that varies over time continuously in x and y.","function_tokens":["tweeny","=","do","easeMiddle","50","0","dur","easeMiddle","0","50","dur","tweeny","-- | Our Point value that varies over time continuously in x and y."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L42-L48","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ma1 `mplus` ma2 = AccumC $ \\k w -> runAccumC ma1 k w `mplus` runAccumC ma2 k w","function_tokens":["ma1","`","mplus","`","ma2","=","AccumC","$","\\","k","w","->","runAccumC","ma1","k","w","`","mplus","`","runAccumC","ma2","k","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L112-L112","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Errors.hs","language":"haskell","identifier":"alcErrors","parameters":"device","argument_list":"","return_statement":"","docstring":"OpenAL detects only a subset of those conditions that could be considered errors. This is because in many cases error checking would adversely impact the performance of an error-free program. The state variable 'alcErrors' is used to obtain error information. When an error is detected by ALC, a flag is set and the error code is recorded. Further errors, if they occur, do not affect this recorded code. When 'alcErrors' is read, the error for the given device is returned and the flag is cleared, so that a further error will again record its code. If reading 'alcErrors' returns @\\[\\]@ then there has been no detectable error since the last time 'alcErrors' (or since the ALC was initialized).  When an error flag is set, results of ALC operations are undefined only if 'ALCOutOfMemory' has occurred. In other cases, the command generating the error is ignored so that it has no effect on ALC state or output buffer contents. If the error generating command returns a value, it returns zero. If the generating command modifies values through a pointer argument, no change is made to these values. These error semantics apply only to ALC errors, not to system errors such as memory access errors.","docstring_summary":"OpenAL detects only a subset of those conditions that could be considered errors. This is because in many cases error checking would adversely impact the performance of an error-free program. The state variable 'alcErrors' is used to obtain error information. When an error is detected by ALC, a flag is set and the error code is recorded. Further errors, if they occur, do not affect this recorded code. When 'alcErrors' is read, the error for the given device is returned and the flag is cleared, so that a further error will again record its code. If reading 'alcErrors' returns","docstring_tokens":["OpenAL","detects","only","a","subset","of","those","conditions","that","could","be","considered","errors",".","This","is","because","in","many","cases","error","checking","would","adversely","impact","the","performance","of","an","error","-","free","program",".","The","state","variable","alcErrors","is","used","to","obtain","error","information",".","When","an","error","is","detected","by","ALC","a","flag","is","set","and","the","error","code","is","recorded",".","Further","errors","if","they","occur","do","not","affect","this","recorded","code",".","When","alcErrors","is","read","the","error","for","the","given","device","is","returned","and","the","flag","is","cleared","so","that","a","further","error","will","again","record","its","code",".","If","reading","alcErrors","returns"],"function":"alcErrors device =\n   makeGettableStateVar $ do\n      c <- alcGetError (marshalDevice device)\n      if c == alc_NO_ERROR\n         then return []\n         else do\n            s <- getString (Just device) (ALCErrorCategory c)\n            return [ ALCError (unmarshalALCErrorCategory c) s ]","function_tokens":["alcErrors","device","=","makeGettableStateVar","$","do","c","<-","alcGetError","(","marshalDevice","device",")","if","c","==","alc_NO_ERROR","then","return","[","]","else","do","s","<-","getString","(","Just","device",")","(","ALCErrorCategory","c",")","return","[","ALCError","(","unmarshalALCErrorCategory","c",")","s","]"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Errors.hs#L87-L96","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Errors.hs","hash_val":42696,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unsafeThaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeThaw = MG.unsafeThaw","function_tokens":["unsafeThaw","=","MG","unsafeThaw"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L375-L375","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"recordToAlignable","parameters":"conf","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"recordToAlignable conf = groupAlign (cRecords conf) . fromMaybe [] . traverse fieldDeclToAlignable","function_tokens":["recordToAlignable","conf","=","groupAlign","(","cRecords","conf",")",".","fromMaybe","[","]",".","traverse","fieldDeclToAlignable"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L83-L83","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"restoreM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"restoreM = ZipArchive . StateT . const . return","function_tokens":["restoreM","=","ZipArchive",".","StateT",".","const",".","return"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L213-L213","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"menuPrefix","parameters":"f m","argument_list":"","return_statement":"","docstring":"Change the prefix function.  The prefix function should generate unique, stylized text that the user can use to select a menu item. The default prefix function numbers the menu items starting with 1.  @since 1.0.0.0","docstring_summary":"Change the prefix function.  The prefix function should generate unique, stylized text that the user can use to select a menu item. The default prefix function numbers the menu items starting with 1.","docstring_tokens":["Change","the","prefix","function",".","The","prefix","function","should","generate","unique","stylized","text","that","the","user","can","use","to","select","a","menu","item",".","The","default","prefix","function","numbers","the","menu","items","starting","with","1","."],"function":"menuPrefix f m = m {_menuItemPrefix = f}","function_tokens":["menuPrefix","f","m","=","m","{","_menuItemPrefix","=","f","}"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L178-L178","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(==) = (==) `on` identity","function_tokens":["(","==",")","=","(","==",")","`","on","`","identity"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L72-L72","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"cmdCreateIndex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cmdCreateIndex = command \"create-index\"  $ flip info idm $ runCreateIndex <$> optsCreateIndex","function_tokens":["cmdCreateIndex","=","command","\"create-index\"","$","flip","info","idm","$","runCreateIndex","<$>","optsCreateIndex"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L90-L90","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_PLAYING","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_PLAYING                          = 0x1012","function_tokens":["al_PLAYING","=","0x1012"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L105-L105","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","language":"haskell","identifier":"allocWorkState","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allocWorkState = do\n  fptr <- F.mallocForeignPtrBytes 256\n  let ptr = F.unsafeForeignPtrToPtr fptr\n  let ws = WorkState\n        { workStateZ = ptr `F.plusPtr`  0\n        , workStateO = ptr `F.plusPtr`  8\n        , workStateE = ptr `F.plusPtr` (8 * 2)\n        , workStateM = ptr `F.plusPtr` (8 * 3)\n        , workStateP = fptr\n        }\n  F.poke (workStateZ ws) 0\n  F.poke (workStateO ws) 0\n  F.poke (workStateE ws) 1\n  F.poke (workStateM ws) 0\n  return ws","function_tokens":["allocWorkState","=","do","fptr","<-","F","mallocForeignPtrBytes","256","let","ptr","=","F","unsafeForeignPtrToPtr","fptr","let","ws","=","WorkState","{","workStateZ","=","ptr","`","F","plusPtr","`","0",",","workStateO","=","ptr","`","F","plusPtr","`","8",",","workStateE","=","ptr","`","F","plusPtr","`","(","8","*","2",")",",","workStateM","=","ptr","`","F","plusPtr","`","(","8","*","3",")",",","workStateP","=","fptr","}","F","poke","(","workStateZ","ws",")","0","F","poke","(","workStateO","ws",")","0","F","poke","(","workStateE","ws",")","1","F","poke","(","workStateM","ws",")","0","return","ws"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs#L68-L82","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","hash_val":30325,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"typeFromBinder","parameters":"(KindedTV tv _ StarT)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"typeFromBinder (KindedTV tv _ StarT) = VarT tv","function_tokens":["typeFromBinder","(","KindedTV","tv","_","StarT",")","=","VarT","tv"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L617-L617","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = ChooseC $ \\ fork leaf ->\n    mfix (runChooseS (pure . pure) . f . head)\n    >>= \\case\n      a:|[] -> leaf a\n      a:|_  -> leaf a `fork` runChoose fork leaf (mfix (liftAll . fmap tail . runChooseS (pure . pure) . f))\n      where\n    liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf","function_tokens":["mfix","f","=","ChooseC","$","\\","fork","leaf","->","mfix","(","runChooseS","(","pure",".","pure",")",".","f",".","head",")",">>=","\\","case","a",":|","[","]","->","leaf","a","a",":|","_","->","leaf","a","`","fork","`","runChoose","fork","leaf","(","mfix","(","liftAll",".","fmap","tail",".","runChooseS","(","pure",".","pure",")",".","f",")",")","where","liftAll","m","=","ChooseC","$","\\","fork","leaf","->","m",">>=","foldr1","fork",".","fmap","leaf"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L82-L89","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"unsafeWrite","parameters":"(MMatrix _ _ tda offset v) (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeWrite (MMatrix _ _ tda offset v) (i,j) = GM.unsafeWrite v idx\n      where idx = offset + i * tda + j","function_tokens":["unsafeWrite","(","MMatrix","_","_","tda","offset","v",")","(","i",",","j",")","=","GM","unsafeWrite","v","idx","where","idx","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L38-L40","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"prj","parameters":"(InL _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prj (InL _) = Nothing","function_tokens":["prj","(","InL","_",")","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L52-L52","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"compFunc","parameters":"compRef input","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compFunc compRef input = liftIO $\n      readIORef compRef >>= \\case\n        [] -> Haskeline.completeFilename input\n        fs -> runCompletionFunctions fs input","function_tokens":["compFunc","compRef","input","=","liftIO","$","readIORef","compRef",">>=","\\","case","[","]","->","Haskeline","completeFilename","input","fs","->","runCompletionFunctions","fs","input"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L157-L161","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"undoArchiveChanges","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"undoArchiveChanges = modifyActions f\n  where\n    f = S.filter ((\/= Nothing) . I.targetEntry)\n\n-- | Undo all changes made in this editing session.","function_tokens":["undoArchiveChanges","=","modifyActions","f","where","f","=","S","filter","(","(","\/=","Nothing",")",".","I","targetEntry",")","-- | Undo all changes made in this editing session."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L630-L635","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"fromDistinctAscList","parameters":"(z0 : zs0)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromDistinctAscList (z0 : zs0) = work z0 zs0 Nada\n  where\n    work x []     stk = finish x (tip x) stk\n    work x (z:zs) stk = reduce z zs (branchMask z x) x (tip x) stk\n\n    reduce z zs _ px tx Nada = work z zs (Push px tx Nada)\n    reduce z zs m px tx stk@(Push py ty stk') =\n        let mxy = branchMask px py\n            pxy = mask px mxy\n        in  if shorter m mxy\n                 then reduce z zs m pxy (bin_ pxy mxy ty tx) stk'\n                 else work z zs (Push px tx stk)\n\n    finish _  t  Nada = t\n    finish px tx (Push py ty stk) = finish p (join py ty px tx) stk\n        where m = branchMask px py\n              p = mask px m","function_tokens":["fromDistinctAscList","(","z0",":","zs0",")","=","work","z0","zs0","Nada","where","work","x","[","]","stk","=","finish","x","(","tip","x",")","stk","work","x","(","z",":","zs",")","stk","=","reduce","z","zs","(","branchMask","z","x",")","x","(","tip","x",")","stk","reduce","z","zs","_","px","tx","Nada","=","work","z","zs","(","Push","px","tx","Nada",")","reduce","z","zs","m","px","tx","stk","@","(","Push","py","ty","stk'",")","=","let","mxy","=","branchMask","px","py","pxy","=","mask","px","mxy","in","if","shorter","m","mxy","then","reduce","z","zs","m","pxy","(","bin_","pxy","mxy","ty","tx",")","stk'","else","work","z","zs","(","Push","px","tx","stk",")","finish","_","t","Nada","=","t","finish","px","tx","(","Push","py","ty","stk",")","=","finish","p","(","join","py","ty","px","tx",")","stk","where","m","=","branchMask","px","py","p","=","mask","px","m"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L743-L761","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_ <> _ = NoChange","function_tokens":["_","<>","_","=","NoChange"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L138-L138","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"formatDataDecl","parameters":"cfg@Config{..} decl@MkDataDecl {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"formatDataDecl cfg@Config{..} decl@MkDataDecl {..} =\n    Editor.changeLines originalDeclBlock (const printedDecl)\n  where\n    originalDeclBlock = Editor.Block\n        (GHC.srcSpanStartLine dataLoc)\n        (GHC.srcSpanEndLine dataLoc)\n\n    printerConfig = PrinterConfig\n        { columns = case cMaxColumns of\n            NoMaxColumns -> Nothing\n            MaxColumns n -> Just n\n        }\n\n    printedDecl = runPrinter_ printerConfig $ putDataDecl cfg decl","function_tokens":["formatDataDecl","cfg","@","Config","{","..","}","decl","@","MkDataDecl","{","..","}","=","Editor","changeLines","originalDeclBlock","(","const","printedDecl",")","where","originalDeclBlock","=","Editor","Block","(","GHC","srcSpanStartLine","dataLoc",")","(","GHC","srcSpanEndLine","dataLoc",")","printerConfig","=","PrinterConfig","{","columns","=","case","cMaxColumns","of","NoMaxColumns","->","Nothing","MaxColumns","n","->","Just","n","}","printedDecl","=","runPrinter_","printerConfig","$","putDataDecl","cfg","decl"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L122-L137","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"liftByline","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftByline = lift . liftByline","function_tokens":["liftByline","=","lift",".","liftByline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L49-L49","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"moveAndAge'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moveAndAge' = ageByOneYear' . moveToAmsterdam' . ageByOneYear' . ageByOneYear' . ageByOneYear'","function_tokens":["moveAndAge'","=","ageByOneYear'",".","moveToAmsterdam'",".","ageByOneYear'",".","ageByOneYear'",".","ageByOneYear'"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L45-L45","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \\\/ b = a .|. b","function_tokens":["a","\\\/","b","=","a",".|.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L203-L203","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a .>.  b = b .<. a","function_tokens":["a",".>.","b","=","b",".<.","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L226-L226","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"pickLens","parameters":"\"perimeter\"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pickLens \"perimeter\" = perimeter","function_tokens":["pickLens","\"perimeter\"","=","perimeter"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L93-L93","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_            == _             = False","function_tokens":["_","==","_","=","False"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L63-L63","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"port","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"port = toBinary . fromIntegral . peerPort . peer $ node","function_tokens":["port","=","toBinary",".","fromIntegral",".","peerPort",".","peer","$","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L49-L49","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"fs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fs = vars a","function_tokens":["fs","=","vars","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L706-L706","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"body","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"body    = if total\n                   then [| Poly.point $ Point $getT (modifier $getT $putT) |]\n                   else [| Poly.point $ Point $getP (modifier $getP $putP) |]","function_tokens":["body","=","if","total","then","[","|"," Poly.point $ Point $getT (modifier $getT $putT) ","|]","else","[","|"," Poly.point $ Point $getP (modifier $getP $putP) ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L449-L451","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Setup.hs#L6-L6","hash_key":"mrkkrp\/zip:Setup.hs","hash_val":41007,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Bin _ _ _ _ _ _ `compare` Nil = GT","function_tokens":["Bin","_","_","_","_","_","_","`","compare","`","Nil","=","GT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L853-L853","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"mkCache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkCache   = result where\n  element = CacheState (seedIdentity result) HashMap.empty\n  w       = cacheWidth result\n  result  = Cache\n          $ unsafePerformIO\n          $ traverse newIORef\n          $ listArray (0,w - 1)\n          $ replicate w element","function_tokens":["mkCache","=","result","where","element","=","CacheState","(","seedIdentity","result",")","HashMap","empty","w","=","cacheWidth","result","result","=","Cache","$","unsafePerformIO","$","traverse","newIORef","$","listArray","(","0",",","w","-","1",")","$","replicate","w","element"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L50-L59","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"multiWayIfToAlignable","parameters":"conf (GHC.L _ (Hs.HsMultiIf _ grhss))","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"multiWayIfToAlignable conf (GHC.L _ (Hs.HsMultiIf _ grhss)) =\n    groupAlign (cMultiWayIf conf) as\n  where\n    as = fromMaybe [] $ traverse grhsToAlignable grhss","function_tokens":["multiWayIfToAlignable","conf","(","GHC","L","_","(","Hs","HsMultiIf","_","grhss",")",")","=","groupAlign","(","cMultiWayIf","conf",")","as","where","as","=","fromMaybe","[","]","$","traverse","grhsToAlignable","grhss"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L156-L160","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"packDirRecur","parameters":"t f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"packDirRecur t f = packDirRecur' t f (const $ return ())","function_tokens":["packDirRecur","t","f","=","packDirRecur'","t","f","(","const","$","return","(",")",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L495-L495","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Opts.hs","language":"haskell","identifier":"content","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"content = [here|OVERVIEW\n\nhsinstall is a tool for installing a Haskell software project into a directory structure for deployment. It builds upon the `stack install` and `cabal install` commands and adds these features:\n\n- Copies the `LICENSE` file into <PREFIX>\/share\/<PROJECT-NAME>\/doc\n- Copies the contents of a static directory stucture in your project (named `hsinstall`) into the destination prefix directory. This can contain additional binaries or scripts, resources, documentation, etc. (more on this later in TEMPLATE DIRECTORY)\n- Optionally builds an AppDir directory structure for the project and produces an AppImage binary\n\nTo use hsinstall, it will be necessary to be in the top-level directory of a Haskell project that builds with either cabal or stack. You'll need to have one or the other of the cabal or stack tools on your path as well. Basically, if you can't build the project, hsinstall can't build it either.\n\nAlso note that all cabal commands will be issued as `v2-*` commands. The older `v1-*` commands are deprecated and we don't use them.\n\nIf the AppImage features are desired, you must have these tools on your PATH:\nlinuxdeploy: https:\/\/github.com\/linuxdeploy\/linuxdeploy\/releases\nlinuxdeploy-plugin-appimage: https:\/\/github.com\/linuxdeploy\/linuxdeploy-plugin-appimage\/releases\n\nRunning hsinstall on a project for the first time and with no arguments will produce this in . :\n\n    AppDir\/\n      usr\/\n        bin\/  <-- All binaries in the project\n        share\/\n          <PROJECT-NAME>\/\n            doc\/\n              LICENSE\n\nThe -p,--prefix switch allows you to set a prefix other than `AppDir\/usr`. This could be anywhere, like `myproject-2.3` or `\/usr\/local` or `\/opt`\n\nIn addition, if an `hsinstall` directory exists, its contents will be copied into the prefix before build and install. See TEMPLATE DIRECTORY below for more info on this.\n\nAPPIMAGE CREATION\n\nThe -i,--mk-appimage switch will change the default prefix to `EXE.AppDir\/usr` and only the specified EXE will be installed into `<PREFIX>\/bin`, AppImages are intended to be made for exactly one binary.\n\nIf .desktop and .svg files are not found in the hsinstall directory, defaults will be created for you and placed in the correct subdirs. Check these files into source control for future builds.\n\nThe default `.desktop` file Categories will be populated with 'Utility;'. We recommend adjusting this using the XDG list of registered categories: https:\/\/specifications.freedesktop.org\/menu-spec\/latest\/apa.html\n\nIf your application is a command-line program, append a line containing this to the end of the default `.desktop` file: 'Terminal=true'\n\nIf your application isn't a command-line program, we recommend using a proper icon instead of the hsinstall default, which is a command shell icon.\n\nFor more info on AppImage: https:\/\/appimage.org\/\n\nTEMPLATE DIRECTORY\n\nIf present, hsinstall will copy the contents of the `hsinstall` template directory into `<PREFIX>`. Here's an explanation of the hsinstall directory contents:\n\n    hsinstall\/\n      bin\/  <-- Put additional binaries and scripts to be deployed here\n      share\/\n        applications\/  <-- Only for AppImage\n          <EXE>.desktop  <-- Will be generated by first-time AppImage creation attempt\n        <PROJECT-NAME>\/  <-- Only needed if you have resources\n          resources\/  <-- Put data files your software will need at runtime here\n        icons\/  <-- Only for AppImage\n          hicolor\/\n            scalable\/\n              apps\/\n                <EXE>.svg  <-- Will be generated by first-time AppImage creation attempt\n\nIn order to locate data files at runtime, including resources, the hsinstall project includes a library to construct the share path relative to the executable. See this source code for help with integrating this into your app: https:\/\/github.com\/dino-\/hsinstall\/blob\/master\/src\/lib\/HSInstall\/Resources.hs\n\nVersion %s  Dino Morelli <dino@ui3.info>|]","function_tokens":["content","=","[","here","|","OVERVIEW\n\nhsinstall is a tool for installing a Haskell software project into a directory structure for deployment. It builds upon the `stack install` and `cabal install` commands and adds these features:\n\n- Copies the `LICENSE` file into <PREFIX>\/share\/<PROJECT-NAME>\/doc\n- Copies the contents of a static directory stucture in your project (named `hsinstall`) into the destination prefix directory. This can contain additional binaries or scripts, resources, documentation, etc. (more on this later in TEMPLATE DIRECTORY)\n- Optionally builds an AppDir directory structure for the project and produces an AppImage binary\n\nTo use hsinstall, it will be necessary to be in the top-level directory of a Haskell project that builds with either cabal or stack. You'll need to have one or the other of the cabal or stack tools on your path as well. Basically, if you can't build the project, hsinstall can't build it either.\n\nAlso note that all cabal commands will be issued as `v2-*` commands. The older `v1-*` commands are deprecated and we don't use them.\n\nIf the AppImage features are desired, you must have these tools on your PATH:\nlinuxdeploy: https:\/\/github.com\/linuxdeploy\/linuxdeploy\/releases\nlinuxdeploy-plugin-appimage: https:\/\/github.com\/linuxdeploy\/linuxdeploy-plugin-appimage\/releases\n\nRunning hsinstall on a project for the first time and with no arguments will produce this in . :\n\n    AppDir\/\n      usr\/\n        bin\/  <-- All binaries in the project\n        share\/\n          <PROJECT-NAME>\/\n            doc\/\n              LICENSE\n\nThe -p,--prefix switch allows you to set a prefix other than `AppDir\/usr`. This could be anywhere, like `myproject-2.3` or `\/usr\/local` or `\/opt`\n\nIn addition, if an `hsinstall` directory exists, its contents will be copied into the prefix before build and install. See TEMPLATE DIRECTORY below for more info on this.\n\nAPPIMAGE CREATION\n\nThe -i,--mk-appimage switch will change the default prefix to `EXE.AppDir\/usr` and only the specified EXE will be installed into `<PREFIX>\/bin`, AppImages are intended to be made for exactly one binary.\n\nIf .desktop and .svg files are not found in the hsinstall directory, defaults will be created for you and placed in the correct subdirs. Check these files into source control for future builds.\n\nThe default `.desktop` file Categories will be populated with 'Utility;'. We recommend adjusting this using the XDG list of registered categories: https:\/\/specifications.freedesktop.org\/menu-spec\/latest\/apa.html\n\nIf your application is a command-line program, append a line containing this to the end of the default `.desktop` file: 'Terminal=true'\n\nIf your application isn't a command-line program, we recommend using a proper icon instead of the hsinstall default, which is a command shell icon.\n\nFor more info on AppImage: https:\/\/appimage.org\/\n\nTEMPLATE DIRECTORY\n\nIf present, hsinstall will copy the contents of the `hsinstall` template directory into `<PREFIX>`. Here's an explanation of the hsinstall directory contents:\n\n    hsinstall\/\n      bin\/  <-- Put additional binaries and scripts to be deployed here\n      share\/\n        applications\/  <-- Only for AppImage\n          <EXE>.desktop  <-- Will be generated by first-time AppImage creation attempt\n        <PROJECT-NAME>\/  <-- Only needed if you have resources\n          resources\/  <-- Put data files your software will need at runtime here\n        icons\/  <-- Only for AppImage\n          hicolor\/\n            scalable\/\n              apps\/\n                <EXE>.svg  <-- Will be generated by first-time AppImage creation attempt\n\nIn order to locate data files at runtime, including resources, the hsinstall project includes a library to construct the share path relative to the executable. See this source code for help with integrating this into your app: https:\/\/github.com\/dino-\/hsinstall\/blob\/master\/src\/lib\/HSInstall\/Resources.hs\n\nVersion %s  Dino Morelli <dino@ui3.info>","|]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Opts.hs#L103-L166","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Opts.hs","hash_val":22933,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"squash","parameters":"l r","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Removes anything between two RealSrcSpans, providing they are on the same line.","docstring_summary":"------------------------------------------------------------------------------ Removes anything between two RealSrcSpans, providing they are on the same line.","docstring_tokens":["------------------------------------------------------------------------------","Removes","anything","between","two","RealSrcSpans","providing","they","are","on","the","same","line","."],"function":"squash l r\n    | GHC.srcSpanEndLine l \/= GHC.srcSpanStartLine r = mempty\n    | GHC.srcSpanEndCol l >= GHC.srcSpanStartCol r = mempty\n    | otherwise = Editor.replace\n        (GHC.srcSpanEndLine l)\n        (GHC.srcSpanEndCol l)\n        (GHC.srcSpanStartCol r)\n        \" \"","function_tokens":["squash","l","r","|","GHC","srcSpanEndLine","l","\/=","GHC","srcSpanStartLine","r","=","mempty","|","GHC","srcSpanEndCol","l",">=","GHC","srcSpanStartCol","r","=","mempty","|","otherwise","=","Editor","replace","(","GHC","srcSpanEndLine","l",")","(","GHC","srcSpanEndCol","l",")","(","GHC","srcSpanStartCol","r",")","\" \""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L27-L34","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"alignment","parameters":"~(Source b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alignment ~(Source b) = alignment b","function_tokens":["alignment","~","(","Source","b",")","=","alignment","b"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L118-L118","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"stripCommentMarks","parameters":"MultiLine","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stripCommentMarks MultiLine = reverse . drop 2 . reverse . drop 2","function_tokens":["stripCommentMarks","MultiLine","=","reverse",".","drop","2",".","reverse",".","drop","2"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L47-L47","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Extensions.hs","language":"haskell","identifier":"alVersion","parameters":"","argument_list":"","return_statement":"","docstring":"Contains a version string in the format @\\\"\/\\<spec major number\\>\/.\/\\<spec minor number\\>\/ \/\\<optional vendor version information\\>\/\\\"@.","docstring_summary":"Contains a version string in the format","docstring_tokens":["Contains","a","version","string","in","the","format"],"function":"alVersion = makeGettableStateVar (getString Version)","function_tokens":["alVersion","=","makeGettableStateVar","(","getString","Version",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Extensions.hs#L54-L54","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Extensions.hs","hash_val":40318,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fclError","parameters":"err","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fclError err = error (\"Data.Label.Derive: \" ++ err)","function_tokens":["fclError","err","=","error","(","\"Data.Label.Derive: \"","++","err",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L719-L719","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ifold","parameters":"(And as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (And as) = coerce (mconcat :: [m] -> m) as","function_tokens":["ifold","(","And","as",")","=","coerce","(","mconcat","::","[","m","]","->","m",")","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L365-L365","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"unsafeFreeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFreeze = undefined","function_tokens":["unsafeFreeze","=","undefined"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L121-L121","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"within'","parameters":"a b x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"within' a b x = x >= a && x <= b","function_tokens":["within'","a","b","x","=","x",">=","a","&&","x","<=","b"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L221-L221","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"overflows","parameters":"ss str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"overflows ss str = length ss > maxWidth ||\n        ((length ss + length str) >= maxWidth && ind + length str  <= maxWidth)","function_tokens":["overflows","ss","str","=","length","ss",">","maxWidth","||","(","(","length","ss","+","length","str",")",">=","maxWidth","&&","ind","+","length","str","<=","maxWidth",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L107-L108","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"bullet","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bullet = _menuItemPrefix m index","function_tokens":["bullet","=","_menuItemPrefix","m","index"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L232-L232","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictVector3ALfloat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictVector3ALfloat = Dictionary {\n   alGetter  = alGetSourcefv,\n   alSetter  = alSourcefv,\n   size      = 3,\n   peekSize  = peek3 Vector3,\n   marshal   = id }","function_tokens":["dictVector3ALfloat","=","Dictionary","{","alGetter","=","alGetSourcefv",",","alSetter","=","alSourcefv",",","size","=","3",",","peekSize","=","peek3","Vector3",",","marshal","=","id","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L563-L568","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"match","parameters":"i p m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"match i p m\n  = (mask i m) == p","function_tokens":["match","i","p","m","=","(","mask","i","m",")","==","p"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L910-L911","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"itraverse","parameters":"f (Select is es a i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Select is es a i)   = Select is es <$> f a <*> f i","function_tokens":["itraverse","f","(","Select","is","es","a","i",")","=","Select","is","es","<$>","f","a","<*>","f","i"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L71-L71","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"toRows","parameters":"","argument_list":"","return_statement":"","docstring":"O(m) Return the rows","docstring_summary":"O(m) Return the rows","docstring_tokens":["O","(","m",")","Return","the","rows"],"function":"toRows = MG.toRows","function_tokens":["toRows","=","MG","toRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L171-L171","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"moduleLanguagePragmas","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moduleLanguagePragmas =\n    mapMaybe prag . epAnnComments . GHC.hsmodAnn . GHC.unLoc\n  where\n    prag :: GHC.LEpaComment -> Maybe (GHC.RealSrcSpan, NonEmpty String)\n    prag comment = case GHC.ac_tok (GHC.unLoc comment) of\n        GHC.EpaBlockComment str\n            | lang : p1 : ps <- tokenize str, map toLower lang == \"language\" ->\n                pure (GHC.anchor (GHC.getLoc comment), p1 :| ps)\n        _ -> Nothing\n\n    tokenize = words .\n        map (\\c -> if c == ',' then ' ' else c) .\n        takeWhile (\/= '#') .\n        drop 1 . dropWhile (\/= '#')","function_tokens":["moduleLanguagePragmas","=","mapMaybe","prag",".","epAnnComments",".","GHC","hsmodAnn",".","GHC","unLoc","where","prag","::","GHC","LEpaComment","->","Maybe","(","GHC","RealSrcSpan",",","NonEmpty","String",")","prag","comment","=","case","GHC","ac_tok","(","GHC","unLoc","comment",")","of","GHC","EpaBlockComment","str","|","lang",":","p1",":","ps","<-","tokenize","str",",","map","toLower","lang","==","\"language\"","->","pure","(","GHC","anchor","(","GHC","getLoc","comment",")",",","p1",":|","ps",")","_","->","Nothing","tokenize","=","words",".","map","(","\\","c","->","if","c","==","','","then","' '","else","c",")",".","takeWhile","(","\/=","'#'",")",".","drop","1",".","dropWhile","(","\/=","'#'",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L136-L149","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"ishow","parameters":"(InR ga)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (InR ga) = ishow ga","function_tokens":["ishow","(","InR","ga",")","=","ishow","ga"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L100-L100","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INVERSE_DISTANCE_CLAMPED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INVERSE_DISTANCE_CLAMPED         = 0xD002","function_tokens":["al_INVERSE_DISTANCE_CLAMPED","=","0xD002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L56-L56","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"matchTop","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchTop = match sideBase sideA sideB","function_tokens":["matchTop","=","match","sideBase","sideA","sideB"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L45-L45","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"isRedundant","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isRedundant _ _              = False","function_tokens":["isRedundant","_","_","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L173-L173","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"parser","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser =\n  O.hsubparser $\n    mconcat\n      [ O.command \"help\" (O.info (pure Help) $ O.progDesc \"This message\"),\n        O.command \"echo\" (O.info echoP $ O.progDesc \"Print all arguments\"),\n        O.command \"set-prompt\" (O.info promptP $ O.progDesc \"Change the prompt\")\n      ]\n  where\n    echoP =\n      Echo\n        <$> many\n          ( O.strArgument $\n              mconcat\n                [ O.metavar \"STR\",\n                  O.help \"A string to print\"\n                ]\n          )\n    promptP =\n      SetPrompt\n        <$> O.strArgument\n          ( mconcat\n              [ O.metavar \"STR\",\n                O.help \"Set the prompt to STR\"\n              ]\n          )","function_tokens":["parser","=","O","hsubparser","$","mconcat","[","O","command","\"help\"","(","O","info","(","pure","Help",")","$","O","progDesc","\"This message\"",")",",","O","command","\"echo\"","(","O","info","echoP","$","O","progDesc","\"Print all arguments\"",")",",","O","command","\"set-prompt\"","(","O","info","promptP","$","O","progDesc","\"Change the prompt\"",")","]","where","echoP","=","Echo","<$>","many","(","O","strArgument","$","mconcat","[","O","metavar","\"STR\"",",","O","help","\"A string to print\"","]",")","promptP","=","SetPrompt","<$>","O","strArgument","(","mconcat","[","O","metavar","\"STR\"",",","O","help","\"Set the prompt to STR\"","]",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L31-L57","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"c'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c' = if power `mod` 2 == 1 then c else -c","function_tokens":["c'","=","if","power","`","mod","`","2","==","1","then","c","else","-","c"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L118-L118","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/demo.hs","language":"haskell","identifier":"example","parameters":"","argument_list":"","return_statement":"","docstring":"Simple example.","docstring_summary":"Simple example.","docstring_tokens":["Simple","example","."],"function":"example = do\n  sayLn (\"Hey, I like \" <> (\"Haskell\" & fg magenta) <> \"!\")\n\n  let question =\n        \"What's \"\n          <> (\"your\" & bold)\n          <> \" favorite \"\n          <> (\"language\" & fg green & underline)\n          <> \"? \"\n\n  askLn question (Just \"Haskell\")\n\n-- | Main.","function_tokens":["example","=","do","sayLn","(","\"Hey, I like \"","<>","(","\"Haskell\"","&","fg","magenta",")","<>","\"!\"",")","let","question","=","\"What's \"","<>","(","\"your\"","&","bold",")","<>","\" favorite \"","<>","(","\"language\"","&","fg","green","&","underline",")","<>","\"? \"","askLn","question","(","Just","\"Haskell\"",")","-- | Main."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/demo.hs#L24-L37","hash_key":"pjones\/byline:examples\/demo.hs","hash_val":17487,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ishow","parameters":"(Mul ms)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Mul ms)         = coerce $ \"(* \" ++ intercalate \" \" (coerce ms) ++ \")\"","function_tokens":["ishow","(","Mul","ms",")","=","coerce","$","\"(* \"","++","intercalate","\" \"","(","coerce","ms",")","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L98-L98","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"unicode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unicode =\n        needsUnicode entryName\n          || maybe False needsUnicode edComment","function_tokens":["unicode","=","needsUnicode","entryName","||","maybe","False","needsUnicode","edComment"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L822-L824","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"fmap","parameters":"f m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f m = RSST $ \\r s ->\n        fmap (\\ (a, (s', w)) -> (f a, (s', w))) $ runRSST' m r s","function_tokens":["fmap","f","m","=","RSST","$","\\","r","s","->","fmap","(","\\","(","a",",","(","s'",",","w",")",")","->","(","f","a",",","(","s'",",","w",")",")",")","$","runRSST'","m","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L123-L124","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Bin i _ _ _ _ _ `compare` Bin j _ _ _ _ _ = compare i j","function_tokens":["Bin","i","_","_","_","_","_","`","compare","`","Bin","j","_","_","_","_","_","=","compare","i","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L855-L855","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"pxy","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pxy = mask px mxy","function_tokens":["pxy","=","mask","px","mxy"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L751-L751","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"dropBom","parameters":"('\\xfeff' : str)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dropBom ('\\xfeff' : str) = str","function_tokens":["dropBom","(","'\\xfeff'",":","str",")","=","str"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L54-L54","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"nrow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nrow = n `div` ncol","function_tokens":["nrow","=","n","`","div","`","ncol"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L138-L138","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"linesDown","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"linesDown = linesUp . negate","function_tokens":["linesDown","=","linesUp",".","negate"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L220-L220","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"queens","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"queens n = foldl' (>>=) (pure empty) (replicate n (addOne n))","function_tokens":["queens","n","=","foldl'","(",">>=",")","(","pure","empty",")","(","replicate","n","(","addOne","n",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L49-L49","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"bucket","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bucket = self:closestKnown","function_tokens":["bucket","=","self",":","closestKnown"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L154-L154","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(History _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (History _)              = (True, True, False, False)","function_tokens":["go","(","History","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L372-L372","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"guardsLocs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"guardsLocs = map GHC.getLocA guards","function_tokens":["guardsLocs","=","map","GHC","getLocA","guards"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L168-L168","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Key _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Key _)                  = (False, True{-last-}, True, True)","function_tokens":["go","(","Key","_",")","=","(","False",",","True","{-last-}",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L375-L375","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_ `ieq1` _ = False","function_tokens":["_","`","ieq1","`","_","=","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L66-L66","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseJSON","parameters":"(A.Object v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseJSON (A.Object v) =\n    Quad <$>\n    v A..: \"subject\" <*>\n    v A..: \"predicate\" <*>\n    v A..: \"object\" <*>\n    v A..:? \"label\"","function_tokens":["parseJSON","(","A","Object","v",")","=","Quad","<$>","v","A",".:","\"subject\"","<*>","v","A",".:","\"predicate\"","<*>","v","A",".:","\"object\"","<*>","v","A",".:?","\"label\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L84-L89","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"linfun","parameters":"xs t","argument_list":"","return_statement":"","docstring":"Linear interpolation. Can be useful with 'mapEvents' for envelope changes.  > linfun [a, da, b, db, c, ... ]  @a, b, c ...@ - values  @da, db, ...@ - duration of segments","docstring_summary":"Linear interpolation. Can be useful with 'mapEvents' for envelope changes.  > linfun [a, da, b, db, c, ... ]","docstring_tokens":["Linear","interpolation",".","Can","be","useful","with","mapEvents","for","envelope","changes",".",">","linfun","[","a","da","b","db","c","...","]"],"function":"linfun xs t =\n    case xs of\n        (a:dur:b:[])      -> seg a dur b t\n        (a:dur:b:(x:xs')) -> if t < dur\n                             then seg a dur b t\n                             else linfun (b:x:xs') (t - dur)\n    where seg a dur b t\n                | t < 0     = a\n                | t >= dur  = b\n                | otherwise = a + (b - a)*(t\/dur)\n\n\n-- | With 'linfunRel' you can make linear interpolation\n-- function that has equal distance between points.\n-- First argument gives total length of the interpolation function\n-- and second argument gives list of values. So call\n--\n-- > linfunRel dur [a1, a2, a3, ..., aN]\n--\n-- is equivalent to:\n--\n-- > linfun [a1, dur\/N, a2, dur\/N, a3, ..., dur\/N, aN]","function_tokens":["linfun","xs","t","=","case","xs","of","(","a",":","dur",":","b",":","[","]",")","->","seg","a","dur","b","t","(","a",":","dur",":","b",":","(","x",":","xs'",")",")","->","if","t","<","dur","then","seg","a","dur","b","t","else","linfun","(","b",":","x",":","xs'",")","(","t","-","dur",")","where","seg","a","dur","b","t","|","t","<","0","=","a","|","t",">=","dur","=","b","|","otherwise","=","a","+","(","b","-","a",")","*","(","t","\/","dur",")","-- | With 'linfunRel' you can make linear interpolation","-- function that has equal distance between points.","-- First argument gives total length of the interpolation function","-- and second argument gives list of values. So call","--","-- > linfunRel dur [a1, a2, a3, ..., aN]","--","-- is equivalent to:","--","-- > linfun [a1, dur\/N, a2, dur\/N, a3, ..., dur\/N, aN]"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L385-L407","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"first","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"first v = VarT $ \\(b, d) -> g d <$> runVarT v b\n    where g d (c, v') = ((c, d), first v')","function_tokens":["first","v","=","VarT","$","\\","(","b",",","d",")","->","g","d","<$>","runVarT","v","b","where","g","d","(","c",",","v'",")","=","(","(","c",",","d",")",",","first","v'",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L154-L157","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = ConduitParser $ throwError $ Unexpected \"ConduitParser.empty\"","function_tokens":["empty","=","ConduitParser","$","throwError","$","Unexpected","\"ConduitParser.empty\""],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L70-L70","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"poly","parameters":"p x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"poly p x = go p\n    where\n        go []       = 0\n        go (c:cs)   = c + x * go cs","function_tokens":["poly","p","x","=","go","p","where","go","[","]","=","0","go","(","c",":","cs",")","=","c","+","x","*","go","cs"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L92-L97","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"overwrite","parameters":"fileName newContent","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"overwrite fileName newContent =\n    do  oldPermissions <- getPermissions fileName\n        renameFile fileName bkup\n        writeFile fileName newContent\n        setPermissions fileName oldPermissions\n        removeFile bkup\n    where\n        bkup = fileName <.> \"bk\"","function_tokens":["overwrite","fileName","newContent","=","do","oldPermissions","<-","getPermissions","fileName","renameFile","fileName","bkup","writeFile","fileName","newContent","setPermissions","fileName","oldPermissions","removeFile","bkup","where","bkup","=","fileName","<.>","\"bk\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L73-L82","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Strict.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Strict.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Strict.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Strict.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Strict.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Tell","w",")","->","ctx","<$","Writer","Strict","tell","w","L","(","Listen","m",")","->","swapAndLift","<$>","Writer","Strict","listen","(","hdl","(","m","<$","ctx",")",")","L","(","Censor","f","m",")","->","Writer","Strict","censor","f","(","hdl","(","m","<$","ctx",")",")","R","other","->","Writer","Strict","WriterT","$","getSwap","<$>","thread","(","(","\\","(","Swap","(","x",",","s",")",")","->","Swap",".","fmap","(","mappend","s",")","<$>","Writer","Strict","runWriterT","x",")","~<~","hdl",")","other","(","Swap","(","ctx",",","mempty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L329-L334","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"show","parameters":"Stack","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show Stack = \"stack\"","function_tokens":["show","Stack","=","\"stack\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L22-L22","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"handleCommand","parameters":"(STORE key value) _ inst","argument_list":"","return_statement":"","docstring":"Insert the value into the values store and start the expiration process","docstring_summary":"Insert the value into the values store and start the expiration process","docstring_tokens":["Insert","the","value","into","the","values","store","and","start","the","expiration","process"],"function":"handleCommand (STORE key value) _ inst = do\n    insertValue key value inst\n    void . forkIO . expirationProcess inst $ key\n-- Return the value, if known, or the closest other known Nodes","function_tokens":["handleCommand","(","STORE","key","value",")","_","inst","=","do","insertValue","key","value","inst","void",".","forkIO",".","expirationProcess","inst","$","key","-- Return the value, if known, or the closest other known Nodes"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L270-L274","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"defaultMainWith","parameters":"_ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultMainWith _ [] = pure ()","function_tokens":["defaultMainWith","_","[","]","=","pure","(",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L135-L135","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = Point zeroArrow zeroArrow","function_tokens":["empty","=","Point","zeroArrow","zeroArrow"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L104-L104","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"toList","parameters":"t","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nLists\n------------------------------------------------------------------} \/O(n)\/. Convert the set to a list of elements.","docstring_summary":"{--------------------------------------------------------------------\nLists\n------------------------------------------------------------------} \/O(n)\/. Convert the set to a list of elements.","docstring_tokens":["{","--------------------------------------------------------------------","Lists","------------------------------------------------------------------","}","\/","O","(","n",")","\/",".","Convert","the","set","to","a","list","of","elements","."],"function":"toList t = fold (:) [] t","function_tokens":["toList","t","=","fold","(",":",")","[","]","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L716-L716","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = TweenT . lift . lift","function_tokens":["lift","=","TweenT",".","lift",".","lift"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L186-L186","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"instantiate","parameters":"v (InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"instantiate v (InR gb) = instantiate v gb","function_tokens":["instantiate","v","(","InR","gb",")","=","instantiate","v","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L918-L918","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"fromRational","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromRational = pure . fromRational","function_tokens":["fromRational","=","pure",".","fromRational"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L262-L262","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"alg","parameters":"hdl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl = \\case\n    L sub -> UnderLabel . alg (runUnderLabel . hdl) (injLabelled @label (Labelled sub))\n    R sig -> UnderLabel . alg (runUnderLabel . hdl) sig","function_tokens":["alg","hdl","=","\\","case","L","sub","->","UnderLabel",".","alg","(","runUnderLabel",".","hdl",")","(","injLabelled","@","label","(","Labelled","sub",")",")","R","sig","->","UnderLabel",".","alg","(","runUnderLabel",".","hdl",")","sig"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L149-L152","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/String.hs","language":"haskell","identifier":"peekALCStrings","parameters":"ptr","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"peekALCStrings ptr = loop ptr []\n   where loop p strs = do\n            str <- peekALCString p\n            if str == \"\"\n               then return (reverse strs)\n               else do\n                  len <- lengthArray0 0 p\n                  loop (p `plusPtr` (len + 1)) (str : strs)","function_tokens":["peekALCStrings","ptr","=","loop","ptr","[","]","where","loop","p","strs","=","do","str","<-","peekALCString","p","if","str","==","\"\"","then","return","(","reverse","strs",")","else","do","len","<-","lengthArray0","0","p","loop","(","p","`","plusPtr","`","(","len","+","1",")",")","(","str",":","strs",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/String.hs#L36-L43","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/String.hs","hash_val":13294,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showTree","parameters":"s","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nDebugging\n------------------------------------------------------------------} \/O(n)\/. Show the tree that implements the set. The tree is shown in a compressed, hanging format.","docstring_summary":"{--------------------------------------------------------------------\nDebugging\n------------------------------------------------------------------} \/O(n)\/. Show the tree that implements the set. The tree is shown in a compressed, hanging format.","docstring_tokens":["{","--------------------------------------------------------------------","Debugging","------------------------------------------------------------------","}","\/","O","(","n",")","\/",".","Show","the","tree","that","implements","the","set",".","The","tree","is","shown","in","a","compressed","hanging","format","."],"function":"showTree s\n  = showTreeWith True False s","function_tokens":["showTree","s","=","showTreeWith","True","False","s"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L769-L770","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"optional","parameters":"a","argument_list":"","return_statement":"","docstring":"Select between 'Just' the result of an operation, and 'Nothing'.  @ 'optional' 'empty' = 'pure' 'Nothing' @ @ 'optional' ('pure' a) = 'pure' ('Just' a) @  @since 1.0.0.0","docstring_summary":"Select between 'Just' the result of an operation, and 'Nothing'.","docstring_tokens":["Select","between","Just","the","result","of","an","operation","and","Nothing","."],"function":"optional a = Just <$> a <|> pure Nothing","function_tokens":["optional","a","=","Just","<$>","a","<|>","pure","Nothing"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L80-L80","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"go","parameters":"s t l i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go s t l i = do\n      (e, l1) <- runTweenT s i l\n      case e of\n        Left _        -> return (t, done t)\n        Right (b, s1) -> return (b, VarT $ go s1 b l1)\n\n\n--------------------------------------------------------------------------------\n-- $creation\n-- The most direct route toward tweening values is to use 'tween'\n-- along with an interpolation function such as 'easeInExpo'. For example,\n-- @tween easeInExpo 0 100 10@, this will create a spline that produces a\n-- number interpolated from 0 to 100 over 10 seconds. At the end of the\n-- tween the spline will return the result value.\n--------------------------------------------------------------------------------\n\n-- | Creates a spline that produces a value interpolated between a start and\n-- end value using an easing equation ('Easing') over a duration.  The\n-- resulting spline will take a time delta as input.\n-- Keep in mind that `tween` must be fed time deltas, not absolute time or\n-- duration. This is mentioned because the author has made that mistake\n-- more than once ;)\n--\n-- `tween` concludes returning the latest output value.","function_tokens":["go","s","t","l","i","=","do","(","e",",","l1",")","<-","runTweenT","s","i","l","case","e","of","Left","_","->","return","(","t",",","done","t",")","Right","(","b",",","s1",")","->","return","(","b",",","VarT","$","go","s1","b","l1",")","--------------------------------------------------------------------------------","-- $creation","-- The most direct route toward tweening values is to use 'tween'","-- along with an interpolation function such as 'easeInExpo'. For example,","-- @tween easeInExpo 0 100 10@, this will create a spline that produces a","-- number interpolated from 0 to 100 over 10 seconds. At the end of the","-- tween the spline will return the result value.","--------------------------------------------------------------------------------","-- | Creates a spline that produces a value interpolated between a start and","-- end value using an easing equation ('Easing') over a duration.  The","-- resulting spline will take a time delta as input.","-- Keep in mind that `tween` must be fed time deltas, not absolute time or","-- duration. This is mentioned because the author has made that mistake","-- more than once ;)","--","-- `tween` concludes returning the latest output value."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L266-L290","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"cnst'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cnst' = toDynamicallySorted . cnst <$> signed decimal","function_tokens":["cnst'","=","toDynamicallySorted",".","cnst","<$>","signed","decimal"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L104-L104","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_FREQUENCY","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_FREQUENCY                       = 0x1007","function_tokens":["alc_FREQUENCY","=","0x1007"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L132-L132","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Bin i _ _ _ _ _ == Bin j _ _ _ _ _ = i == j","function_tokens":["Bin","i","_","_","_","_","_","==","Bin","j","_","_","_","_","_","=","i","==","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L838-L838","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"asin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"asin = fmap asin","function_tokens":["asin","=","fmap","asin"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L249-L249","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"go","parameters":"ty","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go ty =\n    case ty of\n      ForallT v c t -> f (ForallT v c (go t))\n      AppT a b      -> f (AppT (go a) (go b))\n      SigT t k      -> f (SigT (go t) k)\n      _             -> f ty","function_tokens":["go","ty","=","case","ty","of","ForallT","v","c","t","->","f","(","ForallT","v","c","(","go","t",")",")","AppT","a","b","->","f","(","AppT","(","go","a",")","(","go","b",")",")","SigT","t","k","->","f","(","SigT","(","go","t",")","k",")","_","->","f","ty"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L657-L664","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"hasMergableQualified","parameters":"QualifiedPre QualifiedPost","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hasMergableQualified QualifiedPre QualifiedPost = True","function_tokens":["hasMergableQualified","QualifiedPre","QualifiedPost","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L73-L73","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrState","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrState      = F.unsafeForeignPtrToPtr fptrState","function_tokens":["ptrState","=","F","unsafeForeignPtrToPtr","fptrState"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L43-L43","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Lens pointing to the second component of a 2-tuple. (Total and polymorphic)","docstring_summary":"Lens pointing to the second component of a 2-tuple. (Total and polymorphic)","docstring_tokens":["Lens","pointing","to","the","second","component","of","a","2","-","tuple",".","(","Total","and","polymorphic",")"],"function":"(fst, snd) = $(getLabel ''(,))","function_tokens":["(","fst",",","snd",")","=","(","getLabel","''","(",",",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L89-L89","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"genObjectNames","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"genObjectNames n = liftIO $\n      allocaArray n $ \\buf -> do\n         alGenSources (fromIntegral n) buf\n         peekArray n buf","function_tokens":["genObjectNames","n","=","liftIO","$","allocaArray","n","$","\\","buf","->","do","alGenSources","(","fromIntegral","n",")","buf","peekArray","n","buf"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L128-L133","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"prenex","parameters":"f","argument_list":"","return_statement":"","docstring":"Puts an expression into prenex form (quantifier prefix and a quantifier-free formula).","docstring_summary":"Puts an expression into prenex form (quantifier prefix and a quantifier-free formula).","docstring_tokens":["Puts","an","expression","into","prenex","form","(","quantifier","prefix","and","a","quantifier","-","free","formula",")","."],"function":"prenex f = let (a, (_, q)) = runState (imapM (pushQuantifier . unIFix) (nnf f)) (freenames f, id) in q a","function_tokens":["prenex","f","=","let","(","a",",","(","_",",","q",")",")","=","runState","(","imapM","(","pushQuantifier",".","unIFix",")","(","nnf","f",")",")","(","freenames","f",",","id",")","in","q","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L752-L752","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"binderFromType","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"binderFromType = go\n  where\n  go ty =\n    case ty of\n      ForallT ts _ _ -> ts\n      AppT a b       -> go a ++ go b\n      SigT t _       -> go t\n#if MIN_VERSION_template_haskell(2,17,0)\n      VarT n         -> [PlainTV n SpecifiedSpec]\n#else\n      VarT n         -> [PlainTV n]\n#endif\n      _              -> []","function_tokens":["binderFromType","=","go","where","go","ty","=","case","ty","of","ForallT","ts","_","_","->","ts","AppT","a","b","->","go","a","++","go","b","SigT","t","_","->","go","t","#if MIN_VERSION_template_haskell(2,17,0)","VarT","n","->","[","PlainTV","n","SpecifiedSpec","]","#else\n      VarT n         -> [PlainTV n]\n","#endif","_","->","[","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L628-L642","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","language":"haskell","identifier":"emptyBpState","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"emptyBpState = do\n  fptr <- F.mallocForeignPtrBytes 32\n  return (BpState (F.castForeignPtr fptr))","function_tokens":["emptyBpState","=","do","fptr","<-","F","mallocForeignPtrBytes","32","return","(","BpState","(","F","castForeignPtr","fptr",")",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs#L49-L53","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","hash_val":30325,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Common.hs","language":"haskell","identifier":"iconFilename","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"iconFilename = \"unix-terminal\" <.> \"svg\"","function_tokens":["iconFilename","=","\"unix-terminal\"","<.>","\"svg\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Common.hs#L38-L38","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Common.hs","hash_val":33449,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mappendTList","parameters":"a       Empty","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappendTList a       Empty   = a","function_tokens":["mappendTList","a","Empty","=","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L316-L316","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"PING","argument_list":"","return_statement":"","docstring":"Turn the command arguments into a ByteString","docstring_summary":"Turn the command arguments into a ByteString","docstring_tokens":["Turn","the","command","arguments","into","a","ByteString"],"function":"commandArgs PING                 = B.empty","function_tokens":["commandArgs","PING","=","B","empty"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L36-L36","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"isUnary","parameters":"c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isUnary c = case GHC.unLoc c of\n      GHC.ConDeclH98 {..} -> case con_args of\n        GHC.PrefixCon tyargs args -> null tyargs && null args\n        _                         -> False\n      _ -> False","function_tokens":["isUnary","c","=","case","GHC","unLoc","c","of","GHC","ConDeclH98","{","..","}","->","case","con_args","of","GHC","PrefixCon","tyargs","args","->","null","tyargs","&&","null","args","_","->","False","_","->","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L540-L546","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"isSubsetOf","parameters":"(Tip _ x) t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSubsetOf (Tip _ x) t          = member x t","function_tokens":["isSubsetOf","(","Tip","_","x",")","t","=","member","x","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L489-L489","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty = go\n        where\n            go Major        = \"\"\n            go Minor        = \"minor\"\n            go Ionian       = \"ionian\"\n            go Dorian       = \"dorian\"\n            go Phrygian     = \"phrygian\"\n            go Lydian       = \"lydian\"\n            go Mixolydian   = \"mixolydian\"\n            go Aeolian      = \"aeolian\"\n            go Locrian      = \"locrian\"\n\n\n\n\n-- | Optional string, numerators, frequency (3.1.8)","function_tokens":["pretty","=","go","where","go","Major","=","\"\"","go","Minor","=","\"minor\"","go","Ionian","=","\"ionian\"","go","Dorian","=","\"dorian\"","go","Phrygian","=","\"phrygian\"","go","Lydian","=","\"lydian\"","go","Mixolydian","=","\"mixolydian\"","go","Aeolian","=","\"aeolian\"","go","Locrian","=","\"locrian\"","-- | Optional string, numerators, frequency (3.1.8)"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L526-L542","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","language":"haskell","identifier":"allocWorkBuffers","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allocWorkBuffers n = do\n  fptr <- F.mallocForeignPtrBytes (6 * n)\n  let ptr = F.unsafeForeignPtrToPtr fptr\n  return WorkBuffers\n    { workBuffersP = fptr\n    , workBuffersD = ptr `F.plusPtr`  0\n    , workBuffersA = ptr `F.plusPtr`  n\n    , workBuffersZ = ptr `F.plusPtr` (n * 2)\n    , workBuffersQ = ptr `F.plusPtr` (n * 3)\n    , workBuffersB = ptr `F.plusPtr` (n * 4)\n    , workBuffersE = ptr `F.plusPtr` (n * 5)\n    }","function_tokens":["allocWorkBuffers","n","=","do","fptr","<-","F","mallocForeignPtrBytes","(","6","*","n",")","let","ptr","=","F","unsafeForeignPtrToPtr","fptr","return","WorkBuffers","{","workBuffersP","=","fptr",",","workBuffersD","=","ptr","`","F","plusPtr","`","0",",","workBuffersA","=","ptr","`","F","plusPtr","`","n",",","workBuffersZ","=","ptr","`","F","plusPtr","`","(","n","*","2",")",",","workBuffersQ","=","ptr","`","F","plusPtr","`","(","n","*","3",")",",","workBuffersB","=","ptr","`","F","plusPtr","`","(","n","*","4",")",",","workBuffersE","=","ptr","`","F","plusPtr","`","(","n","*","5",")","}"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs#L54-L67","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","hash_val":30325,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"fmt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmt = commentFormat c","function_tokens":["fmt","=","commentFormat","c"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L39-L39","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"connectCayley","parameters":"c","argument_list":"","return_statement":"","docstring":"Get a connection to Cayley with the given configuration.  >\u03bb> conn <- connectCayley defaultCayleyConfig","docstring_summary":"Get a connection to Cayley with the given configuration.  >\u03bb> conn <- connectCayley defaultCayleyConfig","docstring_tokens":["Get","a","connection","to","Cayley","with","the","given","configuration",".",">","\u03bb",">","conn","<","-","connectCayley","defaultCayleyConfig"],"function":"connectCayley c =\n  newManager defaultManagerSettings\n    >>= \\m -> return $ CayleyConnection { cayleyConfig = c, manager = m }","function_tokens":["connectCayley","c","=","newManager","defaultManagerSettings",">>=","\\","m","->","return","$","CayleyConnection","{","cayleyConfig","=","c",",","manager","=","m","}"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L52-L54","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"createArchive","parameters":"path m","argument_list":"","return_statement":"","docstring":"Create a new archive given its location and an action that describes how to create contents of the archive. This will silently overwrite the specified file if it already exists. See 'withArchive' if you want to work with an existing archive.","docstring_summary":"Create a new archive given its location and an action that describes how to create contents of the archive. This will silently overwrite the specified file if it already exists. See 'withArchive' if you want to work with an existing archive.","docstring_tokens":["Create","a","new","archive","given","its","location","and","an","action","that","describes","how","to","create","contents","of","the","archive",".","This","will","silently","overwrite","the","specified","file","if","it","already","exists",".","See","withArchive","if","you","want","to","work","with","an","existing","archive","."],"function":"createArchive path m = liftIO $ do\n  apath <- makeAbsolute path\n  ignoringAbsence (removeFile apath)\n  let st =\n        ZipState\n          { zsFilePath = apath,\n            zsEntries = M.empty,\n            zsArchive = ArchiveDescription Nothing 0 0,\n            zsActions = S.empty\n          }\n      action = unZipArchive (m <* commit)\n  evalStateT action st\n\n-- | Work with an existing archive. See 'createArchive' if you want to\n-- create a new archive instead.\n--\n-- This operation may fail with:\n--\n--     * @isAlreadyInUseError@ if the file is already open and cannot be\n--     reopened;\n--\n--     * @isDoesNotExistError@ if the file does not exist;\n--\n--     * @isPermissionError@ if the user does not have permission to open\n--     the file;\n--\n--     * 'ParsingFailed' when specified archive is something this library\n--     cannot parse (this includes multi-disk archives, for example).\n--\n-- Please note that entries with invalid (non-portable) file names may be\n-- missing in the list of entries. Files that are compressed with\n-- unsupported compression methods are skipped as well. Also, if several\n-- entries would collide on some operating systems (such as Windows, because\n-- of its case-insensitivity), only one of them will be available, because\n-- 'EntrySelector' is case-insensitive. These are the consequences of the\n-- design decision to make it impossible to create non-portable archives\n-- with this library.","function_tokens":["createArchive","path","m","=","liftIO","$","do","apath","<-","makeAbsolute","path","ignoringAbsence","(","removeFile","apath",")","let","st","=","ZipState","{","zsFilePath","=","apath",",","zsEntries","=","M","empty",",","zsArchive","=","ArchiveDescription","Nothing","0","0",",","zsActions","=","S","empty","}","action","=","unZipArchive","(","m","<*","commit",")","evalStateT","action","st","-- | Work with an existing archive. See 'createArchive' if you want to","-- create a new archive instead.","--","-- This operation may fail with:","--","--     * @isAlreadyInUseError@ if the file is already open and cannot be","--     reopened;","--","--     * @isDoesNotExistError@ if the file does not exist;","--","--     * @isPermissionError@ if the user does not have permission to open","--     the file;","--","--     * 'ParsingFailed' when specified archive is something this library","--     cannot parse (this includes multi-disk archives, for example).","--","-- Please note that entries with invalid (non-portable) file names may be","-- missing in the list of entries. Files that are compressed with","-- unsupported compression methods are skipped as well. Also, if several","-- entries would collide on some operating systems (such as Windows, because","-- of its case-insensitivity), only one of them will be available, because","-- 'EntrySelector' is case-insensitive. These are the consequences of the","-- design decision to make it impossible to create non-portable archives","-- with this library."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L242-L279","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/Setup.hs#L20-L20","hash_key":"pjones\/byline:Setup.hs","hash_val":6256,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DLam v t e   == DLam v' t' e' = v == v' && t == t' && e == e'","function_tokens":["DLam","v","t","e","==","DLam","v'","t'","e'","=","v","==","v'","&&","t","==","t'","&&","e","==","e'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L60-L60","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"example","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"example = testGroup \"teletype\"\n  [ testProperty \"reads\" . property $ do\n    line <- forAll genLine\n    run (runTeletypeRet [line] read) === ([], ([], line))\n\n  , testProperty \"writes\" . property $ do\n    input  <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output <- forAll genLine\n    run (runTeletypeRet input (write output)) === ([output], (input, ()))\n\n  , testProperty \"writes multiple things\" . property $ do\n    input   <- forAll (Gen.list (Range.linear 0 10) genLine)\n    output1 <- forAll genLine\n    output2 <- forAll genLine\n    run (runTeletypeRet input (write output1 >> write output2)) === ([output1, output2], (input, ()))\n  ] where\n  genLine = Gen.string (Range.linear 0 20) Gen.unicode","function_tokens":["example","=","testGroup","\"teletype\"","[","testProperty","\"reads\"",".","property","$","do","line","<-","forAll","genLine","run","(","runTeletypeRet","[","line","]","read",")","===","(","[","]",",","(","[","]",",","line",")",")",",","testProperty","\"writes\"",".","property","$","do","input","<-","forAll","(","Gen","list","(","Range","linear","0","10",")","genLine",")","output","<-","forAll","genLine","run","(","runTeletypeRet","input","(","write","output",")",")","===","(","[","output","]",",","(","input",",","(",")",")",")",",","testProperty","\"writes multiple things\"",".","property","$","do","input","<-","forAll","(","Gen","list","(","Range","linear","0","10",")","genLine",")","output1","<-","forAll","genLine","output2","<-","forAll","genLine","run","(","runTeletypeRet","input","(","write","output1",">>","write","output2",")",")","===","(","[","output1",",","output2","]",",","(","input",",","(",")",")",")","]","where","genLine","=","Gen","string","(","Range","linear","0","20",")","Gen","unicode"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L25-L43","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"generate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"generate = MG.generate","function_tokens":["generate","=","MG","generate"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L369-L369","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Var na _ `ieq1` Var nb _ = na == nb","function_tokens":["Var","na","_","`","ieq1","`","Var","nb","_","=","na","==","nb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L250-L250","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"lineEnding","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lineEnding _ = LF","function_tokens":["lineEnding","_","=","LF"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L100-L100","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"skipCharacter","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"skipCharacter = do\n    bs <- lift get\n    if B.null bs\n        then throwE \"ByteString empty\"\n        else lift . put $ B.drop 1 bs\n\n-- | Parses an Int","function_tokens":["skipCharacter","=","do","bs","<-","lift","get","if","B","null","bs","then","throwE","\"ByteString empty\"","else","lift",".","put","$","B","drop","1","bs","-- | Parses an Int"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L75-L82","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"underThreat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"underThreat = qs' >>= diags","function_tokens":["underThreat","=","qs'",">>=","diags"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L38-L38","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"cacheWidth","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cacheWidth _ = 16384","function_tokens":["cacheWidth","_","=","16384"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L207-L207","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(SetEntryComment _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (SetEntryComment _ s) = Just s","function_tokens":["targetEntry","(","SetEntryComment","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1058-L1058","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"go","parameters":"(RenderSGR s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (RenderSGR s) = ANSI.hSetSGR h s","function_tokens":["go","(","RenderSGR","s",")","=","ANSI","hSetSGR","h","s"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L156-L156","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Rhythm _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Rhythm _)               = (True, True, True, True)","function_tokens":["go","(","Rhythm","_",")","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L384-L384","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"modifier","parameters":"g m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modifier g m = m . first app . arr (\\(n, (f, o)) -> ((n, o), f)) . second (id &&& g)","function_tokens":["modifier","g","m","=","m",".","first","app",".","arr","(","\\","(","n",",","(","f",",","o",")",")","->","(","(","n",",","o",")",",","f",")",")",".","second","(","id","&&&","g",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L489-L489","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"nextThingItem","parameters":"(NextItemWithComment _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nextThingItem (NextItemWithComment _ _) = True","function_tokens":["nextThingItem","(","NextItemWithComment","_","_",")","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L132-L132","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"attachOpenBracket","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"attachOpenBracket\n        | openBracket conf == SameLine = putText \" (\"\n        | otherwise                    = pure ()","function_tokens":["attachOpenBracket","|","openBracket","conf","==","SameLine","=","putText","\" (\"","|","otherwise","=","pure","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L172-L174","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(Forall vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (Forall vs a) = exists vs (dual . unIFix $ a)","function_tokens":["dual","(","Forall","vs","a",")","=","exists","vs","(","dual",".","unIFix","$","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L677-L677","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"fromAscList","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromAscList [] = Nil","function_tokens":["fromAscList","[","]","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L731-L731","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"rendered","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rendered = renderText Plain bullet","function_tokens":["rendered","=","renderText","Plain","bullet"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L233-L233","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty a = string $\u00a0fieldName a ++ \": \" ++ showField a","function_tokens":["pretty","a","=","string","$","ieldName "," ","+ ",": \" ","+ ","howField ",""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L329-L329","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = CullC . lift . lift","function_tokens":["lift","=","CullC",".","lift",".","lift"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L85-L85","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Interpret.hs","language":"haskell","identifier":"go","parameters":"(InterpretC m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (InterpretC m) = Const m","function_tokens":["go","(","InterpretC","m",")","=","Const","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Interpret.hs#L73-L73","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Interpret.hs","hash_val":29980,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"takeNext","parameters":"[] ((cb, c) : comments)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeNext [] ((cb, c) : comments) =\n    Just","function_tokens":["takeNext","[","]","(","(","cb",",","c",")",":","comments",")","=","Just"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L100-L101","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"yStr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"yStr = replicate (round y) ' ' ++ \"y\" ++ replicate (50 - round y) ' '","function_tokens":["yStr","=","replicate","(","round","y",")","' '","++","\"y\"","++","replicate","(","50","-","round","y",")","' '"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L69-L69","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"r","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r = Kleisli (fmap Tuple.fst  . listToMaybe . readsPrec 0)","function_tokens":["r","=","Kleisli","(","fmap","Tuple","fst",".","listToMaybe",".","readsPrec","0",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L115-L115","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"types","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"types   =        map (\\(LabelExpr _ _ t _) -> t) labels","function_tokens":["types","=","map","(","\\","(","LabelExpr","_","_","t","_",")","->","t",")","labels"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L141-L141","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Chord_ ([pitch], dur))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (Chord_ ([pitch], dur))  =\n        pretty pitch <> pretty dur","function_tokens":["pretty","(","Chord_","(","[","pitch","]",",","dur",")",")","=","pretty","pitch","<>","pretty","dur"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L214-L215","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_DEVICE_SPECIFIER","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_DEVICE_SPECIFIER                = 0x1005","function_tokens":["alc_DEVICE_SPECIFIER","=","0x1005"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L151-L151","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"renderText","parameters":"mode stylized","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderText mode stylized = foldMap go (renderInstructions mode stylized)\n  where\n    go :: RenderInstruction -> Text\n    go = \\case\n      RenderText t -> t\n      RenderSGR s ->\n        -- NOTE: The \\STX character below is not a real terminal\n        -- escape character.  Instead it is intercepted by Haskeline.\n        -- See: https:\/\/github.com\/judah\/haskeline\/wiki\/ControlSequencesInPrompt\n        toText (ANSI.setSGRCode s) <> \"\\STX\"\n\n-- | Internal function to turn stylized text into render instructions.\n--\n-- @since 1.0.0.0","function_tokens":["renderText","mode","stylized","=","foldMap","go","(","renderInstructions","mode","stylized",")","where","go","::","RenderInstruction","->","Text","go","=","\\","case","RenderText","t","->","t","RenderSGR","s","->","-- NOTE: The \\STX character below is not a real terminal","-- escape character.  Instead it is intercepted by Haskeline.","-- See: https:\/\/github.com\/judah\/haskeline\/wiki\/ControlSequencesInPrompt","toText","(","ANSI","setSGRCode","s",")","<>","\"\\STX\"","-- | Internal function to turn stylized text into render instructions.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L164-L178","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"failP","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"failP   = if failing\n                   then classP ''ArrowFail [ [t| String |], cat]\n                   else classP ''ArrowZero [cat]","function_tokens":["failP","=","if","failing","then","classP","''","ArrowFail","[","[","t","|"," String ","|]",",","cat","]","else","classP","''","ArrowZero","[","cat","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L440-L442","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"fromDistinctAscList","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromDistinctAscList []         = Nil","function_tokens":["fromDistinctAscList","[","]","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L742-L742","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = G.length . head $ xs","function_tokens":["c","=","G","length",".","head","$","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L158-L158","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printedModuleHeader","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printedModuleHeader = runPrinter_\n            (PrinterConfig maxCols)\n            (printHeader\n                conf name exportGroups haddocks moduleComment whereComment)","function_tokens":["printedModuleHeader","=","runPrinter_","(","PrinterConfig","maxCols",")","(","printHeader","conf","name","exportGroups","haddocks","moduleComment","whereComment",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L108-L111","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = (a + b + c) \/ 2","function_tokens":["s","=","(","a","+","b","+","c",")","\/","2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L26-L26","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a <?> l = ReaderT $ \\r -> StateT $ \\s -> runStateT (runReaderT a r) s A.<?> l","function_tokens":["a","<?>","l","=","ReaderT","$","\\","r","->","StateT","$","\\","s","->","runStateT","(","runReaderT","a","r",")","s","A","<?>","l"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L126-L126","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = rows mat","function_tokens":["n","=","rows","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L96-L96","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Instruction _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Instruction _)          = (True, True, True, True)","function_tokens":["go","(","Instruction","_",")","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L374-L374","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"nrOfRunning","parameters":"(ThreadGroup numThreadsTV)","argument_list":"","return_statement":"","docstring":"{-| Yield a transaction that returns the number of running threads in the\ngroup.\n\nNote that because this function yields a 'STM' computation, the returned number\nis guaranteed to be consistent inside the transaction.\n-}","docstring_summary":"{-| Yield a transaction that returns the number of running threads in the\ngroup.","docstring_tokens":["{","-","|","Yield","a","transaction","that","returns","the","number","of","running","threads","in","the","group","."],"function":"nrOfRunning (ThreadGroup numThreadsTV) = readTVar numThreadsTV","function_tokens":["nrOfRunning","(","ThreadGroup","numThreadsTV",")","=","readTVar","numThreadsTV"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L124-L124","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"plotDataPoints","parameters":"points","argument_list":"","return_statement":"","docstring":"Helper function to plot data points as appropriate for a map, i.e. using contiguous lines.","docstring_summary":"Helper function to plot data points as appropriate for a map, i.e. using contiguous lines.","docstring_tokens":["Helper","function","to","plot","data","points","as","appropriate","for","a","map","i",".","e",".","using","contiguous","lines","."],"function":"plotDataPoints points = toPlot $\n    plot_lines_values .~ points $ plot_lines_style . line_color .~ opaque blue $ plot_lines_title .~ \"Border\" $ def","function_tokens":["plotDataPoints","points","=","toPlot","$","plot_lines_values",".~","points","$","plot_lines_style",".","line_color",".~","opaque","blue","$","plot_lines_title",".~","\"Border\"","$","def"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L35-L36","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"dumpDiff2","parameters":"((lineNoA, markerA), (lineNoB, markerB), diff)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dumpDiff2 ((lineNoA, markerA), (lineNoB, markerB), diff) =\n            do  putStrLn $ concat [filePath, \":\", show lineNoA, \" <->\", markerA]\n                putStrLn $ concat [filePath, \":\", show lineNoB, \": \", markerB]\n                putStr $ unlines $ map (ppDiff colorEnable) diff","function_tokens":["dumpDiff2","(","(","lineNoA",",","markerA",")",",","(","lineNoB",",","markerB",")",",","diff",")","=","do","putStrLn","$","concat","[","filePath",",","\":\"",",","show","lineNoA",",","\" <->\"",",","markerA","]","putStrLn","$","concat","[","filePath",",","\":\"",",","show","lineNoB",",","\": \"",",","markerB","]","putStr","$","unlines","$","map","(","ppDiff","colorEnable",")","diff"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L61-L66","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","language":"haskell","identifier":"zipPadded","parameters":"_ _ []     []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipPadded _ _ []     []     = []","function_tokens":["zipPadded","_","_","[","]","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs#L9-L9","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","hash_val":30237,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putArray","parameters":"vs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putArray vs = putDocument (zipWith f [0..] vs)\n  where f i v = (T.pack $! show i) := v","function_tokens":["putArray","vs","=","putDocument","(","zipWith","f","[","0","..","]","vs",")","where","f","i","v","=","(","T","pack","$!","show","i",")",":=","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L174-L177","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"nullBuffer","parameters":"","argument_list":"","return_statement":"","docstring":"A dummy buffer.","docstring_summary":"A dummy buffer.","docstring_tokens":["A","dummy","buffer","."],"function":"nullBuffer = Buffer 0","function_tokens":["nullBuffer","=","Buffer","0"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L46-L46","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = lift empty","function_tokens":["empty","=","lift","empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L98-L98","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"unintern","parameters":"(App _ f a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (App _ f a) = BApp f a","function_tokens":["unintern","(","App","_","f","a",")","=","BApp","f","a"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L49-L49","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"modify","parameters":"l","argument_list":"","return_statement":"","docstring":"Modify a value with a function somewhere in the state, pointed to by the specified lens.","docstring_summary":"Modify a value with a function somewhere in the state, pointed to by the specified lens.","docstring_tokens":["Modify","a","value","with","a","function","somewhere","in","the","state","pointed","to","by","the","specified","lens","."],"function":"modify l = State.modify . Total.modify l","function_tokens":["modify","l","=","State","modify",".","Total","modify","l"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L42-L42","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"longest","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"longest  = maximum $ map length $ toList . snd =<< languagePragmas","function_tokens":["longest","=","maximum","$","map","length","$","toList",".","snd","=<<","languagePragmas"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L142-L142","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = startLookup sendS end checkSignal","function_tokens":["go","=","startLookup","sendS","end","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L92-L92","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"unqueueBuffers","parameters":"src n","argument_list":"","return_statement":"","docstring":"Once a queue entry for a buffer has been appended to a queue and is pending processing, it should not be changed. Removal of a given queue entry is not possible unless either the source is stopped (in which case then entire queue is considered processed), or if the queue entry has already been processed ('Playing' or 'Paused' source). A playing source will enter the 'Stopped' state if it completes playback of the last buffer in its queue (the same behavior as when a single buffer has been attached to a source and has finished playback).  The 'unqueueBuffers' command removes a number of buffers entries that have finished processing from the queue, returning the buffers that were unqueued. The operation will fail with an 'ALInvalidValue' error if more buffers are requested than available, leaving the destination arguments unchanged.","docstring_summary":"Once a queue entry for a buffer has been appended to a queue and is pending processing, it should not be changed. Removal of a given queue entry is not possible unless either the source is stopped (in which case then entire queue is considered processed), or if the queue entry has already been processed ('Playing' or 'Paused' source). A playing source will enter the 'Stopped' state if it completes playback of the last buffer in its queue (the same behavior as when a single buffer has been attached to a source and has finished playback).  The 'unqueueBuffers' command removes a number of buffers entries that have finished processing from the queue, returning the buffers that were unqueued. The operation will fail with an 'ALInvalidValue' error if more buffers are requested than available, leaving the destination arguments unchanged.","docstring_tokens":["Once","a","queue","entry","for","a","buffer","has","been","appended","to","a","queue","and","is","pending","processing","it","should","not","be","changed",".","Removal","of","a","given","queue","entry","is","not","possible","unless","either","the","source","is","stopped","(","in","which","case","then","entire","queue","is","considered","processed",")","or","if","the","queue","entry","has","already","been","processed","(","Playing","or","Paused","source",")",".","A","playing","source","will","enter","the","Stopped","state","if","it","completes","playback","of","the","last","buffer","in","its","queue","(","the","same","behavior","as","when","a","single","buffer","has","been","attached","to","a","source","and","has","finished","playback",")",".","The","unqueueBuffers","command","removes","a","number","of","buffers","entries","that","have","finished","processing","from","the","queue","returning","the","buffers","that","were","unqueued",".","The","operation","will","fail","with","an","ALInvalidValue","error","if","more","buffers","are","requested","than","available","leaving","the","destination","arguments","unchanged","."],"function":"unqueueBuffers src n = liftIO $ allocaArray (fromIntegral n) $ \\p -> do\n    alSourceUnqueueBuffers src n p\n    peekArray (fromIntegral n) p","function_tokens":["unqueueBuffers","src","n","=","liftIO","$","allocaArray","(","fromIntegral","n",")","$","\\","p","->","do","alSourceUnqueueBuffers","src","n","p","peekArray","(","fromIntegral","n",")","p"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L689-L693","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Extensions.hs","language":"haskell","identifier":"alExtensions","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains the list of available extensions.","docstring_summary":"------------------------------------------------------------------------------ Contains the list of available extensions.","docstring_tokens":["------------------------------------------------------------------------------","Contains","the","list","of","available","extensions","."],"function":"alExtensions = makeGettableStateVar (fmap words $ getString Extensions)","function_tokens":["alExtensions","=","makeGettableStateVar","(","fmap","words","$","getString","Extensions",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Extensions.hs#L46-L46","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Extensions.hs","hash_val":40318,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"identify","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identify = InternedText","function_tokens":["identify","=","InternedText"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L36-L36","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = do\n            -- Poll the supplied node\n            sendS node\n            -- Run a normal lookup from thereon out\n            waitForReply nodeDown checkSignal\n\n          -- No answer to the first signal means, that that Node is down","function_tokens":["go","=","do","-- Poll the supplied node","sendS","node","-- Run a normal lookup from thereon out","waitForReply","nodeDown","checkSignal","-- No answer to the first signal means, that that Node is down"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L129-L136","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"getConDecls","parameters":"d@Hs.HsDataDefn {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getConDecls d@Hs.HsDataDefn {} = map GHC.unLoc $ Hs.dd_cons d","function_tokens":["getConDecls","d","@","Hs","HsDataDefn","{","}","=","map","GHC","unLoc","$","Hs","dd_cons","d"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L78-L78","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"fmap","parameters":"f ma","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f ma = AccumC $ fmap (fmap f) . runAccumC ma","function_tokens":["fmap","f","ma","=","AccumC","$","fmap","(","fmap","f",")",".","runAccumC","ma"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L84-L84","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"","parameters":"Id                 l","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(>-) Id                 l        = unpack l","function_tokens":["(",">-",")","Id","l","=","unpack","l"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L104-L104","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookCheckRunEvent","function_tokens":["reflect","_","=","WebhookCheckRunEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L409-L409","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"lift","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift m = StateC (\\ s -> (,) s <$> m)","function_tokens":["lift","m","=","StateC","(","\\","s","->","(",",",")","s","<$>","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L121-L121","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result,t') = maxViewUnsigned r","function_tokens":["(","result",",","t'",")","=","maxViewUnsigned","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L596-L596","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"diags","parameters":"(i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"diags (i,j) = [ Row i\n              , Col j\n              , Backslash (j - i)\n              , Forwardslash (i + j) ]","function_tokens":["diags","(","i",",","j",")","=","[","Row","i",",","Col","j",",","Backslash","(","j","-","i",")",",","Forwardslash","(","i","+","j",")","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L29-L32","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"oldComment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"oldComment = case (o, M.lookup s eaDeleteComment) of\n        (GenericOrigin, _) -> Nothing\n        (Borrowed ed, Nothing) -> edComment ed\n        (Borrowed _, Just ()) -> Nothing","function_tokens":["oldComment","=","case","(","o",",","M","lookup","s","eaDeleteComment",")","of","(","GenericOrigin",",","_",")","->","Nothing","(","Borrowed","ed",",","Nothing",")","->","edComment","ed","(","Borrowed","_",",","Just","(",")",")","->","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L512-L516","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ishow","parameters":"(Add as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Add as)         = coerce $ \"(+ \" ++ intercalate \" \" (coerce as) ++ \")\"","function_tokens":["ishow","(","Add","as",")","=","coerce","$","\"(+ \"","++","intercalate","\" \"","(","coerce","as",")","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L97-L97","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"newRegistration","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newRegistration = registration { replyTypes = [R_PONG] }","function_tokens":["newRegistration","=","registration","{","replyTypes","=","[","R_PONG","]","}"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L130-L130","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"color","parameters":"l","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"color l = ANSI.SetPaletteColor l . Color.colorAsIndex256","function_tokens":["color","l","=","ANSI","SetPaletteColor","l",".","Color","colorAsIndex256"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L197-L197","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"fieldDeclSeparator","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldDeclSeparator _ = Nothing","function_tokens":["fieldDeclSeparator","_","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L52-L52","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"noWrap'","parameters":"ss []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"noWrap' ss []         = [ss]","function_tokens":["noWrap'","ss","[","]","=","[","ss","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L128-L128","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"displayException","parameters":"UnexpectedEndOfInput","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"displayException UnexpectedEndOfInput = \"Unexpected end of input.\"","function_tokens":["displayException","UnexpectedEndOfInput","=","\"Unexpected end of input.\""],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L201-L201","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"choose","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"choose = asum . fmap pure","function_tokens":["choose","=","asum",".","fmap","pure"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L43-L43","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"NewContent x0 y0 <> NewContent x1 y1 = NewContent (x0<>x1) (y0<>y1)","function_tokens":["NewContent","x0","y0","<>","NewContent","x1","y1","=","NewContent","(","x0","<>","x1",")","(","y0","<>","y1",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L75-L75","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"selector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"selector = EntrySelector pieces","function_tokens":["selector","=","EntrySelector","pieces"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L106-L106","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"putECD","parameters":"totalCount cdSize cdOffset mcomment","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putECD totalCount cdSize cdOffset mcomment = do\n  putWord32le 0x06054b50 -- end of central dir signature\n  putWord16le 0 -- number of this disk\n  putWord16le 0 -- number of the disk with the start of the central directory\n  putWord16le (withSaturation totalCount)\n  -- \u2191 total number of entries on this disk\n  putWord16le (withSaturation totalCount) -- total number of entries\n  putWord32le (withSaturation cdSize) -- size of central directory\n  putWord32le (withSaturation cdOffset) -- offset of start of central directory\n  let comment = maybe B.empty T.encodeUtf8 mcomment\n  putWord16le (fromIntegral $ B.length comment)\n  putByteString comment\n\n-- | Find the absolute offset of the end of central directory record or, if\n-- present, Zip64 end of central directory record.","function_tokens":["putECD","totalCount","cdSize","cdOffset","mcomment","=","do","putWord32le","0x06054b50","-- end of central dir signature","putWord16le","0","-- number of this disk","putWord16le","0","-- number of the disk with the start of the central directory","putWord16le","(","withSaturation","totalCount",")","-- \u2191 total number of entries on this disk","putWord16le","(","withSaturation","totalCount",")","-- total number of entries","putWord32le","(","withSaturation","cdSize",")","-- size of central directory","putWord32le","(","withSaturation","cdOffset",")","-- offset of start of central directory","let","comment","=","maybe","B","empty","T","encodeUtf8","mcomment","putWord16le","(","fromIntegral","$","B","length","comment",")","putByteString","comment","-- | Find the absolute offset of the end of central directory record or, if","-- present, Zip64 end of central directory record."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L948-L963","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"readShow","parameters":"","argument_list":"","return_statement":"","docstring":"Partial isomorphism for readable and showable values. Can easily be lifted into a lens by using `iso`.","docstring_summary":"Partial isomorphism for readable and showable values. Can easily be lifted into a lens by using `iso`.","docstring_tokens":["Partial","isomorphism","for","readable","and","showable","values",".","Can","easily","be","lifted","into","a","lens","by","using","iso","."],"function":"readShow = Iso r s\n  where r = Kleisli (fmap Tuple.fst  . listToMaybe . readsPrec 0)\n        s = arr show","function_tokens":["readShow","=","Iso","r","s","where","r","=","Kleisli","(","fmap","Tuple","fst",".","listToMaybe",".","readsPrec","0",")","s","=","arr","show"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L114-L116","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = Choosing","function_tokens":["lift","=","Choosing"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L142-L142","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"withinColumns","parameters":"PrinterState{currentLine}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withinColumns PrinterState{currentLine} =\n      case cMaxColumns of\n        MaxColumns maxCols -> length currentLine <= maxCols\n        NoMaxColumns       -> True","function_tokens":["withinColumns","PrinterState","{","currentLine","}","=","case","cMaxColumns","of","MaxColumns","maxCols","->","length","currentLine","<=","maxCols","NoMaxColumns","->","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L285-L290","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"mkAppImage'","parameters":"(ExeFile exeFp) di (Arg desktopArg)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkAppImage' (ExeFile exeFp) di (Arg desktopArg) = do\n  setEnv \"VERSION\" (prettyShow . version $ di)\n  callProcess \"linuxdeploy-x86_64.AppImage\"\n    [ \"--appdir=\" ++ (takeDirectory . op PrefixDir . prefixDir $ di)\n    , \"--executable=\" <> ((op BinDir . binDir $ di) <\/> exeFp)\n    , desktopArg\n    , \"--icon-file=\" ++ (iconDir <\/> exeFp <.> \"svg\")\n    , \"--output=appimage\"\n    ]","function_tokens":["mkAppImage'","(","ExeFile","exeFp",")","di","(","Arg","desktopArg",")","=","do","setEnv","\"VERSION\"","(","prettyShow",".","version","$","di",")","callProcess","\"linuxdeploy-x86_64.AppImage\"","[","\"--appdir=\"","++","(","takeDirectory",".","op","PrefixDir",".","prefixDir","$","di",")",",","\"--executable=\"","<>","(","(","op","BinDir",".","binDir","$","di",")","<\/>","exeFp",")",",","desktopArg",",","\"--icon-file=\"","++","(","iconDir","<\/>","exeFp","<.>","\"svg\"",")",",","\"--output=appimage\"","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L69-L77","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Device.hs","language":"haskell","identifier":"defaultDeviceSpecifier","parameters":"","argument_list":"","return_statement":"","docstring":"Contains 'Just' the specifier string for the default device or 'Nothing' if there is no sound support at all.","docstring_summary":"Contains 'Just' the specifier string for the default device or 'Nothing' if there is no sound support at all.","docstring_tokens":["Contains","Just","the","specifier","string","for","the","default","device","or","Nothing","if","there","is","no","sound","support","at","all","."],"function":"defaultDeviceSpecifier = makeGettableStateVar $\n   getStringRaw Nothing DefaultDeviceSpecifier >>= maybePeek peekALCString","function_tokens":["defaultDeviceSpecifier","=","makeGettableStateVar","$","getStringRaw","Nothing","DefaultDeviceSpecifier",">>=","maybePeek","peekALCString"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Device.hs#L202-L203","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Device.hs","hash_val":14318,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) = liftA2 (<>)","function_tokens":["(","<>",")","=","liftA2","(","<>",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L211-L211","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"standardError","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"standardError a | samples a == 1 = fromRational (mean a)\n           | otherwise = standardDeviation a * sqrt (fromIntegral $ squaredWeights a) \/ fromIntegral (samples a)","function_tokens":["standardError","a","|","samples","a","==","1","=","fromRational","(","mean","a",")","|","otherwise","=","standardDeviation","a","*","sqrt","(","fromIntegral","$","squaredWeights","a",")","\/","fromIntegral","(","samples","a",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L192-L193","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fresh\/Church.hs","language":"haskell","identifier":"evalFresh","parameters":"n","argument_list":"","return_statement":"","docstring":"Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.  @ 'evalFresh' n ('pure' a) = 'pure' a @ @ 'evalFresh' n 'fresh' = 'pure' n @  @since 1.1.0.0","docstring_summary":"Run a 'Fresh' effect counting up from an initial value, and forgetting the final value.","docstring_tokens":["Run","a","Fresh","effect","counting","up","from","an","initial","value","and","forgetting","the","final","value","."],"function":"evalFresh n = evalState n . runFreshC","function_tokens":["evalFresh","n","=","evalState","n",".","runFreshC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fresh\/Church.hs#L55-L55","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fresh\/Church.hs","hash_val":22500,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"str","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"str = fst (O.renderFailure help \"\")","function_tokens":["str","=","fst","(","O","renderFailure","help","\"\"",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L72-L72","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/PPDiff.hs","language":"haskell","identifier":"wrap","parameters":"EnableColor color str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrap EnableColor color str = setSGRCode [SetColor Foreground Vivid color] ++ str ++ setSGRCode [Reset]","function_tokens":["wrap","EnableColor","color","str","=","setSGRCode","[","SetColor","Foreground","Vivid","color","]","++","str","++","setSGRCode","[","Reset","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/PPDiff.hs#L13-L13","hash_key":"Peaker\/git-mediate:src\/PPDiff.hs","hash_val":5685,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"eventList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eventList = iter unit\n    where iter !tfm x = case x of\n                Empty       -> Empty\n                Single a    -> Single (eventFromTfm tfm a)\n                TFun t a    -> iter (tfm `composeTfm` t) a\n                Append a b  -> Append (iter tfm a) (iter tfm b)","function_tokens":["eventList","=","iter","unit","where","iter","tfm","x","=","case","x","of","Empty","->","Empty","Single","a","->","Single","(","eventFromTfm","tfm","a",")","TFun","t","a","->","iter","(","tfm","`","composeTfm","`","t",")","a","Append","a","b","->","Append","(","iter","tfm","a",")","(","iter","tfm","b",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L337-L345","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    Tell w     -> (w, ctx)\n    Listen m   -> let (w, a) = hdl (m <$ ctx) in (w, (,) w <$> a)\n    Censor f m -> let (w, a) = hdl (m <$ ctx) in (f w, a)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","Tell","w","->","(","w",",","ctx",")","Listen","m","->","let","(","w",",","a",")","=","hdl","(","m","<$","ctx",")","in","(","w",",","(",",",")","w","<$>","a",")","Censor","f","m","->","let","(","w",",","a",")","=","hdl","(","m","<$","ctx",")","in","(","f","w",",","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L180-L184","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mapType","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapType f = go\n  where\n  go ty =\n    case ty of\n      ForallT v c t -> f (ForallT v c (go t))\n      AppT a b      -> f (AppT (go a) (go b))\n      SigT t k      -> f (SigT (go t) k)\n      _             -> f ty","function_tokens":["mapType","f","=","go","where","go","ty","=","case","ty","of","ForallT","v","c","t","->","f","(","ForallT","v","c","(","go","t",")",")","AppT","a","b","->","f","(","AppT","(","go","a",")","(","go","b",")",")","SigT","t","k","->","f","(","SigT","(","go","t",")","k",")","_","->","f","ty"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L655-L664","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"pp","parameters":"n set","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pp n set\n      | printOnce cfg = pure ()\n      | sortByMean cfg = printAll set\n      | otherwise = printBenchmark cfg n","function_tokens":["pp","n","set","|","printOnce","cfg","=","pure","(",")","|","sortByMean","cfg","=","printAll","set","|","otherwise","=","printBenchmark","cfg","n"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L286-L289","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"setEntryComment","parameters":"text s","argument_list":"","return_statement":"","docstring":"Set an entry comment, if that entry does not exist, nothing will happen. Note that if binary representation of the comment is longer than 65535 bytes, it will be truncated on writing.","docstring_summary":"Set an entry comment, if that entry does not exist, nothing will happen. Note that if binary representation of the comment is longer than 65535 bytes, it will be truncated on writing.","docstring_tokens":["Set","an","entry","comment","if","that","entry","does","not","exist","nothing","will","happen",".","Note","that","if","binary","representation","of","the","comment","is","longer","than","65535","bytes","it","will","be","truncated","on","writing","."],"function":"setEntryComment text s = addPending (I.SetEntryComment text s)","function_tokens":["setEntryComment","text","s","=","addPending","(","I","SetEntryComment","text","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L553-L553","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(ib, NextItem i, items, (cb, c) : comments)\n    | otherwise =\n        Just","function_tokens":["(","ib",",","NextItem","i",",","items",",","(","cb",",","c",")",":","comments",")","|","otherwise","=","Just"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L108-L110","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/hsinstall.hs","language":"haskell","identifier":"licenseFile","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"licenseFile = \"LICENSE\"","function_tokens":["licenseFile","=","\"LICENSE\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/hsinstall.hs#L61-L61","hash_key":"dino-\/hsinstall:src\/app\/hsinstall.hs","hash_val":1203,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"pack","parameters":"bk","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pack bk = zip bk $ map f bk","function_tokens":["pack","bk","=","zip","bk","$","map","f","bk"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L44-L44","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"step","parameters":"maxColumns config","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"step maxColumns config = makeStep \"Cases\" $ \\ls module' ->\n    let changes\n            :: (GHC.Located Hs.HsModule -> [a])\n            -> (a -> [[Alignable GHC.RealSrcSpan]])\n            -> Editor.Edits\n        changes search toAlign = mconcat $ do\n            item <- search module'\n            pure $ foldMap (align maxColumns) (toAlign item)\n\n        configured :: Editor.Edits\n        configured =\n            changes records (recordToAlignable config) <>\n            changes everything (matchGroupToAlignable config) <>\n            changes everything (multiWayIfToAlignable config) in\n    Editor.apply configured ls","function_tokens":["step","maxColumns","config","=","makeStep","\"Cases\"","$","\\","ls","module'","->","let","changes","::","(","GHC","Located","Hs","HsModule","->","[","a","]",")","->","(","a","->","[","[","Alignable","GHC","RealSrcSpan","]","]",")","->","Editor","Edits","changes","search","toAlign","=","mconcat","$","do","item","<-","search","module'","pure","$","foldMap","(","align","maxColumns",")","(","toAlign","item",")","configured","::","Editor","Edits","configured","=","changes","records","(","recordToAlignable","config",")","<>","changes","everything","(","matchGroupToAlignable","config",")","<>","changes","everything","(","multiWayIfToAlignable","config",")","in","Editor","apply","configured","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L185-L199","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"con","parameters":"(RecGadtC ns vst ty)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"con (RecGadtC ns vst ty) = GadtC ns (map (\\(_, s, t) -> (s, t)) vst) ty","function_tokens":["con","(","RecGadtC","ns","vst","ty",")","=","GadtC","ns","(","map","(","\\","(","_",",","s",",","t",")","->","(","s",",","t",")",")","vst",")","ty"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L230-L230","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"joinBrokenLines","parameters":"(line1:line2:rest)","argument_list":"","return_statement":"","docstring":"if the last line is broken","docstring_summary":"if the last line is broken","docstring_tokens":["if","the","last","line","is","broken"],"function":"joinBrokenLines (line1:line2:rest) =\n  if isBrokenLine line1 then \n    let joinedLine = (stripBreak line1) ++ line2 in\n    joinBrokenLines (joinedLine:rest)\n  else \n    line1:(joinBrokenLines (line2:rest))","function_tokens":["joinBrokenLines","(","line1",":","line2",":","rest",")","=","if","isBrokenLine","line1","then","let","joinedLine","=","(","stripBreak","line1",")","++","line2","in","joinBrokenLines","(","joinedLine",":","rest",")","else","line1",":","(","joinBrokenLines","(","line2",":","rest",")",")"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L30-L35","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"durEvent","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"durEvent = eventDur","function_tokens":["durEvent","=","eventDur"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L213-L213","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"newMean","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newMean = mean + diffWeight \/ fromIntegral newSamples","function_tokens":["newMean","=","mean","+","diffWeight","\/","fromIntegral","newSamples"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L381-L381","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"mapM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM_ = MG.mapM_","function_tokens":["mapM_","=","MG","mapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L243-L243","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Voice _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Voice _)                = \"V\"","function_tokens":["go","(","Voice","_",")","=","\"V\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L357-L357","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"NonDetC l <|> NonDetC r = NonDetC $ \\ fork leaf nil ->\n    l fork leaf nil `fork` r fork leaf nil","function_tokens":["NonDetC","l","<|>","NonDetC","r","=","NonDetC","$","\\","fork","leaf","nil","->","l","fork","leaf","nil","`","fork","`","r","fork","leaf","nil"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L93-L94","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"withNewFile","parameters":"fpath action","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withNewFile fpath action =\n  bracketOnError allocate release $ \\(path, h) -> do\n    action h\n    hClose h\n    renameFile path fpath\n  where\n    allocate = openBinaryTempFile (takeDirectory fpath) \".zip\"\n    release (path, h) = do\n      hClose h\n      -- Despite using `bracketOnError` the file is not guaranteed to exist\n      -- here since we could be interrupted with an async exception after\n      -- the file has been renamed. Therefore, we silentely ignore\n      -- `DoesNotExistError`.\n      catchJust (guard . isDoesNotExistError) (removeFile path) (const $ pure ())\n\n-- | Determine what comment in new archive will look like given its original\n-- value and a collection of pending actions.","function_tokens":["withNewFile","fpath","action","=","bracketOnError","allocate","release","$","\\","(","path",",","h",")","->","do","action","h","hClose","h","renameFile","path","fpath","where","allocate","=","openBinaryTempFile","(","takeDirectory","fpath",")","\".zip\"","release","(","path",",","h",")","=","do","hClose","h","-- Despite using `bracketOnError` the file is not guaranteed to exist","-- here since we could be interrupted with an async exception after","-- the file has been renamed. Therefore, we silentely ignore","-- `DoesNotExistError`.","catchJust","(","guard",".","isDoesNotExistError",")","(","removeFile","path",")","(","const","$","pure","(",")",")","-- | Determine what comment in new archive will look like given its original","-- value and a collection of pending actions."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L304-L321","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"true'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"true'  = string \"true\"  *> pure (toDynamicallySorted true)","function_tokens":["true'","=","string","\"true\"","*>","pure","(","toDynamicallySorted","true",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L396-L396","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"flatten","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten = MG.flatten","function_tokens":["flatten","=","MG","flatten"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L167-L167","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"render","parameters":"mode h stylized","argument_list":"","return_statement":"","docstring":"Send stylized text to the given handle.  @since 1.0.0.0","docstring_summary":"Send stylized text to the given handle.","docstring_tokens":["Send","stylized","text","to","the","given","handle","."],"function":"render mode h stylized = mapM_ go (renderInstructions mode stylized)\n  where\n    go :: RenderInstruction -> IO ()\n    go (RenderText t) = Text.hPutStr h t\n    go (RenderSGR s) = ANSI.hSetSGR h s\n\n-- | Render all modifiers as escape characters and return the\n-- resulting text.  The text produced from this function is formatted\n-- for output by Haskeline.\n--\n-- @since 1.0.0.0","function_tokens":["render","mode","h","stylized","=","mapM_","go","(","renderInstructions","mode","stylized",")","where","go","::","RenderInstruction","->","IO","(",")","go","(","RenderText","t",")","=","Text","hPutStr","h","t","go","(","RenderSGR","s",")","=","ANSI","hSetSGR","h","s","-- | Render all modifiers as escape characters and return the","-- resulting text.  The text produced from this function is formatted","-- for output by Haskeline.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L152-L163","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureSamples","parameters":"device buf n","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"captureSamples device buf n = liftIO $ do\n   funPtr <- getCaptureFunc \"alcCaptureSamples\"\n   invokeCaptureSamples funPtr (marshalDevice device) buf n","function_tokens":["captureSamples","device","buf","n","=","liftIO","$","do","funPtr","<-","getCaptureFunc","\"alcCaptureSamples\"","invokeCaptureSamples","funPtr","(","marshalDevice","device",")","buf","n"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L94-L98","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"fromAdornment","parameters":"GHC.NameSquare","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromAdornment GHC.NameSquare     = (\"[\", \"]\")","function_tokens":["fromAdornment","GHC","NameSquare","=","(","\"[\"",",","\"]\"",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L187-L187","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"stripBreak","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stripBreak s | isBrokenLine s  = dropLast (stripTrailingWhitespace s)\n             | otherwise       = s\n  where \n    dropLast = reverse . tail . reverse","function_tokens":["stripBreak","s","|","isBrokenLine","s","=","dropLast","(","stripTrailingWhitespace","s",")","|","otherwise","=","s","where","dropLast","=","reverse",".","tail",".","reverse"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L15-L20","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWithM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM_ = MG.zipWithM_","function_tokens":["zipWithM_","=","MG","zipWithM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L340-L340","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"isNewtype","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isNewtype = (== GHC.NewType) . GHC.dd_ND . dataDefn","function_tokens":["isNewtype","=","(","==","GHC","NewType",")",".","GHC","dd_ND",".","dataDefn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L532-L532","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"setEnabled","parameters":"True (Buffer a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setEnabled True (Buffer a) = Buffer (a <|> Just mempty)","function_tokens":["setEnabled","True","(","Buffer","a",")","=","Buffer","(","a","<|>","Just","mempty",")"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L153-L153","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"takeRow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeRow = MG.takeRow","function_tokens":["takeRow","=","MG","takeRow"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L129-L129","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"runRSST","parameters":"m r s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"runRSST m r s = do\n    (a,(s',w)) <- runRSST' m r (s,mempty)\n    return (a,s',w)\n\n-- | Evaluate a computation with the given initial state and environment,\n-- returning the final value and output, discarding the final state.","function_tokens":["runRSST","m","r","s","=","do","(","a",",","(","s'",",","w",")",")","<-","runRSST'","m","r","(","s",",","mempty",")","return","(","a",",","s'",",","w",")","-- | Evaluate a computation with the given initial state and environment,","-- returning the final value and output, discarding the final state."],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L87-L93","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/ALboolean.hs","language":"haskell","identifier":"marshalALboolean","parameters":"True","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalALboolean True  = al_TRUE","function_tokens":["marshalALboolean","True","=","al_TRUE"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/ALboolean.hs#L27-L27","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/ALboolean.hs","hash_val":20506,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"matchToAlignable","parameters":"(GHC.L matchLoc (Hs.Match _ (Hs.FunRhs name _ _) pats@(_ : _) grhss))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchToAlignable (GHC.L matchLoc (Hs.Match _ (Hs.FunRhs name _ _) pats@(_ : _) grhss)) = do\n  body <- unguardedRhsBody grhss\n  let patsLocs = map GHC.getLocA pats\n      nameLoc  = GHC.getLocA name\n      left     = last (nameLoc : patsLocs)\n      bodyLoc  = GHC.getLocA body\n  matchPos <- GHC.srcSpanToRealSrcSpan $ GHC.locA matchLoc\n  leftPos  <- GHC.srcSpanToRealSrcSpan left\n  bodyPos  <- GHC.srcSpanToRealSrcSpan bodyLoc\n  Just . Right $ Alignable\n    { aContainer = matchPos\n    , aLeft      = leftPos\n    , aRight     = bodyPos\n    , aRightLead = length \"= \"\n    }","function_tokens":["matchToAlignable","(","GHC","L","matchLoc","(","Hs","Match","_","(","Hs","FunRhs","name","_","_",")","pats","@","(","_",":","_",")","grhss",")",")","=","do","body","<-","unguardedRhsBody","grhss","let","patsLocs","=","map","GHC","getLocA","pats","nameLoc","=","GHC","getLocA","name","left","=","last","(","nameLoc",":","patsLocs",")","bodyLoc","=","GHC","getLocA","body","matchPos","<-","GHC","srcSpanToRealSrcSpan","$","GHC","locA","matchLoc","leftPos","<-","GHC","srcSpanToRealSrcSpan","left","bodyPos","<-","GHC","srcSpanToRealSrcSpan","bodyLoc","Just",".","Right","$","Alignable","{","aContainer","=","matchPos",",","aLeft","=","leftPos",",","aRight","=","bodyPos",",","aRightLead","=","length","\"= \"","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L133-L148","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"printAll","parameters":"set","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printAll set = do\n      when (sortByMean cfg && not (printOnce cfg)) . B.hPutBuilder stdout . linesUp $ printHeight cfg*length set\n      mapM_ (printBenchmark cfg) . f $ S.toList set","function_tokens":["printAll","set","=","do","when","(","sortByMean","cfg","&&","not","(","printOnce","cfg",")",")",".","B","hPutBuilder","stdout",".","linesUp","$","printHeight","cfg","*","length","set","mapM_","(","printBenchmark","cfg",")",".","f","$","S","toList","set"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L278-L282","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"splitMember","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"splitMember x t\n  = case t of\n      Bin _ _ _ m l r\n        | m < 0       -> if x >= 0 then let (lt,found,gt) = splitMember' x l in (union r lt, found, gt)\n                                   else let (lt,found,gt) = splitMember' x r in (lt, found, union gt l)\n                                   -- handle negative numbers.\n        | otherwise   -> splitMember' x t\n      Tip _ y\n        | x>y       -> (t,False,Nil)\n        | x<y       -> (Nil,False,t)\n        | otherwise -> (Nil,True,Nil)\n      Nil -> (Nil,False,Nil)","function_tokens":["splitMember","x","t","=","case","t","of","Bin","_","_","_","m","l","r","|","m","<","0","->","if","x",">=","0","then","let","(","lt",",","found",",","gt",")","=","splitMember'","x","l","in","(","union","r","lt",",","found",",","gt",")","else","let","(","lt",",","found",",","gt",")","=","splitMember'","x","r","in","(","lt",",","found",",","union","gt","l",")","-- handle negative numbers.","|","otherwise","->","splitMember'","x","t","Tip","_","y","|","x",">","y","->","(","t",",","False",",","Nil",")","|","x","<","y","->","(","Nil",",","False",",","t",")","|","otherwise","->","(","Nil",",","True",",","Nil",")","Nil","->","(","Nil",",","False",",","Nil",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L557-L570","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decompressingPipe","parameters":"Store","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decompressingPipe Store = C.awaitForever C.yield","function_tokens":["decompressingPipe","Store","=","C","awaitForever","C","yield"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1149-L1149","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_CONE_OUTER_GAIN","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_CONE_OUTER_GAIN                  = 0x1022","function_tokens":["al_CONE_OUTER_GAIN","=","0x1022"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L92-L92","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"checkComment","parameters":"pos","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkComment pos = do\n      size <- hFileSize h\n      hSeek h AbsoluteSeek (pos + 20)\n      l <- fromIntegral <$> getNum getWord16le 2\n      return $\n        if l + 22 == size - pos\n          then Just pos\n          else Nothing","function_tokens":["checkComment","pos","=","do","size","<-","hFileSize","h","hSeek","h","AbsoluteSeek","(","pos","+","20",")","l","<-","fromIntegral","<$>","getNum","getWord16le","2","return","$","if","l","+","22","==","size","-","pos","then","Just","pos","else","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L988-L996","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_MIN_GAIN","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_MIN_GAIN                         = 0x100D","function_tokens":["al_MIN_GAIN","=","0x100D"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L83-L83","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"fs c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one fs c  = let s = take (length fs) in (conP c (s pats), apps (conE c) (s vars))","function_tokens":["one","fs","c","=","let","s","=","take","(","length","fs",")","in","(","conP","c","(","s","pats",")",",","apps","(","conE","c",")","(","s","vars",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L552-L552","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"parseJSON","parameters":"o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseJSON o = EventWithHookRepo <$> Aeson.parseJSON o","function_tokens":["parseJSON","o","=","EventWithHookRepo","<$>","Aeson","parseJSON","o"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L249-L249","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"done","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"done = pos <= limit","function_tokens":["done","=","pos","<=","limit"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L976-L976","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"ignoringAbsence","parameters":"io","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ignoringAbsence io = catchJust select io handler\n  where\n    select e = if isDoesNotExistError e then Just e else Nothing\n    handler = const (return ())","function_tokens":["ignoringAbsence","io","=","catchJust","select","io","handler","where","select","e","=","if","isDoesNotExistError","e","then","Just","e","else","Nothing","handler","=","const","(","return","(",")",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L713-L716","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Macro","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Macro                    = \"m\"","function_tokens":["go","Macro","=","\"m\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L346-L346","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"sepBy1","parameters":"","argument_list":"","return_statement":"","docstring":"Matches one or more times, separated by specified separator.","docstring_summary":"Matches one or more times, separated by specified separator.","docstring_tokens":["Matches","one","or","more","times","separated","by","specified","separator","."],"function":"sepBy1 = A.sepBy1","function_tokens":["sepBy1","=","A","sepBy1"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L105-L105","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Error.hs","language":"haskell","identifier":"benchmark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark = bgroup \"Error\"\n  [ bench \"Either\" $ whnf (errorLoop :: Int -> Either Int ()) n\n  , bgroup \"Identity\"\n    [ bench \"Church.ErrorC\" $ whnf (run . Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnf (run . Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnf (run . Except.runExceptT @Int . errorLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.ErrorC\" $ whnfAppIO (Church.runError @Int (pure . Left) (pure . Right) . errorLoop) n\n    , bench \"Either.ErrorC\" $ whnfAppIO (Either.runError @Int . errorLoop) n\n    , bench \"ExceptT\"       $ whnfAppIO (Except.runExceptT @Int . errorLoop) n\n    ]\n  ]\n  where\n  n = 100000","function_tokens":["benchmark","=","bgroup","\"Error\"","[","bench","\"Either\"","$","whnf","(","errorLoop","::","Int","->","Either","Int","(",")",")","n",",","bgroup","\"Identity\"","[","bench","\"Church.ErrorC\"","$","whnf","(","run",".","Church","runError","@","Int","(","pure",".","Left",")","(","pure",".","Right",")",".","errorLoop",")","n",",","bench","\"Either.ErrorC\"","$","whnf","(","run",".","Either","runError","@","Int",".","errorLoop",")","n",",","bench","\"ExceptT\"","$","whnf","(","run",".","Except","runExceptT","@","Int",".","errorLoop",")","n","]",",","bgroup","\"IO\"","[","bench","\"Church.ErrorC\"","$","whnfAppIO","(","Church","runError","@","Int","(","pure",".","Left",")","(","pure",".","Right",")",".","errorLoop",")","n",",","bench","\"Either.ErrorC\"","$","whnfAppIO","(","Either","runError","@","Int",".","errorLoop",")","n",",","bench","\"ExceptT\"","$","whnfAppIO","(","Except","runExceptT","@","Int",".","errorLoop",")","n","]","]","where","n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Error.hs#L13-L29","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Error.hs","hash_val":32578,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"describe","parameters":"(BSet n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe (BSet n) = DSet n","function_tokens":["describe","(","BSet","n",")","=","DSet","n"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L34-L34","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"\".\" <\/> p = p","function_tokens":["\".\"","<\/>","p","=","p"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L138-L138","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"fromCompressionMethod","parameters":"Zstd","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromCompressionMethod Zstd = 93","function_tokens":["fromCompressionMethod","Zstd","=","93"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1121-L1121","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"limit","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"limit = max 0 (fsize - 0xffff - 22)","function_tokens":["limit","=","max","0","(","fsize","-","0xffff","-","22",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L968-L968","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Opts.hs","language":"haskell","identifier":"footer'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"footer' = footerDoc . Just . string . printf content . showVersion $ version\n    where content = [here|OVERVIEW\n\nhsinstall is a tool for installing a Haskell software project into a directory structure for deployment. It builds upon the `stack install` and `cabal install` commands and adds these features:\n\n- Copies the `LICENSE` file into <PREFIX>\/share\/<PROJECT-NAME>\/doc\n- Copies the contents of a static directory stucture in your project (named `hsinstall`) into the destination prefix directory. This can contain additional binaries or scripts, resources, documentation, etc. (more on this later in TEMPLATE DIRECTORY)\n- Optionally builds an AppDir directory structure for the project and produces an AppImage binary\n\nTo use hsinstall, it will be necessary to be in the top-level directory of a Haskell project that builds with either cabal or stack. You'll need to have one or the other of the cabal or stack tools on your path as well. Basically, if you can't build the project, hsinstall can't build it either.\n\nAlso note that all cabal commands will be issued as `v2-*` commands. The older `v1-*` commands are deprecated and we don't use them.\n\nIf the AppImage features are desired, you must have these tools on your PATH:\nlinuxdeploy: https:\/\/github.com\/linuxdeploy\/linuxdeploy\/releases\nlinuxdeploy-plugin-appimage: https:\/\/github.com\/linuxdeploy\/linuxdeploy-plugin-appimage\/releases\n\nRunning hsinstall on a project for the first time and with no arguments will produce this in . :\n\n    AppDir\/\n      usr\/\n        bin\/  <-- All binaries in the project\n        share\/\n          <PROJECT-NAME>\/\n            doc\/\n              LICENSE\n\nThe -p,--prefix switch allows you to set a prefix other than `AppDir\/usr`. This could be anywhere, like `myproject-2.3` or `\/usr\/local` or `\/opt`\n\nIn addition, if an `hsinstall` directory exists, its contents will be copied into the prefix before build and install. See TEMPLATE DIRECTORY below for more info on this.\n\nAPPIMAGE CREATION\n\nThe -i,--mk-appimage switch will change the default prefix to `EXE.AppDir\/usr` and only the specified EXE will be installed into `<PREFIX>\/bin`, AppImages are intended to be made for exactly one binary.\n\nIf .desktop and .svg files are not found in the hsinstall directory, defaults will be created for you and placed in the correct subdirs. Check these files into source control for future builds.\n\nThe default `.desktop` file Categories will be populated with 'Utility;'. We recommend adjusting this using the XDG list of registered categories: https:\/\/specifications.freedesktop.org\/menu-spec\/latest\/apa.html\n\nIf your application is a command-line program, append a line containing this to the end of the default `.desktop` file: 'Terminal=true'\n\nIf your application isn't a command-line program, we recommend using a proper icon instead of the hsinstall default, which is a command shell icon.\n\nFor more info on AppImage: https:\/\/appimage.org\/\n\nTEMPLATE DIRECTORY\n\nIf present, hsinstall will copy the contents of the `hsinstall` template directory into `<PREFIX>`. Here's an explanation of the hsinstall directory contents:\n\n    hsinstall\/\n      bin\/  <-- Put additional binaries and scripts to be deployed here\n      share\/\n        applications\/  <-- Only for AppImage\n          <EXE>.desktop  <-- Will be generated by first-time AppImage creation attempt\n        <PROJECT-NAME>\/  <-- Only needed if you have resources\n          resources\/  <-- Put data files your software will need at runtime here\n        icons\/  <-- Only for AppImage\n          hicolor\/\n            scalable\/\n              apps\/\n                <EXE>.svg  <-- Will be generated by first-time AppImage creation attempt\n\nIn order to locate data files at runtime, including resources, the hsinstall project includes a library to construct the share path relative to the executable. See this source code for help with integrating this into your app: https:\/\/github.com\/dino-\/hsinstall\/blob\/master\/src\/lib\/HSInstall\/Resources.hs\n\nVersion %s  Dino Morelli <dino@ui3.info>|]","function_tokens":["footer'","=","footerDoc",".","Just",".","string",".","printf","content",".","showVersion","$","version","where","content","=","[","here","|","OVERVIEW\n\nhsinstall is a tool for installing a Haskell software project into a directory structure for deployment. It builds upon the `stack install` and `cabal install` commands and adds these features:\n\n- Copies the `LICENSE` file into <PREFIX>\/share\/<PROJECT-NAME>\/doc\n- Copies the contents of a static directory stucture in your project (named `hsinstall`) into the destination prefix directory. This can contain additional binaries or scripts, resources, documentation, etc. (more on this later in TEMPLATE DIRECTORY)\n- Optionally builds an AppDir directory structure for the project and produces an AppImage binary\n\nTo use hsinstall, it will be necessary to be in the top-level directory of a Haskell project that builds with either cabal or stack. You'll need to have one or the other of the cabal or stack tools on your path as well. Basically, if you can't build the project, hsinstall can't build it either.\n\nAlso note that all cabal commands will be issued as `v2-*` commands. The older `v1-*` commands are deprecated and we don't use them.\n\nIf the AppImage features are desired, you must have these tools on your PATH:\nlinuxdeploy: https:\/\/github.com\/linuxdeploy\/linuxdeploy\/releases\nlinuxdeploy-plugin-appimage: https:\/\/github.com\/linuxdeploy\/linuxdeploy-plugin-appimage\/releases\n\nRunning hsinstall on a project for the first time and with no arguments will produce this in . :\n\n    AppDir\/\n      usr\/\n        bin\/  <-- All binaries in the project\n        share\/\n          <PROJECT-NAME>\/\n            doc\/\n              LICENSE\n\nThe -p,--prefix switch allows you to set a prefix other than `AppDir\/usr`. This could be anywhere, like `myproject-2.3` or `\/usr\/local` or `\/opt`\n\nIn addition, if an `hsinstall` directory exists, its contents will be copied into the prefix before build and install. See TEMPLATE DIRECTORY below for more info on this.\n\nAPPIMAGE CREATION\n\nThe -i,--mk-appimage switch will change the default prefix to `EXE.AppDir\/usr` and only the specified EXE will be installed into `<PREFIX>\/bin`, AppImages are intended to be made for exactly one binary.\n\nIf .desktop and .svg files are not found in the hsinstall directory, defaults will be created for you and placed in the correct subdirs. Check these files into source control for future builds.\n\nThe default `.desktop` file Categories will be populated with 'Utility;'. We recommend adjusting this using the XDG list of registered categories: https:\/\/specifications.freedesktop.org\/menu-spec\/latest\/apa.html\n\nIf your application is a command-line program, append a line containing this to the end of the default `.desktop` file: 'Terminal=true'\n\nIf your application isn't a command-line program, we recommend using a proper icon instead of the hsinstall default, which is a command shell icon.\n\nFor more info on AppImage: https:\/\/appimage.org\/\n\nTEMPLATE DIRECTORY\n\nIf present, hsinstall will copy the contents of the `hsinstall` template directory into `<PREFIX>`. Here's an explanation of the hsinstall directory contents:\n\n    hsinstall\/\n      bin\/  <-- Put additional binaries and scripts to be deployed here\n      share\/\n        applications\/  <-- Only for AppImage\n          <EXE>.desktop  <-- Will be generated by first-time AppImage creation attempt\n        <PROJECT-NAME>\/  <-- Only needed if you have resources\n          resources\/  <-- Put data files your software will need at runtime here\n        icons\/  <-- Only for AppImage\n          hicolor\/\n            scalable\/\n              apps\/\n                <EXE>.svg  <-- Will be generated by first-time AppImage creation attempt\n\nIn order to locate data files at runtime, including resources, the hsinstall project includes a library to construct the share path relative to the executable. See this source code for help with integrating this into your app: https:\/\/github.com\/dino-\/hsinstall\/blob\/master\/src\/lib\/HSInstall\/Resources.hs\n\nVersion %s  Dino Morelli <dino@ui3.info>","|]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Opts.hs#L102-L166","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Opts.hs","hash_val":22933,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getClosure","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getClosure = do\n  getInt32\n  x <- getString\n  y <- getDocument\n  return (x, y)\n\n\n{- Authors: Tony Hannan <tony@10gen.com>\n   Copyright 2010 10gen Inc.\n   Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at: http:\/\/www.apache.org\/licenses\/LICENSE-2.0. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. -}","function_tokens":["getClosure","=","do","getInt32","x","<-","getString","y","<-","getDocument","return","(","x",",","y",")","{- Authors: Tony Hannan <tony@10gen.com>\n   Copyright 2010 10gen Inc.\n   Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at: http:\/\/www.apache.org\/licenses\/LICENSE-2.0. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. -}"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L241-L250","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"bg","parameters":"c (StylizedList l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bg c (StylizedList l) = StylizedList (map (bg c) l)","function_tokens":["bg","c","(","StylizedList","l",")","=","StylizedList","(","map","(","bg","c",")","l",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L104-L104","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"reifyDec","parameters":"name","argument_list":"","return_statement":"","docstring":"Reify a name into a declaration.","docstring_summary":"Reify a name into a declaration.","docstring_tokens":["Reify","a","name","into","a","declaration","."],"function":"reifyDec name =\n  do info <- reify name\n     case info of\n       TyConI dec -> return dec\n       _ -> fclError \"Info must be type declaration type.\"\n\n-- Throw a fclabels specific error.","function_tokens":["reifyDec","name","=","do","info","<-","reify","name","case","info","of","TyConI","dec","->","return","dec","_","->","fclError","\"Info must be type declaration type.\"","-- Throw a fclabels specific error."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L710-L718","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"rest","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rest = polled \\\\ known","function_tokens":["rest","=","polled","\\\\","known"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L57-L57","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"NonDetC f <*> NonDetC a = NonDetC $ \\ fork leaf nil ->\n    f fork (\\ f' -> a fork (leaf . f') nil) nil","function_tokens":["NonDetC","f","<*>","NonDetC","a","=","NonDetC","$","\\","fork","leaf","nil","->","f","fork","(","\\","f'","->","a","fork","(","leaf",".","f'",")","nil",")","nil"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L85-L86","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"printedDecl","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printedDecl = runPrinter_ printerConfig $ putDataDecl cfg decl","function_tokens":["printedDecl","=","runPrinter_","printerConfig","$","putDataDecl","cfg","decl"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L135-L135","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putConDeclField","parameters":"cfg GHC.ConDeclField {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putConDeclField cfg GHC.ConDeclField {..} = do\n    sep\n        (comma >> space)\n        (fmap putOutputable cd_fld_names)\n    space\n    putText \"::\"\n    space\n    putType' cfg cd_fld_type\n\n-- | A variant of 'putType' that takes 'cCurriedContext' into account","function_tokens":["putConDeclField","cfg","GHC","ConDeclField","{","..","}","=","do","sep","(","comma",">>","space",")","(","fmap","putOutputable","cd_fld_names",")","space","putText","\"::\"","space","putType'","cfg","cd_fld_type","-- | A variant of 'putType' that takes 'cCurriedContext' into account"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L493-L503","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind","parameters":"_ a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind _ a = case index (unIFix a) %~ (sing :: Sing v) of\n        Proved Refl -> Just . (\\s -> (False, s)) $ do\n            (ns, q) <- get\n\n            let x :: forall f. VarF :<: f => IFix f v\n                x = var n\n\n                (n, ns') = runCoiter ns\n\n            put (ns', (freevars a, forall [x] . (x .=. a .->.)) : q)\n            return x\n        Disproved _ -> Nothing","function_tokens":["bind","_","a","=","case","index","(","unIFix","a",")","%~","(","sing","::","Sing","v",")","of","Proved","Refl","->","Just",".","(","\\","s","->","(","False",",","s",")",")","$","do","(","ns",",","q",")","<-","get","let","x","::","forall","f",".","VarF",":<:","f","=>","IFix","f","v","x","=","var","n","(","n",",","ns'",")","=","runCoiter","ns","put","(","ns'",",","(","freevars","a",",","forall","[","x","]",".","(","x",".=.","a",".->.",")",")",":","q",")","return","x","Disproved","_","->","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L758-L771","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"isGADT","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isGADT = any isGADTCons . GHC.dd_cons . dataDefn\n  where\n    isGADTCons c = case GHC.unLoc c of\n      GHC.ConDeclGADT {} -> True\n      _                  -> False","function_tokens":["isGADT","=","any","isGADTCons",".","GHC","dd_cons",".","dataDefn","where","isGADTCons","c","=","case","GHC","unLoc","c","of","GHC","ConDeclGADT","{","}","->","True","_","->","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L525-L531","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseNode","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseNode _            = fail \"Node expected\"","function_tokens":["parseNode","_","=","fail","\"Node expected\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L113-L113","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"getViewPat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getViewPat = \\case\n      GHC.ViewPat{} -> [()]\n      _             -> []\n\n\n--------------------------------------------------------------------------------\n-- | Check if the BangPatterns language pragma is redundant.","function_tokens":["getViewPat","=","\\","case","GHC","ViewPat","{","}","->","[","(",")","]","_","->","[","]","--------------------------------------------------------------------------------","-- | Check if the BangPatterns language pragma is redundant."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L182-L189","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"enabledMakeSimpleJsonIbBps","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"enabledMakeSimpleJsonIbBps = C.avx_2 && C.sse_4_2 && C.bmi_2","function_tokens":["enabledMakeSimpleJsonIbBps","=","C","avx_2","&&","C","sse_4_2","&&","C","bmi_2"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L148-L148","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"a@(Or [])","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' a@(Or []) = Just (True, return . inject $ a)","function_tokens":["bind'","a","@","(","Or","[","]",")","=","Just","(","True",",","return",".","inject","$","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L815-L815","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"prefix","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prefix = Text.dropEnd (Text.length word) left","function_tokens":["prefix","=","Text","dropEnd","(","Text","length","word",")","left"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L96-L96","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"clean","parameters":"Stack","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"clean Stack = callProcess \"stack\" [\"clean\"]","function_tokens":["clean","Stack","=","callProcess","\"stack\"","[","\"clean\"","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L35-L35","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Key _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Key _)                  = \"K\"","function_tokens":["go","(","Key","_",")","=","\"K\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L343-L343","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"select","parameters":"a i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"select a i = inject (Select sing sing a i)","function_tokens":["select","a","i","=","inject","(","Select","sing","sing","a","i",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L114-L114","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"durTList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"durTList = maximum . fmap totalEventDur . renderTList\n    where totalEventDur = (+) <$> eventStart <*> eventDur","function_tokens":["durTList","=","maximum",".","fmap","totalEventDur",".","renderTList","where","totalEventDur","=","(","+",")","<$>","eventStart","<*>","eventDur"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L319-L322","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"h","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"h = handle inst","function_tokens":["h","=","handle","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L111-L111","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"identity","parameters":"(App i _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identity (App i _ _) = i","function_tokens":["identity","(","App","i","_","_",")","=","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L43-L43","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","language":"haskell","identifier":"unsafeRead","parameters":"(SymMMatrix n v) (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeRead (SymMMatrix n v) (i,j) = GM.unsafeRead v (idx n i j)","function_tokens":["unsafeRead","(","SymMMatrix","n","v",")","(","i",",","j",")","=","GM","unsafeRead","v","(","idx","n","i","j",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs#L29-L29","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","hash_val":33107,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"diagRect","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_summary":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_tokens":["O","(","m","*","n",")","Create","a","rectangular","matrix","with","default","values","and","given","diagonal"],"function":"diagRect = MG.diagRect","function_tokens":["diagRect","=","MG","diagRect"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L211-L211","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"identity","parameters":"(Tip i _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identity (Tip i _) = i","function_tokens":["identity","(","Tip","i","_",")","=","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L194-L194","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection","parameters":"Nil _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intersection Nil _ = Nil","function_tokens":["intersection","Nil","_","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L437-L437","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"marshalDevice","parameters":"(Device device)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalDevice (Device device) = device","function_tokens":["marshalDevice","(","Device","device",")","=","device"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L132-L132","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"flags","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flags = fromMaybe [] $ do\n      cmd <- Text.words left & viaNonEmpty head\n      names <- lookup cmd commands\n      pure $\n        flip map names $ \\case\n          O.OptShort c -> toText ['-', c]\n          O.OptLong s -> \"--\" <> toText s\n\n    -- A map of command names and their flags.","function_tokens":["flags","=","fromMaybe","[","]","$","do","cmd","<-","Text","words","left","&","viaNonEmpty","head","names","<-","lookup","cmd","commands","pure","$","flip","map","names","$","\\","case","O","OptShort","c","->","toText","[","'-'",",","c","]","O","OptLong","s","->","\"--\"","<>","toText","s","-- A map of command names and their flags."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L102-L111","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"element","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"element = CacheState (seedIdentity result) HashMap.empty","function_tokens":["element","=","CacheState","(","seedIdentity","result",")","HashMap","empty"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L51-L51","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"","parameters":"(StylizedList l) t@(Stylized _ _)","argument_list":"","return_statement":"","docstring":"StylizedList on LHS.","docstring_summary":"StylizedList on LHS.","docstring_tokens":["StylizedList","on","LHS","."],"function":"(<>) (StylizedList l) t@(Stylized _ _) = StylizedList (l <> [t])","function_tokens":["(","<>",")","(","StylizedList","l",")","t","@","(","Stylized","_","_",")","=","StylizedList","(","l","<>","[","t","]",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L56-L56","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"finish","parameters":"","argument_list":"","return_statement":"","docstring":"As long as there still are pending requests, wait for the next one","docstring_summary":"As long as there still are pending requests, wait for the next one","docstring_tokens":["As","long","as","there","still","are","pending","requests","wait","for","the","next","one"],"function":"finish = do\n                pending <- gets pending\n                unless (null pending) $ waitForReply (return ()) finishCheck\n\n          -- Record the nodes which return the value","function_tokens":["finish","=","do","pending","<-","gets","pending","unless","(","null","pending",")","$","waitForReply","(","return","(",")",")","finishCheck","-- Record the nodes which return the value"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L77-L82","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"setEnabled","parameters":"_ (Buffer _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setEnabled _ (Buffer _)    = Buffer mempty","function_tokens":["setEnabled","_","(","Buffer","_",")","=","Buffer","mempty"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L154-L154","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = G.length vec","function_tokens":["n","=","G","length","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L139-L139","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"toRWSTF","parameters":"w (a, s, w')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toRWSTF w (a, s, w') = RWSTF (a, s, mappend w w')","function_tokens":["toRWSTF","w","(","a",",","s",",","w'",")","=","RWSTF","(","a",",","s",",","mappend","w","w'",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L246-L246","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"read","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"read = send Read","function_tokens":["read","=","send","Read"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L49-L49","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Instruction a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Instruction a)          = show $ pretty a","function_tokens":["go","(","Instruction","a",")","=","show","$","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L412-L412","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_INVALID_VALUE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_INVALID_VALUE                   = 0xA004","function_tokens":["alc_INVALID_VALUE","=","0xA004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L144-L144","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"go","parameters":"(x : y : zs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (x : y : zs) = (x, False, False) : go (y : zs)","function_tokens":["go","(","x",":","y",":","zs",")","=","(","x",",","False",",","False",")",":","go","(","y",":","zs",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L209-L209","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"project","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"project = unPackageName . pkgName $ pkgId","function_tokens":["project","=","unPackageName",".","pkgName","$","pkgId"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L98-L98","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"fromLists","parameters":"xs","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_summary":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","list","of","lists","it","doesn","t","check","if","the","list","of","list","is","a","valid","matrix"],"function":"fromLists xs | null xs = empty\n             | otherwise = fromVector (r,c) . G.fromList . concat $ xs\n  where\n    r = length xs\n    c = length . head $ xs","function_tokens":["fromLists","xs","|","null","xs","=","empty","|","otherwise","=","fromVector","(","r",",","c",")",".","G","fromList",".","concat","$","xs","where","r","=","length","xs","c","=","length",".","head","$","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L145-L150","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"lift","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift m = NonDetC (\\ _ leaf _ -> m >>= leaf)","function_tokens":["lift","m","=","NonDetC","(","\\","_","leaf","_","->","m",">>=","leaf",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L123-L123","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"runLabelled","parameters":"(Labelled l)","argument_list":"","return_statement":"","docstring":"@since 1.0.2.0","docstring_summary":"","docstring_tokens":[],"function":"runLabelled (Labelled l) = l","function_tokens":["runLabelled","(","Labelled","l",")","=","l"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L64-L64","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"slot","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"slot = getCache cache ! r","function_tokens":["slot","=","getCache","cache","!","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L83-L83","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"forall","parameters":"[] f","argument_list":"","return_statement":"","docstring":"A smart constructor for universally quantified formulae","docstring_summary":"A smart constructor for universally quantified formulae","docstring_tokens":["A","smart","constructor","for","universally","quantified","formulae"],"function":"forall [] f = f","function_tokens":["forall","[","]","f","=","f"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L652-L652","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unzip","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip = MG.unzip","function_tokens":["unzip","=","MG","unzip"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L344-L344","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"makeSourceGettableStateVar","parameters":"dict name source","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeSourceGettableStateVar dict name source =\n   makeGettableStateVar\n      (makeGetter dict name source)","function_tokens":["makeSourceGettableStateVar","dict","name","source","=","makeGettableStateVar","(","makeGetter","dict","name","source",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L599-L601","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bottom = false","function_tokens":["bottom","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L217-L217","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"imapM","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, yielding a matrix of results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","yielding","a","matrix","of","results","."],"function":"imapM = MG.imapM","function_tokens":["imapM","=","MG","imapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L240-L240","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookPushEvent","function_tokens":["reflect","_","=","WebhookPushEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L466-L466","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","language":"haskell","identifier":"zipPadded","parameters":"a b (c:cs) []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipPadded a b (c:cs) []     = (c, b):zipPadded a b cs []","function_tokens":["zipPadded","a","b","(","c",":","cs",")","[","]","=","(","c",",","b",")",":","zipPadded","a","b","cs","[","]"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs#L8-L8","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","hash_val":30237,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"marshalMaybeDevice","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalMaybeDevice = marshalDevice . maybe nullDevice id","function_tokens":["marshalMaybeDevice","=","marshalDevice",".","maybe","nullDevice","id"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L66-L66","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"unguardedRhsBody","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unguardedRhsBody _ = Nothing","function_tokens":["unguardedRhsBody","_","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L230-L230","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"map","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"map = MG.map","function_tokens":["map","=","MG","map"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L229-L229","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"execAccum","parameters":"w","argument_list":"","return_statement":"","docstring":"Run a 'Accum' effect (typically with a 'Monoid'al log), producing the final log and discarding the result value.  @ 'execAccum' w = 'fmap' 'fst' . 'runAccum' w @  @since 1.1.2.0","docstring_summary":"Run a 'Accum' effect (typically with a 'Monoid'al log), producing the final log and discarding the result value.","docstring_tokens":["Run","a","Accum","effect","(","typically","with","a","Monoid","al","log",")","producing","the","final","log","and","discarding","the","result","value","."],"function":"execAccum w = fmap fst . runAccum w","function_tokens":["execAccum","w","=","fmap","fst",".","runAccum","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L61-L61","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putRegex","parameters":"(Regex x y)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putRegex (Regex x y) = putCString x >> putCString y","function_tokens":["putRegex","(","Regex","x","y",")","=","putCString","x",">>","putCString","y"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L212-L212","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showsBars","parameters":"bars","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsBars bars\n  = case bars of\n      [] -> id\n      _  -> showString (concat (reverse (tail bars))) . showString node","function_tokens":["showsBars","bars","=","case","bars","of","[","]","->","id","_","->","showString","(","concat","(","reverse","(","tail","bars",")",")",")",".","showString","node"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L818-L823","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"loop","parameters":"m !i !j","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop m !i !j\n            | i >= n = return ()\n            | j >= n = loop m (i+1) (i+1)\n            | otherwise = unsafeWrite m (i,j) (f (i,j) x) >>\n                          loop m i (j+1)\n          where\n            x = unsafeIndex mat (i,j)","function_tokens":["loop","m","i","j","|","i",">=","n","=","return","(",")","|","j",">=","n","=","loop","m","(","i","+","1",")","(","i","+","1",")","|","otherwise","=","unsafeWrite","m","(","i",",","j",")","(","f","(","i",",","j",")","x",")",">>","loop","m","i","(","j","+","1",")","where","x","=","unsafeIndex","mat","(","i",",","j",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L86-L93","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"seg","parameters":"a dur b t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"seg a dur b t\n                | t < 0     = a\n                | t >= dur  = b\n                | otherwise = a + (b - a)*(t\/dur)","function_tokens":["seg","a","dur","b","t","|","t","<","0","=","a","|","t",">=","dur","=","b","|","otherwise","=","a","+","(","b","-","a",")","*","(","t","\/","dur",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L391-L394","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","language":"haskell","identifier":"ptr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptr = F.unsafeForeignPtrToPtr fptr","function_tokens":["ptr","=","F","unsafeForeignPtrToPtr","fptr"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs#L44-L44","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","hash_val":16990,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge []  = cnst 0","function_tokens":["merge","[","]","=","cnst","0"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L170-L170","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"host","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"host = peerHost . peer $ node","function_tokens":["host","=","peerHost",".","peer","$","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L48-L48","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"show","parameters":"V1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show V1 = \"1\"","function_tokens":["show","V1","=","\"1\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L18-L18","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseJSON","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseJSON _            = mzero","function_tokens":["parseJSON","_","=","mzero"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L90-L90","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"areaTriangle","parameters":"x1 x2 x3","argument_list":"","return_statement":"","docstring":"Compute the area of a triangle using L'Huillier's formula","docstring_summary":"Compute the area of a triangle using L'Huillier's formula","docstring_tokens":["Compute","the","area","of","a","triangle","using","L","Huillier","s","formula"],"function":"areaTriangle x1 x2 x3 = r^2 * e\n    where r = 6371\n          e = 4 * atan(sqrt(tan(s\/2) * tan((s - a)\/2) * tan((s - b)\/2) * tan((s - c)\/2)))\n          s = (a + b + c) \/ 2\n          a = distanceRad x1 x2\n          b = distanceRad x1 x3\n          c = distanceRad x2 x3\n          distanceRad = on centralAngle toRadians\n\n-- TODO mandelbrot\/fractal dimension? \n-- consider \"area of largest circumscribable circle\" as well. \n\n-- | Relative compactness, i.e. compactness divided by the compactness of a Euclidean circle","function_tokens":["areaTriangle","x1","x2","x3","=","r","^","2","*","e","where","r","=","6371","e","=","4","*","atan","(","sqrt","(","tan","(","s","\/","2",")","*","tan","(","(","s","-","a",")","\/","2",")","*","tan","(","(","s","-","b",")","\/","2",")","*","tan","(","(","s","-","c",")","\/","2",")",")",")","s","=","(","a","+","b","+","c",")","\/","2","a","=","distanceRad","x1","x2","b","=","distanceRad","x1","x3","c","=","distanceRad","x2","x3","distanceRad","=","on","centralAngle","toRadians","-- TODO mandelbrot\/fractal dimension? ","-- consider \"area of largest circumscribable circle\" as well. ","-- | Relative compactness, i.e. compactness divided by the compactness of a Euclidean circle"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L23-L36","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"foldT","parameters":"empty single append tfun x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldT empty single append tfun x = case x of\n        Empty        -> empty\n        Single a     -> single a\n        Append a b   -> append (f a) (f b)\n        TFun t a     -> tfun t (f a)\n    where f = foldT empty single append tfun\n\n\n\n#if MIN_VERSION_base(4,11,0)","function_tokens":["foldT","empty","single","append","tfun","x","=","case","x","of","Empty","->","empty","Single","a","->","single","a","Append","a","b","->","append","(","f","a",")","(","f","b",")","TFun","t","a","->","tfun","t","(","f","a",")","where","f","=","foldT","empty","single","append","tfun","#if MIN_VERSION_base(4,11,0)"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L290-L300","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"locateCabalFile","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"locateCabalFile = find (isSuffixOf \".cabal\")\n    <$> getDirectoryContents \".\"","function_tokens":["locateCabalFile","=","find","(","isSuffixOf","\".cabal\"",")","<$>","getDirectoryContents","\".\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L76-L77","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_BITS","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_BITS                             = 0x2002","function_tokens":["al_BITS","=","0x2002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L114-L114","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"app\/MainPng.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = exec","function_tokens":["main","=","exec"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/app\/MainPng.hs#L6-L6","hash_key":"vmchale\/hgis:app\/MainPng.hs","hash_val":6692,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"local","parameters":"l f","argument_list":"","return_statement":"","docstring":"Execute a computation in a modified environment. The lens is used to point out the part to modify.","docstring_summary":"Execute a computation in a modified environment. The lens is used to point out the part to modify.","docstring_tokens":["Execute","a","computation","in","a","modified","environment",".","The","lens","is","used","to","point","out","the","part","to","modify","."],"function":"local l f = Reader.local (Total.modify l f)","function_tokens":["local","l","f","=","Reader","local","(","Total","modify","l","f",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L65-L65","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ifold","parameters":"(Or os)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Or os) = coerce (mconcat :: [m] -> m) os","function_tokens":["ifold","(","Or","os",")","=","coerce","(","mconcat","::","[","m","]","->","m",")","os"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L369-L369","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"x'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x' = vec `U.unsafeIndex` k","function_tokens":["x'","=","vec","`","U","unsafeIndex","`","k"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L166-L166","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"deleteEntryComment","parameters":"s","argument_list":"","return_statement":"","docstring":"Delete an entry's comment, if that entry does not exist, nothing will happen.","docstring_summary":"Delete an entry's comment, if that entry does not exist, nothing will happen.","docstring_tokens":["Delete","an","entry","s","comment","if","that","entry","does","not","exist","nothing","will","happen","."],"function":"deleteEntryComment s = addPending (I.DeleteEntryComment s)","function_tokens":["deleteEntryComment","s","=","addPending","(","I","DeleteEntryComment","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L558-L558","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"exec","parameters":"","argument_list":"","return_statement":"","docstring":"FIXME make it work with -a (generate-all)","docstring_summary":"FIXME make it work with -a (generate-all)","docstring_tokens":["FIXME","make","it","work","with","-","a","(","generate","-","all",")"],"function":"exec = pick =<< execParser helpDisplay","function_tokens":["exec","=","pick","=<<","execParser","helpDisplay"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L28-L28","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"state","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"state = LookupState inst id chan [] [] []","function_tokens":["state","=","LookupState","inst","id","chan","[","]","[","]","[","]"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L199-L199","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"stride","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stride = r - i","function_tokens":["stride","=","r","-","i"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L137-L137","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"peer","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"peer = Peer (C.unpack host) (fromIntegral port)","function_tokens":["peer","=","Peer","(","C","unpack","host",")","(","fromIntegral","port",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L114-L114","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"add","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"add []  = cnst 0","function_tokens":["add","[","]","=","cnst","0"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L198-L198","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"dim","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim = MG.dim","function_tokens":["dim","=","MG","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L114-L114","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"unmatched","parameters":"xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmatched xs = drop matchTop $ dropEnd matchBottom xs","function_tokens":["unmatched","xs","=","drop","matchTop","$","dropEnd","matchBottom","xs"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L50-L50","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"just","parameters":"","argument_list":"","return_statement":"","docstring":"Lens pointing to the value in a Maybe. (Partial and polymorphic)","docstring_summary":"Lens pointing to the value in a Maybe. (Partial and polymorphic)","docstring_tokens":["Lens","pointing","to","the","value","in","a","Maybe",".","(","Partial","and","polymorphic",")"],"function":"just = $(getLabel ''Maybe)","function_tokens":["just","=","(","getLabel","''","Maybe",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L79-L79","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(=:) = puts","function_tokens":["(","=:",")","=","puts"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L48-L48","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapMaybe","parameters":"Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapMaybe Nothing         = noWrap","function_tokens":["wrapMaybe","Nothing","=","noWrap"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L118-L118","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Pitch (cl, acc, oct))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (Pitch (cl, acc, oct)) = pretty acc <> (string $\n        (if oct <= 0 then id else fmap toLower) (show cl)\n        ++ replicate (negate (fromIntegral oct) `max` 0) ','\n        ++ replicate (fromIntegral (oct - 1) `max` 0) '\\'')","function_tokens":["pretty","(","Pitch","(","cl",",","acc",",","oct",")",")","=","pretty","acc","<>","(","string","$","(","if","oct","<=","0","then","id","else","fmap","toLower",")","(","show","cl",")","++","replicate","(","negate","(","fromIntegral","oct",")","`","max","`","0",")","','","++","replicate","(","fromIntegral","(","oct","-","1",")","`","max","`","0",")","'\\''",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L442-L445","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"needZip64","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"needZip64 =\n        totalCount >= ffff\n          || cdSize >= ffffffff\n          || cdOffset >= ffffffff","function_tokens":["needZip64","=","totalCount",">=","ffff","||","cdSize",">=","ffffffff","||","cdOffset",">=","ffffffff"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L637-L640","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"tmap","parameters":"f","argument_list":"","return_statement":"","docstring":"Maps values and time stamps.","docstring_summary":"Maps values and time stamps.","docstring_tokens":["Maps","values","and","time","stamps","."],"function":"tmap f = mapEvents $ \\e -> e{ eventContent = f e }","function_tokens":["tmap","f","=","mapEvents","$","\\","e","->","e","{","eventContent","=","f","e","}"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L240-L240","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!w'' = mappend w (f w')","function_tokens":["w''","=","mappend","w","(","f","w'",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Strict.hs#L75-L75","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Strict.hs","hash_val":32183,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = realToFrac $ sqrt (1 - t*t)","function_tokens":["s","=","realToFrac","$","sqrt","(","1","-","t","*","t",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L146-L146","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"relativePath","parameters":"base path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"relativePath base path\n    | rel \/= path = rel\n    | revRel \/= base =\n          joinPath $ replicate (length (splitPath revRel)) \"..\"\n    | otherwise = path\n    where\n        rel = makeRelative base path\n        revRel = makeRelative path base","function_tokens":["relativePath","base","path","|","rel","\/=","path","=","rel","|","revRel","\/=","base","=","joinPath","$","replicate","(","length","(","splitPath","revRel",")",")","\"..\"","|","otherwise","=","path","where","rel","=","makeRelative","base","path","revRel","=","makeRelative","path","base"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L128-L137","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_STREAMING","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_STREAMING                        = 0x1029","function_tokens":["al_STREAMING","=","0x1029"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L101-L101","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sourceState","parameters":"source","argument_list":"","return_statement":"","docstring":"Contains the current execution state of the given source. The initial state of any source is 'Initial'.  Note that the 'Initial' state is not necessarily identical to the initial state in which a source is created, because the other source attributes are not automatically reset to their initial values. 'Initial' merely indicates that the source can be executed using the 'play' command. A 'Stopped' or 'Initial' source can be reset into the default configuration by using a sequence of source commands as necessary. As the application has to specify all relevant state anyway to create a useful source configuration, no reset command is provided.","docstring_summary":"Contains the current execution state of the given source. The initial state of any source is 'Initial'.  Note that the 'Initial' state is not necessarily identical to the initial state in which a source is created, because the other source attributes are not automatically reset to their initial values. 'Initial' merely indicates that the source can be executed using the 'play' command. A 'Stopped' or 'Initial' source can be reset into the default configuration by using a sequence of source commands as necessary. As the application has to specify all relevant state anyway to create a useful source configuration, no reset command is provided.","docstring_tokens":["Contains","the","current","execution","state","of","the","given","source",".","The","initial","state","of","any","source","is","Initial",".","Note","that","the","Initial","state","is","not","necessarily","identical","to","the","initial","state","in","which","a","source","is","created","because","the","other","source","attributes","are","not","automatically","reset","to","their","initial","values",".","Initial","merely","indicates","that","the","source","can","be","executed","using","the","play","command",".","A","Stopped","or","Initial","source","can","be","reset","into","the","default","configuration","by","using","a","sequence","of","source","commands","as","necessary",".","As","the","application","has","to","specify","all","relevant","state","anyway","to","create","a","useful","source","configuration","no","reset","command","is","provided","."],"function":"sourceState source =\n   makeGettableStateVar\n      (makeGetter dictSourceState GetSourceState source)","function_tokens":["sourceState","source","=","makeGettableStateVar","(","makeGetter","dictSourceState","GetSourceState","source",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L717-L719","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"pass","parameters":"rw","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pass rw = RSST $ \\r (s, w) -> do\n        ( (a, fw), (s', w') ) <- runRSST' rw r (s, mempty)\n        return (a, (s', w `mappend` fw w'))","function_tokens":["pass","rw","=","RSST","$","\\","r","(","s",",","w",")","->","do","(","(","a",",","fw",")",",","(","s'",",","w'",")",")","<-","runRSST'","rw","r","(","s",",","mempty",")","return","(","a",",","(","s'",",","w","`","mappend","`","fw","w'",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L199-L202","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putComment","parameters":"epaComment","argument_list":"","return_statement":"","docstring":"Put all comments that has positions within 'SrcSpan' and separate by passed @P ()@ {-\nputAllSpanComments :: P () -> SrcSpan -> P ()\nputAllSpanComments suff = \\case\nUnhelpfulSpan _ -> pure ()\nRealSrcSpan rspan -> do\ncmts <- removeComments \\(L rloc _) ->\nsrcSpanStartLine rloc >= srcSpanStartLine rspan &&\nsrcSpanEndLine rloc <= srcSpanEndLine rspan\n\nforM_ cmts (\\c -> putComment c >> suff)\n-} Print any comment","docstring_summary":"Put all comments that has positions within 'SrcSpan' and separate by passed @P ()@ {-\nputAllSpanComments :: P () -> SrcSpan -> P ()\nputAllSpanComments suff = \\case\nUnhelpfulSpan _ -> pure ()\nRealSrcSpan rspan -> do\ncmts <- removeComments \\(L rloc _) ->\nsrcSpanStartLine rloc >= srcSpanStartLine rspan &&\nsrcSpanEndLine rloc <= srcSpanEndLine rspan","docstring_tokens":["Put","all","comments","that","has","positions","within","SrcSpan","and","separate","by","passed","@P","()","@","{","-","putAllSpanComments","::","P","()","-",">","SrcSpan","-",">","P","()","putAllSpanComments","suff","=","\\","case","UnhelpfulSpan","_","-",">","pure","()","RealSrcSpan","rspan","-",">","do","cmts","<","-","removeComments","\\","(","L","rloc","_",")","-",">","srcSpanStartLine","rloc",">","=","srcSpanStartLine","rspan","&&","srcSpanEndLine","rloc","<","=","srcSpanEndLine","rspan"],"function":"putComment epaComment = case GHC.ac_tok epaComment of\n  GHC.EpaLineComment s     -> putText s\n  GHC.EpaDocCommentNext s  -> putText s\n  GHC.EpaDocCommentPrev s  -> putText s\n  GHC.EpaDocCommentNamed s -> putText s\n  GHC.EpaDocSection _ s    -> putText s\n  GHC.EpaDocOptions s      -> putText s\n  GHC.EpaBlockComment s    -> putText s\n  GHC.EpaEofComment        -> pure ()","function_tokens":["putComment","epaComment","=","case","GHC","ac_tok","epaComment","of","GHC","EpaLineComment","s","->","putText","s","GHC","EpaDocCommentNext","s","->","putText","s","GHC","EpaDocCommentPrev","s","->","putText","s","GHC","EpaDocCommentNamed","s","->","putText","s","GHC","EpaDocSection","_","s","->","putText","s","GHC","EpaDocOptions","s","->","putText","s","GHC","EpaBlockComment","s","->","putText","s","GHC","EpaEofComment","->","pure","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L138-L148","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"thaw","parameters":"(SymMatrix n v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thaw (SymMatrix n v) = SymMMatrix n `liftM` G.thaw v","function_tokens":["thaw","(","SymMatrix","n","v",")","=","SymMMatrix","n","`","liftM","`","G","thaw","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L64-L64","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"runMain","parameters":"cfg (Time start)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"runMain cfg (Time start) = printAll <=< go . (,) (0,0)\n  where\n    go ((pos,m), s) = handleJust (\\e -> if e == UserInterrupt then Just s else Nothing) pure $\n        let (BenchmarkMeta{..}, s') = S.deleteFindMin s in do\n              ana <- analysis <$> step benchmark\n              let newMax | pos == position = (pos, mean ana)\n                         | mean ana > m = (position, mean ana)\n                         | otherwise = (pos, m)\n                  new = BenchmarkMeta (informationOf ana) (snd newMax) position benchmark{analysis = ana}\n                  set = S.insert new s'\n              mask_ $ pp new set\n\n              timeup <- case timeout cfg of\n                Just to -> do\n                  Time end <- now\n                  pure $ fromIntegral (end - start) \/ 1e9 >= to\n                Nothing -> pure False\n\n              if terminates set || timeup\n                 then pure set\n                 else go (newMax, set)\n\n    f | sortByMean cfg = sortOn (negate . mean . analysis . benchmark)\n      | otherwise = sortOn (negate . position)\n\n    printAll set = do\n      when (sortByMean cfg && not (printOnce cfg)) . B.hPutBuilder stdout . linesUp $ printHeight cfg*length set\n      mapM_ (printBenchmark cfg) . f $ S.toList set\n\n    terminates set = case relativeError cfg of\n        Just re -> re >= maximum (map (uncurry (\/) . ((confidence cfg*) . standardError &&& fromRational . mean) . analysis . benchmark) $ S.toList set)\n        Nothing -> False\n\n    pp n set\n      | printOnce cfg = pure ()\n      | sortByMean cfg = printAll set\n      | otherwise = printBenchmark cfg n","function_tokens":["runMain","cfg","(","Time","start",")","=","printAll","<=<","go",".","(",",",")","(","0",",","0",")","where","go","(","(","pos",",","m",")",",","s",")","=","handleJust","(","\\","e","->","if","e","==","UserInterrupt","then","Just","s","else","Nothing",")","pure","$","let","(","BenchmarkMeta","{","..","}",",","s'",")","=","S","deleteFindMin","s","in","do","ana","<-","analysis","<$>","step","benchmark","let","newMax","|","pos","==","position","=","(","pos",",","mean","ana",")","|","mean","ana",">","m","=","(","position",",","mean","ana",")","|","otherwise","=","(","pos",",","m",")","new","=","BenchmarkMeta","(","informationOf","ana",")","(","snd","newMax",")","position","benchmark","{","analysis","=","ana","}","set","=","S","insert","new","s'","mask_","$","pp","new","set","timeup","<-","case","timeout","cfg","of","Just","to","->","do","Time","end","<-","now","pure","$","fromIntegral","(","end","-","start",")","\/","1e9",">=","to","Nothing","->","pure","False","if","terminates","set","||","timeup","then","pure","set","else","go","(","newMax",",","set",")","f","|","sortByMean","cfg","=","sortOn","(","negate",".","mean",".","analysis",".","benchmark",")","|","otherwise","=","sortOn","(","negate",".","position",")","printAll","set","=","do","when","(","sortByMean","cfg","&&","not","(","printOnce","cfg",")",")",".","B","hPutBuilder","stdout",".","linesUp","$","printHeight","cfg","*","length","set","mapM_","(","printBenchmark","cfg",")",".","f","$","S","toList","set","terminates","set","=","case","relativeError","cfg","of","Just","re","->","re",">=","maximum","(","map","(","uncurry","(","\/",")",".","(","(","confidence","cfg","*",")",".","standardError","&&&","fromRational",".","mean",")",".","analysis",".","benchmark",")","$","S","toList","set",")","Nothing","->","False","pp","n","set","|","printOnce","cfg","=","pure","(",")","|","sortByMean","cfg","=","printAll","set","|","otherwise","=","printBenchmark","cfg","n"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L253-L291","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"bench","parameters":"label f x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bench label f x = Benchmark label (Analysis 0 0 0 0) $ \\ana -> newIORef x >>= \\io -> measure (\\n -> replicateM_ n $ (return$!) . force . f =<< readIORef io) ana","function_tokens":["bench","label","f","x","=","Benchmark","label","(","Analysis","0","0","0","0",")","$","\\","ana","->","newIORef","x",">>=","\\","io","->","measure","(","\\","n","->","replicateM_","n","$","(","return","$!",")",".","force",".","f","=<<","readIORef","io",")","ana"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L114-L114","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,gt) = split' x r","function_tokens":["(","lt",",","gt",")","=","split'","x","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L531-L531","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"untabified","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"untabified = maybe id untabify mUntabifySize","function_tokens":["untabified","=","maybe","id","untabify","mUntabifySize"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L136-L136","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ma >>= f = AccumC $ \\w -> do\n    (w', a) <- runAccumC ma w\n    (w'', b) <- runAccumC (f a) $ mappend w w'\n    return (mappend w' w'', b)","function_tokens":["ma",">>=","f","=","AccumC","$","\\","w","->","do","(","w'",",","a",")","<-","runAccumC","ma","w","(","w''",",","b",")","<-","runAccumC","(","f","a",")","$","mappend","w","w'","return","(","mappend","w'","w''",",","b",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L105-L109","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapRestMaybe","parameters":"Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapRestMaybe Nothing         = noWrapRest","function_tokens":["wrapRestMaybe","Nothing","=","noWrapRest"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L156-L156","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"measure","parameters":"cmd ana","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"measure cmd ana\n  = performMinorGC\n  >> refineAnalysis ana\n  <$> now\n  <* cmd (fromIntegral $ weightOf ana)\n  <*> now","function_tokens":["measure","cmd","ana","=","performMinorGC",">>","refineAnalysis","ana","<$>","now","<*","cmd","(","fromIntegral","$","weightOf","ana",")","<*>","now"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L292-L297","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"def","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"def = ModuleHeader.defaultConfig","function_tokens":["def","=","ModuleHeader","defaultConfig"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L206-L206","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"cmp c d","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge cmp c d = do\n       (Const v) <- match c\n       (Add as)  <- match d\n       return . (\\(v', r) -> cnst (-v') `cmp` add r) . foldr mergeConstAdd (0, []) $ cnst (-v) : as","function_tokens":["merge","cmp","c","d","=","do","(","Const","v",")","<-","match","c","(","Add","as",")","<-","match","d","return",".","(","\\","(","v'",",","r",")","->","cnst","(","-","v'",")","`","cmp","`","add","r",")",".","foldr","mergeConstAdd","(","0",",","[","]",")","$","cnst","(","-","v",")",":","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L217-L222","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"zipWith","parameters":"f (SymMatrix n1 v1) (SymMatrix n2 v2)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith f (SymMatrix n1 v1) (SymMatrix n2 v2)\n    | n1 \/= n2 = error \"imcompatible size\"\n    | otherwise = SymMatrix n1 . G.zipWith f v1 $ v2","function_tokens":["zipWith","f","(","SymMatrix","n1","v1",")","(","SymMatrix","n2","v2",")","|","n1","\/=","n2","=","error","\"imcompatible size\"","|","otherwise","=","SymMatrix","n1",".","G","zipWith","f","v1","$","v2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L108-L110","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"asText","parameters":"i","argument_list":"","return_statement":"","docstring":"Convert a menu item to a String.","docstring_summary":"Convert a menu item to a String.","docstring_tokens":["Convert","a","menu","item","to","a","String","."],"function":"asText i = renderText Plain (toStylizedText i)","function_tokens":["asText","i","=","renderText","Plain","(","toStylizedText","i",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L146-L146","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"getParserName","parameters":"","argument_list":"","return_statement":"","docstring":"Return the name (assigned through ('<?>')) of the current parser (most nested), or 'mempty' if it has none.","docstring_summary":"Return the name (assigned through ('<?>')) of the current parser (most nested), or 'mempty' if it has none.","docstring_tokens":["Return","the","name","(","assigned","through","(","<?",">","))","of","the","current","parser","(","most","nested",")","or","mempty","if","it","has","none","."],"function":"getParserName = ConduitParser $ lift $ gets (headDef \"\" . fst)","function_tokens":["getParserName","=","ConduitParser","$","lift","$","gets","(","headDef","\"\"",".","fst",")"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L113-L113","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(Or [])","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Or []) = coerce (\"false\" :: String)","function_tokens":["ishow","(","Or","[","]",")","=","coerce","(","\"false\"","::","String",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L388-L388","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_LINEAR_DISTANCE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_LINEAR_DISTANCE                  = 0xD003","function_tokens":["al_LINEAR_DISTANCE","=","0xD003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L57-L57","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"[e]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge [e] = e","function_tokens":["merge","[","e","]","=","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L171-L171","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(BenchmarkMeta{..}, s') = S.deleteFindMin s","function_tokens":["(","BenchmarkMeta","{","..","}",",","s'",")","=","S","deleteFindMin","s"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L256-L256","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_FORMAT_STEREO16","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_FORMAT_STEREO16                  = 0x1103","function_tokens":["al_FORMAT_STEREO16","=","0x1103"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L122-L122","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"defaultMain","parameters":"bs","argument_list":"","return_statement":"","docstring":"Main function for running a list of benchmarks.  It also allows to specify options via commandline.  > defaultMain [bench \"not True\" not True, bench \"id True\" id True]","docstring_summary":"Main function for running a list of benchmarks.  It also allows to specify options via commandline.  > defaultMain [bench \"not True\" not True, bench \"id True\" id True]","docstring_tokens":["Main","function","for","running","a","list","of","benchmarks",".","It","also","allows","to","specify","options","via","commandline",".",">","defaultMain","[","bench","not","True","not","True","bench","id","True","id","True","]"],"function":"defaultMain bs = flip defaultMainWith bs =<< execParser opts\n  where\n    opts = info (configParser Config <**> helper) fullDesc\n\n-- | Construct a benchmark of a name, a pure function and an argument.\n--\n-- > bench \"reverse abc\" reverse \"abc\"","function_tokens":["defaultMain","bs","=","flip","defaultMainWith","bs","=<<","execParser","opts","where","opts","=","info","(","configParser","Config","<**>","helper",")","fullDesc","-- | Construct a benchmark of a name, a pure function and an argument.","--","-- > bench \"reverse abc\" reverse \"abc\""],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L106-L113","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"listen","parameters":"rw","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"listen rw = RSST $ \\r (s, w) -> do\n        (a, (ns, nw)) <- runRSST' rw r (s,mempty)\n        let ow = w `mappend` nw\n        ow `seq` return ((a, nw), (ns, ow))","function_tokens":["listen","rw","=","RSST","$","\\","r","(","s",",","w",")","->","do","(","a",",","(","ns",",","nw",")",")","<-","runRSST'","rw","r","(","s",",","mempty",")","let","ow","=","w","`","mappend","`","nw","ow","`","seq","`","return","(","(","a",",","nw",")",",","(","ns",",","ow",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L194-L198","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"str","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"str  = zipWith f xStr yStr","function_tokens":["str","=","zipWith","f","xStr","yStr"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L70-L70","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unzip4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip4 = MG.unzip4","function_tokens":["unzip4","=","MG","unzip4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L354-L354","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,found,gt) = splitMember x l","function_tokens":["(","lt",",","found",",","gt",")","=","splitMember","x","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L574-L574","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection","parameters":"t (Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intersection t (Tip _ x)\n  = case lookup x t of\n      Just y  -> tip y\n      Nothing -> Nil","function_tokens":["intersection","t","(","Tip","_","x",")","=","case","lookup","x","t","of","Just","y","->","tip","y","Nothing","->","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L433-L437","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_PAUSED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_PAUSED                           = 0x1013","function_tokens":["al_PAUSED","=","0x1013"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L106-L106","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfseries","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfseries x = go 1 x x\n    where\n        go k coef e\n            | k < 30    = \n                let\n                    k'      = k + 1\n                    coef'   = coef * negate (x*x\/k)\n                    e'      =  e + coef' \/ (2 * k + 1)\n                in go k' coef' e'\n            | otherwise = 2 \/ sqrt pi * e","function_tokens":["erfseries","x","=","go","1","x","x","where","go","k","coef","e","|","k","<","30","=","let","k'","=","k","+","1","coef'","=","coef","*","negate","(","x","*","x","\/","k",")","e'","=","e","+","coef'","\/","(","2","*","k","+","1",")","in","go","k'","coef'","e'","|","otherwise","=","2","\/","sqrt","pi","*","e"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L39-L50","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"go","parameters":"bpState bpvm","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go bpState bpvm = fmap fromIntegral . ST.unsafeIOToST $ do\n          let (outFptr, _, _) = DVSM.unsafeToForeignPtr bpvm\n\n          F.withForeignPtr outFptr $ \\outPtr ->\n            F.withForeignPtr (bpStateP bpState) $ \\bpStatePtr -> do\n              F.writeBpChunkFinal (F.castPtr bpStatePtr) (F.castPtr outPtr)","function_tokens":["go","bpState","bpvm","=","fmap","fromIntegral",".","ST","unsafeIOToST","$","do","let","(","outFptr",",","_",",","_",")","=","DVSM","unsafeToForeignPtr","bpvm","F","withForeignPtr","outFptr","$","\\","outPtr","->","F","withForeignPtr","(","bpStateP","bpState",")","$","\\","bpStatePtr","->","do","F","writeBpChunkFinal","(","F","castPtr","bpStatePtr",")","(","F","castPtr","outPtr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L132-L139","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"m@(Just (True, _)) _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge m@(Just (True, _)) _ = m","function_tokens":["merge","m","@","(","Just","(","True",",","_",")",")","_","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L792-L792","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfc8_sum","parameters":"x","argument_list":"","return_statement":"","docstring":"estimates erfc(x) valid for 8 < x < 100 This is based on index 5725 in Hart et al","docstring_summary":"estimates erfc(x) valid for 8 < x < 100 This is based on index 5725 in Hart et al","docstring_tokens":["estimates","erfc","(","x",")","valid","for","8","<","x","<","100","This","is","based","on","index","5725","in","Hart","et","al"],"function":"erfc8_sum x = num \/ den\n    where\n        p = [ 2.97886562639399288862\n            , 7.409740605964741794425\n            , 6.1602098531096305440906\n            , 5.019049726784267463450058\n            , 1.275366644729965952479585264\n            , 0.5641895835477550741253201704\n            ]\n        q = [ 3.3690752069827527677\n            , 9.608965327192787870698\n            , 17.08144074746600431571095\n            , 12.0489519278551290360340491\n            , 9.396034016235054150430579648\n            , 2.260528520767326969591866945\n            , 1.0\n            ]\n        num = poly p x\n        den = poly q x","function_tokens":["erfc8_sum","x","=","num","\/","den","where","p","=","[","2.97886562639399288862",",","7.409740605964741794425",",","6.1602098531096305440906",",","5.019049726784267463450058",",","1.275366644729965952479585264",",","0.5641895835477550741253201704","]","q","=","[","3.3690752069827527677",",","9.608965327192787870698",",","17.08144074746600431571095",",","12.0489519278551290360340491",",","9.396034016235054150430579648",",","2.260528520767326969591866945",",","1.0","]","num","=","poly","p","x","den","=","poly","q","x"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L72-L92","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"rel","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rel = makeRelative base path","function_tokens":["rel","=","makeRelative","base","path"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L134-L134","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"partial","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"partial = if failing\n                   then [t| Failing String |]\n                   else [t| Partial |]","function_tokens":["partial","=","if","failing","then","[","t","|"," Failing String ","|]","else","[","t","|"," Partial ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L455-L457","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"takeRow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeRow = MG.takeRow","function_tokens":["takeRow","=","MG","takeRow"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L129-L129","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"var","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var n = inject (Var n (sing :: Sing s))","function_tokens":["var","n","=","inject","(","Var","n","(","sing","::","Sing","s",")",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L295-L295","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Origin a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Origin a)               = a","function_tokens":["go","(","Origin","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L418-L418","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"withFileName","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withFileName x = maybe \"\" (<> \": \") fp <> x","function_tokens":["withFileName","x","=","maybe","\"\"","(","<>","\": \"",")","fp","<>","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L93-L93","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"newKey","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newKey = STUnsafe.unsafeIOToST $ Key <$> newUnique <*> newIORef Nothing","function_tokens":["newKey","=","STUnsafe","unsafeIOToST","$","Key","<$>","newUnique","<*>","newIORef","Nothing"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L31-L31","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"nnf'","parameters":"(IFix f)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nnf' (IFix f) = case index f %~ SBooleanSort of\n        Proved Refl -> fromJust $ ( match (IFix f) >>= not' ) <|> Just (IFix (imap nnf' f))\n        Disproved _ -> IFix (imap nnf' f)","function_tokens":["nnf'","(","IFix","f",")","=","case","index","f","%~","SBooleanSort","of","Proved","Refl","->","fromJust","$","(","match","(","IFix","f",")",">>=","not'",")","<|>","Just","(","IFix","(","imap","nnf'","f",")",")","Disproved","_","->","IFix","(","imap","nnf'","f",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L697-L701","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(+) = liftA2 (+)","function_tokens":["(","+",")","=","liftA2","(","+",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L231-L231","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"substitute","parameters":"env","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"substitute env = mapType sub\n  where sub v = case lookup v env of\n                  Nothing -> v\n                  Just w  -> w","function_tokens":["substitute","env","=","mapType","sub","where","sub","v","=","case","lookup","v","env","of","Nothing","->","v","Just","w","->","w"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L665-L670","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"difference2 | nomatch p1 p2 m2  = t1\n                | zero p1 m2        = difference t1 l2\n                | otherwise         = difference t1 r2","function_tokens":["difference2","|","nomatch","p1","p2","m2","=","t1","|","zero","p1","m2","=","difference","t1","l2","|","otherwise","=","difference","t1","r2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L397-L399","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"copyEntry","parameters":"path s' s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"copyEntry path s' s = do\n  apath <- liftIO (canonicalizePath path)\n  addPending (I.CopyEntry apath s' s)\n\n-- | Add an directory to the archive. Please note that due to the design of\n-- the library, empty sub-directories will not be added.\n--\n-- The action can throw 'InvalidEntrySelector'.","function_tokens":["copyEntry","path","s'","s","=","do","apath","<-","liftIO","(","canonicalizePath","path",")","addPending","(","I","CopyEntry","apath","s'","s",")","-- | Add an directory to the archive. Please note that due to the design of","-- the library, empty sub-directories will not be added.","--","-- The action can throw 'InvalidEntrySelector'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L478-L486","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"go","parameters":"ty","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go ty =\n    case ty of\n      ForallT ts a b -> ForallT (mapTyVarBndr f <$> ts)\n                                (mapPred f <$> a) (go b)\n      AppT a b       -> AppT (go a) (go b)\n      SigT t a       -> SigT (go t) a\n      VarT n         -> VarT (f n)\n      t              -> t","function_tokens":["go","ty","=","case","ty","of","ForallT","ts","a","b","->","ForallT","(","mapTyVarBndr","f","<$>","ts",")","(","mapPred","f","<$>","a",")","(","go","b",")","AppT","a","b","->","AppT","(","go","a",")","(","go","b",")","SigT","t","a","->","SigT","(","go","t",")","a","VarT","n","->","VarT","(","f","n",")","t","->","t"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L645-L654","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"indexStepFinal","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"indexStepFinal = Step go 2\n  where go  :: BpState\n            -> DVSM.MVector s Word64\n            -> ST s Int\n        go bpState bpvm = fmap fromIntegral . ST.unsafeIOToST $ do\n          let (outFptr, _, _) = DVSM.unsafeToForeignPtr bpvm\n\n          F.withForeignPtr outFptr $ \\outPtr ->\n            F.withForeignPtr (bpStateP bpState) $ \\bpStatePtr -> do\n              F.writeBpChunkFinal (F.castPtr bpStatePtr) (F.castPtr outPtr)","function_tokens":["indexStepFinal","=","Step","go","2","where","go","::","BpState","->","DVSM","MVector","s","Word64","->","ST","s","Int","go","bpState","bpvm","=","fmap","fromIntegral",".","ST","unsafeIOToST","$","do","let","(","outFptr",",","_",",","_",")","=","DVSM","unsafeToForeignPtr","bpvm","F","withForeignPtr","outFptr","$","\\","outPtr","->","F","withForeignPtr","(","bpStateP","bpState",")","$","\\","bpStatePtr","->","do","F","writeBpChunkFinal","(","F","castPtr","bpStatePtr",")","(","F","castPtr","outPtr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L128-L139","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"delayTList","parameters":"k x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delayTList k x = case x of\n        TFun t a    -> TFun (delayTfm k t) a\n        Empty       -> Empty\n        a           -> TFun (Tfm 1 k) a","function_tokens":["delayTList","k","x","=","case","x","of","TFun","t","a","->","TFun","(","delayTfm","k","t",")","a","Empty","->","Empty","a","->","TFun","(","Tfm","1","k",")","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L327-L333","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"tailTy","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tailTy = drop 1 tys","function_tokens":["tailTy","=","drop","1","tys"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L233-L233","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"evalRSS","parameters":"m r s","argument_list":"","return_statement":"","docstring":"^final value and output","docstring_summary":"^final value and output","docstring_tokens":["^final","value","and","output"],"function":"evalRSS m r s = let\n    (a, _, w) = runRSS m r s\n    in (a, w)","function_tokens":["evalRSS","m","r","s","=","let","(","a",",","_",",","w",")","=","runRSS","m","r","s","in","(","a",",","w",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L59-L61","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"f","parameters":"v col row ((i',j'), acc) ((i,j),x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f v col row ((i',j'), acc) ((i,j),x) =\n        if i > i' || (i == i' && j > j')\n           then do\n               GM.write v acc x\n               GM.write col acc j\n               let stride = i - i'\n               when (stride > 0) $ forM_ [0..stride-1] $ \\s -> GM.write row (i-s) acc\n\n               return ((i,j), acc+1)\n           else error $ printf \"Input must be sorted by row and then by column: (%d,%d) >= (%d,%d)\" i' j' i j","function_tokens":["f","v","col","row","(","(","i'",",","j'",")",",","acc",")","(","(","i",",","j",")",",","x",")","=","if","i",">","i'","||","(","i","==","i'","&&","j",">","j'",")","then","do","GM","write","v","acc","x","GM","write","col","acc","j","let","stride","=","i","-","i'","when","(","stride",">","0",")","$","forM_","[","0","..","stride","-","1","]","$","\\","s","->","GM","write","row","(","i","-","s",")","acc","return","(","(","i",",","j",")",",","acc","+","1",")","else","error","$","printf","\"Input must be sorted by row and then by column: (%d,%d) >= (%d,%d)\"","i'","j'","i","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L144-L153","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(AbcTune header elements)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (AbcTune header elements) = mempty\n        <> pretty header <> \"\\n\"\n        <> sepBy \"\\n\" (fmap pretty elements) <> \"\\n\"","function_tokens":["pretty","(","AbcTune","header","elements",")","=","mempty","<>","pretty","header","<>","\"\\n\"","<>","sepBy","\"\\n\"","(","fmap","pretty","elements",")","<>","\"\\n\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L142-L144","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"embed","parameters":"l","argument_list":"","return_statement":"","docstring":"Embed a total lens that points to a `Maybe` field into a lens that might fail.","docstring_summary":"Embed a total lens that points to a `Maybe` field into a lens that might fail.","docstring_tokens":["Embed","a","total","lens","that","points","to","a","Maybe","field","into","a","lens","that","might","fail","."],"function":"embed l = lens (Poly.get l) (\\m f -> const (Poly.modify l ((>>= m), f)) <$> Poly.get l f)","function_tokens":["embed","l","=","lens","(","Poly","get","l",")","(","\\","m","f","->","const","(","Poly","modify","l","(","(",">>=","m",")",",","f",")",")","<$>","Poly","get","l","f",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L80-L80","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' a = bind (Proxy :: Proxy g) (inject a)","function_tokens":["bind'","a","=","bind","(","Proxy","::","Proxy","g",")","(","inject","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L812-L812","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"fromString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromString = intern . T.pack","function_tokens":["fromString","=","intern",".","T","pack"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L18-L18","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unsafeIndex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeIndex = MG.unsafeIndex","function_tokens":["unsafeIndex","=","MG","unsafeIndex"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L123-L123","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"newInstance","parameters":"id handle","argument_list":"","return_statement":"","docstring":"Create a new KademliaInstance from an Id and a KademliaHandle","docstring_summary":"Create a new KademliaInstance from an Id and a KademliaHandle","docstring_tokens":["Create","a","new","KademliaInstance","from","an","Id","and","a","KademliaHandle"],"function":"newInstance id handle = do\n    tree <- atomically . newTVar . T.create $ id\n    values <- atomically . newTVar $ M.empty\n    threads <- atomically . newTVar $ M.empty\n    return . KI handle (KS tree values) $ threads\n\n-- | Insert a Node into the NodeTree","function_tokens":["newInstance","id","handle","=","do","tree","<-","atomically",".","newTVar",".","T","create","$","id","values","<-","atomically",".","newTVar","$","M","empty","threads","<-","atomically",".","newTVar","$","M","empty","return",".","KI","handle","(","KS","tree","values",")","$","threads","-- | Insert a Node into the NodeTree"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L56-L63","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"simpleAlign","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"simpleAlign = SimpleAlign.step","function_tokens":["simpleAlign","=","SimpleAlign","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L54-L54","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"Off Off","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) Off Off = Off","function_tokens":["(","<>",")","Off","Off","=","Off"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L48-L48","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Compound as a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Compound as a)  = sepBy \"+\" (fmap integer as) <> \"\/\" <> integer a","function_tokens":["go","(","Compound","as","a",")","=","sepBy","\"+\"","(","fmap","integer","as",")","<>","\"\/\"","<>","integer","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L495-L495","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"equals","parameters":"(DynamicallySorted s1 a)\n               (DynamicallySorted s2 b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"equals (DynamicallySorted s1 a)\n               (DynamicallySorted s2 b) = case s1 %~ s2 of\n            Proved Refl -> return . toDynamicallySorted . inject $ Equals s1 a b\n            Disproved _ -> fail \"multi-sorted equality\"\n\n-- | A smart constructor for an equality predicate","function_tokens":["equals","(","DynamicallySorted","s1","a",")","(","DynamicallySorted","s2","b",")","=","case","s1","%~","s2","of","Proved","Refl","->","return",".","toDynamicallySorted",".","inject","$","Equals","s1","a","b","Disproved","_","->","fail","\"multi-sorted equality\"","-- | A smart constructor for an equality predicate"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L69-L75","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"isSafeIn","parameters":"(i, j) qs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSafeIn (i, j) qs = null (diags (i, j) `List.intersect` underThreat)\n  where\n    qs' = zip [1..length qs] qs\n    underThreat = qs' >>= diags","function_tokens":["isSafeIn","(","i",",","j",")","qs","=","null","(","diags","(","i",",","j",")","`","List","intersect","`","underThreat",")","where","qs'","=","zip","[","1","..","length","qs","]","qs","underThreat","=","qs'",">>=","diags"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L35-L40","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"g","parameters":"(f, vf1) (x, vx1)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g (f, vf1) (x, vx1) = (f x, vf1 <*> vx1)","function_tokens":["g","(","f",",","vf1",")","(","x",",","vx1",")","=","(","f","x",",","vf1","<*>","vx1",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L128-L128","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"squashMatch","parameters":"lmatch","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"squashMatch lmatch = case GHC.m_grhss match of\n    GHC.GRHSs _ [lgrhs] _\n        | GHC.GRHS ext [] body <- GHC.unLoc lgrhs\n        , Just left <- mbLeft\n        , Just sep <- matchSeparator ext\n        , Just right <- GHC.srcSpanToRealSrcSpan $ GHC.getLocA body ->\n            squash left sep <> squash sep right\n    _ -> mempty\n  where\n    match = GHC.unLoc lmatch\n    mbLeft = case match of\n        GHC.Match _ (GHC.FunRhs name _ _) [] _ ->\n            GHC.srcSpanToRealSrcSpan $ GHC.getLocA name\n        GHC.Match _ _ pats@(_ : _) _ ->\n            GHC.srcSpanToRealSrcSpan . GHC.getLocA $ last pats\n        _ -> Nothing\n\n\n--------------------------------------------------------------------------------","function_tokens":["squashMatch","lmatch","=","case","GHC","m_grhss","match","of","GHC","GRHSs","_","[","lgrhs","]","_","|","GHC","GRHS","ext","[","]","body","<-","GHC","unLoc","lgrhs",",","Just","left","<-","mbLeft",",","Just","sep","<-","matchSeparator","ext",",","Just","right","<-","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","body","->","squash","left","sep","<>","squash","sep","right","_","->","mempty","where","match","=","GHC","unLoc","lmatch","mbLeft","=","case","match","of","GHC","Match","_","(","GHC","FunRhs","name","_","_",")","[","]","_","->","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","name","GHC","Match","_","_","pats","@","(","_",":","_",")","_","->","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA","$","last","pats","_","->","Nothing","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L58-L77","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = Off","function_tokens":["mempty","=","Off"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L55-L55","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"release","parameters":"(path, h)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"release (path, h) = do\n      hClose h\n      -- Despite using `bracketOnError` the file is not guaranteed to exist\n      -- here since we could be interrupted with an async exception after\n      -- the file has been renamed. Therefore, we silentely ignore\n      -- `DoesNotExistError`.\n      catchJust (guard . isDoesNotExistError) (removeFile path) (const $ pure ())\n\n-- | Determine what comment in new archive will look like given its original\n-- value and a collection of pending actions.","function_tokens":["release","(","path",",","h",")","=","do","hClose","h","-- Despite using `bracketOnError` the file is not guaranteed to exist","-- here since we could be interrupted with an async exception after","-- the file has been renamed. Therefore, we silentely ignore","-- `DoesNotExistError`.","catchJust","(","guard",".","isDoesNotExistError",")","(","removeFile","path",")","(","const","$","pure","(",")",")","-- | Determine what comment in new archive will look like given its original","-- value and a collection of pending actions."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L311-L321","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(RenameEntry s _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (RenameEntry s _) = Just s","function_tokens":["targetEntry","(","RenameEntry","s","_",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1055-L1055","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"mapM","parameters":"f (Choosing m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM f (Choosing m) = fmap Choosing (mapM f m)","function_tokens":["mapM","f","(","Choosing","m",")","=","fmap","Choosing","(","mapM","f","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L155-L155","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"cdir","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cdir = path <\/> adir","function_tokens":["cdir","=","path","<\/>","adir"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L693-L693","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"bold","parameters":"(Stylized m t)","argument_list":"","return_statement":"","docstring":"Produce bold text.  @since 1.0.0.0","docstring_summary":"Produce bold text.","docstring_tokens":["Produce","bold","text","."],"function":"bold (Stylized m t) = Stylized (m {modBold = On}) t","function_tokens":["bold","(","Stylized","m","t",")","=","Stylized","(","m","{","modBold","=","On","}",")","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L110-L110","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Get     -> State.Strict.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Strict.put s\n    R other   -> State.Strict.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Strict.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Get","->","State","Strict","gets","(","<$","ctx",")","L","(","Put","s",")","->","ctx","<$","State","Strict","put","s","R","other","->","State","Strict","StateT","$","\\","s","->","getSwap","<$>","thread","(","fmap","Swap",".","uncurry","State","Strict","runStateT",".","getSwap","~<~","hdl",")","other","(","Swap","(","ctx",",","s",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L303-L307","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"tween_","parameters":"f a b c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tween_ f a b c = Control.Monad.void (tween f a b c)","function_tokens":["tween_","f","a","b","c","=","Control","Monad","void","(","tween","f","a","b","c",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L321-L321","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"endings","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"endings = fmap lineEndings cBodies","function_tokens":["endings","=","fmap","lineEndings","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L126-L126","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"show","parameters":"MQL","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show MQL     = \"mql\"","function_tokens":["show","MQL","=","\"mql\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L24-L24","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_NO_ERROR","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_NO_ERROR                        = 0x0000","function_tokens":["alc_NO_ERROR","=","0x0000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L140-L140","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"unsafeIndex","parameters":"(CSR _ _ vec ci rp) (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeIndex (CSR _ _ vec ci rp) (i,j) =\n        case binarySearchByBounds ci j r0 r1 of\n            Nothing -> zero\n            Just k -> vec `G.unsafeIndex` k\n      where\n        r0 = rp `U.unsafeIndex` i\n        r1 = rp `U.unsafeIndex` (i+1) - 1","function_tokens":["unsafeIndex","(","CSR","_","_","vec","ci","rp",")","(","i",",","j",")","=","case","binarySearchByBounds","ci","j","r0","r1","of","Nothing","->","zero","Just","k","->","vec","`","G","unsafeIndex","`","k","where","r0","=","rp","`","U","unsafeIndex","`","i","r1","=","rp","`","U","unsafeIndex","`","(","i","+","1",")","-","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L81-L88","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"setEqs","parameters":"(Field a b c d)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setEqs (Field a b c d) = Field a b c (first upd . second (eqs ++) $ d)","function_tokens":["setEqs","(","Field","a","b","c","d",")","=","Field","a","b","c","(","first","upd",".","second","(","eqs","++",")","$","d",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L355-L355","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Remark","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Remark                   = \"\"","function_tokens":["go","Remark","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L422-L422","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty = go\n        where\n            go (Chord a) = pretty a\n            go (Sequence as) = sepBy \" \" $ fmap pretty as\n    -- FIXME","function_tokens":["pretty","=","go","where","go","(","Chord","a",")","=","pretty","a","go","(","Sequence","as",")","=","sepBy","\" \"","$","fmap","pretty","as","-- FIXME"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L184-L191","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"as","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"as = fromMaybe [] $ traverse grhsToAlignable grhss","function_tokens":["as","=","fromMaybe","[","]","$","traverse","grhsToAlignable","grhss"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L159-L159","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"add","parameters":"as","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"add as  = foldr (.+.) (cnst 0) as","function_tokens":["add","as","=","foldr","(",".+.",")","(","cnst","0",")","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L200-L200","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"modeToStackArg","parameters":"(AppImageExe (ExeFile exeFp))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modeToStackArg (AppImageExe (ExeFile exeFp)) = ':' : exeFp","function_tokens":["modeToStackArg","(","AppImageExe","(","ExeFile","exeFp",")",")","=","':'",":","exeFp"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L39-L39","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_BUFFERS_QUEUED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_BUFFERS_QUEUED                   = 0x1015","function_tokens":["al_BUFFERS_QUEUED","=","0x1015"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L81-L81","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"elementSort","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"elementSort = fmap getAA . toStaticallySorted","function_tokens":["elementSort","=","fmap","getAA",".","toStaticallySorted"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L131-L131","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Lens pointing to the third component of a 3-tuple. (Total and polymorphic)","docstring_summary":"Lens pointing to the third component of a 3-tuple. (Total and polymorphic)","docstring_tokens":["Lens","pointing","to","the","third","component","of","a","3","-","tuple",".","(","Total","and","polymorphic",")"],"function":"(fst3, snd3, trd3) = $(getLabel ''(,,))","function_tokens":["(","fst3",",","snd3",",","trd3",")","=","(","getLabel","''","(",",",",",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L108-L108","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"exportGroups","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exportGroups = case GHC.hsmodExports modul of\n            Nothing -> Nothing\n            Just lexports -> Just $ doSort $ commentGroups\n                (GHC.srcSpanToRealSrcSpan . GHC.getLocA)\n                (GHC.unLoc lexports)\n                (epAnnComments . GHC.ann $ GHC.getLoc lexports)","function_tokens":["exportGroups","=","case","GHC","hsmodExports","modul","of","Nothing","->","Nothing","Just","lexports","->","Just","$","doSort","$","commentGroups","(","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")","(","GHC","unLoc","lexports",")","(","epAnnComments",".","GHC","ann","$","GHC","getLoc","lexports",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L101-L108","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"writeCD","parameters":"h comment m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"writeCD h comment m = do\n  let cd = runPut (putCD m)\n  cdOffset <- fromIntegral <$> hTell h\n  B.hPut h cd -- write central directory\n  let totalCount = fromIntegral (M.size m)\n      cdSize = fromIntegral (B.length cd)\n      needZip64 =\n        totalCount >= ffff\n          || cdSize >= ffffffff\n          || cdOffset >= ffffffff\n  when needZip64 $ do\n    zip64ecdOffset <- fromIntegral <$> hTell h\n    (B.hPut h . runPut) (putZip64ECD totalCount cdSize cdOffset)\n    (B.hPut h . runPut) (putZip64ECDLocator zip64ecdOffset)\n  (B.hPut h . runPut) (putECD totalCount cdSize cdOffset comment)\n\n----------------------------------------------------------------------------\n-- Binary serialization\n\n-- | Extract the number of bytes between the start of file name in local\n-- header and the start of actual data.","function_tokens":["writeCD","h","comment","m","=","do","let","cd","=","runPut","(","putCD","m",")","cdOffset","<-","fromIntegral","<$>","hTell","h","B","hPut","h","cd","-- write central directory","let","totalCount","=","fromIntegral","(","M","size","m",")","cdSize","=","fromIntegral","(","B","length","cd",")","needZip64","=","totalCount",">=","ffff","||","cdSize",">=","ffffffff","||","cdOffset",">=","ffffffff","when","needZip64","$","do","zip64ecdOffset","<-","fromIntegral","<$>","hTell","h","(","B","hPut","h",".","runPut",")","(","putZip64ECD","totalCount","cdSize","cdOffset",")","(","B","hPut","h",".","runPut",")","(","putZip64ECDLocator","zip64ecdOffset",")","(","B","hPut","h",".","runPut",")","(","putECD","totalCount","cdSize","cdOffset","comment",")","----------------------------------------------------------------------------","-- Binary serialization","-- | Extract the number of bytes between the start of file name in local","-- header and the start of actual data."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L631-L652","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"and''","parameters":"as","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"and'' as = case mapM toStaticallySorted as of\n            Just as' -> return . toDynamicallySorted . and $ as'\n            Nothing  -> fail \"and of non-boolean arguments\"","function_tokens":["and''","as","=","case","mapM","toStaticallySorted","as","of","Just","as'","->","return",".","toDynamicallySorted",".","and","$","as'","Nothing","->","fail","\"and of non-boolean arguments\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L404-L408","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"continue","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"continue = waitForReply end checkSignal","function_tokens":["continue","=","waitForReply","end","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L176-L176","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"x","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x = unsafeIndex mat (i,j)","function_tokens":["x","=","unsafeIndex","mat","(","i",",","j",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L92-L92","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"mfix","parameters":"ma","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix ma = AccumC $ \\ k w -> mfix ((\\accumC -> runAccumC accumC (curry pure) w) . ma . snd) >>= uncurry k","function_tokens":["mfix","ma","=","AccumC","$","\\","k","w","->","mfix","(","(","\\","accumC","->","runAccumC","accumC","(","curry","pure",")","w",")",".","ma",".","snd",")",">>=","uncurry","k"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L120-L120","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zip","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip = MG.zip","function_tokens":["zip","=","MG","zip"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L310-L310","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a .*. b = merge . (\\(c, r) -> if c == 1 then r else cnst c : r) . foldr mergeConstMul (1, []) $ flatten a ++ flatten b where\n    merge []  = cnst 1\n    merge [e] = e\n    merge es  = inject $ Mul es\n\n    flatten e = case match e of\n        Just (Const 1) -> []\n        Just (Mul ms)  -> ms\n        _              -> [e]\n\n-- | A smart constructor for a variadic addition","function_tokens":["a",".*.","b","=","merge",".","(","\\","(","c",",","r",")","->","if","c","==","1","then","r","else","cnst","c",":","r",")",".","foldr","mergeConstMul","(","1",",","[","]",")","$","flatten","a","++","flatten","b","where","merge","[","]","=","cnst","1","merge","[","e","]","=","e","merge","es","=","inject","$","Mul","es","flatten","e","=","case","match","e","of","Just","(","Const","1",")","->","[","]","Just","(","Mul","ms",")","->","ms","_","->","[","e","]","-- | A smart constructor for a variadic addition"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L186-L197","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"g","parameters":"(b, vb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g (b, vb) = (f b, f <$> vb)","function_tokens":["g","(","b",",","vb",")","=","(","f","b",",","f","<$>","vb",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L92-L92","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"sequence","parameters":"(Choosing m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sequence (Choosing m) = fmap Choosing (sequence m)","function_tokens":["sequence","(","Choosing","m",")","=","fmap","Choosing","(","sequence","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L152-L152","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseSimpleAlign","parameters":"c o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseSimpleAlign c o = SimpleAlign.step\n    <$> pure (configColumns c)\n    <*> (SimpleAlign.Config\n        <$> parseAlign \"cases\"              SimpleAlign.cCases\n        <*> parseAlign \"top_level_patterns\" SimpleAlign.cTopLevelPatterns\n        <*> parseAlign \"records\"            SimpleAlign.cRecords\n        <*> parseAlign \"multi_way_if\"       SimpleAlign.cMultiWayIf)\n  where\n    parseAlign key f =\n        (o A..:? key >>= parseEnum aligns (f SimpleAlign.defaultConfig)) <|>\n        (boolToAlign <$> o A..: key)\n    aligns =\n        [ (\"always\",   SimpleAlign.Always)\n        , (\"adjacent\", SimpleAlign.Adjacent)\n        , (\"never\",    SimpleAlign.Never)\n        ]\n    boolToAlign True  = SimpleAlign.Always\n    boolToAlign False = SimpleAlign.Never\n\n\n--------------------------------------------------------------------------------","function_tokens":["parseSimpleAlign","c","o","=","SimpleAlign","step","<$>","pure","(","configColumns","c",")","<*>","(","SimpleAlign","Config","<$>","parseAlign","\"cases\"","SimpleAlign","cCases","<*>","parseAlign","\"top_level_patterns\"","SimpleAlign","cTopLevelPatterns","<*>","parseAlign","\"records\"","SimpleAlign","cRecords","<*>","parseAlign","\"multi_way_if\"","SimpleAlign","cMultiWayIf",")","where","parseAlign","key","f","=","(","o","A",".:?","key",">>=","parseEnum","aligns","(","f","SimpleAlign","defaultConfig",")",")","<|>","(","boolToAlign","<$>","o","A",".:","key",")","aligns","=","[","(","\"always\"",",","SimpleAlign","Always",")",",","(","\"adjacent\"",",","SimpleAlign","Adjacent",")",",","(","\"never\"",",","SimpleAlign","Never",")","]","boolToAlign","True","=","SimpleAlign","Always","boolToAlign","False","=","SimpleAlign","Never","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L224-L245","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"fullySuccessful","parameters":"(Result _ reduced failed)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fullySuccessful (Result _ reduced failed) = reduced == 0 && failed == 0","function_tokens":["fullySuccessful","(","Result","_","reduced","failed",")","=","reduced","==","0","&&","failed","==","0"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L62-L62","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"describe","parameters":"(UTip j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe (UTip j) = DTip j","function_tokens":["describe","(","UTip","j",")","=","DTip","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L205-L205","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"accesses","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"accesses = execWriter . imapM accesses' where\n  accesses' :: forall (s' :: Sort). IFix f s' -> Writer [DynamicArrayAccess f] (IFix f s')\n  accesses' e = do\n    case match e of\n      Just (Select is es a i)   -> tell [ DynamicallySorted is\n                                        $ DynamicValueArrayAccess\n                                        $ DynamicallySorted es\n                                        $ ArrayAccess\n                                        $ (a, i) ]\n      Just (Store  is es a i _) -> tell [ DynamicallySorted is\n                                        $ DynamicValueArrayAccess\n                                        $ DynamicallySorted es\n                                        $ ArrayAccess\n                                        $ (a, i) ]\n      _                         -> return ()\n    return e","function_tokens":["accesses","=","execWriter",".","imapM","accesses'","where","accesses'","::","forall","(","s'","::","Sort",")",".","IFix","f","s'","->","Writer","[","DynamicArrayAccess","f","]","(","IFix","f","s'",")","accesses'","e","=","do","case","match","e","of","Just","(","Select","is","es","a","i",")","->","tell","[","DynamicallySorted","is","$","DynamicValueArrayAccess","$","DynamicallySorted","es","$","ArrayAccess","$","(","a",",","i",")","]","Just","(","Store","is","es","a","i","_",")","->","tell","[","DynamicallySorted","is","$","DynamicValueArrayAccess","$","DynamicallySorted","es","$","ArrayAccess","$","(","a",",","i",")","]","_","->","return","(",")","return","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L138-L153","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"tr","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix transpose","docstring_summary":"O(m*n) Matrix transpose","docstring_tokens":["O","(","m","*","n",")","Matrix","transpose"],"function":"tr = MG.tr","function_tokens":["tr","=","MG","tr"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L186-L186","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"string","parameters":"","argument_list":"","return_statement":"","docstring":"Matches a given string.","docstring_summary":"Matches a given string.","docstring_tokens":["Matches","a","given","string","."],"function":"string = lift . lift . A.string","function_tokens":["string","=","lift",".","lift",".","A","string"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L117-L117","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_DEFAULT_DEVICE_SPECIFIER","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_DEFAULT_DEVICE_SPECIFIER        = 0x1004","function_tokens":["alc_DEFAULT_DEVICE_SPECIFIER","=","0x1004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L150-L150","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"retrieve","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"retrieve f = atomically . readTVar . f . state $ inst","function_tokens":["retrieve","f","=","atomically",".","readTVar",".","f",".","state","$","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L180-L180","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Quad s p o l == Quad s' p' o' l' = s == s' && p == p' && o == o' && l == l'","function_tokens":["Quad","s","p","o","l","==","Quad","s'","p'","o'","l'","=","s","==","s'","&&","p","==","p'","&&","o","==","o'","&&","l","==","l'"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L73-L73","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_MAX_DISTANCE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_MAX_DISTANCE                     = 0x1023","function_tokens":["al_MAX_DISTANCE","=","0x1023"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L87-L87","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWith5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith5 = MG.zipWith5","function_tokens":["zipWith5","=","MG","zipWith5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L273-L273","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Parts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Parts                    = \"\"","function_tokens":["go","Parts","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L419-L419","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,_) = dim mat","function_tokens":["(","r",",","_",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L174-L174","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Chord_ ([], dur))","argument_list":"","return_statement":"","docstring":"TODO skip duration if zero","docstring_summary":"TODO skip duration if zero","docstring_tokens":["TODO","skip","duration","if","zero"],"function":"pretty (Chord_ ([], dur))       = \"\"","function_tokens":["pretty","(","Chord_","(","[","]",",","dur",")",")","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L213-L213","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseNode","parameters":"(A.Object v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseNode (A.Object v) = Node <$>\n                       v A..: \"id\"<*>\n                       v A..:? \"tags\" <*>\n                       v A..:? \"values\" <*>\n                       v A..: \"is_link_node\" <*>\n                       v A..: \"is_fixed\"","function_tokens":["parseNode","(","A","Object","v",")","=","Node","<$>","v","A",".:","\"id\"","<*>","v","A",".:?","\"tags\"","<*>","v","A",".:?","\"values\"","<*>","v","A",".:","\"is_link_node\"","<*>","v","A",".:","\"is_fixed\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L107-L112","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!r =\n                ( BSI.fromForeignPtr resIbFptr 0 idxByteLen\n                , BSI.fromForeignPtr resBpFptr 0 (fromIntegral bpByteLen * 8)\n                )","function_tokens":["r","=","(","BSI","fromForeignPtr","resIbFptr","0","idxByteLen",",","BSI","fromForeignPtr","resBpFptr","0","(","fromIntegral","bpByteLen","*","8",")",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L104-L107","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"x","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x = Proxy :: Proxy x","function_tokens":["x","=","Proxy","::","Proxy","x"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L399-L399","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"0","argument_list":"","return_statement":"","docstring":"Parses the rest of a command corresponding to an id","docstring_summary":"Parses the rest of a command corresponding to an id","docstring_tokens":["Parses","the","rest","of","a","command","corresponding","to","an","id"],"function":"parseCommand 0 = return PING","function_tokens":["parseCommand","0","=","return","PING"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L124-L124","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"runUnderLabel","parameters":"(UnderLabel l)","argument_list":"","return_statement":"","docstring":"@since 1.0.2.0","docstring_summary":"","docstring_tokens":[],"function":"runUnderLabel (UnderLabel l) = l","function_tokens":["runUnderLabel","(","UnderLabel","l",")","=","l"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L141-L141","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"rChan","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rChan = timeoutChan rq","function_tokens":["rChan","=","timeoutChan","rq"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L111-L111","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getArchiveDescription","parameters":"","argument_list":"","return_statement":"","docstring":"Get the archive description record.","docstring_summary":"Get the archive description record.","docstring_tokens":["Get","the","archive","description","record","."],"function":"getArchiveDescription = ZipArchive (gets zsArchive)","function_tokens":["getArchiveDescription","=","ZipArchive","(","gets","zsArchive",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L420-L420","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"untabify","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"untabify = Conflict.setStrings . untabifyStr","function_tokens":["untabify","=","Conflict","setStrings",".","untabifyStr"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L93-L93","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"deleteObjectNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteObjectNames = liftIO . withArraySizei alDeleteSources","function_tokens":["deleteObjectNames","=","liftIO",".","withArraySizei","alDeleteSources"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L123-L123","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"printBenchmark","parameters":"cfg b","argument_list":"","return_statement":"","docstring":"* Internal functions.","docstring_summary":"* Internal functions.","docstring_tokens":["*","Internal","functions","."],"function":"printBenchmark cfg b = do\n  w <- maybe 60 width <$> size\n  B.hPutBuilder stdout . mv $ renderBenchmark cfg w (maxDuration b) (benchmark b)\n  where mv x | sortByMean cfg || printOnce cfg = x\n             | otherwise = linesUp (printHeight cfg*position b) <> x <> linesDown (printHeight cfg*(position b-1))","function_tokens":["printBenchmark","cfg","b","=","do","w","<-","maybe","60","width","<$>","size","B","hPutBuilder","stdout",".","mv","$","renderBenchmark","cfg","w","(","maxDuration","b",")","(","benchmark","b",")","where","mv","x","|","sortByMean","cfg","||","printOnce","cfg","=","x","|","otherwise","=","linesUp","(","printHeight","cfg","*","position","b",")","<>","x","<>","linesDown","(","printHeight","cfg","*","(","position","b","-","1",")",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L208-L214","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"stretchTList","parameters":"k x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stretchTList k x = case x of\n        TFun t a   -> TFun (stretchTfm k t) a\n        Empty      -> Empty\n        a          -> TFun (Tfm k 0) a","function_tokens":["stretchTList","k","x","=","case","x","of","TFun","t","a","->","TFun","(","stretchTfm","k","t",")","a","Empty","->","Empty","a","->","TFun","(","Tfm","k","0",")","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L322-L327","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"completionFromList","parameters":"loc ts (left, right)","argument_list":"","return_statement":"","docstring":"Generate a completion function that uses the given list as the completion candidates.  @since 1.1.0.0","docstring_summary":"Generate a completion function that uses the given list as the completion candidates.","docstring_tokens":["Generate","a","completion","function","that","uses","the","given","list","as","the","completion","candidates","."],"function":"completionFromList loc ts (left, right) =\n  case loc of\n    CompHead ->\n      if Text.null left || Text.all (isSpace >>> not) left\n        then go (left, right)\n        else pure (mempty, mempty)\n    CompTail ->\n      if Text.any isSpace left\n        then completeLastWord (left, right)\n        else pure (mempty, mempty)\n    CompAny ->\n      completeLastWord (left, right)\n  where\n    go :: CompletionFunc m\n    go (left, _) =\n      if Text.null left\n        then pure (\"\", completions ts)\n        else pure (\"\", completions (filter (Text.isPrefixOf left) ts))\n    completeLastWord :: CompletionFunc m\n    completeLastWord (left, right) =\n      let word = Text.takeWhileEnd (isSpace >>> not) left\n          prefix = Text.dropEnd (Text.length word) left\n       in go (word, right) <&> first (const prefix)\n    completions :: [Text] -> [Completion]\n    completions = map (\\t -> Completion t t True)\n\n-- $use\n--\n-- Haskeline makes it very difficult (if not impossible) to implement\n-- a completion function that runs in an arbitrary monad.  More\n-- information can be found in the documentation for 'CompletionFunc'.","function_tokens":["completionFromList","loc","ts","(","left",",","right",")","=","case","loc","of","CompHead","->","if","Text","null","left","||","Text","all","(","isSpace",">>>","not",")","left","then","go","(","left",",","right",")","else","pure","(","mempty",",","mempty",")","CompTail","->","if","Text","any","isSpace","left","then","completeLastWord","(","left",",","right",")","else","pure","(","mempty",",","mempty",")","CompAny","->","completeLastWord","(","left",",","right",")","where","go","::","CompletionFunc","m","go","(","left",",","_",")","=","if","Text","null","left","then","pure","(","\"\"",",","completions","ts",")","else","pure","(","\"\"",",","completions","(","filter","(","Text","isPrefixOf","left",")","ts",")",")","completeLastWord","::","CompletionFunc","m","completeLastWord","(","left",",","right",")","=","let","word","=","Text","takeWhileEnd","(","isSpace",">>>","not",")","left","prefix","=","Text","dropEnd","(","Text","length","word",")","left","in","go","(","word",",","right",")","<&>","first","(","const","prefix",")","completions","::","[","Text","]","->","[","Completion","]","completions","=","map","(","\\","t","->","Completion","t","t","True",")","-- $use","--","-- Haskeline makes it very difficult (if not impossible) to implement","-- a completion function that runs in an arbitrary monad.  More","-- information can be found in the documentation for 'CompletionFunc'."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L75-L105","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"marshalSourceRelative","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalSourceRelative = (== Listener)","function_tokens":["marshalSourceRelative","=","(","==","Listener",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L195-L195","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bottom = false","function_tokens":["bottom","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L214-L214","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"exists","parameters":"vs f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exists vs f = case match f of\n    Just (Exists vs' f') -> exists (vs ++ vs') f'\n    Nothing -> inject $ Exists vs f","function_tokens":["exists","vs","f","=","case","match","f","of","Just","(","Exists","vs'","f'",")","->","exists","(","vs","++","vs'",")","f'","Nothing","->","inject","$","Exists","vs","f"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L660-L664","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m *> k = m >>= const k","function_tokens":["m","*>","k","=","m",">>=","const","k"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L88-L88","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"pick","parameters":"(Program (MapMaker outfile False projection) infile)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pick (Program (MapMaker outfile False projection) infile) = let p = pickProjection projection in\n    mkMapSVG outfile =<< districtToMapP p <$> getDistricts infile","function_tokens":["pick","(","Program","(","MapMaker","outfile","False","projection",")","infile",")","=","let","p","=","pickProjection","projection","in","mkMapSVG","outfile","=<<","districtToMapP","p","<$>","getDistricts","infile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L20-L21","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmp","parameters":"Nil _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subsetCmp Nil _   = LT","function_tokens":["subsetCmp","Nil","_","=","LT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L477-L477","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SOURCE_TYPE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SOURCE_TYPE                      = 0x1027","function_tokens":["al_SOURCE_TYPE","=","0x1027"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L78-L78","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"doShape","parameters":"m CayleyConfig{..} q","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doShape m CayleyConfig{..} q = do\n      r <- apiRequest\n             m (urlBase serverName apiVersion ++ \"\/shape\/\" ++ show queryLang)\n             serverPort (RequestBodyBS $ encodeUtf8 q)\n      return $\n        case r of\n          Just o  ->\n            case A.fromJSON o of\n              A.Success s -> Right s\n              A.Error e   -> Left (\"Not a shape (\\\"\" ++ e ++ \"\\\")\")\n          Nothing -> Left \"API request error\"\n\n-- | Write a 'Quad' with the given subject, predicate, object and optional\n-- label. Throw result or extract amount of query 'results'\n-- from it.\n--\n-- >\u03bb> writeQuad conn \"Humphrey\" \"loves\" \"Lauren\" (Just \"In love\")\n-- >Just (Object (fromList [(\"result\",String \"Successfully wrote 1 quads.\")]))\n--","function_tokens":["doShape","m","CayleyConfig","{","..","}","q","=","do","r","<-","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/shape\/\"","++","show","queryLang",")","serverPort","(","RequestBodyBS","$","encodeUtf8","q",")","return","$","case","r","of","Just","o","->","case","A","fromJSON","o","of","A","Success","s","->","Right","s","A","Error","e","->","Left","(","\"Not a shape (\\\"\"","++","e","++","\"\\\")\"",")","Nothing","->","Left","\"API request error\"","-- | Write a 'Quad' with the given subject, predicate, object and optional","-- label. Throw result or extract amount of query 'results'","-- from it.","--","-- >\u03bb> writeQuad conn \"Humphrey\" \"loves\" \"Lauren\" (Just \"In love\")","-- >Just (Object (fromList [(\"result\",String \"Successfully wrote 1 quads.\")]))","--"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L90-L109","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/hsinstall.hs","language":"haskell","identifier":"deployApplication","parameters":"buildTool mode di","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deployApplication buildTool mode di = do\n  -- Copy the binaries\n  let binFp = op BinDir . binDir $ di\n  Dir.createDirectoryIfMissing True binFp\n  installBinaries buildTool mode binFp\n\n  -- Copy the license\n  let licenseFile = \"LICENSE\"\n  licenseFileExists <- Dir.doesFileExist licenseFile\n  when licenseFileExists $ do\n    printf \"\\nCopying %s\\n\" licenseFile\n    let docFp = op DocDir . docDir $ di\n    Dir.createDirectoryIfMissing True docFp\n    Dir.copyFile licenseFile (docFp <\/> licenseFile)\n\n  -- Copy the static template directory\n  let tmplFp = op TmplDir tmplDir\n  tmplExists <- Dir.doesDirectoryExist tmplFp\n  when tmplExists $ do\n    printf \"\\nCopying distribution files from template dir (%s)\\n\" tmplFp\n    copyTree False tmplFp (op PrefixDir . prefixDir $ di)","function_tokens":["deployApplication","buildTool","mode","di","=","do","-- Copy the binaries","let","binFp","=","op","BinDir",".","binDir","$","di","Dir","createDirectoryIfMissing","True","binFp","installBinaries","buildTool","mode","binFp","-- Copy the license","let","licenseFile","=","\"LICENSE\"","licenseFileExists","<-","Dir","doesFileExist","licenseFile","when","licenseFileExists","$","do","printf","\"\\nCopying %s\\n\"","licenseFile","let","docFp","=","op","DocDir",".","docDir","$","di","Dir","createDirectoryIfMissing","True","docFp","Dir","copyFile","licenseFile","(","docFp","<\/>","licenseFile",")","-- Copy the static template directory","let","tmplFp","=","op","TmplDir","tmplDir","tmplExists","<-","Dir","doesDirectoryExist","tmplFp","when","tmplExists","$","do","printf","\"\\nCopying distribution files from template dir (%s)\\n\"","tmplFp","copyTree","False","tmplFp","(","op","PrefixDir",".","prefixDir","$","di",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/hsinstall.hs#L54-L74","hash_key":"dino-\/hsinstall:src\/app\/hsinstall.hs","hash_val":1203,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia.hs","language":"haskell","identifier":"close","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"close = closeK . handle","function_tokens":["close","=","closeK",".","handle"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia.hs#L152-L152","hash_key":"froozen\/kademlia:src\/Network\/Kademlia.hs","hash_val":2353,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"src","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"src = CB.sourceFile apath","function_tokens":["src","=","CB","sourceFile","apath"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L459-L459","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/NonDet.hs","language":"haskell","identifier":"foldMapA","parameters":"f","argument_list":"","return_statement":"","docstring":"Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.  @since 1.0.0.0","docstring_summary":"Map a 'Foldable' collection of values into a nondeterministic computation using the supplied action.","docstring_tokens":["Map","a","Foldable","collection","of","values","into","a","nondeterministic","computation","using","the","supplied","action","."],"function":"foldMapA f = getAlt #. foldMap (Alt #. f)","function_tokens":["foldMapA","f","=","getAlt","#.","foldMap","(","Alt","#.","f",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/NonDet.hs#L61-L61","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/NonDet.hs","hash_val":29874,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = Nil","function_tokens":["empty","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L298-L298","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"con","parameters":"(RecC n vst)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"con (RecC n vst) = NormalC n (map (\\(_, s, t) -> (s, t)) vst)","function_tokens":["con","(","RecC","n","vst",")","=","NormalC","n","(","map","(","\\","(","_",",","s",",","t",")","->","(","s",",","t",")",")","vst",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L228-L228","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"withRSST","parameters":"f m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withRSST f m = RSST $ \\r (s,w) ->\n    let (r',s') = f r s\n    in  runRSST' m r' (s',w)","function_tokens":["withRSST","f","m","=","RSST","$","\\","r","(","s",",","w",")","->","let","(","r'",",","s'",")","=","f","r","s","in","runRSST'","m","r'","(","s'",",","w",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L118-L120","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getCharVal","parameters":"","argument_list":"","return_statement":"","docstring":"Char (presumably 8-bit)","docstring_summary":"Char (presumably 8-bit)","docstring_tokens":["Char","(","presumably","8","-","bit",")"],"function":"getCharVal = C.head <$> getByteString 1","function_tokens":["getCharVal","=","C","head","<$>","getByteString","1"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L40-L40","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"nonOverlapping","parameters":"ss","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nonOverlapping ss = length ss == length (nub $ map GHC.srcSpanStartLine ss)","function_tokens":["nonOverlapping","ss","=","length","ss","==","length","(","nub","$","map","GHC","srcSpanStartLine","ss",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L98-L98","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"null","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"null _   = False","function_tokens":["null","_","=","False"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L250-L250","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"matches","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matches =\n      if Text.null left\n        then toList (_menuItems config)\n        else matchOnPrefix config left","function_tokens":["matches","=","if","Text","null","left","then","toList","(","_menuItems","config",")","else","matchOnPrefix","config","left"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L141-L144","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"fmap","parameters":"f e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f e = e{ eventContent = f (eventContent e) }","function_tokens":["fmap","f","e","=","e","{","eventContent","=","f","(","eventContent","e",")","}"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L211-L211","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(cases, patterns) = partitionEithers . fromMaybe [] $ traverse matchToAlignable (GHC.unLoc alts)","function_tokens":["(","cases",",","patterns",")","=","partitionEithers",".","fromMaybe","[","]","$","traverse","matchToAlignable","(","GHC","unLoc","alts",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L108-L108","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"action","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"action = unZipArchive (m <* commit)","function_tokens":["action","=","unZipArchive","(","m","<*","commit",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L252-L252","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"doDump","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doDump =\n            dumpAndOpenEditor colorEnable opts fileName\n            [ conflict | Right conflict <- Conflict.parse newContent ]","function_tokens":["doDump","=","dumpAndOpenEditor","colorEnable","opts","fileName","[","conflict","|","Right","conflict","<-","Conflict","parse","newContent","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L109-L111","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"res","parameters":"(InL _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"res (InL _) = Nothing","function_tokens":["res","(","InL","_",")","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L61-L61","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"marshalStringQuery","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalStringQuery x = case x of\n   DefaultDeviceSpecifier -> alc_DEFAULT_DEVICE_SPECIFIER\n   DeviceSpecifier -> alc_DEVICE_SPECIFIER\n   Extensions -> alc_EXTENSIONS\n   CaptureDefaultDeviceSpecifier -> alc_CAPTURE_DEFAULT_DEVICE_SPECIFIER\n   CaptureDeviceSpecifier -> alc_CAPTURE_DEVICE_SPECIFIER\n   ALCErrorCategory e -> e\n\n--------------------------------------------------------------------------------","function_tokens":["marshalStringQuery","x","=","case","x","of","DefaultDeviceSpecifier","->","alc_DEFAULT_DEVICE_SPECIFIER","DeviceSpecifier","->","alc_DEVICE_SPECIFIER","Extensions","->","alc_EXTENSIONS","CaptureDefaultDeviceSpecifier","->","alc_CAPTURE_DEFAULT_DEVICE_SPECIFIER","CaptureDeviceSpecifier","->","alc_CAPTURE_DEVICE_SPECIFIER","ALCErrorCategory","e","->","e","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L48-L58","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"relativeCompactness","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"relativeCompactness = (*scale) . compactness1\n    where scale = (1\/4*pi)\n\n-- | Take the area of the polygon and divide by the perimeter squared. This is a dimensionless measurement.","function_tokens":["relativeCompactness","=","(","*","scale",")",".","compactness1","where","scale","=","(","1","\/","4","*","pi",")","-- | Take the area of the polygon and divide by the perimeter squared. This is a dimensionless measurement."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L37-L41","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"loop","parameters":"!prev !n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop !prev !n\n            | n > r1 = replicate (c-prev-1) zero\n            | otherwise = replicate (cur-prev-1) zero ++ (x : loop cur (n+1))\n          where\n            cur = ci `U.unsafeIndex` n\n            x = vec `G.unsafeIndex` n","function_tokens":["loop","prev","n","|","n",">","r1","=","replicate","(","c","-","prev","-","1",")","zero","|","otherwise","=","replicate","(","cur","-","prev","-","1",")","zero","++","(","x",":","loop","cur","(","n","+","1",")",")","where","cur","=","ci","`","U","unsafeIndex","`","n","x","=","vec","`","G","unsafeIndex","`","n"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L108-L114","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Strict.hs","language":"haskell","identifier":"runWriter","parameters":"(WriterC m)","argument_list":"","return_statement":"","docstring":"Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.  @ 'runWriter' ('tell' w) = 'pure' (w, ()) @ @ 'runWriter' ('pure' a) = 'pure' ('mempty', a) @","docstring_summary":"Run a 'Writer' effect with a 'Monoid'al log, producing the final log alongside the result value.","docstring_tokens":["Run","a","Writer","effect","with","a","Monoid","al","log","producing","the","final","log","alongside","the","result","value","."],"function":"runWriter (WriterC m) = runState mempty m","function_tokens":["runWriter","(","WriterC","m",")","=","runState","mempty","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Strict.hs#L44-L44","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Strict.hs","hash_val":32183,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intersection1 | nomatch p2 p1 m1  = Nil\n                  | zero p2 m1        = intersection l1 t2\n                  | otherwise         = intersection r1 t2","function_tokens":["intersection1","|","nomatch","p2","p1","m1","=","Nil","|","zero","p2","m1","=","intersection","l1","t2","|","otherwise","=","intersection","r1","t2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L422-L424","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Throw\/Either.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Throw e) -> ThrowC (throwError e)\n    R other     -> ThrowC (alg (runThrowC . hdl) (R other) ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Throw","e",")","->","ThrowC","(","throwError","e",")","R","other","->","ThrowC","(","alg","(","runThrowC",".","hdl",")","(","R","other",")","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Throw\/Either.hs#L38-L41","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Throw\/Either.hs","hash_val":29621,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"records","parameters":"modu","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"records modu = do\n  let decls           = map GHC.unLoc (Hs.hsmodDecls (GHC.unLoc modu))\n      tyClDecls       = [ tyClDecl | Hs.TyClD _ tyClDecl <- decls ]\n      dataDecls       = [ d | d@(Hs.DataDecl _ _ _ _ _)  <- tyClDecls ]\n      dataDefns       = map Hs.tcdDataDefn dataDecls\n  d@Hs.ConDeclH98 {} <- concatMap getConDecls dataDefns\n  case Hs.con_args d of\n      Hs.RecCon rec -> [GHC.unLoc rec]\n      _             -> []\n where\n  getConDecls :: Hs.HsDataDefn Hs.GhcPs -> [Hs.ConDecl Hs.GhcPs]\n  getConDecls d@Hs.HsDataDefn {} = map GHC.unLoc $ Hs.dd_cons d\n\n\n--------------------------------------------------------------------------------","function_tokens":["records","modu","=","do","let","decls","=","map","GHC","unLoc","(","Hs","hsmodDecls","(","GHC","unLoc","modu",")",")","tyClDecls","=","[","tyClDecl","|","Hs","TyClD","_","tyClDecl","<-","decls","]","dataDecls","=","[","d","|","d","@","(","Hs","DataDecl","_","_","_","_","_",")","<-","tyClDecls","]","dataDefns","=","map","Hs","tcdDataDefn","dataDecls","d","@","Hs","ConDeclH98","{","}","<-","concatMap","getConDecls","dataDefns","case","Hs","con_args","d","of","Hs","RecCon","rec","->","[","GHC","unLoc","rec","]","_","->","[","]","where","getConDecls","::","Hs","HsDataDefn","Hs","GhcPs","->","[","Hs","ConDecl","Hs","GhcPs","]","getConDecls","d","@","Hs","HsDataDefn","{","}","=","map","GHC","unLoc","$","Hs","dd_cons","d","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L67-L82","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.Lazy.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.Lazy.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.Lazy.censor f (hdl (m <$ ctx))\n    R other        -> Writer.Lazy.WriterT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.Lazy.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Tell","w",")","->","ctx","<$","Writer","Lazy","tell","w","L","(","Listen","m",")","->","swapAndLift","<$>","Writer","Lazy","listen","(","hdl","(","m","<$","ctx",")",")","L","(","Censor","f","m",")","->","Writer","Lazy","censor","f","(","hdl","(","m","<$","ctx",")",")","R","other","->","Writer","Lazy","WriterT","$","getSwap","<$>","thread","(","(","\\","(","Swap","(","x",",","s",")",")","->","Swap",".","fmap","(","mappend","s",")","<$>","Writer","Lazy","runWriterT","x",")","~<~","hdl",")","other","(","Swap","(","ctx",",","mempty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L321-L326","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrap","parameters":"maxWidth leading ind","argument_list":"","return_statement":"","docstring":"^ Resulting lines","docstring_summary":"^ Resulting lines","docstring_tokens":["^","Resulting","lines"],"function":"wrap maxWidth leading ind = wrap' leading\n  where\n    wrap' ss [] = [ss]\n    wrap' ss (str:strs)\n        | overflows ss str =\n            ss : wrapRest maxWidth ind (str:strs)\n        | otherwise = wrap' (ss ++ \" \" ++ str) strs\n\n    overflows ss str = length ss > maxWidth ||\n        ((length ss + length str) >= maxWidth && ind + length str  <= maxWidth)\n\n\n--------------------------------------------------------------------------------","function_tokens":["wrap","maxWidth","leading","ind","=","wrap'","leading","where","wrap'","ss","[","]","=","[","ss","]","wrap'","ss","(","str",":","strs",")","|","overflows","ss","str","=","ss",":","wrapRest","maxWidth","ind","(","str",":","strs",")","|","otherwise","=","wrap'","(","ss","++","\" \"","++","str",")","strs","overflows","ss","str","=","length","ss",">","maxWidth","||","(","(","length","ss","+","length","str",")",">=","maxWidth","&&","ind","+","length","str","<=","maxWidth",")","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L99-L112","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putMongoStamp","parameters":"(MongoStamp x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putMongoStamp (MongoStamp x) = putInt64 x","function_tokens":["putMongoStamp","(","MongoStamp","x",")","=","putInt64","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L218-L218","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2\n            | zero p2 m1        = bin_ p1 m1 (union l1 t2) r1\n            | otherwise         = bin_ p1 m1 l1 (union r1 t2)","function_tokens":["union1","|","nomatch","p2","p1","m1","=","join","p1","t1","p2","t2","|","zero","p2","m1","=","bin_","p1","m1","(","union","l1","t2",")","r1","|","otherwise","=","bin_","p1","m1","l1","(","union","r1","t2",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L368-L370","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"waitForReply","parameters":"cancel onSignal","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"waitForReply cancel onSignal = do\n    chan <- gets replyChan\n    sPending <- gets pending\n    known <- gets known\n    inst <- gets inst\n    polled <- gets polled\n\n    result <- liftIO . readChan $ chan\n    case result of\n        -- If there was a reply\n        Answer sig@(Signal node _) -> do\n            -- Insert the node into the tree, as it might be a new one or it\n            -- would have to be refreshed\n            liftIO . insertNode inst $ node\n\n            -- Remove the node from the list of nodes with pending replies\n            modify $ \\s -> s { pending = delete node sPending }\n\n            -- Call the signal handler\n            onSignal sig\n\n        -- On timeout\n        Timeout registration -> do\n            let id = replyOrigin registration\n\n            -- Find the node corresponding to the id\n            --\n            -- ReplyQueue guarantees us, that it will be in polled, therefore\n            -- we can use fromJust\n            let node = fromJust . find (\\n -> nodeId n == id) $ polled\n\n            -- Remove every trace of the node's existance\n            modify $ \\s -> s {\n                  pending = delete node sPending\n                , known = delete node known\n                , polled = delete node polled\n                }\n\n            -- Continue, if there still are pending responses\n            updatedPending <- gets pending\n            if not . null $ updatedPending\n                then waitForReply cancel onSignal\n                else cancel\n\n        Closed -> cancel\n\n-- Decide wether, and which node to poll and react appropriately.\n--\n-- This is the meat of kademlia lookups","function_tokens":["waitForReply","cancel","onSignal","=","do","chan","<-","gets","replyChan","sPending","<-","gets","pending","known","<-","gets","known","inst","<-","gets","inst","polled","<-","gets","polled","result","<-","liftIO",".","readChan","$","chan","case","result","of","-- If there was a reply","Answer","sig","@","(","Signal","node","_",")","->","do","-- Insert the node into the tree, as it might be a new one or it","-- would have to be refreshed","liftIO",".","insertNode","inst","$","node","-- Remove the node from the list of nodes with pending replies","modify","$","\\","s","->","s","{","pending","=","delete","node","sPending","}","-- Call the signal handler","onSignal","sig","-- On timeout","Timeout","registration","->","do","let","id","=","replyOrigin","registration","-- Find the node corresponding to the id","--","-- ReplyQueue guarantees us, that it will be in polled, therefore","-- we can use fromJust","let","node","=","fromJust",".","find","(","\\","n","->","nodeId","n","==","id",")","$","polled","-- Remove every trace of the node's existance","modify","$","\\","s","->","s","{","pending","=","delete","node","sPending",",","known","=","delete","node","known",",","polled","=","delete","node","polled","}","-- Continue, if there still are pending responses","updatedPending","<-","gets","pending","if","not",".","null","$","updatedPending","then","waitForReply","cancel","onSignal","else","cancel","Closed","->","cancel","-- Decide wether, and which node to poll and react appropriately.","--","-- This is the meat of kademlia lookups"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L229-L278","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Writer.hs","language":"haskell","identifier":"tellLoop","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tellLoop i = replicateM_ i (tell (Sum (1 :: Int)))","function_tokens":["tellLoop","i","=","replicateM_","i","(","tell","(","Sum","(","1","::","Int",")",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Writer.hs#L44-L44","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Writer.hs","hash_val":8772,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Add as `ieq1` Add bs | length as == length bs = foldr (&&) True $ zipWith ieq as bs","function_tokens":["Add","as","`","ieq1","`","Add","bs","|","length","as","==","length","bs","=","foldr","(","&&",")","True","$","zipWith","ieq","as","bs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L60-L60","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"mapMWithKey","parameters":"f m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapMWithKey f m = sequence . map snd . M.toList . M.mapWithKey f $ m","function_tokens":["mapMWithKey","f","m","=","sequence",".","map","snd",".","M","toList",".","M","mapWithKey","f","$","m"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L242-L242","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = MG.empty","function_tokens":["empty","=","MG","empty"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L164-L164","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union","parameters":"t1@(Bin _ _ p1 m1 l1 r1) t2@(Bin _ _ p2 m2 l2 r2)","argument_list":"","return_statement":"","docstring":"\/O(n+m)\/. The union of two sets.","docstring_summary":"\/O(n+m)\/. The union of two sets.","docstring_tokens":["\/","O","(","n","+","m",")","\/",".","The","union","of","two","sets","."],"function":"union t1@(Bin _ _ p1 m1 l1 r1) t2@(Bin _ _ p2 m2 l2 r2)\n  | shorter m1 m2  = union1\n  | shorter m2 m1  = union2\n  | p1 == p2       = bin_ p1 m1 (union l1 l2) (union r1 r2)\n  | otherwise      = join p1 t1 p2 t2\n  where\n    union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2\n            | zero p2 m1        = bin_ p1 m1 (union l1 t2) r1\n            | otherwise         = bin_ p1 m1 l1 (union r1 t2)\n\n    union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2\n            | zero p1 m2        = bin_ p2 m2 (union t1 l2) r2\n            | otherwise         = bin_ p2 m2 l2 (union t1 r2)","function_tokens":["union","t1","@","(","Bin","_","_","p1","m1","l1","r1",")","t2","@","(","Bin","_","_","p2","m2","l2","r2",")","|","shorter","m1","m2","=","union1","|","shorter","m2","m1","=","union2","|","p1","==","p2","=","bin_","p1","m1","(","union","l1","l2",")","(","union","r1","r2",")","|","otherwise","=","join","p1","t1","p2","t2","where","union1","|","nomatch","p2","p1","m1","=","join","p1","t1","p2","t2","|","zero","p2","m1","=","bin_","p1","m1","(","union","l1","t2",")","r1","|","otherwise","=","bin_","p1","m1","l1","(","union","r1","t2",")","union2","|","nomatch","p1","p2","m2","=","join","p1","t1","p2","t2","|","zero","p1","m2","=","bin_","p2","m2","(","union","t1","l2",")","r2","|","otherwise","=","bin_","p2","m2","l2","(","union","t1","r2",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L362-L376","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"getLabel","parameters":"","argument_list":"","return_statement":"","docstring":"Derive unnamed labels as n-tuples that can be named manually. The types will be polymorphic and can be used in an arbitrary context.  Example:  > (left, right) = $(getLabel ''Either)  The lenses can now also be typed manually:  > left  :: (Either a b -> Either c b) :~> (a -> c) > right :: (Either a b -> Either a c) :~> (b -> c)  Note: Because of the abstract nature of the generated lenses and the top level pattern match, it might be required to use 'NoMonomorphismRestriction' in some cases.","docstring_summary":"Derive unnamed labels as n-tuples that can be named manually. The types will be polymorphic and can be used in an arbitrary context.  Example:  > (left, right) = $(getLabel ''Either)  The lenses can now also be typed manually:  > left  :: (Either a b -> Either c b) :~> (a -> c) > right :: (Either a b -> Either a c) :~> (b -> c)  Note: Because of the abstract nature of the generated lenses and the top level pattern match, it might be required to use 'NoMonomorphismRestriction' in some cases.","docstring_tokens":["Derive","unnamed","labels","as","n","-","tuples","that","can","be","named","manually",".","The","types","will","be","polymorphic","and","can","be","used","in","an","arbitrary","context",".","Example",":",">","(","left","right",")","=","$","(","getLabel","Either",")","The","lenses","can","now","also","be","typed","manually",":",">","left","::","(","Either","a","b","-",">","Either","c","b",")",":","~",">","(","a","-",">","c",")",">","right","::","(","Either","a","b","-",">","Either","a","c",")",":","~",">","(","b","-",">","c",")","Note",":","Because","of","the","abstract","nature","of","the","generated","lenses","and","the","top","level","pattern","match","it","might","be","required","to","use","NoMonomorphismRestriction","in","some","cases","."],"function":"getLabel = getLabelWith True False False","function_tokens":["getLabel","=","getLabelWith","True","False","False"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L122-L122","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"importModuleName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"importModuleName = GHC.moduleNameString . GHC.unLoc . GHC.ideclName","function_tokens":["importModuleName","=","GHC","moduleNameString",".","GHC","unLoc",".","GHC","ideclName"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L59-L59","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bin\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = uncurry defaultMainWith . fmap (map (benchShell <*> id)) =<< execParser opts\n  where\n    opts = info (arguments <**> helper)\n      ( fullDesc <> header \"chronos - a tool to comparatively benchmark programs with lazy precision\" )","function_tokens":["main","=","uncurry","defaultMainWith",".","fmap","(","map","(","benchShell","<*>","id",")",")","=<<","execParser","opts","where","opts","=","info","(","arguments","<**>","helper",")","(","fullDesc","<>","header","\"chronos - a tool to comparatively benchmark programs with lazy precision\"",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bin\/Main.hs#L12-L17","hash_key":"knupfer\/chronos:bin\/Main.hs","hash_val":24460,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"thaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thaw = MG.thaw","function_tokens":["thaw","=","MG","thaw"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L372-L372","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"puts","parameters":"l","argument_list":"","return_statement":"","docstring":"Set a value somewhere in the state, pointed to by the specified lens.","docstring_summary":"Set a value somewhere in the state, pointed to by the specified lens.","docstring_tokens":["Set","a","value","somewhere","in","the","state","pointed","to","by","the","specified","lens","."],"function":"puts l = State.modify . Total.set l","function_tokens":["puts","l","=","State","modify",".","Total","set","l"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L36-L36","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"hour","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hour = 60 * 60 * 1000000","function_tokens":["hour","=","60","*","60","*","1000000"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L260-L260","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"keywordLine","parameters":"kw","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"keywordLine kw = listToMaybe $ do\n            GHC.EpAnn {..} <- pure $ GHC.hsmodAnn modul\n            GHC.AddEpAnn kw' (GHC.EpaSpan s) <- GHC.am_main anns\n            guard $ kw == kw'\n            pure $ GHC.srcSpanEndLine s","function_tokens":["keywordLine","kw","=","listToMaybe","$","do","GHC","EpAnn","{","..","}","<-","pure","$","GHC","hsmodAnn","modul","GHC","AddEpAnn","kw'","(","GHC","EpaSpan","s",")","<-","GHC","am_main","anns","guard","$","kw","==","kw'","pure","$","GHC","srcSpanEndLine","s"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L83-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"top","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"top = true","function_tokens":["top","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L222-L222","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x <> y          = x `mappendTrack` y","function_tokens":["x","<>","y","=","x","`","mappendTrack","`","y"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L81-L81","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a .|. b = merge (flatten'' a ++ flatten'' b) where\n    merge []  = false\n    merge [f] = f\n    merge os  = inject $ Or os\n\n    flatten'' e = case match e of\n        Just (Or os) -> os\n        _ -> [e]","function_tokens":["a",".|.","b","=","merge","(","flatten''","a","++","flatten''","b",")","where","merge","[","]","=","false","merge","[","f","]","=","f","merge","os","=","inject","$","Or","os","flatten''","e","=","case","match","e","of","Just","(","Or","os",")","->","os","_","->","[","e","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L466-L475","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"linesUp","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"linesUp n | n > 0 = csi' [n] 'F'\n          | n < 0 = csi' [abs n] 'E'\n          | otherwise = mempty","function_tokens":["linesUp","n","|","n",">","0","=","csi'","[","n","]","'F'","|","n","<","0","=","csi'","[","abs","n","]","'E'","|","otherwise","=","mempty"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L215-L217","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"unsafeRead","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeRead = MG.unsafeRead","function_tokens":["unsafeRead","=","MG","unsafeRead"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L42-L42","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"bodyLoc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bodyLoc  = GHC.getLocA body","function_tokens":["bodyLoc","=","GHC","getLocA","body"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L138-L138","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"result  = Cache\n          $ unsafePerformIO\n          $ traverse newIORef\n          $ listArray (0,w - 1)\n          $ replicate w element","function_tokens":["result","=","Cache","$","unsafePerformIO","$","traverse","newIORef","$","listArray","(","0",",","w","-","1",")","$","replicate","w","element"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L53-L57","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"uncurry","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"uncurry a = app . arr (first a)","function_tokens":["uncurry","a","=","app",".","arr","(","first","a",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L166-L166","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"turnOn","parameters":"dynFlags ext","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"turnOn dynFlags ext = foldl'\n        turnOn\n        (GHC.xopt_set dynFlags ext)\n        [rhs | (lhs, True, rhs) <- GHC.impliedXFlags, lhs == ext]","function_tokens":["turnOn","dynFlags","ext","=","foldl'","turnOn","(","GHC","xopt_set","dynFlags","ext",")","[","rhs","|","(","lhs",",","True",",","rhs",")","<-","GHC","impliedXFlags",",","lhs","==","ext","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L95-L98","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"xs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"xs = Proxy :: Proxy xs","function_tokens":["xs","=","Proxy","::","Proxy","xs"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L400-L400","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"runLookup","parameters":"lookup inst id","argument_list":"","return_statement":"","docstring":"Run a LookupM, returning its result","docstring_summary":"Run a LookupM, returning its result","docstring_tokens":["Run","a","LookupM","returning","its","result"],"function":"runLookup lookup inst id = do\n    chan <- newChan\n    let state = LookupState inst id chan [] [] []\n\n    evalStateT lookup state\n\n-- The initial phase of the normal kademlia lookup operation","function_tokens":["runLookup","lookup","inst","id","=","do","chan","<-","newChan","let","state","=","LookupState","inst","id","chan","[","]","[","]","[","]","evalStateT","lookup","state","-- The initial phase of the normal kademlia lookup operation"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L197-L204","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/StrUtils.hs","language":"haskell","identifier":"suffix","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"suffix\n            | \"\\n\" `isSuffixOf` str = \"\"\n            | otherwise = \"\\n\"","function_tokens":["suffix","|","\"\\n\"","`","isSuffixOf","`","str","=","\"\"","|","otherwise","=","\"\\n\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/StrUtils.hs#L20-L22","hash_key":"Peaker\/git-mediate:src\/StrUtils.hs","hash_val":9940,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"resolveConflict","parameters":"conflict@Conflict {cBodies}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resolveConflict conflict@Conflict {cBodies} =\n    case resolveGen cBodies of\n    Just r -> Resolution $ unlines r\n    Nothing\n        | matchTop > 0 || matchBottom > 0 ->\n            PartialResolution $ unlines $\n            take matchTop sideA ++\n            Conflict.prettyLines (Conflict.setEachBody unmatched conflict) ++\n            takeEnd matchBottom sideA\n        | otherwise -> NoResolution\n    where\n        Sides {sideA, sideBase, sideB} = cBodies\n        match base a b\n            | null base = lengthOfCommonPrefix a b\n            | otherwise = minimum $ map (lengthOfCommonPrefix base) [a, b]\n        matchTop = match sideBase sideA sideB\n        revBottom = reverse . drop matchTop\n        matchBottom = match (revBottom sideBase) (revBottom sideA) (revBottom sideB)\n        dropEnd count xs = take (length xs - count) xs\n        takeEnd count xs = drop (length xs - count) xs\n        unmatched xs = drop matchTop $ dropEnd matchBottom xs","function_tokens":["resolveConflict","conflict","@","Conflict","{","cBodies","}","=","case","resolveGen","cBodies","of","Just","r","->","Resolution","$","unlines","r","Nothing","|","matchTop",">","0","||","matchBottom",">","0","->","PartialResolution","$","unlines","$","take","matchTop","sideA","++","Conflict","prettyLines","(","Conflict","setEachBody","unmatched","conflict",")","++","takeEnd","matchBottom","sideA","|","otherwise","->","NoResolution","where","Sides","{","sideA",",","sideBase",",","sideB","}","=","cBodies","match","base","a","b","|","null","base","=","lengthOfCommonPrefix","a","b","|","otherwise","=","minimum","$","map","(","lengthOfCommonPrefix","base",")","[","a",",","b","]","matchTop","=","match","sideBase","sideA","sideB","revBottom","=","reverse",".","drop","matchTop","matchBottom","=","match","(","revBottom","sideBase",")","(","revBottom","sideA",")","(","revBottom","sideB",")","dropEnd","count","xs","=","take","(","length","xs","-","count",")","xs","takeEnd","count","xs","=","drop","(","length","xs","-","count",")","xs","unmatched","xs","=","drop","matchTop","$","dropEnd","matchBottom","xs"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L30-L52","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"defaultConfigBytes","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"defaultConfigBytes = $(FileEmbed.embedFile \"data\/stylish-haskell.yaml\")","function_tokens":["defaultConfigBytes","=","(","FileEmbed","embedFile","\"data\/stylish-haskell.yaml\"",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L94-L94","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"text","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"text = Stylized mempty","function_tokens":["text","=","Stylized","mempty"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L86-L86","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"runNonDetA","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.  Using @[]@ as the 'Alternative' functor will produce all results, while 'Maybe' will return only the first. However, unless used with 'Control.Effect.Cull.cull', this will still enumerate the entire search space before returning, meaning that it will diverge for infinite search spaces, even when using 'Maybe'.  @ 'runNonDetA' ('pure' a) = 'pure' [a] @ @ 'runNonDetA' ('pure' a) = 'pure' ('Just' a) @  @since 1.0.0.0","docstring_summary":"Run a 'NonDet' effect, collecting all branches\u2019 results into an 'Alternative' functor.  Using","docstring_tokens":["Run","a","NonDet","effect","collecting","all","branches\u2019","results","into","an","Alternative","functor",".","Using"],"function":"runNonDetA = runNonDet (liftA2 (<|>)) (pure . pure) (pure empty)","function_tokens":["runNonDetA","=","runNonDet","(","liftA2","(","<|>",")",")","(","pure",".","pure",")","(","pure","empty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L65-L65","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"nm","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nm = maybe (tupE []) (litE . StringL . nameBase) (guard failing >> mn)","function_tokens":["nm","=","maybe","(","tupE","[","]",")","(","litE",".","StringL",".","nameBase",")","(","guard","failing",">>","mn",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L497-L497","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"tr","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix transpose","docstring_summary":"O(m*n) Matrix transpose","docstring_tokens":["O","(","m","*","n",")","Matrix","transpose"],"function":"tr = MG.tr","function_tokens":["tr","=","MG","tr"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L186-L186","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"b'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b' = f b a","function_tokens":["b'","=","f","b","a"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L338-L338","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"find","parameters":"(Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"find (Tip _ x)          = x","function_tokens":["find","(","Tip","_","x",")","=","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L644-L644","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWithM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM = MG.zipWithM","function_tokens":["zipWithM","=","MG","zipWithM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L336-L336","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"context","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"context = head $ map (\\(LabelExpr _ c _ _) -> c) labels","function_tokens":["context","=","head","$","map","(","\\","(","LabelExpr","_","c","_","_",")","->","c",")","labels"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L142-L142","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SIZE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SIZE                             = 0x2004","function_tokens":["al_SIZE","=","0x2004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L113-L113","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"defaultCacheWidth","parameters":"","argument_list":"","return_statement":"","docstring":"tuning parameter","docstring_summary":"tuning parameter","docstring_tokens":["tuning","parameter"],"function":"defaultCacheWidth = 1024","function_tokens":["defaultCacheWidth","=","1024"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L33-L33","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"fromString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromString = text . toText","function_tokens":["fromString","=","text",".","toText"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L65-L65","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Tell w)     -> ctx <$ Writer.CPS.tell w\n    L (Listen m)   -> swapAndLift <$> Writer.CPS.listen (hdl (m <$ ctx))\n    L (Censor f m) -> Writer.CPS.censor f (hdl (m <$ ctx))\n    R other        -> Writer.CPS.writerT $ getSwap <$> thread ((\\ (Swap (x, s)) -> Swap . fmap (mappend s) <$> Writer.CPS.runWriterT x) ~<~ hdl) other (Swap (ctx, mempty))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Tell","w",")","->","ctx","<$","Writer","CPS","tell","w","L","(","Listen","m",")","->","swapAndLift","<$>","Writer","CPS","listen","(","hdl","(","m","<$","ctx",")",")","L","(","Censor","f","m",")","->","Writer","CPS","censor","f","(","hdl","(","m","<$","ctx",")",")","R","other","->","Writer","CPS","writerT","$","getSwap","<$>","thread","(","(","\\","(","Swap","(","x",",","s",")",")","->","Swap",".","fmap","(","mappend","s",")","<$>","Writer","CPS","runWriterT","x",")","~<~","hdl",")","other","(","Swap","(","ctx",",","mempty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L312-L317","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"top","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"top = true","function_tokens":["top","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L224-L224","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = CullC empty","function_tokens":["empty","=","CullC","empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L68-L68","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"dumpDiffs","parameters":"colorEnable opts filePath count (idx, conflict)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dumpDiffs colorEnable opts filePath count (idx, conflict) =\n    do\n        putStrLn $ unwords [\"### Conflict\", show idx, \"of\", show count]\n        when (shouldDumpDiffs opts) $ traverse_ dumpDiff $ getConflictDiffs conflict\n        when (shouldDumpDiff2 opts) $ dumpDiff2 $ getConflictDiff2s conflict\n    where\n        dumpDiff (side, (lineNo, marker), diff) =\n            do  putStrLn $ concat\n                    [filePath, \":\", show lineNo, \":Diff\", show side, \": \", marker]\n                putStr $ unlines $ map (ppDiff colorEnable) (trimDiff (diffsContext opts) diff)\n        dumpDiff2 ((lineNoA, markerA), (lineNoB, markerB), diff) =\n            do  putStrLn $ concat [filePath, \":\", show lineNoA, \" <->\", markerA]\n                putStrLn $ concat [filePath, \":\", show lineNoB, \": \", markerB]\n                putStr $ unlines $ map (ppDiff colorEnable) diff","function_tokens":["dumpDiffs","colorEnable","opts","filePath","count","(","idx",",","conflict",")","=","do","putStrLn","$","unwords","[","\"### Conflict\"",",","show","idx",",","\"of\"",",","show","count","]","when","(","shouldDumpDiffs","opts",")","$","traverse_","dumpDiff","$","getConflictDiffs","conflict","when","(","shouldDumpDiff2","opts",")","$","dumpDiff2","$","getConflictDiff2s","conflict","where","dumpDiff","(","side",",","(","lineNo",",","marker",")",",","diff",")","=","do","putStrLn","$","concat","[","filePath",",","\":\"",",","show","lineNo",",","\":Diff\"",",","show","side",",","\": \"",",","marker","]","putStr","$","unlines","$","map","(","ppDiff","colorEnable",")","(","trimDiff","(","diffsContext","opts",")","diff",")","dumpDiff2","(","(","lineNoA",",","markerA",")",",","(","lineNoB",",","markerB",")",",","diff",")","=","do","putStrLn","$","concat","[","filePath",",","\":\"",",","show","lineNoA",",","\" <->\"",",","markerA","]","putStrLn","$","concat","[","filePath",",","\":\"",",","show","lineNoB",",","\": \"",",","markerB","]","putStr","$","unlines","$","map","(","ppDiff","colorEnable",")","diff"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L51-L66","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"harTMap","parameters":"f xs","argument_list":"","return_statement":"","docstring":"Transforms a sequence and then applies a harT.","docstring_summary":"Transforms a sequence and then applies a harT.","docstring_tokens":["Transforms","a","sequence","and","then","applies","a","harT","."],"function":"harTMap f xs = harT $ fmap f xs","function_tokens":["harTMap","f","xs","=","harT","$","fmap","f","xs"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L144-L144","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putUnbrokenEnum","parameters":"cfg decl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putUnbrokenEnum cfg decl = sep\n    (space >> putText \"|\" >> space)\n    (fmap (putConstructor cfg 0) . GHC.dd_cons . dataDefn $ decl)","function_tokens":["putUnbrokenEnum","cfg","decl","=","sep","(","space",">>","putText","\"|\"",">>","space",")","(","fmap","(","putConstructor","cfg","0",")",".","GHC","dd_cons",".","dataDefn","$","decl",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L296-L298","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = do\n      prefixes <- displayMenu\n      answer <- askLn prompt (Just firstItem)\n      pure (_menuItemFromChoiceFunc m m prefixes answer)\n    -- The default menu item.","function_tokens":["go","=","do","prefixes","<-","displayMenu","answer","<-","askLn","prompt","(","Just","firstItem",")","pure","(","_menuItemFromChoiceFunc","m","m","prefixes","answer",")","-- The default menu item."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L218-L223","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"dynFlags1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dynFlags1 = foldl' turnOn dynFlags0 fileExtensions\n            `GHC.gopt_set` GHC.Opt_KeepRawTokenStream","function_tokens":["dynFlags1","=","foldl'","turnOn","dynFlags0","fileExtensions","`","GHC","gopt_set","`","GHC","Opt_KeepRawTokenStream"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L79-L80","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ishow","parameters":"(c `Divides`  a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (c `Divides`  a) = coerce $ \"(\" ++ show c ++ \"| \" ++ coerce a ++ \")\"","function_tokens":["ishow","(","c","`","Divides","`","a",")","=","coerce","$","\"(\"","++","show","c","++","\"| \"","++","coerce","a","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L99-L99","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"prettyType","parameters":"","argument_list":"","return_statement":"","docstring":"Prettify a type.","docstring_summary":"Prettify a type.","docstring_tokens":["Prettify","a","type","."],"function":"prettyType = mapTypeVariables pretty","function_tokens":["prettyType","=","mapTypeVariables","pretty"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L705-L705","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"assumeSort","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"assumeSort n = do\n    ss <- ask\n    ds <- lift get\n\n    case n `lookup` (ss `union` ds) of\n        Just s  -> return s\n        Nothing -> fail \"unspecified sort\"","function_tokens":["assumeSort","n","=","do","ss","<-","ask","ds","<-","lift","get","case","n","`","lookup","`","(","ss","`","union","`","ds",")","of","Just","s","->","return","s","Nothing","->","fail","\"unspecified sort\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L140-L146","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"ishow","parameters":"(Equals _ a b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Equals _ a b) = coerce $ \"(= \" ++ coerce a ++ \" \" ++ coerce b ++ \")\"","function_tokens":["ishow","(","Equals","_","a","b",")","=","coerce","$","\"(= \"","++","coerce","a","++","\" \"","++","coerce","b","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L57-L57","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"fiveMinutes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fiveMinutes = 300000000","function_tokens":["fiveMinutes","=","300000000"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L223-L223","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"askWithMenu","parameters":"m prompt","argument_list":"","return_statement":"","docstring":"Ask the user to choose an item from a menu.  The menu will only be shown once and the user's choice will be returned in a 'Choice' value.  If you want to force the user to only choose from the displayed menu items you should use 'askWithMenuRepeatedly' instead.  @since 1.0.0.0","docstring_summary":"Ask the user to choose an item from a menu.  The menu will only be shown once and the user's choice will be returned in a 'Choice' value.  If you want to force the user to only choose from the displayed menu items you should use 'askWithMenuRepeatedly' instead.","docstring_tokens":["Ask","the","user","to","choose","an","item","from","a","menu",".","The","menu","will","only","be","shown","once","and","the","user","s","choice","will","be","returned","in","a","Choice","value",".","If","you","want","to","force","the","user","to","only","choose","from","the","displayed","menu","items","you","should","use","askWithMenuRepeatedly","instead","."],"function":"askWithMenu m prompt =\n  pushCompletionFunction (defaultCompFunc m)\n    *> go\n    <* popCompletionFunction\n  where\n    go = do\n      prefixes <- displayMenu\n      answer <- askLn prompt (Just firstItem)\n      pure (_menuItemFromChoiceFunc m m prefixes answer)\n    -- The default menu item.\n    firstItem = Text.strip (renderText Plain (_menuItemPrefix m 1))\n    -- Print the entire menu.\n    displayMenu = do\n      maybe pass ((<> text \"\\n\") >>> sayLn) (_menuBanner m)\n      cache <- foldlM listItem mempty (zip [1 ..] (toList $ _menuItems m))\n      sayLn (maybe mempty (text \"\\n\" <>) (_menuBeforePrompt m))\n      pure cache\n    -- Print a menu item and cache its prefix in a Map.\n    listItem cache (index, item) = do\n      let bullet = _menuItemPrefix m index\n          rendered = renderText Plain bullet\n      sayLn $\n        mconcat\n          [ text \"  \", -- Indent.\n            bullet, -- Unique identifier.\n            _menuItemSuffix m, -- Spacer or marker.\n            toStylizedText item -- The item.\n          ]\n      pure (one (Text.strip rendered, item) <> cache)\n\n-- | Like 'askWithMenu' except that arbitrary input is not allowed.\n-- If the user doesn't correctly select a menu item then the menu will\n-- be repeated and an error message will be displayed.\n--\n-- @since 1.0.0.0","function_tokens":["askWithMenu","m","prompt","=","pushCompletionFunction","(","defaultCompFunc","m",")","*>","go","<*","popCompletionFunction","where","go","=","do","prefixes","<-","displayMenu","answer","<-","askLn","prompt","(","Just","firstItem",")","pure","(","_menuItemFromChoiceFunc","m","m","prefixes","answer",")","-- The default menu item.","firstItem","=","Text","strip","(","renderText","Plain","(","_menuItemPrefix","m","1",")",")","-- Print the entire menu.","displayMenu","=","do","maybe","pass","(","(","<>","text","\"\\n\"",")",">>>","sayLn",")","(","_menuBanner","m",")","cache","<-","foldlM","listItem","mempty","(","zip","[","1","..","]","(","toList","$","_menuItems","m",")",")","sayLn","(","maybe","mempty","(","text","\"\\n\"","<>",")","(","_menuBeforePrompt","m",")",")","pure","cache","-- Print a menu item and cache its prefix in a Map.","listItem","cache","(","index",",","item",")","=","do","let","bullet","=","_menuItemPrefix","m","index","rendered","=","renderText","Plain","bullet","sayLn","$","mconcat","[","text","\"  \"",",","-- Indent.","bullet",",","-- Unique identifier.","_menuItemSuffix","m",",","-- Spacer or marker.","toStylizedText","item","-- The item.","]","pure","(","one","(","Text","strip","rendered",",","item",")","<>","cache",")","-- | Like 'askWithMenu' except that arbitrary input is not allowed.","-- If the user doesn't correctly select a menu item then the menu will","-- be repeated and an error message will be displayed.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L213-L248","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"inline","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"inline = InlineP n Inline FunLike (FromPhase 0)","function_tokens":["inline","=","InlineP","n","Inline","FunLike","(","FromPhase","0",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L480-L480","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookCheckSuiteEvent","function_tokens":["reflect","_","=","WebhookCheckSuiteEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L406-L406","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"lineEnding","parameters":"x@(_:_)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lineEnding x@(_:_) | last x == '\\r' = CRLF","function_tokens":["lineEnding","x","@","(","_",":","_",")","|","last","x","==","'\\r'","=","CRLF"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L99-L99","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"get","parameters":"l","argument_list":"","return_statement":"","docstring":"Getter for a lens that can fail. When the field to which the lens points is not accessible the getter returns 'Nothing'.","docstring_summary":"Getter for a lens that can fail. When the field to which the lens points is not accessible the getter returns 'Nothing'.","docstring_tokens":["Getter","for","a","lens","that","can","fail",".","When","the","field","to","which","the","lens","points","is","not","accessible","the","getter","returns","Nothing","."],"function":"get l = runKleisli (Poly.get l)","function_tokens":["get","l","=","runKleisli","(","Poly","get","l",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L62-L62","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/CP437.hs","language":"haskell","identifier":"decodeCP437","parameters":"bs","argument_list":"","return_statement":"","docstring":"Decode a 'ByteString' containing CP 437 encoded text.","docstring_summary":"Decode a 'ByteString' containing CP 437 encoded text.","docstring_tokens":["Decode","a","ByteString","containing","CP","437","encoded","text","."],"function":"decodeCP437 bs =\n  T.unfoldrN\n    (B.length bs)\n    (fmap (first decodeByteCP437) . B.uncons)\n    bs","function_tokens":["decodeCP437","bs","=","T","unfoldrN","(","B","length","bs",")","(","fmap","(","first","decodeByteCP437",")",".","B","uncons",")","bs"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/CP437.hs#L26-L30","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/CP437.hs","hash_val":21977,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a .+. b = merge . (\\(c, r) -> if c == 0 then r else cnst c : r) . foldr mergeConstAdd (0, []) $ flatten a ++ flatten b where\n    merge []  = cnst 0\n    merge [e] = e\n    merge es  = inject $ Add es\n\n    flatten e = case match e of\n        Just (Const 0) -> []\n        Just (Add as)  -> as\n        _              -> [e]","function_tokens":["a",".+.","b","=","merge",".","(","\\","(","c",",","r",")","->","if","c","==","0","then","r","else","cnst","c",":","r",")",".","foldr","mergeConstAdd","(","0",",","[","]",")","$","flatten","a","++","flatten","b","where","merge","[","]","=","cnst","0","merge","[","e","]","=","e","merge","es","=","inject","$","Add","es","flatten","e","=","case","match","e","of","Just","(","Const","0",")","->","[","]","Just","(","Add","as",")","->","as","_","->","[","e","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L169-L179","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"getCurrentLineLength","parameters":"","argument_list":"","return_statement":"","docstring":"Get current line length","docstring_summary":"Get current line length","docstring_tokens":["Get","current","line","length"],"function":"getCurrentLineLength = fmap length getCurrentLine","function_tokens":["getCurrentLineLength","=","fmap","length","getCurrentLine"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L323-L323","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"sizeOf","parameters":"~(Buffer b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sizeOf    ~(Buffer b) = sizeOf b","function_tokens":["sizeOf","~","(","Buffer","b",")","=","sizeOf","b"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L56-L56","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC f <*> StateC a = StateC $ \\ s -> do\n    (s', f') <- f s\n    (s'', a') <- a s'\n    pure (s'', f' a')","function_tokens":["StateC","f","<*>","StateC","a","=","StateC","$","\\","s","->","do","(","s'",",","f'",")","<-","f","s","(","s''",",","a'",")","<-","a","s'","pure","(","s''",",","f'","a'",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L82-L86","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"texts","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"texts = plot_annotation_values .~ pairs $ plot_annotation_style .~ fontStyle $ def","function_tokens":["texts","=","plot_annotation_values",".~","pairs","$","plot_annotation_style",".~","fontStyle","$","def"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L49-L49","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"force","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"force = MG.force","function_tokens":["force","=","MG","force"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L223-L223","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"shellHelp","parameters":"Shell {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shellHelp Shell {..} = do\n  let h = O.parserFailure shellPrefs shellInfo (O.ShowHelpText Nothing) mempty\n      s = fst (O.renderFailure h \"\")\n  sayLn (text $ toText s)\n\n-- | A completion function for shell commands.\n--\n-- Adds completion for subcommand names and their flags.\n--\n-- @since 1.1.0.0","function_tokens":["shellHelp","Shell","{","..","}","=","do","let","h","=","O","parserFailure","shellPrefs","shellInfo","(","O","ShowHelpText","Nothing",")","mempty","s","=","fst","(","O","renderFailure","h","\"\"",")","sayLn","(","text","$","toText","s",")","-- | A completion function for shell commands.","--","-- Adds completion for subcommand names and their flags.","--","-- @since 1.1.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L84-L94","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"rhsBody","parameters":"(Hs.GRHSs _ [grhs] _)","argument_list":"","return_statement":"","docstring":"Utility: grab the body out of guarded RHSs","docstring_summary":"Utility: grab the body out of guarded RHSs","docstring_tokens":["Utility",":","grab","the","body","out","of","guarded","RHSs"],"function":"rhsBody (Hs.GRHSs _ [grhs] _)\n    | Hs.GRHS _ _ body <- GHC.unLoc grhs = Just body","function_tokens":["rhsBody","(","Hs","GRHSs","_","[","grhs","]","_",")","|","Hs","GRHS","_","_","body","<-","GHC","unLoc","grhs","=","Just","body"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L235-L236","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"e","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"e = -10 * realToFrac t","function_tokens":["e","=","-","10","*","realToFrac","t"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L142-L142","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"nullContext","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nullContext = Context (ALCcontext nullPtr)","function_tokens":["nullContext","=","Context","(","ALCcontext","nullPtr",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L165-L165","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"a _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) a _ = a","function_tokens":["(","<>",")","a","_","=","a"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L66-L66","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"main = OA.execParser parserInfo >>= stylishHaskell","function_tokens":["main","=","OA","execParser","parserInfo",">>=","stylishHaskell"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L95-L95","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookInstallationEvent","function_tokens":["reflect","_","=","WebhookInstallationEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L433-L433","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/menu.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"It's main!","docstring_summary":"It's main!","docstring_tokens":["It","s","main!"],"function":"main = do\n  let menuConfig =\n        menuBanner (\"Pick a snack: \" & bold) $\n          menu items\n      prompt = \"Which snack? \" & bold & fg yellow\n      onError = \"Please pick a valid item!\" & bg (vivid red)\n\n  -- Display the menu and get back the item the user selected.  The\n  -- user will be able to select an item using it's index, name, or\n  -- using tab completion.\n  answer <-\n    runBylineT $\n      askWithMenuRepeatedly menuConfig prompt onError\n\n  putStrLn (\"You picked: \" ++ show answer)","function_tokens":["main","=","do","let","menuConfig","=","menuBanner","(","\"Pick a snack: \"","&","bold",")","$","menu","items","prompt","=","\"Which snack? \"","&","bold","&","fg","yellow","onError","=","\"Please pick a valid item!\"","&","bg","(","vivid","red",")","-- Display the menu and get back the item the user selected.  The","-- user will be able to select an item using it's index, name, or","-- using tab completion.","answer","<-","runBylineT","$","askWithMenuRepeatedly","menuConfig","prompt","onError","putStrLn","(","\"You picked: \"","++","show","answer",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/menu.hs#L47-L61","hash_key":"pjones\/byline:examples\/menu.hs","hash_val":10089,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"and'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"and' = do\n            _  <- char '(' *> string \"and\" *> space\n            as <- r `sepBy1` space\n            _  <- char ')'\n            and'' as","function_tokens":["and'","=","do","_","<-","char","'('","*>","string","\"and\"","*>","space","as","<-","r","`","sepBy1","`","space","_","<-","char","')'","and''","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L398-L404","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtToMapLensP","parameters":"p lens districts","argument_list":"","return_statement":"","docstring":"Given a projection and lists of districts, draw a map, with labels determined by a lens","docstring_summary":"Given a projection and lists of districts, draw a map, with labels determined by a lens","docstring_tokens":["Given","a","projection","and","lists","of","districts","draw","a","map","with","labels","determined","by","a","lens"],"function":"districtToMapLensP p lens districts = projectMap p (districtToMapLens lens districts)","function_tokens":["districtToMapLensP","p","lens","districts","=","projectMap","p","(","districtToMapLens","lens","districts",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L45-L45","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Rhythm a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Rhythm a)               = a","function_tokens":["go","(","Rhythm","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L421-L421","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fsTys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fsTys = map (typeVariables . snd) [a, b]","function_tokens":["fsTys","=","map","(","typeVariables",".","snd",")","[","a",",","b","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L346-L346","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"mzero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mzero = empty","function_tokens":["mzero","=","empty"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L139-L139","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","language":"haskell","identifier":"idx","parameters":"n i j","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"idx n i j | i <= j = (i * (2 * n - i - 1)) `shiftR` 1 + j\n          | otherwise = (j * (2 * n - j - 1)) `shiftR` 1 + i","function_tokens":["idx","n","i","j","|","i","<=","j","=","(","i","*","(","2","*","n","-","i","-","1",")",")","`","shiftR","`","1","+","j","|","otherwise","=","(","j","*","(","2","*","n","-","j","-","1",")",")","`","shiftR","`","1","+","i"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs#L44-L45","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","hash_val":33107,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"alcIsExtensionPresent","parameters":"maybeDevice extensionName","argument_list":"","return_statement":"","docstring":"To verify that a given extension is available for the current context and the device it is associated with, use 'alcIsExtensionPresent'. For invalid and unsupported string tokens it contains 'False'. Using 'Nothing' as the device is acceptable. The extension name is not case sensitive: The implementation will convert the name to all upper-case internally (and will express extension names in upper-case).","docstring_summary":"To verify that a given extension is available for the current context and the device it is associated with, use 'alcIsExtensionPresent'. For invalid and unsupported string tokens it contains 'False'. Using 'Nothing' as the device is acceptable. The extension name is not case sensitive: The implementation will convert the name to all upper-case internally (and will express extension names in upper-case).","docstring_tokens":["To","verify","that","a","given","extension","is","available","for","the","current","context","and","the","device","it","is","associated","with","use","alcIsExtensionPresent",".","For","invalid","and","unsupported","string","tokens","it","contains","False",".","Using","Nothing","as","the","device","is","acceptable",".","The","extension","name","is","not","case","sensitive",":","The","implementation","will","convert","the","name","to","all","upper","-","case","internally","(","and","will","express","extension","names","in","upper","-","case",")","."],"function":"alcIsExtensionPresent maybeDevice extensionName = makeGettableStateVar $\n   fmap unmarshalALCboolean $\n      withALCString extensionName $\n         alcIsExtensionPresent_ (marshalMaybeDevice maybeDevice)","function_tokens":["alcIsExtensionPresent","maybeDevice","extensionName","=","makeGettableStateVar","$","fmap","unmarshalALCboolean","$","withALCString","extensionName","$","alcIsExtensionPresent_","(","marshalMaybeDevice","maybeDevice",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L117-L120","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"f","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f x =\n        case filter (not . FP.isPathSeparator) x of\n          [] -> Nothing\n          xs -> Just (CI.mk xs)","function_tokens":["f","x","=","case","filter","(","not",".","FP","isPathSeparator",")","x","of","[","]","->","Nothing","xs","->","Just","(","CI","mk","xs",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L98-L102","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getString = do\n  len <- subtract 1 <$> getInt32\n  b <- getByteString (fromIntegral len)\n  getWord8\n  return $ TE.decodeUtf8 b","function_tokens":["getString","=","do","len","<-","subtract","1","<$>","getInt32","b","<-","getByteString","(","fromIntegral","len",")","getWord8","return","$","TE","decodeUtf8","b"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L151-L157","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Notes _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Notes _)                = \"N\"","function_tokens":["go","(","Notes","_",")","=","\"N\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L347-L347","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"(RETURN_VALUE _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandId (RETURN_VALUE _ _) = 6","function_tokens":["commandId","(","RETURN_VALUE","_","_",")","=","6"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L32-L32","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"compactLinePragmas","parameters":"lg columns align pragmas'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compactLinePragmas lg columns align pragmas' = map (wrapLanguage . pad) prags\n  where\n    wrapLanguage ps = \"{-# \" ++ lg ++ ps ++  \" #-}\"\n    maxWidth = fmap (\\c -> c - 16) columns\n    longest  = maximum $ map length prags\n    pad\n      | align = padRight longest\n      | otherwise = id\n    prags = map truncateComma $ wrapMaybe maxWidth \"\" 1 $\n      map (++ \",\") (init pragmas') ++ [last pragmas']\n\n\n--------------------------------------------------------------------------------","function_tokens":["compactLinePragmas","lg","columns","align","pragmas'","=","map","(","wrapLanguage",".","pad",")","prags","where","wrapLanguage","ps","=","\"{-# \"","++","lg","++","ps","++","\" #-}\"","maxWidth","=","fmap","(","\\","c","->","c","-","16",")","columns","longest","=","maximum","$","map","length","prags","pad","|","align","=","padRight","longest","|","otherwise","=","id","prags","=","map","truncateComma","$","wrapMaybe","maxWidth","\"\"","1","$","map","(","++","\",\"",")","(","init","pragmas'",")","++","[","last","pragmas'","]","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L61-L74","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"renderMod","parameters":"mode (t, m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderMod mode (t, m) =\n      case mode of\n        Plain ->\n          -- Only render text, no modifiers.\n          [RenderText t]\n        Simple ->\n          -- Terminal supports basic 16 colors.\n          let color l c = case c of\n                Color.ColorCode ai ac -> ANSI.SetColor l ai ac\n                rgb -> ANSI.SetColor l ANSI.Dull (Color.colorAsANSI rgb)\n           in renderToSGR t m color\n        Term256 ->\n          -- Terminal supports the 256-color palette.\n          let color l = ANSI.SetPaletteColor l . Color.colorAsIndex256\n           in renderToSGR t m color\n        TermRGB ->\n          -- Super terminal!\n          let color l c = case Color.colorAsRGB c of\n                Left (ai,ac) -> ANSI.SetColor l ai ac\n                Right rgb -> ANSI.SetRGBColor l rgb\n           in renderToSGR t m color","function_tokens":["renderMod","mode","(","t",",","m",")","=","case","mode","of","Plain","->","-- Only render text, no modifiers.","[","RenderText","t","]","Simple","->","-- Terminal supports basic 16 colors.","let","color","l","c","=","case","c","of","Color","ColorCode","ai","ac","->","ANSI","SetColor","l","ai","ac","rgb","->","ANSI","SetColor","l","ANSI","Dull","(","Color","colorAsANSI","rgb",")","in","renderToSGR","t","m","color","Term256","->","-- Terminal supports the 256-color palette.","let","color","l","=","ANSI","SetPaletteColor","l",".","Color","colorAsIndex256","in","renderToSGR","t","m","color","TermRGB","->","-- Super terminal!","let","color","l","c","=","case","Color","colorAsRGB","c","of","Left","(","ai",",","ac",")","->","ANSI","SetColor","l","ai","ac","Right","rgb","->","ANSI","SetRGBColor","l","rgb","in","renderToSGR","t","m","color"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L184-L205","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"maxView","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maxView t\n    = case t of\n        Bin _ _ p m l r | m < 0 -> let (result,t') = maxViewUnsigned l in Just (result, bin p m t' r)\n        Bin _ _ p m l r         -> let (result,t') = maxViewUnsigned r in Just (result, bin p m l t')\n        Tip _ y -> Just (y,Nil)\n        Nil -> Nothing","function_tokens":["maxView","t","=","case","t","of","Bin","_","_","p","m","l","r","|","m","<","0","->","let","(","result",",","t'",")","=","maxViewUnsigned","l","in","Just","(","result",",","bin","p","m","t'","r",")","Bin","_","_","p","m","l","r","->","let","(","result",",","t'",")","=","maxViewUnsigned","r","in","Just","(","result",",","bin","p","m","l","t'",")","Tip","_","y","->","Just","(","y",",","Nil",")","Nil","->","Nothing"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L593-L600","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"dropLast","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dropLast = reverse . tail . reverse","function_tokens":["dropLast","=","reverse",".","tail",".","reverse"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L18-L18","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"substitute","parameters":"a s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"substitute a s = case runSubstitution s a of\n    Just b -> b\n    Nothing -> IFix . imap (flip substitute s) . unIFix $ a","function_tokens":["substitute","a","s","=","case","runSubstitution","s","a","of","Just","b","->","b","Nothing","->","IFix",".","imap","(","flip","substitute","s",")",".","unIFix","$","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L319-L323","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"nk","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nk = natFromInt k","function_tokens":["nk","=","natFromInt","k"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L279-L279","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_BYTE_OFFSET","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_BYTE_OFFSET                      = 0x1026","function_tokens":["al_BYTE_OFFSET","=","0x1026"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L95-L95","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"fieldAllowedInTuneBody","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldAllowedInTuneBody   a = r where (_,_,r,_) = fieldAllowed a","function_tokens":["fieldAllowedInTuneBody","a","=","r","where","(","_",",","_",",","r",",","_",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L399-L400","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"5","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand 5 = FIND_VALUE `liftM` parseSerialize","function_tokens":["parseCommand","5","=","FIND_VALUE","`","liftM","`","parseSerialize"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L129-L129","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","language":"haskell","identifier":"new","parameters":"(r,c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"new (r,c) | r \/= c = error \"colmumns \/= rows\"\n              | otherwise = SymMMatrix r `liftM` GM.new ((r*(r+1)) `shiftR` 1)","function_tokens":["new","(","r",",","c",")","|","r","\/=","c","=","error","\"colmumns \/= rows\"","|","otherwise","=","SymMMatrix","r","`","liftM","`","GM","new","(","(","r","*","(","r","+","1",")",")","`","shiftR","`","1",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs#L35-L36","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","hash_val":33107,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"newSamples","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newSamples = samples + weight","function_tokens":["newSamples","=","samples","+","weight"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L379-L379","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"[e]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge [e] = e","function_tokens":["merge","[","e","]","=","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L188-L188","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/demo.hs","language":"haskell","identifier":"question","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"question =\n        \"What's \"\n          <> (\"your\" & bold)\n          <> \" favorite \"\n          <> (\"language\" & fg green & underline)\n          <> \"? \"","function_tokens":["question","=","\"What's \"","<>","(","\"your\"","&","bold",")","<>","\" favorite \"","<>","(","\"language\"","&","fg","green","&","underline",")","<>","\"? \""],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/demo.hs#L27-L32","hash_key":"pjones\/byline:examples\/demo.hs","hash_val":17487,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"waitN","parameters":"i tg","argument_list":"","return_statement":"","docstring":"Block until there are fewer than @N@ running threads in the group.","docstring_summary":"Block until there are fewer than","docstring_tokens":["Block","until","there","are","fewer","than"],"function":"waitN i tg = atomically $ nrOfRunning tg >>= \\n -> when (n >= i) retry","function_tokens":["waitN","i","tg","=","atomically","$","nrOfRunning","tg",">>=","\\","n","->","when","(","n",">=","i",")","retry"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L134-L134","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"imap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap = fmap","function_tokens":["imap","=","fmap"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L35-L35","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/menu.hs","language":"haskell","identifier":"onError","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"onError = \"Please pick a valid item!\" & bg (vivid red)","function_tokens":["onError","=","\"Please pick a valid item!\"","&","bg","(","vivid","red",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/menu.hs#L52-L52","hash_key":"pjones\/byline:examples\/menu.hs","hash_val":10089,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"alSourceiv","parameters":"source n buf","argument_list":"","return_statement":"","docstring":"Note: Older OpenAL implementations have no alSourceiv, so we emulate it here.","docstring_summary":"Note: Older OpenAL implementations have no alSourceiv, so we emulate it here.","docstring_tokens":["Note",":","Older","OpenAL","implementations","have","no","alSourceiv","so","we","emulate","it","here","."],"function":"alSourceiv source n buf =  peek buf >>= alSourcei source n","function_tokens":["alSourceiv","source","n","buf","=","peek","buf",">>=","alSourcei","source","n"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L616-L616","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictMaybeBuffer","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictMaybeBuffer = Dictionary {\n   alGetter  = alGetSourceiv,\n   alSetter  = alSourceiv,\n   size      = 1,\n   peekSize  = peek1 (unmarshalBuffer . fromIntegral),\n   marshal   = fromIntegral . marshalBuffer }","function_tokens":["dictMaybeBuffer","=","Dictionary","{","alGetter","=","alGetSourceiv",",","alSetter","=","alSourceiv",",","size","=","1",",","peekSize","=","peek1","(","unmarshalBuffer",".","fromIntegral",")",",","marshal","=","fromIntegral",".","marshalBuffer","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L571-L576","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"fromBlocks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromBlocks = MG.fromBlocks","function_tokens":["fromBlocks","=","MG","fromBlocks"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L217-L217","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Meter a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Meter a)                = show $ pretty a","function_tokens":["go","(","Meter","a",")","=","show","$","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L415-L415","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Raw.hs","language":"haskell","identifier":"rawForkIO","parameters":"action","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rawForkIO action = IO $ \\s ->\n   case (fork# action s) of (# s1, tid #) -> (# s1, ThreadId tid #)","function_tokens":["rawForkIO","action","=","IO","$","\\","s","->","case","(","fork#","action","s",")","of","(# ","s1",",","tid","->","(# ","s1",",","ThreadId","tid"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Raw.hs#L15-L18","hash_key":"basvandijk\/threads:Control\/Concurrent\/Raw.hs","hash_val":7507,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"modTime","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modTime = case o of\n        GenericOrigin -> currentTime\n        Borrowed ed -> edModTime ed","function_tokens":["modTime","=","case","o","of","GenericOrigin","->","currentTime","Borrowed","ed","->","edModTime","ed"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L500-L503","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"pick","parameters":"(Program (MapMaker outfile True projection) infile)","argument_list":"","return_statement":"","docstring":"svg now idk?","docstring_summary":"svg now idk?","docstring_tokens":["svg","now","idk?"],"function":"pick (Program (MapMaker outfile True projection) infile) = let p = pickProjection projection in\n    makeFoldersPng =<< districtToMapFilesP p <$> getDistricts infile","function_tokens":["pick","(","Program","(","MapMaker","outfile","True","projection",")","infile",")","=","let","p","=","pickProjection","projection","in","makeFoldersPng","=<<","districtToMapFilesP","p","<$>","getDistricts","infile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L36-L37","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"endLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"endLine = fromMaybe 1 $ whereLine <|>\n            (do\n                loc <- GHC.getLocA <$> GHC.hsmodExports modul\n                GHC.srcSpanEndLine <$> GHC.srcSpanToRealSrcSpan loc)","function_tokens":["endLine","=","fromMaybe","1","$","whereLine","<|>","(","do","loc","<-","GHC","getLocA","<$>","GHC","hsmodExports","modul","GHC","srcSpanEndLine","<$>","GHC","srcSpanToRealSrcSpan","loc",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L78-L81","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"6","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand 6 = liftM2 RETURN_VALUE parseSerialize parseSerialize","function_tokens":["parseCommand","6","=","liftM2","RETURN_VALUE","parseSerialize","parseSerialize"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L130-L130","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"prependItem","parameters":"new (Buffer a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prependItem new (Buffer a) = Buffer $ fmap (cons new) a","function_tokens":["prependItem","new","(","Buffer","a",")","=","Buffer","$","fmap","(","cons","new",")","a"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L157-L157","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"copyTree","parameters":"chatty s t","argument_list":"","return_statement":"","docstring":"{-\nRecursive file copying code\n\nIt proved difficult to find a stock recursive file copy utility that\npreserved the executable bits on things.\n\nchatty in this context means describe the file copies on stdout.\n\nMany thanks to [abuzittin gillifirca](https:\/\/codereview.stackexchange.com\/users\/20251\/abuzittin-gillifirca)\nfor the StackOverflow post [Copying files in Haskell](https:\/\/codereview.stackexchange.com\/questions\/68908\/copying-files-in-haskell)\nfrom which the following code was lifted.\n-}","docstring_summary":"{-\nRecursive file copying code","docstring_tokens":["{","-","Recursive","file","copying","code"],"function":"copyTree chatty s t = do\n  createDirectoryIfMissing True t\n  subItems <- getSubitems s\n  mapM_ (copyItem chatty s t) subItems","function_tokens":["copyTree","chatty","s","t","=","do","createDirectoryIfMissing","True","t","subItems","<-","getSubitems","s","mapM_","(","copyItem","chatty","s","t",")","subItems"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L30-L36","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"desktopFile","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desktopFile = op ExeFile exeFile <.> \"desktop\"","function_tokens":["desktopFile","=","op","ExeFile","exeFile","<.>","\"desktop\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L61-L61","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"buffersProcessed","parameters":"","argument_list":"","return_statement":"","docstring":"'buffersProcessed' contains the number of buffers that have been played by a given source.  Indirectly, this gives the index of the buffer currently playing. It can be used to determine how much slots are needed for unqueuing them. On a source in the 'Stopped' state, all buffers are processed. On a source in the 'Initial' state, no buffers are processed, all buffers are pending. It will contain 0 if 'buffer' has been set to 'Nothing'.","docstring_summary":"'buffersProcessed' contains the number of buffers that have been played by a given source.  Indirectly, this gives the index of the buffer currently playing. It can be used to determine how much slots are needed for unqueuing them. On a source in the 'Stopped' state, all buffers are processed. On a source in the 'Initial' state, no buffers are processed, all buffers are pending. It will contain 0 if 'buffer' has been set to 'Nothing'.","docstring_tokens":["buffersProcessed","contains","the","number","of","buffers","that","have","been","played","by","a","given","source",".","Indirectly","this","gives","the","index","of","the","buffer","currently","playing",".","It","can","be","used","to","determine","how","much","slots","are","needed","for","unqueuing","them",".","On","a","source","in","the","Stopped","state","all","buffers","are","processed",".","On","a","source","in","the","Initial","state","no","buffers","are","processed","all","buffers","are","pending",".","It","will","contain","0","if","buffer","has","been","set","to","Nothing","."],"function":"buffersProcessed = makeSourceGettableStateVar dictALint GetBuffersProcessed","function_tokens":["buffersProcessed","=","makeSourceGettableStateVar","dictALint","GetBuffersProcessed"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L307-L307","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/hsinstall.hs","language":"haskell","identifier":"docFp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"docFp = op DocDir . docDir $ di","function_tokens":["docFp","=","op","DocDir",".","docDir","$","di"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/hsinstall.hs#L65-L65","hash_key":"dino-\/hsinstall:src\/app\/hsinstall.hs","hash_val":1203,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putBinary","parameters":"t x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putBinary t x = let len = toEnum (SC.length x) in do\n  putInt32 len\n  putTag t\n  putByteString x","function_tokens":["putBinary","t","x","=","let","len","=","toEnum","(","SC","length","x",")","in","do","putInt32","len","putTag","t","putByteString","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L183-L188","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge []  = true","function_tokens":["merge","[","]","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L456-L456","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"moveToAmsterdam","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moveToAmsterdam = set (city . place) \"Amsterdam\"","function_tokens":["moveToAmsterdam","=","set","(","city",".","place",")","\"Amsterdam\""],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L30-L30","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getCString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getCString = TE.decodeUtf8 . SC.concat . LC.toChunks <$> getLazyByteStringNul","function_tokens":["getCString","=","TE","decodeUtf8",".","SC","concat",".","LC","toChunks","<$>","getLazyByteStringNul"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L142-L142","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"((x1, y1),(xn, yn)) = (pt, last pts)","function_tokens":["(","(","x1",",","y1",")",",","(","xn",",","yn",")",")","=","(","pt",",","last","pts",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L66-L66","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"groupAlign","parameters":"a xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"groupAlign a xs = case a of\n    Never    -> []\n    Adjacent -> byLine . sortOn (GHC.srcSpanStartLine . aLeft) $ xs\n    Always   -> [xs]\n  where\n    byLine = map toList . groupByLine aLeft\n\n\n--------------------------------------------------------------------------------","function_tokens":["groupAlign","a","xs","=","case","a","of","Never","->","[","]","Adjacent","->","byLine",".","sortOn","(","GHC","srcSpanStartLine",".","aLeft",")","$","xs","Always","->","[","xs","]","where","byLine","=","map","toList",".","groupByLine","aLeft","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L53-L62","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"","parameters":"a@(Stylized _ _) (StylizedList b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) a@(Stylized _ _) (StylizedList b) = StylizedList (a : b)","function_tokens":["(","<>",")","a","@","(","Stylized","_","_",")","(","StylizedList","b",")","=","StylizedList","(","a",":","b",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L54-L54","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","language":"haskell","identifier":"icata","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"icata f = f . imap (icata f) . unIFix","function_tokens":["icata","f","=","f",".","imap","(","icata","f",")",".","unIFix"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Functor.hs#L32-L32","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","hash_val":19560,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(ReferenceNumber a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (ReferenceNumber a)      = show a","function_tokens":["go","(","ReferenceNumber","a",")","=","show","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L429-L429","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"left","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"left     = last (nameLoc : patsLocs)","function_tokens":["left","=","last","(","nameLoc",":","patsLocs",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L137-L137","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"ask","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ask = RSST $ \\r s -> return (r, s)","function_tokens":["ask","=","RSST","$","\\","r","s","->","return","(","r",",","s",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L180-L180","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"identify","parameters":"_ UNil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identify _ UNil = Nil","function_tokens":["identify","_","UNil","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L209-L209","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"runAccum","parameters":"k w ma","argument_list":"","return_statement":"","docstring":"Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.  @ 'runAccum' k w0 ('pure' a) = k 'w0' a @ @ 'runAccum' k w0 ('add' w) = k (w0 <> w) () @ @ 'runAccum' k w0 ('add' w >> 'look') = k (w0 <> w) (w0 <> w) @  @since 1.1.2.0","docstring_summary":"Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.","docstring_tokens":["Run","an","Accum","effect","with","a","Monoid","al","log","applying","a","continuation","to","the","final","log","and","result","."],"function":"runAccum k w ma = runAccumC ma k w","function_tokens":["runAccum","k","w","ma","=","runAccumC","ma","k","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L51-L51","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"toColumns","parameters":"mat","argument_list":"","return_statement":"","docstring":"O(m*n) Return the columns","docstring_summary":"O(m*n) Return the columns","docstring_tokens":["O","(","m","*","n",")","Return","the","columns"],"function":"toColumns mat = map (unsafeTakeColumn mat) [0..c-1]\n  where\n    (_,c) = dim mat","function_tokens":["toColumns","mat","=","map","(","unsafeTakeColumn","mat",")","[","0","..","c","-","1","]","where","(","_",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L188-L191","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Composer _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Composer _)             = \"C\"","function_tokens":["go","(","Composer","_",")","=","\"C\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L337-L337","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = B.pack . foldr (\\i ws -> createWord i : ws) [] $ indexes","function_tokens":["s","=","B","pack",".","foldr","(","\\","i","ws","->","createWord","i",":","ws",")","[","]","$","indexes"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L67-L67","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"b","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b = distanceRad x1 x3","function_tokens":["b","=","distanceRad","x1","x3"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L28-L28","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(vs', ns') = rename ns vs","function_tokens":["(","vs'",",","ns'",")","=","rename","ns","vs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L723-L723","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"lineEndings","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lineEndings [] = Mixed","function_tokens":["lineEndings","[","]","=","Mixed"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L103-L103","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for a divisibility predicate","docstring_summary":"A smart constructor for a divisibility predicate","docstring_tokens":["A","smart","constructor","for","a","divisibility","predicate"],"function":"c .\\. a = inject $ c `Divides` a","function_tokens":["c",".\\.","a","=","inject","$","c","`","Divides","`","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L210-L210","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"cnst","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cnst = inject . Const","function_tokens":["cnst","=","inject",".","Const"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L152-L152","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"izipWith4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith4 = MG.izipWith4","function_tokens":["izipWith4","=","MG","izipWith4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L293-L293","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"sinkEntry","parameters":"t src s","argument_list":"","return_statement":"","docstring":"Stream data from the specified source to an archive entry.","docstring_summary":"Stream data from the specified source to an archive entry.","docstring_tokens":["Stream","data","from","the","specified","source","to","an","archive","entry","."],"function":"sinkEntry t src s = addPending (I.SinkEntry t src s)","function_tokens":["sinkEntry","t","src","s","=","addPending","(","I","SinkEntry","t","src","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L445-L445","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"unCpp","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Filter out lines which use CPP macros","docstring_summary":"------------------------------------------------------------------------------ Filter out lines which use CPP macros","docstring_tokens":["------------------------------------------------------------------------------","Filter","out","lines","which","use","CPP","macros"],"function":"unCpp = unlines . go False . lines\n  where\n    go _           []       = []\n    go isMultiline (x : xs) =\n        let isCpp         = isMultiline || listToMaybe x == Just '#'\n            nextMultiline = isCpp && not (null x) && last x == '\\\\'\n        in (if isCpp then \"\" else x) : go nextMultiline xs\n\n\n--------------------------------------------------------------------------------\n-- | If the given string is prefixed with an UTF-8 Byte Order Mark, drop it\n-- because haskell-src-exts can't handle it.","function_tokens":["unCpp","=","unlines",".","go","False",".","lines","where","go","_","[","]","=","[","]","go","isMultiline","(","x",":","xs",")","=","let","isCpp","=","isMultiline","||","listToMaybe","x","==","Just","'#'","nextMultiline","=","isCpp","&&","not","(","null","x",")","&&","last","x","==","'\\\\'","in","(","if","isCpp","then","\"\"","else","x",")",":","go","nextMultiline","xs","--------------------------------------------------------------------------------","-- | If the given string is prefixed with an UTF-8 Byte Order Mark, drop it","-- because haskell-src-exts can't handle it."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L41-L53","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erff","parameters":"","argument_list":"","return_statement":"","docstring":"I'm lazy: these should be implemented as native Float operations with truncated series, etc., but they aren't.","docstring_summary":"I'm lazy: these should be implemented as native Float operations with truncated series, etc., but they aren't.","docstring_tokens":["I","m","lazy",":","these","should","be","implemented","as","native","Float","operations","with","truncated","series","etc",".","but","they","aren","t","."],"function":"erff = realToFrac . erf . realToFrac","function_tokens":["erff","=","realToFrac",".","erf",".","realToFrac"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L28-L28","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureDefaultDeviceSpecifier","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains the name of the default capture device.","docstring_summary":"------------------------------------------------------------------------------ Contains the name of the default capture device.","docstring_tokens":["------------------------------------------------------------------------------","Contains","the","name","of","the","default","capture","device","."],"function":"captureDefaultDeviceSpecifier = makeGettableStateVar $\n   getString Nothing CaptureDefaultDeviceSpecifier","function_tokens":["captureDefaultDeviceSpecifier","=","makeGettableStateVar","$","getString","Nothing","CaptureDefaultDeviceSpecifier"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L122-L123","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"toRows","parameters":"","argument_list":"","return_statement":"","docstring":"O(m) Return the rows","docstring_summary":"O(m) Return the rows","docstring_tokens":["O","(","m",")","Return","the","rows"],"function":"toRows = MG.toRows","function_tokens":["toRows","=","MG","toRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L171-L171","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"thaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thaw = undefined","function_tokens":["thaw","=","undefined"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L118-L118","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"align","parameters":"maxColumns alignment","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"align maxColumns alignment\n  -- Do not make an changes if we would go past the maximum number of columns\n  | exceedsColumns (longestLeft + longestRight)  = mempty\n  | not (fixable alignment)                      = mempty\n  | otherwise                                    = foldMap align' alignment\n  where\n    exceedsColumns i = case maxColumns of\n      Nothing -> False\n      Just c  -> i > c\n\n    -- The longest thing in the left column\n    longestLeft = maximum $ map (GHC.srcSpanEndCol . aLeft) alignment\n\n    -- The longest thing in the right column\n    longestRight = maximum\n      [ GHC.srcSpanEndCol (aRight a) - GHC.srcSpanStartCol (aRight a)\n          + aRightLead a\n      | a <- alignment\n      ]\n\n    align' a = Editor.changeLine (GHC.srcSpanStartLine $ aContainer a) $ \\str ->\n      let column = GHC.srcSpanEndCol $ aLeft a\n          (pre, post) = splitAt column str\n      in [padRight longestLeft (trimRight pre) ++ trimLeft post]\n\n--------------------------------------------------------------------------------\n-- | Checks that all the alignables appear on a single line, and that they do\n-- not overlap.","function_tokens":["align","maxColumns","alignment","-- Do not make an changes if we would go past the maximum number of columns","|","exceedsColumns","(","longestLeft","+","longestRight",")","=","mempty","|","not","(","fixable","alignment",")","=","mempty","|","otherwise","=","foldMap","align'","alignment","where","exceedsColumns","i","=","case","maxColumns","of","Nothing","->","False","Just","c","->","i",">","c","-- The longest thing in the left column","longestLeft","=","maximum","$","map","(","GHC","srcSpanEndCol",".","aLeft",")","alignment","-- The longest thing in the right column","longestRight","=","maximum","[","GHC","srcSpanEndCol","(","aRight","a",")","-","GHC","srcSpanStartCol","(","aRight","a",")","+","aRightLead","a","|","a","<-","alignment","]","align'","a","=","Editor","changeLine","(","GHC","srcSpanStartLine","$","aContainer","a",")","$","\\","str","->","let","column","=","GHC","srcSpanEndCol","$","aLeft","a","(","pre",",","post",")","=","splitAt","column","str","in","[","padRight","longestLeft","(","trimRight","pre",")","++","trimLeft","post","]","--------------------------------------------------------------------------------","-- | Checks that all the alignables appear on a single line, and that they do","-- not overlap."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L62-L91","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"dtTypes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dtTypes   = substitute subst . typeFromBinder <$> dtVars_","function_tokens":["dtTypes","=","substitute","subst",".","typeFromBinder","<$>","dtVars_"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L564-L564","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands.hs","language":"haskell","identifier":"commands","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commands = commandsGeneral","function_tokens":["commands","=","commandsGeneral"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands.hs#L8-L8","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands.hs","hash_val":4562,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"play","parameters":"","argument_list":"","return_statement":"","docstring":"'play' applied to an 'Initial' source will promote the source to 'Playing', thus the data found in the buffer will be fed into the processing, starting at the beginning. 'play' applied to a 'Playing' source will restart the source from the beginning. It will not affect the configuration, and will leave the source in 'Playing' state, but reset the sampling offset to the beginning. 'play' applied to a 'Paused' source will resume processing using the source state as preserved at the 'pause' operation. 'play' applied to a 'Stopped' source will propagate it to 'Initial' then to 'Playing' immediately.","docstring_summary":"'play' applied to an 'Initial' source will promote the source to 'Playing', thus the data found in the buffer will be fed into the processing, starting at the beginning. 'play' applied to a 'Playing' source will restart the source from the beginning. It will not affect the configuration, and will leave the source in 'Playing' state, but reset the sampling offset to the beginning. 'play' applied to a 'Paused' source will resume processing using the source state as preserved at the 'pause' operation. 'play' applied to a 'Stopped' source will propagate it to 'Initial' then to 'Playing' immediately.","docstring_tokens":["play","applied","to","an","Initial","source","will","promote","the","source","to","Playing","thus","the","data","found","in","the","buffer","will","be","fed","into","the","processing","starting","at","the","beginning",".","play","applied","to","a","Playing","source","will","restart","the","source","from","the","beginning",".","It","will","not","affect","the","configuration","and","will","leave","the","source","in","Playing","state","but","reset","the","sampling","offset","to","the","beginning",".","play","applied","to","a","Paused","source","will","resume","processing","using","the","source","state","as","preserved","at","the","pause","operation",".","play","applied","to","a","Stopped","source","will","propagate","it","to","Initial","then","to","Playing","immediately","."],"function":"play = withArraySizei alSourcePlayv","function_tokens":["play","=","withArraySizei","alSourcePlayv"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L734-L734","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"liftIO","parameters":"io","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO io = StateC (\\ s -> (,) s <$> liftIO io)","function_tokens":["liftIO","io","=","StateC","(","\\","s","->","(",",",")","s","<$>","liftIO","io",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L113-L113","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"comma","parameters":"","argument_list":"","return_statement":"","docstring":"Print a comma","docstring_summary":"Print a comma","docstring_tokens":["Print","a","comma"],"function":"comma = putText \",\"","function_tokens":["comma","=","putText","\",\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L291-L291","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"cols","parameters":"","argument_list":"","return_statement":"","docstring":"Return the number of columns","docstring_summary":"Return the number of columns","docstring_tokens":["Return","the","number","of","columns"],"function":"cols = snd . dim","function_tokens":["cols","=","snd",".","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L96-L96","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"go","parameters":"(BPi v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (BPi v t e) = Pi i v t e","function_tokens":["go","(","BPi","v","t","e",")","=","Pi","i","v","t","e"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L38-L38","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"fromEvent","parameters":"(Event start duration content)","argument_list":"","return_statement":"","docstring":"Constructs a track that contains a single event.","docstring_summary":"Constructs a track that contains a single event.","docstring_tokens":["Constructs","a","track","that","contains","a","single","event","."],"function":"fromEvent (Event start duration content) = singleEvent start duration content","function_tokens":["fromEvent","(","Event","start","duration","content",")","=","singleEvent","start","duration","content"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L183-L183","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"headTy","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"headTy = listToMaybe tys","function_tokens":["headTy","=","listToMaybe","tys"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L232-L232","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"rename","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rename = mapTypeVariables (\\a -> a `fromMaybe` lookup a subs)","function_tokens":["rename","=","mapTypeVariables","(","\\","a","->","a","`","fromMaybe","`","lookup","a","subs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L583-L583","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = Choosing empty","function_tokens":["mempty","=","Choosing","empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L126-L126","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"makeCabal","parameters":"Stack","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeCabal Stack = justDoIt $ callProcess \"stack\" [\"query\"]","function_tokens":["makeCabal","Stack","=","justDoIt","$","callProcess","\"stack\"","[","\"query\"","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L63-L63","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"mkIndexStep","parameters":"_ _ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkIndexStep _ _ _ = error \"Mismatched input size\"","function_tokens":["mkIndexStep","_","_","_","=","error","\"Mismatched input size\""],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L125-L125","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/menu.hs","language":"haskell","identifier":"menuConfig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"menuConfig =\n        menuBanner (\"Pick a snack: \" & bold) $\n          menu items","function_tokens":["menuConfig","=","menuBanner","(","\"Pick a snack: \"","&","bold",")","$","menu","items"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/menu.hs#L48-L50","hash_key":"pjones\/byline:examples\/menu.hs","hash_val":10089,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"benchmarks\/benchmarks.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain\n  [ bench \"takeDiag largeMatrix\" $ nf M.takeDiag largeMatrix\n  ]","function_tokens":["main","=","defaultMain","[","bench","\"takeDiag largeMatrix\"","$","nf","M","takeDiag","largeMatrix","]"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/benchmarks\/benchmarks.hs#L13-L15","hash_key":"kaizhang\/matrices:benchmarks\/benchmarks.hs","hash_val":19425,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"joinWords","parameters":"[a, b]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"joinWords [a, b] = (toWord16 a `shiftL` 8) + toWord16 b","function_tokens":["joinWords","[","a",",","b","]","=","(","toWord16","a","`","shiftL","`","8",")","+","toWord16","b"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L102-L102","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"mkState","parameters":"f s","argument_list":"","return_statement":"","docstring":"Create a var from a state transformer.","docstring_summary":"Create a var from a state transformer.","docstring_tokens":["Create","a","var","from","a","state","transformer","."],"function":"mkState f s = VarT $ \\a -> do\n  let (b', s') = f a s\n  return (b', mkState f s')\n--------------------------------------------------------------------------------\n-- $composition\n-- You can compose vars together using Category's '>>>' and '<<<'. The \"right\n-- plug\" ('>>>') takes the output from a var on the left and \"plugs\" it into\n-- the input of the var on the right. The \"left plug\" does the same thing in\n-- the opposite direction. This allows you to write vars that read\n-- naturally.\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\n-- Adjusting and accumulating\n--------------------------------------------------------------------------------\n-- | Accumulates input values using a folding function and yields\n-- that accumulated value each sample. This is analogous to a stepwise foldl.\n--\n-- >>> testVarOver (accumulate (++) []) $ words \"hey there man\"\n-- \"hey\"\n-- \"heythere\"\n-- \"heythereman\"\n--\n-- >>> print $ foldl (++) [] $ words \"hey there man\"\n-- \"heythereman\"","function_tokens":["mkState","f","s","=","VarT","$","\\","a","->","do","let","(","b'",",","s'",")","=","f","a","s","return","(","b'",",","mkState","f","s'",")","--------------------------------------------------------------------------------","-- $composition","-- You can compose vars together using Category's '>>>' and '<<<'. The \"right","-- plug\" ('>>>') takes the output from a var on the left and \"plugs\" it into","-- the input of the var on the right. The \"left plug\" does the same thing in","-- the opposite direction. This allows you to write vars that read","-- naturally.","--------------------------------------------------------------------------------","--------------------------------------------------------------------------------","-- Adjusting and accumulating","--------------------------------------------------------------------------------","-- | Accumulates input values using a folding function and yields","-- that accumulated value each sample. This is analogous to a stepwise foldl.","--","-- >>> testVarOver (accumulate (++) []) $ words \"hey there man\"","-- \"hey\"","-- \"heythere\"","-- \"heythereman\"","--","-- >>> print $ foldl (++) [] $ words \"hey there man\"","-- \"heythereman\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L312-L336","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"makeComment","parameters":"file (pos,txt,fmt)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeComment file (pos,txt,fmt) = Comment pos' txt fmt\n  where pos' = convertPosn file pos","function_tokens":["makeComment","file","(","pos",",","txt",",","fmt",")","=","Comment","pos'","txt","fmt","where","pos'","=","convertPosn","file","pos"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L50-L53","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"resolve","parameters":"colorEnable opts fileName","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resolve colorEnable opts fileName =\n    do\n        resolutions <-\n            Resolution.resolveContent (Untabify (Opts.untabify opts))\n            . Conflict.parse\n            <$> readFile fileName\n        _result resolutions <$ handleFileResult colorEnable opts fileName resolutions","function_tokens":["resolve","colorEnable","opts","fileName","=","do","resolutions","<-","Resolution","resolveContent","(","Untabify","(","Opts","untabify","opts",")",")",".","Conflict","parse","<$>","readFile","fileName","_result","resolutions","<$","handleFileResult","colorEnable","opts","fileName","resolutions"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L119-L127","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"rs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rs = bind (Proxy :: Proxy g) a","function_tokens":["rs","=","bind","(","Proxy","::","Proxy","g",")","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L787-L787","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"program","parameters":"","argument_list":"","return_statement":"","docstring":"Parses the `Program` data type","docstring_summary":"Parses the `Program` data type","docstring_tokens":["Parses","the","Program","data","type"],"function":"program = Program \n    <$> hsubparser\n        ( command \"compute\" (info computationP ( progDesc \"Compute perimeter, area, etc. of map\" ))\n        <> command \"map\" (info mapMaker ( progDesc \"Make a map from a shapefile database.\" ))\n        <> command \"labelmap\" (info mapLabelMaker ( progDesc \"Make a map from a shapefile database, and label areas with relevant info\" )))\n    <*> ( argument str \n            (metavar \"SHAPEFILE\" \n            <> help \"Path to .shp file\"\n            <> completer (bashCompleter \"file -X '!*.shp' -o plusdirs\")))","function_tokens":["program","=","Program","<$>","hsubparser","(","command","\"compute\"","(","info","computationP","(","progDesc","\"Compute perimeter, area, etc. of map\"",")",")","<>","command","\"map\"","(","info","mapMaker","(","progDesc","\"Make a map from a shapefile database.\"",")",")","<>","command","\"labelmap\"","(","info","mapLabelMaker","(","progDesc","\"Make a map from a shapefile database, and label areas with relevant info\"",")",")",")","<*>","(","argument","str","(","metavar","\"SHAPEFILE\"","<>","help","\"Path to .shp file\"","<>","completer","(","bashCompleter","\"file -X '!*.shp' -o plusdirs\"",")",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L23-L31","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"left","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"left f  = f +++ arr id","function_tokens":["left","f","=","f","+++","arr","id"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L165-L165","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_MAJOR_VERSION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_MAJOR_VERSION                   = 0x1000","function_tokens":["alc_MAJOR_VERSION","=","0x1000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L160-L160","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(Substitution f) <> (Substitution g) = Substitution $ \\a -> getFirst (mconcat ([First . f, First . g] <*> [a]))","function_tokens":["(","Substitution","f",")","<>","(","Substitution","g",")","=","Substitution","$","\\","a","->","getFirst","(","mconcat","(","[","First",".","f",",","First",".","g","]","<*>","[","a","]",")",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L324-L324","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"force","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"force = MG.force","function_tokens":["force","=","MG","force"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L223-L223","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"toAscList","parameters":"t","argument_list":"","return_statement":"","docstring":"\/O(n)\/. Convert the set to an ascending list of elements.","docstring_summary":"\/O(n)\/. Convert the set to an ascending list of elements.","docstring_tokens":["\/","O","(","n",")","\/",".","Convert","the","set","to","an","ascending","list","of","elements","."],"function":"toAscList t = toList t","function_tokens":["toAscList","t","=","toList","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L720-L720","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"unEntrySelector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unEntrySelector =\n  FP.joinPath . fmap CI.original . NE.toList . unES","function_tokens":["unEntrySelector","=","FP","joinPath",".","fmap","CI","original",".","NE","toList",".","unES"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L120-L121","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!w'' = mappend w w'","function_tokens":["w''","=","mappend","w","w'"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Strict.hs#L67-L67","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Strict.hs","hash_val":32183,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"changes","parameters":"search toAlign","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changes search toAlign = mconcat $ do\n            item <- search module'\n            pure $ foldMap (align maxColumns) (toAlign item)","function_tokens":["changes","search","toAlign","=","mconcat","$","do","item","<-","search","module'","pure","$","foldMap","(","align","maxColumns",")","(","toAlign","item",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L190-L194","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseAlign","parameters":"key f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseAlign key f =\n        (o A..:? key >>= parseEnum aligns (f SimpleAlign.defaultConfig)) <|>\n        (boolToAlign <$> o A..: key)","function_tokens":["parseAlign","key","f","=","(","o","A",".:?","key",">>=","parseEnum","aligns","(","f","SimpleAlign","defaultConfig",")",")","<|>","(","boolToAlign","<$>","o","A",".:","key",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L232-L234","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtArea","parameters":"districts","argument_list":"","return_statement":"","docstring":"Get the areas of various objects and return a string suitable for printing","docstring_summary":"Get the areas of various objects and return a string suitable for printing","docstring_tokens":["Get","the","areas","of","various","objects","and","return","a","string","suitable","for","printing"],"function":"districtArea districts = concat . intercalate (pure \"\\n\") $ map (pure . show . distA) districts\n    where distA (District _ label _ area _) = (label, sum area) -- TODO figure out which one is the correct one\n\n-- | Get the perimeters of various objects and return a string suitable for printing","function_tokens":["districtArea","districts","=","concat",".","intercalate","(","pure","\"\\n\"",")","$","map","(","pure",".","show",".","distA",")","districts","where","distA","(","District","_","label","_","area","_",")","=","(","label",",","sum","area",")","-- TODO figure out which one is the correct one","-- | Get the perimeters of various objects and return a string suitable for printing"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L26-L30","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"m","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m = branchMask px py","function_tokens":["m","=","branchMask","px","py"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L758-L758","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"[f]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge [f] = f","function_tokens":["merge","[","f","]","=","f"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L457-L457","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"tokenize","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tokenize = words .\n        map (\\c -> if c == ',' then ' ' else c) .\n        takeWhile (\/= '#') .\n        drop 1 . dropWhile (\/= '#')","function_tokens":["tokenize","=","words",".","map","(","\\","c","->","if","c","==","','","then","' '","else","c",")",".","takeWhile","(","\/=","'#'",")",".","drop","1",".","dropWhile","(","\/=","'#'",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L146-L149","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) = union","function_tokens":["(","<>",")","=","union"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L233-L233","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"evalState","parameters":"s","argument_list":"","return_statement":"","docstring":"Run a lazy 'State' effect, yielding the result value and discarding the final state.  @ 'evalState' s m = 'fmap' 'snd' ('runState' s m) @  @since 1.0.0.0","docstring_summary":"Run a lazy 'State' effect, yielding the result value and discarding the final state.","docstring_tokens":["Run","a","lazy","State","effect","yielding","the","result","value","and","discarding","the","final","state","."],"function":"evalState s = fmap snd . runState s","function_tokens":["evalState","s","=","fmap","snd",".","runState","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L59-L59","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"(STORE k v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandArgs (STORE k v)          = toBS k `B.append` toBS v","function_tokens":["commandArgs","(","STORE","k","v",")","=","toBS","k","`","B","append","`","toBS","v"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L38-L38","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"listAligns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"listAligns =\n        [ (\"new_line\",          Imports.NewLine)\n        , (\"with_module_name\",  Imports.WithModuleName)\n        , (\"with_alias\",        Imports.WithAlias)\n        , (\"after_alias\",       Imports.AfterAlias)\n        , (\"repeat\",            Imports.Repeat)\n        ]","function_tokens":["listAligns","=","[","(","\"new_line\"",",","Imports","NewLine",")",",","(","\"with_module_name\"",",","Imports","WithModuleName",")",",","(","\"with_alias\"",",","Imports","WithAlias",")",",","(","\"after_alias\"",",","Imports","AfterAlias",")",",","(","\"repeat\"",",","Imports","Repeat",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L302-L308","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"filterRedundant'","parameters":"(l, xs) (known, zs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"filterRedundant' (l, xs) (known, zs)\n        | S.null xs' = (known', zs)\n        | otherwise  = (known', (l, S.toAscList xs') : zs)\n      where\n        fxs    = filter (not . isRedundant') xs\n        xs'    = S.fromList fxs `S.difference` known\n        known' = xs' `S.union` known\n\n--------------------------------------------------------------------------------","function_tokens":["filterRedundant'","(","l",",","xs",")","(","known",",","zs",")","|","S","null","xs'","=","(","known'",",","zs",")","|","otherwise","=","(","known'",",","(","l",",","S","toAscList","xs'",")",":","zs",")","where","fxs","=","filter","(","not",".","isRedundant'",")","xs","xs'","=","S","fromList","fxs","`","S","difference","`","known","known'","=","xs'","`","S","union","`","known","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L107-L116","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"gitHubKey","parameters":"f","argument_list":"","return_statement":"","docstring":"Smart constructor for 'GitHubKey', for a so-called \/global\/ key.","docstring_summary":"Smart constructor for 'GitHubKey', for a so-called \/global\/ key.","docstring_tokens":["Smart","constructor","for","GitHubKey","for","a","so","-","called","\/","global","\/","key","."],"function":"gitHubKey f = GitHubKey (\\_ _ -> Just <$> f)","function_tokens":["gitHubKey","f","=","GitHubKey","(","\\","_","_","->","Just","<$>","f",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L193-L193","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"marshalIntQuery","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalIntQuery x = case x of\n   AttributesSize -> alc_ATTRIBUTES_SIZE\n   AllAttributes -> alc_ALL_ATTRIBUTES\n   MajorVersion -> alc_MAJOR_VERSION\n   MinorVersion -> alc_MINOR_VERSION\n   CaptureSamples -> alc_CAPTURE_SAMPLES\n\n--------------------------------------------------------------------------------","function_tokens":["marshalIntQuery","x","=","case","x","of","AttributesSize","->","alc_ATTRIBUTES_SIZE","AllAttributes","->","alc_ALL_ATTRIBUTES","MajorVersion","->","alc_MAJOR_VERSION","MinorVersion","->","alc_MINOR_VERSION","CaptureSamples","->","alc_CAPTURE_SAMPLES","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L81-L90","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"common\/Parser.hs","language":"haskell","identifier":"configParser","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"configParser f = f\n  <$> switch ( long \"hide-bar\" <> help \"Hide the bar indicating relative performance.\" )\n  <*> switch ( long \"same-line\" <> help \"Print the analysis on the same line as the command.\" )\n  <*> switch ( long \"hide-details\" <> help \"Hide standard deviation and number of samples.\" )\n  <*> switch ( long \"print-once\" <> help \"Print only once the analysis.  This is will print the analysis on timeout, maximal relative error or ctrl-c.\" )\n  <*> switch ( long \"sort\" <> help \"Sort benchmarks by mean duration.\" )\n  <*> switch ( long \"simple\" <> help \"Don't colorize output and don't use unicode.\" )\n  <*> option auto\n  ( long \"confidence\"\n    <> help \"Factor by which the standard error will be multiplied for calculating confidence intervals (default is 6).\"\n    <> value 6\n    <> metavar \"DOUBLE\"\n  )\n  <*> optional\n  ( option auto\n    ( long \"timeout\"\n      <> help \"Timeout after which the program is terminated. It finishes the currently running benchmark.\"\n      <> metavar \"DOUBLE\"\n    )\n  )\n  <*> optional\n  ( option auto\n    ( long \"relative-error\"\n      <> help \"After every benchmark has got a relative error (calculated via confidence interval) below DOUBLE the program is terminated.\"\n      <> metavar \"DOUBLE\"\n    )\n  )","function_tokens":["configParser","f","=","f","<$>","switch","(","long","\"hide-bar\"","<>","help","\"Hide the bar indicating relative performance.\"",")","<*>","switch","(","long","\"same-line\"","<>","help","\"Print the analysis on the same line as the command.\"",")","<*>","switch","(","long","\"hide-details\"","<>","help","\"Hide standard deviation and number of samples.\"",")","<*>","switch","(","long","\"print-once\"","<>","help","\"Print only once the analysis.  This is will print the analysis on timeout, maximal relative error or ctrl-c.\"",")","<*>","switch","(","long","\"sort\"","<>","help","\"Sort benchmarks by mean duration.\"",")","<*>","switch","(","long","\"simple\"","<>","help","\"Don't colorize output and don't use unicode.\"",")","<*>","option","auto","(","long","\"confidence\"","<>","help","\"Factor by which the standard error will be multiplied for calculating confidence intervals (default is 6).\"","<>","value","6","<>","metavar","\"DOUBLE\"",")","<*>","optional","(","option","auto","(","long","\"timeout\"","<>","help","\"Timeout after which the program is terminated. It finishes the currently running benchmark.\"","<>","metavar","\"DOUBLE\"",")",")","<*>","optional","(","option","auto","(","long","\"relative-error\"","<>","help","\"After every benchmark has got a relative error (calculated via confidence interval) below DOUBLE the program is terminated.\"","<>","metavar","\"DOUBLE\"",")",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/common\/Parser.hs#L18-L44","hash_key":"knupfer\/chronos:common\/Parser.hs","hash_val":45793,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Exit.hs","language":"haskell","identifier":"warn","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"warn a = liftIO $ do\n  name <- Environment.getProgName <&> toText\n\n  let msg =\n        mconcat\n          [ text name,\n            text \": \",\n            toStylizedText a,\n            text \"\\n\"\n          ]\n\n  mode <- defaultRenderMode stderr\n  render mode stderr msg","function_tokens":["warn","a","=","liftIO","$","do","name","<-","Environment","getProgName","<&>","toText","let","msg","=","mconcat","[","text","name",",","text","\": \"",",","toStylizedText","a",",","text","\"\\n\"","]","mode","<-","defaultRenderMode","stderr","render","mode","stderr","msg"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Exit.hs#L53-L65","hash_key":"pjones\/byline:src\/Byline\/Exit.hs","hash_val":6289,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zip6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip6 = MG.zip6","function_tokens":["zip6","=","MG","zip6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L332-L332","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parse","parameters":"peer","argument_list":"","return_statement":"","docstring":"Parse a signal from a ByteString  (This needs to be supplied a Peer, to be able to create a complete Signal)","docstring_summary":"Parse a signal from a ByteString  (This needs to be supplied a Peer, to be able to create a complete Signal)","docstring_tokens":["Parse","a","signal","from","a","ByteString","(","This","needs","to","be","supplied","a","Peer","to","be","able","to","create","a","complete","Signal",")"],"function":"parse peer = evalState (runExceptT $ parseSignal peer)","function_tokens":["parse","peer","=","evalState","(","runExceptT","$","parseSignal","peer",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L31-L31","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sourceGain","parameters":"","argument_list":"","return_statement":"","docstring":"'sourceGain' contains a scalar amplitude multiplier for the given source. The initial value 1 means that the sound is unattenuated. A 'sourceGain' value of 0.5 is equivalent to an attenuation of 6dB. The value zero equals silence (no output). Driver implementations are free to optimize this case and skip mixing and processing stages where applicable. The implementation is in charge of ensuring artifact-free (click-free) changes of gain values and is free to defer actual modification of the sound samples, within the limits of acceptable latencies.  A 'sourceGain' larger than 1 (amplification) is permitted. However, the implementation is free to clamp the total gain (effective gain per source times listener gain) to 1 to prevent overflow.","docstring_summary":"'sourceGain' contains a scalar amplitude multiplier for the given source. The initial value 1 means that the sound is unattenuated. A 'sourceGain' value of 0.5 is equivalent to an attenuation of 6dB. The value zero equals silence (no output). Driver implementations are free to optimize this case and skip mixing and processing stages where applicable. The implementation is in charge of ensuring artifact-free (click-free) changes of gain values and is free to defer actual modification of the sound samples, within the limits of acceptable latencies.  A 'sourceGain' larger than 1 (amplification) is permitted. However, the implementation is free to clamp the total gain (effective gain per source times listener gain) to 1 to prevent overflow.","docstring_tokens":["sourceGain","contains","a","scalar","amplitude","multiplier","for","the","given","source",".","The","initial","value","1","means","that","the","sound","is","unattenuated",".","A","sourceGain","value","of","0",".","5","is","equivalent","to","an","attenuation","of","6dB",".","The","value","zero","equals","silence","(","no","output",")",".","Driver","implementations","are","free","to","optimize","this","case","and","skip","mixing","and","processing","stages","where","applicable",".","The","implementation","is","in","charge","of","ensuring","artifact","-","free","(","click","-","free",")","changes","of","gain","values","and","is","free","to","defer","actual","modification","of","the","sound","samples","within","the","limits","of","acceptable","latencies",".","A","sourceGain","larger","than","1","(","amplification",")","is","permitted",".","However","the","implementation","is","free","to","clamp","the","total","gain","(","effective","gain","per","source","times","listener","gain",")","to","1","to","prevent","overflow","."],"function":"sourceGain = makeSourceStateVar dictALfloat GetGain","function_tokens":["sourceGain","=","makeSourceStateVar","dictALfloat","GetGain"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L182-L182","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"bench\/bench.hs","language":"haskell","identifier":"toBench","parameters":"(n', a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toBench (n', a) = bench (n' ++ \" [\" ++ n ++ \"]\") $ nf a benchlen","function_tokens":["toBench","(","n'",",","a",")","=","bench","(","n'","++","\" [\"","++","n","++","\"]\"",")","$","nf","a","benchlen"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/bench\/bench.hs#L48-L48","hash_key":"bartavelle\/stateWriter:bench\/bench.hs","hash_val":16621,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Accum.hs","language":"haskell","identifier":"looks","parameters":"f","argument_list":"","return_statement":"","docstring":"Look up the previous accumulation and apply a function to it.  @ looks f = fmap f look @  @since 1.1.2.0","docstring_summary":"Look up the previous accumulation and apply a function to it.","docstring_tokens":["Look","up","the","previous","accumulation","and","apply","a","function","to","it","."],"function":"looks f = fmap f look","function_tokens":["looks","f","=","fmap","f","look"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Accum.hs#L65-L65","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Accum.hs","hash_val":45199,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s  = sqrt (1 - t'*t')","function_tokens":["s","=","sqrt","(","1","-","t'","*","t'",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L151-L151","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mono","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L342-L342","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"scanArchive","parameters":"path","argument_list":"","return_statement":"","docstring":"Scan the central directory of an archive and return its description 'ArchiveDescription' as well as a collection of its entries.  This operation may fail with:  * @isAlreadyInUseError@ if the file is already open and cannot be reopened;  * @isDoesNotExistError@ if the file does not exist;  * @isPermissionError@ if the user does not have permission to open the file;  * 'ParsingFailed' when specified archive is something this library cannot parse (this includes multi-disk archives, for example).  Please note that entries with invalid (non-portable) file names may be missing in the list of entries. Files that are compressed with unsupported compression methods are skipped as well. Also, if several entries would collide on some operating systems (such as Windows, because of its case-insensitivity), only one of them will be available, because 'EntrySelector' is case-insensitive. These are the consequences of the design decision to make it impossible to create non-portable archives with this library.","docstring_summary":"Scan the central directory of an archive and return its description 'ArchiveDescription' as well as a collection of its entries.  This operation may fail with:  *","docstring_tokens":["Scan","the","central","directory","of","an","archive","and","return","its","description","ArchiveDescription","as","well","as","a","collection","of","its","entries",".","This","operation","may","fail","with",":","*"],"function":"scanArchive path = withBinaryFile path ReadMode $ \\h -> do\n  mecdOffset <- locateECD path h\n  case mecdOffset of\n    Just ecdOffset -> do\n      hSeek h AbsoluteSeek ecdOffset\n      ecdSize <- subtract ecdOffset <$> hFileSize h\n      ecdRaw <- B.hGet h (fromIntegral ecdSize)\n      case runGet getECD ecdRaw of\n        Left msg -> throwM (ParsingFailed path msg)\n        Right ecd -> do\n          hSeek h AbsoluteSeek $ fromIntegral (adCDOffset ecd)\n          cdRaw <- B.hGet h $ fromIntegral (adCDSize ecd)\n          case runGet getCD cdRaw of\n            Left msg -> throwM (ParsingFailed path msg)\n            Right cd -> return (ecd, cd)\n    Nothing ->\n      throwM (ParsingFailed path \"Cannot locate end of central directory\")\n\n-- | Given location of the archive and information about a specific archive\n-- entry 'EntryDescription', return 'Source' of its data. The actual data\n-- can be compressed or uncompressed depending on the third argument.","function_tokens":["scanArchive","path","=","withBinaryFile","path","ReadMode","$","\\","h","->","do","mecdOffset","<-","locateECD","path","h","case","mecdOffset","of","Just","ecdOffset","->","do","hSeek","h","AbsoluteSeek","ecdOffset","ecdSize","<-","subtract","ecdOffset","<$>","hFileSize","h","ecdRaw","<-","B","hGet","h","(","fromIntegral","ecdSize",")","case","runGet","getECD","ecdRaw","of","Left","msg","->","throwM","(","ParsingFailed","path","msg",")","Right","ecd","->","do","hSeek","h","AbsoluteSeek","$","fromIntegral","(","adCDOffset","ecd",")","cdRaw","<-","B","hGet","h","$","fromIntegral","(","adCDSize","ecd",")","case","runGet","getCD","cdRaw","of","Left","msg","->","throwM","(","ParsingFailed","path","msg",")","Right","cd","->","return","(","ecd",",","cd",")","Nothing","->","throwM","(","ParsingFailed","path","\"Cannot locate end of central directory\"",")","-- | Given location of the archive and information about a specific archive","-- entry 'EntryDescription', return 'Source' of its data. The actual data","-- can be compressed or uncompressed depending on the third argument."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L211-L232","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"clearEditingFor","parameters":"s ea","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"clearEditingFor s ea =\n      ea\n        { eaCompression = M.delete s (eaCompression ea),\n          eaEntryComment = M.delete s (eaEntryComment ea),\n          eaDeleteComment = M.delete s (eaDeleteComment ea),\n          eaModTime = M.delete s (eaModTime ea),\n          eaExtraField = M.delete s (eaExtraField ea),\n          eaDeleteField = M.delete s (eaDeleteField ea),\n          eaExtFileAttr = M.delete s (eaExtFileAttr ea)\n        }","function_tokens":["clearEditingFor","s","ea","=","ea","{","eaCompression","=","M","delete","s","(","eaCompression","ea",")",",","eaEntryComment","=","M","delete","s","(","eaEntryComment","ea",")",",","eaDeleteComment","=","M","delete","s","(","eaDeleteComment","ea",")",",","eaModTime","=","M","delete","s","(","eaModTime","ea",")",",","eaExtraField","=","M","delete","s","(","eaExtraField","ea",")",",","eaDeleteField","=","M","delete","s","(","eaDeleteField","ea",")",",","eaExtFileAttr","=","M","delete","s","(","eaExtFileAttr","ea",")","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L431-L440","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseNode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseNode = do\n    id <- parseSerialize\n    host <- parseSplit ' '\n    skipCharacter\n    port <- parseWord16\n    let peer = Peer (C.unpack host) (fromIntegral port)\n    return $ Node peer id\n\n-- | Parses a trailing k-bucket","function_tokens":["parseNode","=","do","id","<-","parseSerialize","host","<-","parseSplit","' '","skipCharacter","port","<-","parseWord16","let","peer","=","Peer","(","C","unpack","host",")","(","fromIntegral","port",")","return","$","Node","peer","id","-- | Parses a trailing k-bucket"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L109-L118","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"f","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f | sortByMean cfg = sortOn (negate . mean . analysis . benchmark)\n      | otherwise = sortOn (negate . position)","function_tokens":["f","|","sortByMean","cfg","=","sortOn","(","negate",".","mean",".","analysis",".","benchmark",")","|","otherwise","=","sortOn","(","negate",".","position",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L275-L276","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"rght","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rght = if total then id else appE [| Right |]","function_tokens":["rght","=","if","total","then","id","else","appE","[","|"," Right ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L499-L499","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"mapM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM = MG.mapM","function_tokens":["mapM","=","MG","mapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L235-L235","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"makeStandardJsonIbBpsUnsafe","parameters":"lbs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeStandardJsonIbBpsUnsafe lbs = F.unsafeLocalState $ do\n  wb <- allocWorkBuffers (32 * 1024 * 1204)\n  ws <- newWorkState 0\n  fptrState       :: F.ForeignPtr F.UInt32  <- F.mallocForeignPtr\n  fptrRemBits     :: F.ForeignPtr F.UInt64  <- F.mallocForeignPtr\n  fptrRemBitsLen  :: F.ForeignPtr F.Size    <- F.mallocForeignPtr\n  let ptrState      = F.unsafeForeignPtrToPtr fptrState\n  let ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits\n  let ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen\n  F.poke ptrState       0\n  F.poke ptrRemBits     0\n  F.poke ptrRemBitsLen  0\n  IO.unsafeInterleaveIO $ go wb ws fptrState fptrRemBits fptrRemBitsLen (LBS.toChunks lbs)\n  where go :: ()\n          => WorkBuffers\n          -> WorkState\n          -> F.ForeignPtr F.UInt32\n          -> F.ForeignPtr F.UInt64\n          -> F.ForeignPtr F.Size\n          -> [BS.ByteString]\n          -> IO [(BS.ByteString, BS.ByteString)]\n        go _ _ _ fptrRemBits fptrRemBitsLen  []       = do\n          resBpFptr  <- F.mallocForeignPtrBytes 8\n          let resBpPtr      = F.castPtr (F.unsafeForeignPtrToPtr resBpFptr  )\n          let ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits\n          let ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen\n          remBits     <- F.peek ptrRemBits\n          remBitsLen  <- F.peek ptrRemBitsLen\n          bpByteLen <- F.smWriteBpChunkFinal\n            remBits     -- remaining_bp_bits\n            remBitsLen  -- remaning_bp_bits_len\n            resBpPtr    -- out_buffer\n          return  [ ( BS.empty\n                    , BSI.fromForeignPtr resBpFptr 0 (fromIntegral bpByteLen * 8)\n                    )\n                  ]\n        go wb ws fptrState fptrRemBits fptrRemBitsLen (bs:bss) = do\n          let (!bsFptr, !bsOff, !bsLen) = BSI.toForeignPtr bs\n          let !idxByteLen = (bsLen + 7) `div` 8\n          resIbFptr  <- F.mallocForeignPtrBytes idxByteLen\n          resBpFptr  <- F.mallocForeignPtrBytes idxByteLen\n          let resIbPtr      = F.castPtr (F.unsafeForeignPtrToPtr resIbFptr  )\n          let resBpPtr      = F.castPtr (F.unsafeForeignPtrToPtr resBpFptr  )\n          let bsPtr         = F.castPtr (F.unsafeForeignPtrToPtr bsFptr)\n          let ptrState      = F.unsafeForeignPtrToPtr fptrState\n          let ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits\n          let ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen\n          s :: Word8 <- fromIntegral <$> F.peek ptrState\n          void $ F.smProcessChunk\n            (F.plusPtr bsPtr bsOff) -- in_buffer:   Ptr UInt8\n            (fromIntegral bsLen)    -- in_length:   Size\n            ptrState                -- work state:  Ptr UInt32\n            (workBuffersP wb)       -- result_phi:  Ptr UInt8\n          void $ F.smMakeIbOpClChunks\n            (fromIntegral s)          -- state\n            (workBuffersP wb)         -- in_phis\n            (fromIntegral bsLen)      -- phi_length\n            resIbPtr                  -- out_ibs\n            (workBuffersO wb)         -- out_ops\n            (workBuffersC wb)         -- out_cls\n          bpByteLen <- F.smWriteBpChunk\n            (workBuffersO wb)         -- result_op\n            (workBuffersC wb)         -- result_cl\n            (fromIntegral idxByteLen) -- ib_bytes\n            ptrRemBits                -- remaining_bp_bits\n            ptrRemBitsLen             -- remaning_bp_bits_len\n            resBpPtr                  -- out_buffer\n          let !r =\n                ( BSI.fromForeignPtr resIbFptr 0 idxByteLen\n                , BSI.fromForeignPtr resBpFptr 0 (fromIntegral bpByteLen * 8)\n                )\n          rs <- IO.unsafeInterleaveIO $ go wb ws fptrState fptrRemBits fptrRemBitsLen bss\n          return (r:rs)","function_tokens":["makeStandardJsonIbBpsUnsafe","lbs","=","F","unsafeLocalState","$","do","wb","<-","allocWorkBuffers","(","32","*","1024","*","1204",")","ws","<-","newWorkState","0","fptrState","::","F","ForeignPtr","F","UInt32","<-","F","mallocForeignPtr","fptrRemBits","::","F","ForeignPtr","F","UInt64","<-","F","mallocForeignPtr","fptrRemBitsLen","::","F","ForeignPtr","F","Size","<-","F","mallocForeignPtr","let","ptrState","=","F","unsafeForeignPtrToPtr","fptrState","let","ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits","let","ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen","F","poke","ptrState","0","F","poke","ptrRemBits","0","F","poke","ptrRemBitsLen","0","IO","unsafeInterleaveIO","$","go","wb","ws","fptrState","fptrRemBits","fptrRemBitsLen","(","LBS","toChunks","lbs",")","where","go","::","(",")","=>","WorkBuffers","->","WorkState","->","F","ForeignPtr","F","UInt32","->","F","ForeignPtr","F","UInt64","->","F","ForeignPtr","F","Size","->","[","BS","ByteString","]","->","IO","[","(","BS","ByteString",",","BS","ByteString",")","]","go","_","_","_","fptrRemBits","fptrRemBitsLen","[","]","=","do","resBpFptr","<-","F","mallocForeignPtrBytes","8","let","resBpPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBpFptr",")","let","ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits","let","ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen","remBits","<-","F","peek","ptrRemBits","remBitsLen","<-","F","peek","ptrRemBitsLen","bpByteLen","<-","F","smWriteBpChunkFinal","remBits","-- remaining_bp_bits","remBitsLen","-- remaning_bp_bits_len","resBpPtr","-- out_buffer","return","[","(","BS","empty",",","BSI","fromForeignPtr","resBpFptr","0","(","fromIntegral","bpByteLen","*","8",")",")","]","go","wb","ws","fptrState","fptrRemBits","fptrRemBitsLen","(","bs",":","bss",")","=","do","let","(","bsFptr",",","bsOff",",","bsLen",")","=","BSI","toForeignPtr","bs","let","idxByteLen","=","(","bsLen","+","7",")","`","div","`","8","resIbFptr","<-","F","mallocForeignPtrBytes","idxByteLen","resBpFptr","<-","F","mallocForeignPtrBytes","idxByteLen","let","resIbPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resIbFptr",")","let","resBpPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBpFptr",")","let","bsPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","bsFptr",")","let","ptrState","=","F","unsafeForeignPtrToPtr","fptrState","let","ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits","let","ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen","s","::","Word8","<-","fromIntegral","<$>","F","peek","ptrState","void","$","F","smProcessChunk","(","F","plusPtr","bsPtr","bsOff",")","-- in_buffer:   Ptr UInt8","(","fromIntegral","bsLen",")","-- in_length:   Size","ptrState","-- work state:  Ptr UInt32","(","workBuffersP","wb",")","-- result_phi:  Ptr UInt8","void","$","F","smMakeIbOpClChunks","(","fromIntegral","s",")","-- state","(","workBuffersP","wb",")","-- in_phis","(","fromIntegral","bsLen",")","-- phi_length","resIbPtr","-- out_ibs","(","workBuffersO","wb",")","-- out_ops","(","workBuffersC","wb",")","-- out_cls","bpByteLen","<-","F","smWriteBpChunk","(","workBuffersO","wb",")","-- result_op","(","workBuffersC","wb",")","-- result_cl","(","fromIntegral","idxByteLen",")","-- ib_bytes","ptrRemBits","-- remaining_bp_bits","ptrRemBitsLen","-- remaning_bp_bits_len","resBpPtr","-- out_buffer","let","r","=","(","BSI","fromForeignPtr","resIbFptr","0","idxByteLen",",","BSI","fromForeignPtr","resBpFptr","0","(","fromIntegral","bpByteLen","*","8",")",")","rs","<-","IO","unsafeInterleaveIO","$","go","wb","ws","fptrState","fptrRemBits","fptrRemBitsLen","bss","return","(","r",":","rs",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L37-L111","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mapTyVarBndr","parameters":"f (PlainTV  n flag)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapTyVarBndr f (PlainTV  n flag) = PlainTV (f n) flag","function_tokens":["mapTyVarBndr","f","(","PlainTV","n","flag",")","=","PlainTV","(","f","n",")","flag"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L690-L690","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"lookupSig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookupSig = lookup \"X-Hub-Signature\"","function_tokens":["lookupSig","=","lookup","\"X-Hub-Signature\""],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L285-L285","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"write","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"write = MG.write","function_tokens":["write","=","MG","write"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L33-L33","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_NONE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_NONE                             = 0x0000","function_tokens":["al_NONE","=","0x0000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L54-L54","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(ib <> cb, NextItemWithComment i c, items, comments)\n    | blockStart ib < blockStart cb =\n        Just","function_tokens":["(","ib","<>","cb",",","NextItemWithComment","i","c",",","items",",","comments",")","|","blockStart","ib","<","blockStart","cb","=","Just"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L106-L108","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"x","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x = tweenStream tweenx 0","function_tokens":["x","=","tweenStream","tweenx","0"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L53-L53","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"sepDecl","parameters":"bracePos","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sepDecl bracePos = newline >> spaces case (cEquals cfg, cFirstField cfg) of\n        (_, Indent y) | not (cBreakSingleConstructors cfg) -> y\n        (SameLine, SameLine)                               -> bracePos\n        (Indent x, Indent y)                               -> x + y + 2\n        (SameLine, Indent y)                               -> bracePos + y - 2\n        (Indent x, SameLine)                               -> bracePos + x - 2","function_tokens":["sepDecl","bracePos","=","newline",">>","spaces","case","(","cEquals","cfg",",","cFirstField","cfg",")","of","(","_",",","Indent","y",")","|","not","(","cBreakSingleConstructors","cfg",")","->","y","(","SameLine",",","SameLine",")","->","bracePos","(","Indent","x",",","Indent","y",")","->","x","+","y","+","2","(","SameLine",",","Indent","y",")","->","bracePos","+","y","-","2","(","Indent","x",",","SameLine",")","->","bracePos","+","x","-","2"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L431-L438","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Device.hs","language":"haskell","identifier":"openDevice","parameters":"maybeDeviceSpec","argument_list":"","return_statement":"","docstring":"'openDevice' allows the application (i.e. the client program) to connect to a device (i.e. the server). If the function returns 'Nothing', then no sound driver\\\/device has been found. The argument to 'openDevice' specifies a certain device or device configuration. If it is 'Nothing', the implementation will provide an implementation specific default, see 'defaultDeviceSpecifier'. Otherwise it is 'Just' an implementation-dependent string. You can use 'allDeviceSpecifiers' to get a list of the known OpenAL devices.  \/Notes for Windows:\/ There are 3 possible device strings, each having a deprecated equivalent for legacy applications only:  * @\\\"Generic Hardware\\\"@ (legacy string: @\\\"DirectSound3D\\\"@)  * @\\\"Generic Software\\\"@ (legacy string: @\\\"DirectSound\\\"@)  * @\\\"Generic Software Fallback\\\"@ (legacy string: @\\\"MMSYSTEM\\\"@)  \/Notes for Linux\\\/\\*nix:\/ If an @.openalrc@ file is present in the user\\'s home directory, it is loaded first, otherwise @\\\/etc\\\/openalrc@ is tried. The bindings (if any) of @devices@, @direction@, @sampling-rate@, and @speaker-num@ (see below) after loading one of these files take precedence over any bindings done via the argument to 'openDevice'.  The syntax of these files is lisp-based and a sequence of expressions, where an expression is one the following:  * A boolean value of the form @\\#f@ or @\\#t@, which evaluate to \/false\/ and \/true\/, respectively.  * An non-negative integer value, i.e. a sequence of decimal digits, evaluating to itself.  * A (signed) floating point value, as recoginzed by C\\'s @atof()@, evaluating to itself.  * A pointer value of the form @\\#p\/num\/@, where \/num\/ can be an octal, decimal or hexadecimal value, as recoginzed by C\\`s @strtol()@, evaluating to itself. This kind of expression is currently unused.  * A string, i.e. a sequence of printable\\\/whitespace characters between double quotes, evaluating to itself.  * A symbol, i.e. a sequence of almost all characters which don\\'t form a simple expression like the ones mentioned below, e.g. @foo@, @bar1@, @3baz@, ... The symbol evaluates to the value currently bound to it.  * A function application of the form @(\/symbol\/ \/expression\/...)@. The function bound to the symbol is applied to the evaluated arguments.  * A quotation of the form @(quote \/expression\/)@ or @\\'\/expression\/@, evaluating to the unevaluated \/expression\/ itself.  * A definition of the form @(define \/symbol\/ \/expression\/)@, binding \/symbol\/ to the value of \/expression\/. The whole expression evaluates to the value of \/expression\/, too.  * A conjunction of boolean expressions of the form @(and \/expression\/...)@. Each \/expression\/ is evaluated in turn, and if one of them evaluates to \/false\/, the value of the whole expression is \/false\/. Otherwise the value is \/true\/.  * An extension loading mechanism of the form @(load-extension \/libraryName\/)@, where \/libraryName\/ has to evaluate to a string. This tries to load the dynamic library with up to 3 special entry points: @alExtension_03282000@ (pointing to a mandatory NULL-terminated sequence of pairs of pointers to names and extension functions), @alExtInit_03282000@ (an optional initialization function), and @alExtFini_03282000@ (an optional cleanup function). If the extension could be loaded successfully, the whole expression evaluates to \/true\/, otherwise to \/false\/.  Some symbols have a special meaning for OpenAL:  [@devices@] Has the form @(\/devspec\/...)@, where \/devspec\/ is either a symbol\\\/string specifying a device or @(\/device\/ \/device-param\/...)@, specifying a device with additional parameters. These optional device parameters are stored in a variable @device-params@, but are currently unused. The first device which can successfully opened is used.  [@direction@] Type string or symbol: @\\\"read\\\"@ specifies that the device should be an input device, everything else means output device (default).  [@sampling-rate@] Type integer or float: Specifies the internal mixing frequency, default is 44.1kHz.  [@speaker-num@] Type integer or float: Specifies the number of speakers, which can be 1, 2 (default), or 4.  [@alsa-device@] Type string, @alsa@ backend only: Specifies both @alsa-out-device@ and @alsa-in-device@, default @\\\"plughw:0,0\\\"@.  [@alsa-out-device@] Type string, @alsa@ backend only: Specifies the ALSA output device, defaults to the value of @alsa-device@.  [@alsa-in-device@] Type string, @alsa@ backend only: Specifies the ALSA input device, defaults to the value of @alsa-device@.  [@native-in-device@] Type string, @native@ backend on IRIX only.  [@native-out-device@] Type string, @native@ backend on IRIX only.  [@native-rear-out-device@] Type string, @native@ backend on IRIX only.  [@native-use-select@] Type boolean, @native@ backend on Linux only: If @\\#t@, wait up to 0.8sec for the device to become ready for writing. If @\\#f@, just try to write and hope it won\\'t hang forever. The latter might be necessary for some drivers which don\\'t implement @select()@ , like some Aureal drivers.  [@lin-dsp-path@] Type string, @native@ backend on Linux only: Path to DSP device for writing, tried before @\\\/dev\\\/sound\\\/dsp@ and @\\\/dev\\\/sound@ if set.  [@lin-dsp-read-path@] Type string, @native@ backend on Linux only: Path to DSP device for reading, tried before @\\\/dev\\\/sound\\\/dsp@ and @\\\/dev\\\/sound@ if set. Defaults to the value of @lin-dsp-path@.  [@native-backend-debug@] Type boolean, @native@ backend on Darwin only: If set to @\\#f@, be a bit verbose on stderr about what\\'s going on in the backend.  [@source-rolloff-factor@] Type integer or float: Value of the initial rolloff factor for sources, default is @1.0@.  [@listener-position@] List of 3 integers or floats: Value of the initial listener position, default is @(0 0 0)@.  [@listener-velocity@] List of 3 integers or floats: Value of the initial listener velocity, default is @(0 0 0)@.  [@listener-orientation@] List of 6 integers or floats: Value of the initial listener orientation (at\\\/up), default is @(0 0 -1 0 1 0)@.  The string given to 'openDevice' has to be of the form @\\'((\/symbol\/ \/expression\/) ...)@, which means basically a sequence of @define@ expressions. Example:  @ \\\"\\'((sampling-rate 8000) (native-backend-debug \\#f))\\\" @  \/Note:\/ The information above has been reverse-engineered from the OpenAL SI and could be inaccurate. Any corrections and\\\/or additions are highly welcome.","docstring_summary":"'openDevice' allows the application (i.e. the client program) to connect to a device (i.e. the server). If the function returns 'Nothing', then no sound driver\\\/device has been found. The argument to 'openDevice' specifies a certain device or device configuration. If it is 'Nothing', the implementation will provide an implementation specific default, see 'defaultDeviceSpecifier'. Otherwise it is 'Just' an implementation-dependent string. You can use 'allDeviceSpecifiers' to get a list of the known OpenAL devices.  \/Notes for Windows:\/ There are 3 possible device strings, each having a deprecated equivalent for legacy applications only:  *","docstring_tokens":["openDevice","allows","the","application","(","i",".","e",".","the","client","program",")","to","connect","to","a","device","(","i",".","e",".","the","server",")",".","If","the","function","returns","Nothing","then","no","sound","driver","\\","\/","device","has","been","found",".","The","argument","to","openDevice","specifies","a","certain","device","or","device","configuration",".","If","it","is","Nothing","the","implementation","will","provide","an","implementation","specific","default","see","defaultDeviceSpecifier",".","Otherwise","it","is","Just","an","implementation","-","dependent","string",".","You","can","use","allDeviceSpecifiers","to","get","a","list","of","the","known","OpenAL","devices",".","\/","Notes","for","Windows",":","\/","There","are","3","possible","device","strings","each","having","a","deprecated","equivalent","for","legacy","applications","only",":","*"],"function":"openDevice maybeDeviceSpec =\n   liftIO $ fmap unmarshalDevice $\n      maybe (alcOpenDevice nullPtr)   -- use preferred device\n            (flip withALCString alcOpenDevice)\n            maybeDeviceSpec","function_tokens":["openDevice","maybeDeviceSpec","=","liftIO","$","fmap","unmarshalDevice","$","maybe","(","alcOpenDevice","nullPtr",")","-- use preferred device","(","flip","withALCString","alcOpenDevice",")","maybeDeviceSpec"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Device.hs#L187-L191","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Device.hs","hash_val":14318,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"receivingProcess","parameters":"inst rq replyChan registerChan","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"receivingProcess inst rq replyChan registerChan = forever $ do\n    reply <- readChan replyChan\n\n    case reply of\n        -- Handle a timed out node\n        Timeout registration -> do\n            let origin = replyOrigin registration\n                h = handle inst\n                newRegistration = registration { replyTypes = [R_PONG] }\n\n            -- Mark the node as timed out\n            pingAgain <- timeoutNode inst origin\n            -- If the node should be repinged\n            when pingAgain $ do\n                result <- lookupNode inst origin\n                case result of\n                    Nothing -> return ()\n                    Just node -> do\n                        -- Ping the node\n                        send h (peer node) PING\n                        expect h newRegistration registerChan\n\n        -- Store values in newly encountered nodes that you are the closest to\n        Answer (Signal node cmd) -> do\n            let originId = nodeId node\n            tree <- retrieve sTree\n\n            -- This node is not yet known\n            when (not . isJust . T.lookup tree $ originId) $ do\n                let closestKnown = T.findClosest tree originId 1\n                    ownId = T.extractId tree\n                    self = node { nodeId = ownId }\n                    bucket = self:closestKnown\n                    -- Find out closest known node\n                    closestId = nodeId . head . sortByDistanceTo bucket $ originId\n\n                -- This node can be assumed to be closest to the new node\n                when (ownId == closestId) $ do\n                    storedValues <- toList <$> retrieve values\n                    let h = handle inst\n                        p = peer node\n                    -- Store all stored values in the new node\n                    forM_ storedValues (send h p . uncurry STORE)\n\n            case cmd of\n                -- Ping unknown Nodes that were returned by RETURN_NODES.\n                -- Pinging them first is neccessary to prevent disconnected\n                -- nodes from spreading through the networks NodeTrees.\n                (RETURN_NODES _ nodes) -> forM_ nodes $ \\node -> do\n                    result <- lookupNode inst . nodeId $ node\n                    case result of\n                        Nothing -> send (handle inst) (peer node) PING\n                        _ -> return ()\n                _ -> return ()\n\n        _ -> return ()\n\n    dispatch reply rq\n    where retrieve f = atomically . readTVar . f . state $ inst\n\n\n-- | The actual process running in the background","function_tokens":["receivingProcess","inst","rq","replyChan","registerChan","=","forever","$","do","reply","<-","readChan","replyChan","case","reply","of","-- Handle a timed out node","Timeout","registration","->","do","let","origin","=","replyOrigin","registration","h","=","handle","inst","newRegistration","=","registration","{","replyTypes","=","[","R_PONG","]","}","-- Mark the node as timed out","pingAgain","<-","timeoutNode","inst","origin","-- If the node should be repinged","when","pingAgain","$","do","result","<-","lookupNode","inst","origin","case","result","of","Nothing","->","return","(",")","Just","node","->","do","-- Ping the node","send","h","(","peer","node",")","PING","expect","h","newRegistration","registerChan","-- Store values in newly encountered nodes that you are the closest to","Answer","(","Signal","node","cmd",")","->","do","let","originId","=","nodeId","node","tree","<-","retrieve","sTree","-- This node is not yet known","when","(","not",".","isJust",".","T","lookup","tree","$","originId",")","$","do","let","closestKnown","=","T","findClosest","tree","originId","1","ownId","=","T","extractId","tree","self","=","node","{","nodeId","=","ownId","}","bucket","=","self",":","closestKnown","-- Find out closest known node","closestId","=","nodeId",".","head",".","sortByDistanceTo","bucket","$","originId","-- This node can be assumed to be closest to the new node","when","(","ownId","==","closestId",")","$","do","storedValues","<-","toList","<$>","retrieve","values","let","h","=","handle","inst","p","=","peer","node","-- Store all stored values in the new node","forM_","storedValues","(","send","h","p",".","uncurry","STORE",")","case","cmd","of","-- Ping unknown Nodes that were returned by RETURN_NODES.","-- Pinging them first is neccessary to prevent disconnected","-- nodes from spreading through the networks NodeTrees.","(","RETURN_NODES","_","nodes",")","->","forM_","nodes","$","\\","node","->","do","result","<-","lookupNode","inst",".","nodeId","$","node","case","result","of","Nothing","->","send","(","handle","inst",")","(","peer","node",")","PING","_","->","return","(",")","_","->","return","(",")","_","->","return","(",")","dispatch","reply","rq","where","retrieve","f","=","atomically",".","readTVar",".","f",".","state","$","inst","-- | The actual process running in the background"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L122-L184","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"fromColumns","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from columns","docstring_summary":"O(m*n) Create matrix from columns","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","columns"],"function":"fromColumns = MG.fromColumns","function_tokens":["fromColumns","=","MG","fromColumns"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L161-L161","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prefixDir'@(PrefixDir prefixFp) = computePrefixDir (optPrefix opts) (optBuildMode opts)","function_tokens":["prefixDir'","@","(","PrefixDir","prefixFp",")","=","computePrefixDir","(","optPrefix","opts",")","(","optBuildMode","opts",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L96-L96","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"getFullName","parameters":"(Object o)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getFullName (Object o) = getFullName o","function_tokens":["getFullName","(","Object","o",")","=","getFullName","o"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L223-L223","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"defaultConfig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultConfig = Config\n    { cCases            = Always\n    , cTopLevelPatterns = Always\n    , cRecords          = Always\n    , cMultiWayIf       = Always\n    }","function_tokens":["defaultConfig","=","Config","{","cCases","=","Always",",","cTopLevelPatterns","=","Always",",","cRecords","=","Always",",","cMultiWayIf","=","Always","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L45-L50","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"relativeErrorAbove","parameters":"cfg d a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"relativeErrorAbove cfg d a = d < confidence cfg * standardError a \/ fromRational (mean a)","function_tokens":["relativeErrorAbove","cfg","d","a","=","d","<","confidence","cfg","*","standardError","a","\/","fromRational","(","mean","a",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L330-L330","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"pickLens","parameters":"\"compactness\"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pickLens \"compactness\" = compactness","function_tokens":["pickLens","\"compactness\"","=","compactness"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L92-L92","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"matchEvent","parameters":"WebhookWildcardEvent s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchEvent WebhookWildcardEvent s = decode' (fromStrict s') where\n  s' = \"\\\"\" <> s <> \"\\\"\"","function_tokens":["matchEvent","WebhookWildcardEvent","s","=","decode'","(","fromStrict","s'",")","where","s'","=","\"\\\"\"","<>","s","<>","\"\\\"\""],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L495-L497","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"csi'","parameters":"(x:xs) b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"csi' (x:xs) b = B.char7 '\\ESC' <> B.char7 '[' <> B.intDec x <> foldMap (\\n -> B.char7 ';' <> B.intDec n) xs <> B.char7 b","function_tokens":["csi'","(","x",":","xs",")","b","=","B","char7","'\\ESC'","<>","B","char7","'['","<>","B","intDec","x","<>","foldMap","(","\\","n","->","B","char7","';'","<>","B","intDec","n",")","xs","<>","B","char7","b"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L391-L391","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"minView","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"minView t\n    = case t of\n        Bin _ _ p m l r | m < 0 -> let (result,t') = minViewUnsigned r in Just (result, bin p m l t')\n        Bin _ _ p m l r         -> let (result,t') = minViewUnsigned l in Just (result, bin p m t' r)\n        Tip _ y -> Just (y, Nil)\n        Nil -> Nothing","function_tokens":["minView","t","=","case","t","of","Bin","_","_","p","m","l","r","|","m","<","0","->","let","(","result",",","t'",")","=","minViewUnsigned","r","in","Just","(","result",",","bin","p","m","l","t'",")","Bin","_","_","p","m","l","r","->","let","(","result",",","t'",")","=","minViewUnsigned","l","in","Just","(","result",",","bin","p","m","t'","r",")","Tip","_","y","->","Just","(","y",",","Nil",")","Nil","->","Nothing"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L610-L617","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"split'","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"split' x t\n  = case t of\n      Bin _ _ p m l r\n        | match x p m -> if zero x m then let (lt,gt) = split' x l in (lt,union gt r)\n                                     else let (lt,gt) = split' x r in (union l lt,gt)\n        | otherwise   -> if x < p then (Nil, t)\n                                  else (t, Nil)\n      Tip _ y\n        | x>y       -> (t,Nil)\n        | x<y       -> (Nil,t)\n        | otherwise -> (Nil,Nil)\n      Nil -> (Nil,Nil)\n\n-- | \/O(min(n,W))\/. Performs a 'split' but also returns whether the pivot\n-- element was found in the original set.","function_tokens":["split'","x","t","=","case","t","of","Bin","_","_","p","m","l","r","|","match","x","p","m","->","if","zero","x","m","then","let","(","lt",",","gt",")","=","split'","x","l","in","(","lt",",","union","gt","r",")","else","let","(","lt",",","gt",")","=","split'","x","r","in","(","union","l","lt",",","gt",")","|","otherwise","->","if","x","<","p","then","(","Nil",",","t",")","else","(","t",",","Nil",")","Tip","_","y","|","x",">","y","->","(","t",",","Nil",")","|","x","<","y","->","(","Nil",",","t",")","|","otherwise","->","(","Nil",",","Nil",")","Nil","->","(","Nil",",","Nil",")","-- | \/O(min(n,W))\/. Performs a 'split' but also returns whether the pivot","-- element was found in the original set."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L541-L556","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"isSubsetOf","parameters":"Nil _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSubsetOf Nil _                = True","function_tokens":["isSubsetOf","Nil","_","=","True"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L490-L490","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"steps","parameters":"(_:[])","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"steps     (_:[]) = []","function_tokens":["steps","(","_",":","[","]",")","=","[","]"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L53-L53","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"free","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"free  = filter (not . (`elem` used)) names","function_tokens":["free","=","filter","(","not",".","(","`","elem","`","used",")",")","names"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L581-L581","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zip4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip4 = MG.zip4","function_tokens":["zip4","=","MG","zip4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L320-L320","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"secondTvar","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"secondTvar = listToMaybe . drop 1 $ GHC.hsq_explicit dataTypeVars","function_tokens":["secondTvar","=","listToMaybe",".","drop","1","$","GHC","hsq_explicit","dataTypeVars"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L318-L318","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Interpret.hs","language":"haskell","identifier":"runInterpret","parameters":"f m","argument_list":"","return_statement":"","docstring":"Interpret an effect using a higher-order function.  Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write @runInterpret f (runInterpret g myPrgram)@ or @runInterpret f $ runInterpret g $ myProgram@. If you try and write @runInterpret f . runInterpret g@, you will unfortunately get a rather scary type error!  @since 1.0.0.0","docstring_summary":"Interpret an effect using a higher-order function.  Note that due to the higher-rank type, you have to use either '$' or explicit application when applying this interpreter. That is, you will need to write","docstring_tokens":["Interpret","an","effect","using","a","higher","-","order","function",".","Note","that","due","to","the","higher","-","rank","type","you","have","to","use","either","$","or","explicit","application","when","applying","this","interpreter",".","That","is","you","will","need","to","write"],"function":"runInterpret f m = reify (Interpreter (\\ hdl sig -> InterpretC . f (runInterpretC . hdl) sig)) (go m) where\n  go :: InterpretC s eff m x -> Const (m x) s\n  go (InterpretC m) = Const m","function_tokens":["runInterpret","f","m","=","reify","(","Interpreter","(","\\","hdl","sig","->","InterpretC",".","f","(","runInterpretC",".","hdl",")","sig",")",")","(","go","m",")","where","go","::","InterpretC","s","eff","m","x","->","Const","(","m","x",")","s","go","(","InterpretC","m",")","=","Const","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Interpret.hs#L71-L74","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Interpret.hs","hash_val":29980,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Equals sa aa ba `ieq1` Equals sb ab bb = case sa %~ sb of\n        Proved Refl -> aa `ieq` ab && ba `ieq` bb\n        Disproved _ -> False","function_tokens":["Equals","sa","aa","ba","`","ieq1","`","Equals","sb","ab","bb","=","case","sa","%~","sb","of","Proved","Refl","->","aa","`","ieq","`","ab","&&","ba","`","ieq","`","bb","Disproved","_","->","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L42-L46","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"sliceDur","parameters":"(Track _ a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sliceDur (Track _ a) = Track (t1 - t0) a","function_tokens":["sliceDur","(","Track","_","a",")","=","Track","(","t1","-","t0",")","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L166-L166","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"displayException","parameters":"ExpectedEndOfInput","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"displayException ExpectedEndOfInput = \"Unexpected input, expected end of input.\"","function_tokens":["displayException","ExpectedEndOfInput","=","\"Unexpected input, expected end of input.\""],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L199-L199","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"case1","parameters":"i con","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"case1 i con =\n    case con of\n      NormalC  c  fs   -> [one fs c]\n      RecC     c  fs   -> [one fs c]\n      InfixC   _  c  _ -> [( infixP (pats !! 0) c (pats !! 1)\n                          , infixE (Just (vars !! 0)) (conE c) (Just (vars !! 1))\n                          )\n                         ]\n      ForallC  _  _  c -> case1 i c\n#if MIN_VERSION_template_haskell(2,11,0)\n      GadtC    cs fs _ -> map (one fs) cs\n      RecGadtC cs fs _ -> map (one fs) cs\n#endif\n    where fresh     = mkName <$> delete \"f\" (delete \"v\" freshNames)\n          pats1     = varP <$> fresh\n          pats      = take i pats1 ++ [wildP] ++ drop (i + 1) pats1\n          vars1     = varE <$> fresh\n          v         = varE (mkName \"v\")\n          vars      = take i vars1 ++ [v] ++ drop (i + 1) vars1\n          apps f as = foldl appE f as\n          one fs c  = let s = take (length fs) in (conP c (s pats), apps (conE c) (s vars))","function_tokens":["case1","i","con","=","case","con","of","NormalC","c","fs","->","[","one","fs","c","]","RecC","c","fs","->","[","one","fs","c","]","InfixC","_","c","_","->","[","(","infixP","(","pats","!!","0",")","c","(","pats","!!","1",")",",","infixE","(","Just","(","vars","!!","0",")",")","(","conE","c",")","(","Just","(","vars","!!","1",")",")",")","]","ForallC","_","_","c","->","case1","i","c","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","cs","fs","_","->","map","(","one","fs",")","cs","RecGadtC","cs","fs","_","->","map","(","one","fs",")","cs","#endif","where","fresh","=","mkName","<$>","delete","\"f\"","(","delete","\"v\"","freshNames",")","pats1","=","varP","<$>","fresh","pats","=","take","i","pats1","++","[","wildP","]","++","drop","(","i","+","1",")","pats1","vars1","=","varE","<$>","fresh","v","=","varE","(","mkName","\"v\"",")","vars","=","take","i","vars1","++","[","v","]","++","drop","(","i","+","1",")","vars1","apps","f","as","=","foldl","appE","f","as","one","fs","c","=","let","s","=","take","(","length","fs",")","in","(","conP","c","(","s","pats",")",",","apps","(","conE","c",")","(","s","vars",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L532-L554","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"iconPath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"iconPath = iconDir <\/> exeFp <.> \"svg\"","function_tokens":["iconPath","=","iconDir","<\/>","exeFp","<.>","\"svg\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L37-L37","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"lookupGHEvent","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookupGHEvent = lookup \"X-Github-Event\"","function_tokens":["lookupGHEvent","=","lookup","\"X-Github-Event\""],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L354-L354","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"withBar","parameters":"bars","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withBar bars   = \"|  \":bars","function_tokens":["withBar","bars","=","\"|  \"",":","bars"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L827-L827","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getFilePath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getFilePath = ZipArchive (gets zsFilePath)","function_tokens":["getFilePath","=","ZipArchive","(","gets","zsFilePath",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L672-L672","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Sides {sideA, sideBase, sideB} = cBodies","function_tokens":["Sides","{","sideA",",","sideBase",",","sideB","}","=","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L41-L41","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"maxWidth","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maxWidth = fmap (\\c -> c - 16) columns","function_tokens":["maxWidth","=","fmap","(","\\","c","->","c","-","16",")","columns"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L64-L64","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInExpo","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease in exponential.","docstring_summary":"Ease in exponential.","docstring_tokens":["Ease","in","exponential","."],"function":"easeInExpo c t b =  let e = 10 * (realToFrac t - 1) in c * (2**e) + b","function_tokens":["easeInExpo","c","t","b","=","let","e","=","10","*","(","realToFrac","t","-","1",")","in","c","*","(","2","**","e",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L138-L138","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"gets","parameters":"","argument_list":"","return_statement":"","docstring":"Get a value out of the state, pointed to by the specified lens.","docstring_summary":"Get a value out of the state, pointed to by the specified lens.","docstring_tokens":["Get","a","value","out","of","the","state","pointed","to","by","the","specified","lens","."],"function":"gets = State.gets . Total.get","function_tokens":["gets","=","State","gets",".","Total","get"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L31-L31","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Rhythm _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Rhythm _)               = \"R\"","function_tokens":["go","(","Rhythm","_",")","=","\"R\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L351-L351","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"fg","parameters":"c (Stylized m t)","argument_list":"","return_statement":"","docstring":"Set the foreground color.  For example:  @ \"Hello World!\" <> fg magenta @  @since 1.0.0.0","docstring_summary":"Set the foreground color.  For example:","docstring_tokens":["Set","the","foreground","color",".","For","example",":"],"function":"fg c (Stylized m t) = Stylized (m {modColorFG = OnlyOne (Just c)}) t","function_tokens":["fg","c","(","Stylized","m","t",")","=","Stylized","(","m","{","modColorFG","=","OnlyOne","(","Just","c",")","}",")","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L96-L96","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"log","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"log = fmap log","function_tokens":["log","=","fmap","log"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L248-L248","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"repositoryKey","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"repositoryKey f = dynamicKey f getFullName","function_tokens":["repositoryKey","f","=","dynamicKey","f","getFullName"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L213-L213","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"menuBanner","parameters":"b m","argument_list":"","return_statement":"","docstring":"Change the banner of a menu.  The banner is printed just before the menu items are displayed.  @since 1.0.0.0","docstring_summary":"Change the banner of a menu.  The banner is printed just before the menu items are displayed.","docstring_tokens":["Change","the","banner","of","a","menu",".","The","banner","is","printed","just","before","the","menu","items","are","displayed","."],"function":"menuBanner b m = m {_menuBanner = Just (toStylizedText b)}","function_tokens":["menuBanner","b","m","=","m","{","_menuBanner","=","Just","(","toStylizedText","b",")","}"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L170-L170","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Title a)","argument_list":"","return_statement":"","docstring":"TODO","docstring_summary":"TODO","docstring_tokens":["TODO"],"function":"go (Title a)                = a","function_tokens":["go","(","Title","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L425-L425","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"itraverse","parameters":"f (And as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (And as) = And <$> traverse f as","function_tokens":["itraverse","f","(","And","as",")","=","And","<$>","traverse","f","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L375-L375","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(DeleteEntry s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (DeleteEntry s) = Just s","function_tokens":["targetEntry","(","DeleteEntry","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1056-L1056","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"subst","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subst = concat (snd <$> vals)","function_tokens":["subst","=","concat","(","snd","<$>","vals",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L318-L318","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"resetBuffer","parameters":"(Buffer a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resetBuffer (Buffer a) = Buffer $ fmap (const mempty) a","function_tokens":["resetBuffer","(","Buffer","a",")","=","Buffer","$","fmap","(","const","mempty",")","a"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L166-L166","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"And as `ieq1` And bs = foldr (&&) True $ zipWith ieq as bs","function_tokens":["And","as","`","ieq1","`","And","bs","=","foldr","(","&&",")","True","$","zipWith","ieq","as","bs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L343-L343","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,found,gt) = splitMember' x r","function_tokens":["(","lt",",","found",",","gt",")","=","splitMember'","x","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L561-L561","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"asText","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"asText i = renderText Plain (toStylizedText i)","function_tokens":["asText","i","=","renderText","Plain","(","toStylizedText","i",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L109-L109","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"originId","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"originId = nodeId node","function_tokens":["originId","=","nodeId","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L146-L146","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Throw e)   -> Left e\n    R (Catch m h) -> either (hdl . (<$ ctx) . h) pure (hdl (m <$ ctx))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Throw","e",")","->","Left","e","R","(","Catch","m","h",")","->","either","(","hdl",".","(","<$","ctx",")",".","h",")","pure","(","hdl","(","m","<$","ctx",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L162-L165","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"styles","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"styles =\n        [ (\"vertical\",         LanguagePragmas.Vertical)\n        , (\"compact\",          LanguagePragmas.Compact)\n        , (\"compact_line\",     LanguagePragmas.CompactLine)\n        , (\"vertical_compact\", LanguagePragmas.VerticalCompact)\n        ]","function_tokens":["styles","=","[","(","\"vertical\"",",","LanguagePragmas","Vertical",")",",","(","\"compact\"",",","LanguagePragmas","Compact",")",",","(","\"compact_line\"",",","LanguagePragmas","CompactLine",")",",","(","\"vertical_compact\"",",","LanguagePragmas","VerticalCompact",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L336-L341","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"displayMenu","parameters":"","argument_list":"","return_statement":"","docstring":"Print the entire menu.","docstring_summary":"Print the entire menu.","docstring_tokens":["Print","the","entire","menu","."],"function":"displayMenu = do\n      maybe pass ((<> text \"\\n\") >>> sayLn) (_menuBanner m)\n      cache <- foldlM listItem mempty (zip [1 ..] (toList $ _menuItems m))\n      sayLn (maybe mempty (text \"\\n\" <>) (_menuBeforePrompt m))\n      pure cache\n    -- Print a menu item and cache its prefix in a Map.","function_tokens":["displayMenu","=","do","maybe","pass","(","(","<>","text","\"\\n\"",")",">>>","sayLn",")","(","_menuBanner","m",")","cache","<-","foldlM","listItem","mempty","(","zip","[","1","..","]","(","toList","$","_menuItems","m",")",")","sayLn","(","maybe","mempty","(","text","\"\\n\"","<>",")","(","_menuBeforePrompt","m",")",")","pure","cache","-- Print a menu item and cache its prefix in a Map."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L225-L231","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"isCentralDirHeader","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isCentralDirHeader = headerType == CentralDirHeader","function_tokens":["isCentralDirHeader","=","headerType","==","CentralDirHeader"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L813-L813","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Nil `compare` Bin _ _ _ _ _ _ = LT","function_tokens":["Nil","`","compare","`","Bin","_","_","_","_","_","_","=","LT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L849-L849","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"m","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m = branchMask p1 p2","function_tokens":["m","=","branchMask","p1","p2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L894-L894","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Error\/Either.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ErrorC (ExceptT l) <|> ErrorC (ExceptT r) = ErrorC (ExceptT (l <|> r))","function_tokens":["ErrorC","(","ExceptT","l",")","<|>","ErrorC","(","ExceptT","r",")","=","ErrorC","(","ExceptT","(","l","<|>","r",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Error\/Either.hs#L54-L54","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Error\/Either.hs","hash_val":17343,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getLabel","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getLabel = getCString","function_tokens":["getLabel","=","getCString"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L119-L119","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"attachModuleComment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"attachModuleComment = putMaybeLineComment $ GHC.unLoc <$> mbModuleComment","function_tokens":["attachModuleComment","=","putMaybeLineComment","$","GHC","unLoc","<$>","mbModuleComment"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L170-L170","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"hours","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hours = todHour tod","function_tokens":["hours","=","todHour","tod"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1178-L1178","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"unsafeLiftIx","parameters":"","argument_list":"","return_statement":"","docstring":"---------------------------------------------------------------------------- Lift an 'm' action into 'Ix m', changing the current index. 'unsafeLiftIx' is obviously unsafe due to the fact that it can arbitrarily change the index.","docstring_summary":"---------------------------------------------------------------------------- Lift an 'm' action into 'Ix m', changing the current index. 'unsafeLiftIx' is obviously unsafe due to the fact that it can arbitrarily change the index.","docstring_tokens":["----------------------------------------------------------------------------","Lift","an","m","action","into","Ix","m","changing","the","current","index",".","unsafeLiftIx","is","obviously","unsafe","due","to","the","fact","that","it","can","arbitrarily","change","the","index","."],"function":"unsafeLiftIx = coerce","function_tokens":["unsafeLiftIx","=","coerce"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L81-L81","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseSignal","parameters":"peer","argument_list":"","return_statement":"","docstring":"Parses the parsable parts of a signal","docstring_summary":"Parses the parsable parts of a signal","docstring_tokens":["Parses","the","parsable","parts","of","a","signal"],"function":"parseSignal peer = do\n    cId <- parseCommandId\n    id <- parseSerialize\n    cmd <- parseCommand cId\n    let node = Node peer id\n    return $ Signal node cmd\n\n-- | Parses a Serialize","function_tokens":["parseSignal","peer","=","do","cId","<-","parseCommandId","id","<-","parseSerialize","cmd","<-","parseCommand","cId","let","node","=","Node","peer","id","return","$","Signal","node","cmd","-- | Parses a Serialize"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L35-L43","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"mkEntrySelector","parameters":"path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkEntrySelector path =\n  let f x =\n        case filter (not . FP.isPathSeparator) x of\n          [] -> Nothing\n          xs -> Just (CI.mk xs)\n      giveup = throwM (InvalidEntrySelector path)\n   in case NE.nonEmpty (mapMaybe f (FP.splitPath path)) of\n        Nothing -> giveup\n        Just pieces ->\n          let selector = EntrySelector pieces\n              binLength = B.length . T.encodeUtf8 . getEntryName\n           in if Posix.isValid path\n                && Windows.isValid path\n                && not (FP.isAbsolute path || FP.hasTrailingPathSeparator path)\n                && (CI.mk \".\" `notElem` pieces)\n                && (CI.mk \"..\" `notElem` pieces)\n                && binLength selector <= 0xffff\n                then return selector\n                else giveup\n\n-- | Restore a relative path from 'EntrySelector'. Every 'EntrySelector'\n-- corresponds to a 'FilePath'.","function_tokens":["mkEntrySelector","path","=","let","f","x","=","case","filter","(","not",".","FP","isPathSeparator",")","x","of","[","]","->","Nothing","xs","->","Just","(","CI","mk","xs",")","giveup","=","throwM","(","InvalidEntrySelector","path",")","in","case","NE","nonEmpty","(","mapMaybe","f","(","FP","splitPath","path",")",")","of","Nothing","->","giveup","Just","pieces","->","let","selector","=","EntrySelector","pieces","binLength","=","B","length",".","T","encodeUtf8",".","getEntryName","in","if","Posix","isValid","path","&&","Windows","isValid","path","&&","not","(","FP","isAbsolute","path","||","FP","hasTrailingPathSeparator","path",")","&&","(","CI","mk","\".\"","`","notElem","`","pieces",")","&&","(","CI","mk","\"..\"","`","notElem","`","pieces",")","&&","binLength","selector","<=","0xffff","then","return","selector","else","giveup","-- | Restore a relative path from 'EntrySelector'. Every 'EntrySelector'","-- corresponds to a 'FilePath'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L97-L119","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"makeCabal","parameters":"Cabal","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeCabal Cabal = justDoIt $ callProcess \"hpack\" []","function_tokens":["makeCabal","Cabal","=","justDoIt","$","callProcess","\"hpack\"","[","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L62-L62","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"new","parameters":"","argument_list":"","return_statement":"","docstring":"Create a mutable matrix without initialization","docstring_summary":"Create a mutable matrix without initialization","docstring_tokens":["Create","a","mutable","matrix","without","initialization"],"function":"new = MG.new","function_tokens":["new","=","MG","new"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L46-L46","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"underline","parameters":"(Stylized m t)","argument_list":"","return_statement":"","docstring":"Produce underlined text.  @since 1.0.0.0","docstring_summary":"Produce underlined text.","docstring_tokens":["Produce","underlined","text","."],"function":"underline (Stylized m t) = Stylized (m {modUnderline = On}) t","function_tokens":["underline","(","Stylized","m","t",")","=","Stylized","(","m","{","modUnderline","=","On","}",")","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L117-L117","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"whereComment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"whereComment =\n            guard (whereLine \/= moduleLine) >> whereLine >>= commentOnLine","function_tokens":["whereComment","=","guard","(","whereLine","\/=","moduleLine",")",">>","whereLine",">>=","commentOnLine"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L98-L99","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"readListPrec","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readListPrec = readListPrecDefault","function_tokens":["readListPrec","=","readListPrecDefault"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L880-L880","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_DIRECTION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_DIRECTION                        = 0x1005","function_tokens":["al_DIRECTION","=","0x1005"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L89-L89","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmp","parameters":"t1@(Bin _ _ p1 m1 l1 r1) (Bin _ _ p2 m2 l2 r2)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subsetCmp t1@(Bin _ _ p1 m1 l1 r1) (Bin _ _ p2 m2 l2 r2)\n  | shorter m1 m2  = GT\n  | shorter m2 m1  = case subsetCmpLt of\n                       GT -> GT\n                       _ -> LT\n  | p1 == p2       = subsetCmpEq\n  | otherwise      = GT  -- disjoint\n  where\n    subsetCmpLt | nomatch p1 p2 m2  = GT\n                | zero p1 m2        = subsetCmp t1 l2\n                | otherwise         = subsetCmp t1 r2\n    subsetCmpEq = case (subsetCmp l1 l2, subsetCmp r1 r2) of\n                    (GT,_ ) -> GT\n                    (_ ,GT) -> GT\n                    (EQ,EQ) -> EQ\n                    _       -> LT","function_tokens":["subsetCmp","t1","@","(","Bin","_","_","p1","m1","l1","r1",")","(","Bin","_","_","p2","m2","l2","r2",")","|","shorter","m1","m2","=","GT","|","shorter","m2","m1","=","case","subsetCmpLt","of","GT","->","GT","_","->","LT","|","p1","==","p2","=","subsetCmpEq","|","otherwise","=","GT","-- disjoint","where","subsetCmpLt","|","nomatch","p1","p2","m2","=","GT","|","zero","p1","m2","=","subsetCmp","t1","l2","|","otherwise","=","subsetCmp","t1","r2","subsetCmpEq","=","case","(","subsetCmp","l1","l2",",","subsetCmp","r1","r2",")","of","(","GT",",","_",")","->","GT","(","_",",","GT",")","->","GT","(","EQ",",","EQ",")","->","EQ","_","->","LT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L452-L469","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"fold","parameters":"f z t","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nFold\n------------------------------------------------------------------} \/O(n)\/. Fold over the elements of a set in an unspecified order.  > sum set   == fold (+) 0 set > elems set == fold (:) [] set","docstring_summary":"{--------------------------------------------------------------------\nFold\n------------------------------------------------------------------} \/O(n)\/. Fold over the elements of a set in an unspecified order.  > sum set   == fold (+) 0 set > elems set == fold (:) [] set","docstring_tokens":["{","--------------------------------------------------------------------","Fold","------------------------------------------------------------------","}","\/","O","(","n",")","\/",".","Fold","over","the","elements","of","a","set","in","an","unspecified","order",".",">","sum","set","==","fold","(","+",")","0","set",">","elems","set","==","fold","(",":",")","[]","set"],"function":"fold f z t\n  = case t of\n      Bin _ _ 0 m l r | m < 0 -> foldr f (foldr f z l) r\n      -- put negative numbers before.\n      Bin _ _ _ _ _ _ -> foldr f z t\n      Tip _ x         -> f x z\n      Nil             -> z","function_tokens":["fold","f","z","t","=","case","t","of","Bin","_","_","0","m","l","r","|","m","<","0","->","foldr","f","(","foldr","f","z","l",")","r","-- put negative numbers before.","Bin","_","_","_","_","_","_","->","foldr","f","z","t","Tip","_","x","->","f","x","z","Nil","->","z"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L689-L697","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"set","parameters":"p","argument_list":"","return_statement":"","docstring":"Get the setter category from a Point.","docstring_summary":"Get the setter category from a Point.","docstring_tokens":["Get","the","setter","category","from","a","Point","."],"function":"set p = modify p . first (arr const)","function_tokens":["set","p","=","modify","p",".","first","(","arr","const",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L72-L72","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"show","parameters":"ErrorOnFormatExitBehavior","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show ErrorOnFormatExitBehavior = \"error_on_format\"","function_tokens":["show","ErrorOnFormatExitBehavior","=","\"error_on_format\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L80-L80","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"moduleComment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moduleComment = moduleLine >>= commentOnLine","function_tokens":["moduleComment","=","moduleLine",">>=","commentOnLine"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L97-L97","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"cases'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cases' = groupAlign (cCases conf) cases","function_tokens":["cases'","=","groupAlign","(","cCases","conf",")","cases"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L109-L109","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"findMax","parameters":"(Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findMax (Tip _ x) = x","function_tokens":["findMax","(","Tip","_","x",")","=","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L651-L651","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putDouble","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putDouble = putFloat64le","function_tokens":["putDouble","=","putFloat64le"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L121-L121","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictSourceRelative","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictSourceRelative = Dictionary {\n   alGetter  = alGetSourceiv,\n   alSetter  = alSourceiv,\n   size      = 1,\n   peekSize  = peek1 (unmarshalSourceRelative . unmarshalALboolean . fromIntegral),\n   marshal   = fromIntegral . marshalALboolean . marshalSourceRelative }","function_tokens":["dictSourceRelative","=","Dictionary","{","alGetter","=","alGetSourceiv",",","alSetter","=","alSourceiv",",","size","=","1",",","peekSize","=","peek1","(","unmarshalSourceRelative",".","unmarshalALboolean",".","fromIntegral",")",",","marshal","=","fromIntegral",".","marshalALboolean",".","marshalSourceRelative","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L523-L528","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"replicate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"replicate = MG.replicate","function_tokens":["replicate","=","MG","replicate"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L49-L49","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"assertSort","parameters":"n s","argument_list":"","return_statement":"","docstring":"Asserts what sort is assigned to a variable in current context.","docstring_summary":"Asserts what sort is assigned to a variable in current context.","docstring_tokens":["Asserts","what","sort","is","assigned","to","a","variable","in","current","context","."],"function":"assertSort n s = do\n    ss <- ask\n    ds <- lift get\n\n    case n `lookup` (ss `union` ds) of\n        Just s' -> when (s \/= s') $ fail \"sort mismatch\"\n        Nothing -> lift $ modify (insert n s)\n\n-- | Variable assumes sort based on current context.","function_tokens":["assertSort","n","s","=","do","ss","<-","ask","ds","<-","lift","get","case","n","`","lookup","`","(","ss","`","union","`","ds",")","of","Just","s'","->","when","(","s","\/=","s'",")","$","fail","\"sort mismatch\"","Nothing","->","lift","$","modify","(","insert","n","s",")","-- | Variable assumes sort based on current context."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L130-L139","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"needsUnicode","parameters":"","argument_list":"","return_statement":"","docstring":"Detect if the given text needs newer Unicode-aware features to be properly encoded in the archive.","docstring_summary":"Detect if the given text needs newer Unicode-aware features to be properly encoded in the archive.","docstring_tokens":["Detect","if","the","given","text","needs","newer","Unicode","-","aware","features","to","be","properly","encoded","in","the","archive","."],"function":"needsUnicode = not . T.all validCP437\n  where\n    validCP437 x = ord x <= 127\n\n-- | Convert numeric representation (as per the .ZIP specification) of\n-- version into 'Version'.","function_tokens":["needsUnicode","=","not",".","T","all","validCP437","where","validCP437","x","=","ord","x","<=","127","-- | Convert numeric representation (as per the .ZIP specification) of","-- version into 'Version'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1085-L1091","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","language":"haskell","identifier":"dim","parameters":"(SymMMatrix n _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim (SymMMatrix n _) = (n,n)","function_tokens":["dim","(","SymMMatrix","n","_",")","=","(","n",",","n",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs#L26-L26","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","hash_val":33107,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(!) = (MG.!)","function_tokens":["(","!",")","=","(","MG","!",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L126-L126","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"ef","parameters":"k v (Just m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ef k v (Just m) = Just (M.insert k v m)","function_tokens":["ef","k","v","(","Just","m",")","=","Just","(","M","insert","k","v","m",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L442-L442","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"new","parameters":"","argument_list":"","return_statement":"","docstring":"Create an empty group of threads.","docstring_summary":"Create an empty group of threads.","docstring_tokens":["Create","an","empty","group","of","threads","."],"function":"new = fmap ThreadGroup $ newTVarIO 0","function_tokens":["new","=","fmap","ThreadGroup","$","newTVarIO","0"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L115-L115","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Trace\/Returning.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Trace m) -> ctx <$ TraceC (tell (Endo (m :)))\n    R other     -> TraceC (alg (runTraceC . hdl) (R other) ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Trace","m",")","->","ctx","<$","TraceC","(","tell","(","Endo","(","m",":",")",")",")","R","other","->","TraceC","(","alg","(","runTraceC",".","hdl",")","(","R","other",")","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Trace\/Returning.hs#L50-L53","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Trace\/Returning.hs","hash_val":3401,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"bench\/bench.hs","language":"haskell","identifier":"benchlen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchlen = 10000","function_tokens":["benchlen","=","10000"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/bench\/bench.hs#L29-L29","hash_key":"bartavelle\/stateWriter:bench\/bench.hs","hash_val":16621,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"for","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"for = (>-)","function_tokens":["for","=","(",">-",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L112-L112","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putForAll","parameters":"forall ex_tvs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putForAll forall ex_tvs = when forall do\n    putText \"forall\"\n    space\n    sep space $ putOutputable . GHC.unLoc <$> ex_tvs\n    dot\n    space","function_tokens":["putForAll","forall","ex_tvs","=","when","forall","do","putText","\"forall\"","space","sep","space","$","putOutputable",".","GHC","unLoc","<$>","ex_tvs","dot","space"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L471-L478","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"sustain","parameters":"a","argument_list":"","return_statement":"","docstring":"After this transformation events last longer by some constant amount of time.","docstring_summary":"After this transformation events last longer by some constant amount of time.","docstring_tokens":["After","this","transformation","events","last","longer","by","some","constant","amount","of","time","."],"function":"sustain a = mapEvents $ \\e -> e{ eventDur = a + eventDur e }","function_tokens":["sustain","a","=","mapEvents","$","\\","e","->","e","{","eventDur","=","a","+","eventDur","e","}"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L250-L250","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = ConduitParser . lift . lift . lift","function_tokens":["lift","=","ConduitParser",".","lift",".","lift",".","lift"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L42-L42","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"isSubsetOf","parameters":"(Bin _ _ _ _ _ _) _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSubsetOf (Bin _ _ _ _ _ _) _  = False","function_tokens":["isSubsetOf","(","Bin","_","_","_","_","_","_",")","_","=","False"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L488-L488","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"instantiate","parameters":"a' (Store (is :: Sing is) es a i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"instantiate a' (Store (is :: Sing is) es a i e) = case quantify (Proxy :: Proxy g) is of\n        Just q -> Just $ do\n            ns <- get\n\n            let j :: forall f. VarF :<: f => IFix f is\n                j = inject $ Var n is\n\n                (n, ns') = runCoiter ns\n\n            put ns'\n\n            return $ inject (Equals es (inject (Select is es a' i)) e) .&. q [j] (not (inject (Equals is i j)) .->. inject (Equals es (inject (Select is es a' j)) (inject (Select is es a j))))\n        Nothing -> Nothing","function_tokens":["instantiate","a'","(","Store","(","is","::","Sing","is",")","es","a","i","e",")","=","case","quantify","(","Proxy","::","Proxy","g",")","is","of","Just","q","->","Just","$","do","ns","<-","get","let","j","::","forall","f",".","VarF",":<:","f","=>","IFix","f","is","j","=","inject","$","Var","n","is","(","n",",","ns'",")","=","runCoiter","ns","put","ns'","return","$","inject","(","Equals","es","(","inject","(","Select","is","es","a'","i",")",")","e",")",".&.","q","[","j","]","(","not","(","inject","(","Equals","is","i","j",")",")",".->.","inject","(","Equals","es","(","inject","(","Select","is","es","a'","j",")",")","(","inject","(","Select","is","es","a","j",")",")",")",")","Nothing","->","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L901-L914","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"secOffset","parameters":"","argument_list":"","return_statement":"","docstring":"'secOffset' contains the playback position, expressed in seconds (the value will loop back to zero for looping sources).  When setting 'secOffset' on a source which is already playing, the playback will jump to the new offset unless the new offset is out of range, in which case an 'ALInvalidValue' error is set. If the source is not playing, then the offset will be applied on the next 'play' call.  The position is relative to the beginning of all the queued buffers for the source, and any queued buffers traversed by a set call will be marked as processed.  This value is based on byte position, so a pitch-shifted source will have an exaggerated playback speed. For example, you can be 0.5 seconds into a buffer having taken only 0.25 seconds to get there if the pitch is set to 2.","docstring_summary":"'secOffset' contains the playback position, expressed in seconds (the value will loop back to zero for looping sources).  When setting 'secOffset' on a source which is already playing, the playback will jump to the new offset unless the new offset is out of range, in which case an 'ALInvalidValue' error is set. If the source is not playing, then the offset will be applied on the next 'play' call.  The position is relative to the beginning of all the queued buffers for the source, and any queued buffers traversed by a set call will be marked as processed.  This value is based on byte position, so a pitch-shifted source will have an exaggerated playback speed. For example, you can be 0.5 seconds into a buffer having taken only 0.25 seconds to get there if the pitch is set to 2.","docstring_tokens":["secOffset","contains","the","playback","position","expressed","in","seconds","(","the","value","will","loop","back","to","zero","for","looping","sources",")",".","When","setting","secOffset","on","a","source","which","is","already","playing","the","playback","will","jump","to","the","new","offset","unless","the","new","offset","is","out","of","range","in","which","case","an","ALInvalidValue","error","is","set",".","If","the","source","is","not","playing","then","the","offset","will","be","applied","on","the","next","play","call",".","The","position","is","relative","to","the","beginning","of","all","the","queued","buffers","for","the","source","and","any","queued","buffers","traversed","by","a","set","call","will","be","marked","as","processed",".","This","value","is","based","on","byte","position","so","a","pitch","-","shifted","source","will","have","an","exaggerated","playback","speed",".","For","example","you","can","be","0",".","5","seconds","into","a","buffer","having","taken","only","0",".","25","seconds","to","get","there","if","the","pitch","is","set","to","2","."],"function":"secOffset = makeSourceStateVar dictALfloat GetSecOffset","function_tokens":["secOffset","=","makeSourceStateVar","dictALfloat","GetSecOffset"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L455-L455","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"identify","parameters":"i (UTip j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identify i (UTip j) = Tip i j","function_tokens":["identify","i","(","UTip","j",")","=","Tip","i","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L210-L210","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"store","parameters":"a i v","argument_list":"","return_statement":"","docstring":"A smart constructor for store","docstring_summary":"A smart constructor for store","docstring_tokens":["A","smart","constructor","for","store"],"function":"store a i v = inject (Store sing sing a i v)","function_tokens":["store","a","i","v","=","inject","(","Store","sing","sing","a","i","v",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L118-L118","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"mkIndexStep","parameters":"is as zs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkIndexStep is as zs | isLen == asLen && asLen == zsLen = Step go isLen\n  where isLen = BS.length is\n        asLen = BS.length as\n        zsLen = BS.length zs\n        (isFptr, _, _) = BSI.toForeignPtr is\n        (asFptr, _, _) = BSI.toForeignPtr as\n        (zsFptr, _, _) = BSI.toForeignPtr zs\n        go  :: BpState\n            -> DVSM.MVector s Word64\n            -> ST s Int\n        go bpState bpvm = fmap fromIntegral . ST.unsafeIOToST $ do\n          let (outFptr, _, _) = DVSM.unsafeToForeignPtr bpvm\n\n          F.withForeignPtr outFptr $ \\outPtr ->\n            F.withForeignPtr isFptr $ \\isPtr ->\n              F.withForeignPtr asFptr $ \\asPtr ->\n                F.withForeignPtr zsFptr $ \\zsPtr ->\n                  F.withForeignPtr (bpStateP bpState) $ \\bpStatePtr -> do\n                    F.writeBpChunk\n                      (F.castPtr isPtr)\n                      (F.castPtr asPtr)\n                      (F.castPtr zsPtr)\n                      (fromIntegral (BS.length is))\n                      (F.castPtr bpStatePtr)\n                      (F.castPtr outPtr)","function_tokens":["mkIndexStep","is","as","zs","|","isLen","==","asLen","&&","asLen","==","zsLen","=","Step","go","isLen","where","isLen","=","BS","length","is","asLen","=","BS","length","as","zsLen","=","BS","length","zs","(","isFptr",",","_",",","_",")","=","BSI","toForeignPtr","is","(","asFptr",",","_",",","_",")","=","BSI","toForeignPtr","as","(","zsFptr",",","_",",","_",")","=","BSI","toForeignPtr","zs","go","::","BpState","->","DVSM","MVector","s","Word64","->","ST","s","Int","go","bpState","bpvm","=","fmap","fromIntegral",".","ST","unsafeIOToST","$","do","let","(","outFptr",",","_",",","_",")","=","DVSM","unsafeToForeignPtr","bpvm","F","withForeignPtr","outFptr","$","\\","outPtr","->","F","withForeignPtr","isFptr","$","\\","isPtr","->","F","withForeignPtr","asFptr","$","\\","asPtr","->","F","withForeignPtr","zsFptr","$","\\","zsPtr","->","F","withForeignPtr","(","bpStateP","bpState",")","$","\\","bpStatePtr","->","do","F","writeBpChunk","(","F","castPtr","isPtr",")","(","F","castPtr","asPtr",")","(","F","castPtr","zsPtr",")","(","fromIntegral","(","BS","length","is",")",")","(","F","castPtr","bpStatePtr",")","(","F","castPtr","outPtr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L100-L125","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f +++ g = (f >>> arr Left) ||| (g >>> arr Right)","function_tokens":["f","+++","g","=","(","f",">>>","arr","Left",")","|||","(","g",">>>","arr","Right",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L167-L167","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"resolveGen","parameters":"(Sides a base b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resolveGen (Sides a base b)\n    | a == base = Just b\n    | b == base = Just a\n    | a == b = Just a\n    | otherwise = Nothing","function_tokens":["resolveGen","(","Sides","a","base","b",")","|","a","==","base","=","Just","b","|","b","==","base","=","Just","a","|","a","==","b","=","Just","a","|","otherwise","=","Nothing"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L23-L27","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars'","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freevars' (InL fa) = freevars' fa","function_tokens":["freevars'","(","InL","fa",")","=","freevars'","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L631-L631","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"runNonDetM","parameters":"leaf","argument_list":"","return_statement":"","docstring":"Run a 'NonDet' effect, mapping results into a 'Monoid'.  @since 1.0.0.0","docstring_summary":"Run a 'NonDet' effect, mapping results into a 'Monoid'.","docstring_tokens":["Run","a","NonDet","effect","mapping","results","into","a","Monoid","."],"function":"runNonDetM leaf = runNonDet (liftA2 mappend) (pure . leaf) (pure mempty)","function_tokens":["runNonDetM","leaf","=","runNonDet","(","liftA2","mappend",")","(","pure",".","leaf",")","(","pure","mempty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L72-L72","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_STATIC","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_STATIC                           = 0x1028","function_tokens":["al_STATIC","=","0x1028"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L100-L100","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Writer.hs","language":"haskell","identifier":"listen","parameters":"m","argument_list":"","return_statement":"","docstring":"Run a computation, returning the pair of its output and its result.  @ runWriter ('listen' m) = 'fmap' ('fst' 'Control.Arrow.&&&' 'id') (runWriter m) @  @since 0.2.0.0","docstring_summary":"Run a computation, returning the pair of its output and its result.","docstring_tokens":["Run","a","computation","returning","the","pair","of","its","output","and","its","result","."],"function":"listen m = send (Listen m)","function_tokens":["listen","m","=","send","(","Listen","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Writer.hs#L57-L57","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Writer.hs","hash_val":30433,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(w, a) = hdl (m <$ ctx)","function_tokens":["(","w",",","a",")","=","hdl","(","m","<$","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L182-L182","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"UserDefined","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go UserDefined              = \"\"","function_tokens":["go","UserDefined","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L426-L426","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"t","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t = dt + leftover","function_tokens":["t","=","dt","+","leftover"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L301-L301","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"_ b@(OnlyOne (Just _))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) _ b@(OnlyOne (Just _)) = b","function_tokens":["(","<>",")","_","b","@","(","OnlyOne","(","Just","_",")",")","=","b"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L65-L65","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"convertPosn","parameters":"file (AlexPn offset line col)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"convertPosn file (AlexPn offset line col) = position offset file line col","function_tokens":["convertPosn","file","(","AlexPn","offset","line","col",")","=","position","offset","file","line","col"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L19-L19","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"filePath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"filePath      = opts ^. L.filePath","function_tokens":["filePath","=","opts","^.","L","filePath"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L28-L28","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"unsafeIndex","parameters":"(SymMatrix n vec) (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeIndex (SymMatrix n vec) (i,j) = vec `G.unsafeIndex` idx n i j","function_tokens":["unsafeIndex","(","SymMatrix","n","vec",")","(","i",",","j",")","=","vec","`","G","unsafeIndex","`","idx","n","i","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L54-L54","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"g","parameters":"st","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g st = st {zsActions = f (zsActions st)}","function_tokens":["g","st","=","st","{","zsActions","=","f","(","zsActions","st",")","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L682-L682","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"liftAll","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftAll m = ChooseC $ \\ fork leaf -> m >>= foldr1 fork . fmap leaf","function_tokens":["liftAll","m","=","ChooseC","$","\\","fork","leaf","->","m",">>=","foldr1","fork",".","fmap","leaf"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L88-L88","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"(FIND_VALUE _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandId (FIND_VALUE _)     = 5","function_tokens":["commandId","(","FIND_VALUE","_",")","=","5"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L31-L31","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"dropBom","parameters":"str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dropBom str              = str","function_tokens":["dropBom","str","=","str"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L55-L55","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_INVALID_CONTEXT","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_INVALID_CONTEXT                 = 0xA002","function_tokens":["alc_INVALID_CONTEXT","=","0xA002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L142-L142","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"failE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"failE   = if failing\n                   then [| failArrow |]\n                   else [| zeroArrow |]","function_tokens":["failE","=","if","failing","then","[","|"," failArrow ","|]","else","[","|"," zeroArrow ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L433-L435","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"color","parameters":"l c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"color l c = case Color.colorAsRGB c of\n                Left (ai,ac) -> ANSI.SetColor l ai ac\n                Right rgb -> ANSI.SetRGBColor l rgb","function_tokens":["color","l","c","=","case","Color","colorAsRGB","c","of","Left","(","ai",",","ac",")","->","ANSI","SetColor","l","ai","ac","Right","rgb","->","ANSI","SetRGBColor","l","rgb"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L201-L204","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(a,s',w') = f r s","function_tokens":["(","a",",","s'",",","w'",")","=","f","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L44-L44","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"3","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand 3 = FIND_NODE `liftM` parseSerialize","function_tokens":["parseCommand","3","=","FIND_NODE","`","liftM","`","parseSerialize"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L127-L127","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/SideDiff.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Sides markerA _ markerB = cMarkers","function_tokens":["Sides","markerA","_","markerB","=","cMarkers"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/SideDiff.hs#L25-L25","hash_key":"Peaker\/git-mediate:src\/SideDiff.hs","hash_val":4146,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"execRSST","parameters":"m r s","argument_list":"","return_statement":"","docstring":"^computation yielding final state and output","docstring_summary":"^computation yielding final state and output","docstring_tokens":["^computation","yielding","final","state","and","output"],"function":"execRSST m r s = do\n        (_, s', w) <- runRSST m r s\n        return (s', w)\n\n-- | @'withRSST' f m@ executes action @m@ with an initial environment\n-- and state modified by applying @f@.\n--\n-- * @'runRSST' ('withRSST' f m) r s = 'uncurry' ('runRSST' m) (f r s)@","function_tokens":["execRSST","m","r","s","=","do","(","_",",","s'",",","w",")","<-","runRSST","m","r","s","return","(","s'",",","w",")","-- | @'withRSST' f m@ executes action @m@ with an initial environment","-- and state modified by applying @f@.","--","-- * @'runRSST' ('withRSST' f m) r s = 'uncurry' ('runRSST' m) (f r s)@"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L109-L117","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"digit","parameters":"","argument_list":"","return_statement":"","docstring":"Matches a given digit.","docstring_summary":"Matches a given digit.","docstring_tokens":["Matches","a","given","digit","."],"function":"digit = lift . lift $ A.digit","function_tokens":["digit","=","lift",".","lift","$","A","digit"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L93-L93","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(name, cons, vars) =\n          case dec of\n#if MIN_VERSION_template_haskell(2,11,0)\n            DataD    _ n vs _ cs _ -> (n, cs,  vs)\n            NewtypeD _ n vs _ c  _ -> (n, [c], vs)\n#else\n            DataD    _ n vs cs _ -> (n, cs,  vs)\n            NewtypeD _ n vs c  _ -> (n, [c], vs)\n#endif\n            _ -> fclError \"Can only derive labels for datatypes and newtypes.\"\n\n        -- We are only interested in lenses of record constructors.","function_tokens":["(","name",",","cons",",","vars",")","=","case","dec","of","#if MIN_VERSION_template_haskell(2,11,0)","DataD","_","n","vs","_","cs","_","->","(","n",",","cs",",","vs",")","NewtypeD","_","n","vs","_","c","_","->","(","n",",","[","c","]",",","vs",")","#else\n            DataD    _ n vs cs _ -> (n, cs,  vs)\n            NewtypeD _ n vs c  _ -> (n, [c], vs)\n","#endif","_","->","fclError","\"Can only derive labels for datatypes and newtypes.\"","-- We are only interested in lenses of record constructors."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L296-L308","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"w","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"w       = cacheWidth result","function_tokens":["w","=","cacheWidth","result"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L52-L52","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fsTys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fsTys = map (typeVariables . trd) (delete f fs)","function_tokens":["fsTys","=","map","(","typeVariables",".","trd",")","(","delete","f","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L364-L364","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"a@(And [])","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' a@(And []) = Just (True, return . inject $ a)","function_tokens":["bind'","a","@","(","And","[","]",")","=","Just","(","True",",","return",".","inject","$","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L811-L811","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_,cmnts) = parseComments (joinBrokenLines code)","function_tokens":["(","_",",","cmnts",")","=","parseComments","(","joinBrokenLines","code",")"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L56-L56","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"entryName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"entryName = getEntryName s","function_tokens":["entryName","=","getEntryName","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L819-L819","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"t","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t = 0.5 * (ax - 3)","function_tokens":["t","=","0.5","*","(","ax","-","3",")"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L59-L59","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"getDistricts","parameters":"filepath","argument_list":"","return_statement":"","docstring":"Given the path to a shapefile, return a list of districts","docstring_summary":"Given the path to a shapefile, return a list of districts","docstring_tokens":["Given","the","path","to","a","shapefile","return","a","list","of","districts"],"function":"getDistricts filepath = do\n        dbfExists <- doesFileExist (stripExt filepath <> \".dbf\")\n        file <- if dbfExists then readShpWithDbf filepath else readShpFile filepath\n        let districtLabels = fromJust $ (fmap labels) $ mapM (shpRecLabel) . shpRecs $ file -- labels + field descriptions?\n        let shapes = (map (getPolygon . fromJust . shpRecContents)) . shpRecs $ file\n        let perimeters = map (totalPerimeter . getPolygon . fromJust . shpRecContents) . shpRecs $ file\n        let areas = map (fmap areaPolygon . getPolygon . fromJust . shpRecContents) . shpRecs $ file\n        let compacticity = map (relativeCompactness . concat . getPolygon . fromJust . shpRecContents) . shpRecs $ file\n        pure $ zipWith5 (\\a b c d e -> District a b c d e) shapes districtLabels perimeters areas compacticity\n\n-- | Helper function for extracting from shapefiles.","function_tokens":["getDistricts","filepath","=","do","dbfExists","<-","doesFileExist","(","stripExt","filepath","<>","\".dbf\"",")","file","<-","if","dbfExists","then","readShpWithDbf","filepath","else","readShpFile","filepath","let","districtLabels","=","fromJust","$","(","fmap","labels",")","$","mapM","(","shpRecLabel",")",".","shpRecs","$","file","-- labels + field descriptions?","let","shapes","=","(","map","(","getPolygon",".","fromJust",".","shpRecContents",")",")",".","shpRecs","$","file","let","perimeters","=","map","(","totalPerimeter",".","getPolygon",".","fromJust",".","shpRecContents",")",".","shpRecs","$","file","let","areas","=","map","(","fmap","areaPolygon",".","getPolygon",".","fromJust",".","shpRecContents",")",".","shpRecs","$","file","let","compacticity","=","map","(","relativeCompactness",".","concat",".","getPolygon",".","fromJust",".","shpRecContents",")",".","shpRecs","$","file","pure","$","zipWith5","(","\\","a","b","c","d","e","->","District","a","b","c","d","e",")","shapes","districtLabels","perimeters","areas","compacticity","-- | Helper function for extracting from shapefiles."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L66-L77","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DBin p m l r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DBin p m l r) = s `hashWithSalt` (2 :: Int) `hashWithSalt` p `hashWithSalt` m `hashWithSalt` l `hashWithSalt` r","function_tokens":["hashWithSalt","s","(","DBin","p","m","l","r",")","=","s","`","hashWithSalt","`","(","2","::","Int",")","`","hashWithSalt","`","p","`","hashWithSalt","`","m","`","hashWithSalt","`","l","`","hashWithSalt","`","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L217-L217","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"prompt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prompt = toString (renderText renderMode s)","function_tokens":["prompt","=","toString","(","renderText","renderMode","s",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L217-L217","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Utils.hs","language":"haskell","identifier":"checkTestTree","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkTestTree t = case t of\n  Leaf   n p  ->        putStrLn n  *> check p                   <* putStrLn \"\"\n  Branch n ts -> and <$ putStrLn n <*> traverse checkTestTree ts <* putStrLn \"\"","function_tokens":["checkTestTree","t","=","case","t","of","Leaf","n","p","->","putStrLn","n","*>","check","p","<*","putStrLn","\"\"","Branch","n","ts","->","and","<$","putStrLn","n","<*>","traverse","checkTestTree","ts","<*","putStrLn","\"\""],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Utils.hs#L12-L16","hash_key":"fused-effects\/fused-effects:examples\/Utils.hs","hash_val":7652,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"reader","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reader f = RSST $ \\r s -> return (f r, s)","function_tokens":["reader","f","=","RSST","$","\\","r","s","->","return","(","f","r",",","s",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L184-L184","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"closest","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"closest = T.findClosest tree key 7","function_tokens":["closest","=","T","findClosest","tree","key","7"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L238-L238","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"defaultConfig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultConfig = Config\n  { hideBar = False\n  , sameLine = False\n  , hideDetails = False\n  , printOnce = False\n  , sortByMean = False\n  , simple = False\n  , confidence = 6\n  , timeout = Nothing\n  , relativeError = Nothing\n  }","function_tokens":["defaultConfig","=","Config","{","hideBar","=","False",",","sameLine","=","False",",","hideDetails","=","False",",","printOnce","=","False",",","sortByMean","=","False",",","simple","=","False",",","confidence","=","6",",","timeout","=","Nothing",",","relativeError","=","Nothing","}"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L146-L156","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"setBufferData","parameters":"buffer (BufferData (MemoryRegion raw size) format frequency)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setBufferData buffer (BufferData (MemoryRegion raw size) format frequency) =\n      alBufferData buffer (marshalFormat format) raw size (round frequency)","function_tokens":["setBufferData","buffer","(","BufferData","(","MemoryRegion","raw","size",")","format","frequency",")","=","alBufferData","buffer","(","marshalFormat","format",")","raw","size","(","round","frequency",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L134-L135","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getPolyData","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getPolyData = do\n  bb              <- getRecBBox\n  nParts          <- getIntLE\n  nPoints         <- getIntLE\n  partIndices     <- replicateM nParts getIntLE\n  let partLengths = steps $ partIndices ++ [nPoints]\n  pntLists        <- mapM getPointList partLengths\n  return (bb, nParts, nPoints, partLengths, pntLists)\n\n-- | Recurring pattern of M-valued data","function_tokens":["getPolyData","=","do","bb","<-","getRecBBox","nParts","<-","getIntLE","nPoints","<-","getIntLE","partIndices","<-","replicateM","nParts","getIntLE","let","partLengths","=","steps","$","partIndices","++","[","nPoints","]","pntLists","<-","mapM","getPointList","partLengths","return","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","-- | Recurring pattern of M-valued data"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L219-L229","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"extraField","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"extraField =\n        (M.findWithDefault M.empty s eaExtraField `M.union` oldExtraFields)\n          `M.difference` M.findWithDefault M.empty s eaDeleteField","function_tokens":["extraField","=","(","M","findWithDefault","M","empty","s","eaExtraField","`","M","union","`","oldExtraFields",")","`","M","difference","`","M","findWithDefault","M","empty","s","eaDeleteField"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L509-L511","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"singleConstructor","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"singleConstructor = (== 1) . length . GHC.dd_cons . dataDefn","function_tokens":["singleConstructor","=","(","==","1",")",".","length",".","GHC","dd_cons",".","dataDefn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L550-L550","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Origin _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Origin _)               = (True, True, False, False)","function_tokens":["go","(","Origin","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L381-L381","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"sendS","parameters":"","argument_list":"","return_statement":"","docstring":"Send a FIND_VALUE command, looking for the supplied id","docstring_summary":"Send a FIND_VALUE command, looking for the supplied id","docstring_tokens":["Send","a","FIND_VALUE","command","looking","for","the","supplied","id"],"function":"sendS = sendSignal (FIND_VALUE id)","function_tokens":["sendS","=","sendSignal","(","FIND_VALUE","id",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L74-L74","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_BUFFERS_PROCESSED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_BUFFERS_PROCESSED                = 0x1016","function_tokens":["al_BUFFERS_PROCESSED","=","0x1016"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L82-L82","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"minutes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"minutes = fromIntegral (shiftR msDosTime 5 .&. 0x3f)","function_tokens":["minutes","=","fromIntegral","(","shiftR","msDosTime","5",".&.","0x3f",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1191-L1191","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"constructorComments","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"constructorComments = commentGroups\n            (GHC.srcSpanToRealSrcSpan . GHC.getLocA)\n            (GHC.dd_cons defn)\n            (dataComments decl)","function_tokens":["constructorComments","=","commentGroups","(","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")","(","GHC","dd_cons","defn",")","(","dataComments","decl",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L140-L143","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"go","parameters":"[x]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go [x]          = [(x, False, True)]","function_tokens":["go","[","x","]","=","[","(","x",",","False",",","True",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L210-L210","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"read","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"read = MG.read","function_tokens":["read","=","MG","read"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L39-L39","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/State.hs","language":"haskell","identifier":"modLoop","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modLoop i = for_ [1..i] (modify . (+))","function_tokens":["modLoop","i","=","for_","[","1","..","i","]","(","modify",".","(","+",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/State.hs#L35-L35","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/State.hs","hash_val":42170,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/NonDet.hs","language":"haskell","identifier":"oneOf","parameters":"","argument_list":"","return_statement":"","docstring":"Nondeterministically choose an element from a 'Foldable' collection. This can be used to emulate the style of nondeterminism associated with programming in the list monad:  @ pythagoreanTriples = do a <- oneOf [1..10] b <- oneOf [1..10] c <- oneOf [1..10] guard (a^2 + b^2 == c^2) pure (a, b, c) @  @since 1.0.0.0","docstring_summary":"Nondeterministically choose an element from a 'Foldable' collection. This can be used to emulate the style of nondeterminism associated with programming in the list monad:","docstring_tokens":["Nondeterministically","choose","an","element","from","a","Foldable","collection",".","This","can","be","used","to","emulate","the","style","of","nondeterminism","associated","with","programming","in","the","list","monad",":"],"function":"oneOf = foldMapA pure","function_tokens":["oneOf","=","foldMapA","pure"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/NonDet.hs#L54-L54","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/NonDet.hs","hash_val":29874,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"gainBounds","parameters":"source","argument_list":"","return_statement":"","docstring":"'gainBounds' contains two scalar amplitude thresholds between 0 and 1 (included): The minimum guaranteed gain for this source and the maximum gain permitted, with initial values 0 and 1, respectively At the end of the processing of various attenuation factors such as distance based attenuation and 'sourceGain', the effective gain calculated is compared to these values:  If the effective gain is lower than the minimum gain, the minimum gain is applied. This happens before the 'listenerGain' is applied. If a zero minimum gain is set, then the effective gain will not be corrected.  If the effective gain is higher than the maximum gain, the maximum gain is applied. This happens before the 'listenerGain' is applied. If the 'listenerGain' times the maximum gain still exceeds the maximum gain the implementation can handle, the implementation is free to clamp. If a zero maximum gain is set, then the source is effectively muted. The implementation is free to optimize for this situation, but no optimization is required or recommended as setting 'sourceGain' to zero is the proper way to mute a source.","docstring_summary":"'gainBounds' contains two scalar amplitude thresholds between 0 and 1 (included): The minimum guaranteed gain for this source and the maximum gain permitted, with initial values 0 and 1, respectively At the end of the processing of various attenuation factors such as distance based attenuation and 'sourceGain', the effective gain calculated is compared to these values:  If the effective gain is lower than the minimum gain, the minimum gain is applied. This happens before the 'listenerGain' is applied. If a zero minimum gain is set, then the effective gain will not be corrected.  If the effective gain is higher than the maximum gain, the maximum gain is applied. This happens before the 'listenerGain' is applied. If the 'listenerGain' times the maximum gain still exceeds the maximum gain the implementation can handle, the implementation is free to clamp. If a zero maximum gain is set, then the source is effectively muted. The implementation is free to optimize for this situation, but no optimization is required or recommended as setting 'sourceGain' to zero is the proper way to mute a source.","docstring_tokens":["gainBounds","contains","two","scalar","amplitude","thresholds","between","0","and","1","(","included",")",":","The","minimum","guaranteed","gain","for","this","source","and","the","maximum","gain","permitted","with","initial","values","0","and","1","respectively","At","the","end","of","the","processing","of","various","attenuation","factors","such","as","distance","based","attenuation","and","sourceGain","the","effective","gain","calculated","is","compared","to","these","values",":","If","the","effective","gain","is","lower","than","the","minimum","gain","the","minimum","gain","is","applied",".","This","happens","before","the","listenerGain","is","applied",".","If","a","zero","minimum","gain","is","set","then","the","effective","gain","will","not","be","corrected",".","If","the","effective","gain","is","higher","than","the","maximum","gain","the","maximum","gain","is","applied",".","This","happens","before","the","listenerGain","is","applied",".","If","the","listenerGain","times","the","maximum","gain","still","exceeds","the","maximum","gain","the","implementation","can","handle","the","implementation","is","free","to","clamp",".","If","a","zero","maximum","gain","is","set","then","the","source","is","effectively","muted",".","The","implementation","is","free","to","optimize","for","this","situation","but","no","optimization","is","required","or","recommended","as","setting","sourceGain","to","zero","is","the","proper","way","to","mute","a","source","."],"function":"gainBounds source =\n   pairStateVars\n      (makeSourceStateVar dictALfloat GetMinGain source)\n      (makeSourceStateVar dictALfloat GetMaxGain source)","function_tokens":["gainBounds","source","=","pairStateVars","(","makeSourceStateVar","dictALfloat","GetMinGain","source",")","(","makeSourceStateVar","dictALfloat","GetMaxGain","source",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L331-L334","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","language":"haskell","identifier":"show","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show = getConst . icata ishow","function_tokens":["show","=","getConst",".","icata","ishow"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Functor.hs#L41-L41","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","hash_val":19560,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmpLt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subsetCmpLt | nomatch p1 p2 m2  = GT\n                | zero p1 m2        = subsetCmp t1 l2\n                | otherwise         = subsetCmp t1 r2","function_tokens":["subsetCmpLt","|","nomatch","p1","p2","m2","=","GT","|","zero","p1","m2","=","subsetCmp","t1","l2","|","otherwise","=","subsetCmp","t1","r2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L460-L462","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkCase","parameters":"(Context i _ c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkCase (Context i _ c) = map (\\(pat, var) -> match pat (normalB (rght var)) []) (case1 i c)","function_tokens":["mkCase","(","Context","i","_","c",")","=","map","(","\\","(","pat",",","var",")","->","match","pat","(","normalB","(","rght","var",")",")","[","]",")","(","case1","i","c",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L500-L500","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"mplus","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mplus = (<|>)","function_tokens":["mplus","=","(","<|>",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L141-L141","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"louispan\/glazier-pipes","sha":"ebd15c98cea28ad2e15786512ba8607bb5b6434e","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/louispan\/glazier-pipes\/blob\/ebd15c98cea28ad2e15786512ba8607bb5b6434e\/Setup.hs#L2-L2","hash_key":"louispan\/glazier-pipes:Setup.hs","hash_val":37377,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"noWrapRest'","parameters":"ls ss (str:strs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"noWrapRest' ls ss (str:strs)\n        | null ss = noWrapRest' ls (indent ind str) strs\n        | otherwise = noWrapRest' ls (ss ++ \" \" ++ str) strs","function_tokens":["noWrapRest'","ls","ss","(","str",":","strs",")","|","null","ss","=","noWrapRest'","ls","(","indent","ind","str",")","strs","|","otherwise","=","noWrapRest'","ls","(","ss","++","\" \"","++","str",")","strs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L168-L170","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"cosh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cosh = fmap cosh","function_tokens":["cosh","=","fmap","cosh"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L250-L250","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl (LiftWith with)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl (LiftWith with) = with hdl","function_tokens":["alg","hdl","(","LiftWith","with",")","=","with","hdl"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L146-L146","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseModuleHeader","parameters":"config o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseModuleHeader config o = fmap (ModuleHeader.step columns) $ ModuleHeader.Config\n    <$> (o A..:? \"indent\"         A..!= ModuleHeader.indent        def)\n    <*> (o A..:? \"sort\"           A..!= ModuleHeader.sort          def)\n    <*> (o A..:? \"separate_lists\" A..!= ModuleHeader.separateLists def)\n    <*> (o A..:? \"break_where\"      >>= parseEnum breakWhere (ModuleHeader.breakWhere def))\n    <*> (o A..:? \"open_bracket\"     >>= parseEnum openBracket (ModuleHeader.openBracket def))\n  where\n    def = ModuleHeader.defaultConfig\n\n    columns = configColumns config\n\n    breakWhere =\n        [ (\"exports\", ModuleHeader.Exports)\n        , (\"single\",  ModuleHeader.Single)\n        , (\"inline\",  ModuleHeader.Inline)\n        , (\"always\",  ModuleHeader.Always)\n        ]\n\n    openBracket =\n        [ (\"same_line\", ModuleHeader.SameLine)\n        , (\"next_line\", ModuleHeader.NextLine)\n        ]\n\n--------------------------------------------------------------------------------","function_tokens":["parseModuleHeader","config","o","=","fmap","(","ModuleHeader","step","columns",")","$","ModuleHeader","Config","<$>","(","o","A",".:?","\"indent\"","A",".!=","ModuleHeader","indent","def",")","<*>","(","o","A",".:?","\"sort\"","A",".!=","ModuleHeader","sort","def",")","<*>","(","o","A",".:?","\"separate_lists\"","A",".!=","ModuleHeader","separateLists","def",")","<*>","(","o","A",".:?","\"break_where\"",">>=","parseEnum","breakWhere","(","ModuleHeader","breakWhere","def",")",")","<*>","(","o","A",".:?","\"open_bracket\"",">>=","parseEnum","openBracket","(","ModuleHeader","openBracket","def",")",")","where","def","=","ModuleHeader","defaultConfig","columns","=","configColumns","config","breakWhere","=","[","(","\"exports\"",",","ModuleHeader","Exports",")",",","(","\"single\"",",","ModuleHeader","Single",")",",","(","\"inline\"",",","ModuleHeader","Inline",")",",","(","\"always\"",",","ModuleHeader","Always",")","]","openBracket","=","[","(","\"same_line\"",",","ModuleHeader","SameLine",")",",","(","\"next_line\"",",","ModuleHeader","NextLine",")","]","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L199-L223","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_,_,_,r) = fieldAllowed a","function_tokens":["(","_",",","_",",","_",",","r",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L400-L400","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWith5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith5 = MG.zipWith5","function_tokens":["zipWith5","=","MG","zipWith5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L273-L273","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"modeToStackArg","parameters":"Project","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modeToStackArg Project                       = \"\"","function_tokens":["modeToStackArg","Project","=","\"\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L40-L40","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Extensions.hs","language":"haskell","identifier":"alIsExtensionPresent","parameters":"extensionName","argument_list":"","return_statement":"","docstring":"To verify that a given extension is available for the current context, use 'alIsExtensionPresent'. For invalid and unsupported string tokens it contains 'False'. The extension name is not case sensitive: The implementation will convert the name to all upper-case internally (and will express extension names in upper-case).","docstring_summary":"To verify that a given extension is available for the current context, use 'alIsExtensionPresent'. For invalid and unsupported string tokens it contains 'False'. The extension name is not case sensitive: The implementation will convert the name to all upper-case internally (and will express extension names in upper-case).","docstring_tokens":["To","verify","that","a","given","extension","is","available","for","the","current","context","use","alIsExtensionPresent",".","For","invalid","and","unsupported","string","tokens","it","contains","False",".","The","extension","name","is","not","case","sensitive",":","The","implementation","will","convert","the","name","to","all","upper","-","case","internally","(","and","will","express","extension","names","in","upper","-","case",")","."],"function":"alIsExtensionPresent extensionName =\n   makeGettableStateVar $\n      fmap unmarshalALboolean $\n         withALString extensionName alIsExtensionPresent_","function_tokens":["alIsExtensionPresent","extensionName","=","makeGettableStateVar","$","fmap","unmarshalALboolean","$","withALString","extensionName","alIsExtensionPresent_"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Extensions.hs#L65-L68","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Extensions.hs","hash_val":40318,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"r","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r = length xs","function_tokens":["r","=","length","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L157-L157","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs","language":"haskell","identifier":"shpTypeFromId","parameters":"i","argument_list":"","return_statement":"","docstring":"Numeric codes used for record types","docstring_summary":"Numeric codes used for record types","docstring_tokens":["Numeric","codes","used","for","record","types"],"function":"shpTypeFromId i =\n  case i of 0  -> ShpNull\n            1  -> ShpPoint\n            3  -> ShpPolyLine\n            5  -> ShpPolygon\n            8  -> ShpMultiPoint\n            11 -> ShpPointZ\n            13 -> ShpPolyLineZ\n            15 -> ShpPolygonZ\n            18 -> ShpMultiPointZ\n            21 -> ShpPointM\n            23 -> ShpPolyLineM\n            25 -> ShpPolygonM\n            28 -> ShpMultiPointM\n            31 -> ShpMultiPatch\n            _  -> error \"shpTypeFromId: Unknown Shape Type\"","function_tokens":["shpTypeFromId","i","=","case","i","of","0","->","ShpNull","1","->","ShpPoint","3","->","ShpPolyLine","5","->","ShpPolygon","8","->","ShpMultiPoint","11","->","ShpPointZ","13","->","ShpPolyLineZ","15","->","ShpPolygonZ","18","->","ShpMultiPointZ","21","->","ShpPointM","23","->","ShpPolyLineM","25","->","ShpPolygonM","28","->","ShpMultiPointM","31","->","ShpMultiPatch","_","->","error","\"shpTypeFromId: Unknown Shape Type\""],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs#L59-L76","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs","hash_val":20255,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"new","parameters":"","argument_list":"","return_statement":"","docstring":"Create a mutable matrix without initialization","docstring_summary":"Create a mutable matrix without initialization","docstring_tokens":["Create","a","mutable","matrix","without","initialization"],"function":"new = MG.new","function_tokens":["new","=","MG","new"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L46-L46","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"fromColumns","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from columns","docstring_summary":"O(m*n) Create matrix from columns","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","columns"],"function":"fromColumns = MG.fromColumns","function_tokens":["fromColumns","=","MG","fromColumns"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L161-L161","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,_) = dim mat","function_tokens":["(","r",",","_",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L167-L167","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"ne","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ne []       = []","function_tokens":["ne","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L102-L102","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"(Select is es a i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' (Select is es a i) = do\n        a' <- bind'' a\n        i' <- bind'' i\n        return . inject $ Select is es a' i'","function_tokens":["flatten'","(","Select","is","es","a","i",")","=","do","a'","<-","bind''","a","i'","<-","bind''","i","return",".","inject","$","Select","is","es","a'","i'"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L832-L836","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"j","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"j = inject $ Var n is","function_tokens":["j","=","inject","$","Var","n","is"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L906-L906","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Error\/Either.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = ErrorC (ExceptT empty)","function_tokens":["empty","=","ErrorC","(","ExceptT","empty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Error\/Either.hs#L51-L51","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Error\/Either.hs","hash_val":17343,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmp","parameters":"(Tip _ x) (Tip _ y)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subsetCmp (Tip _ x) (Tip _ y)\n  | x==y       = EQ\n  | otherwise  = GT","function_tokens":["subsetCmp","(","Tip","_","x",")","(","Tip","_","y",")","|","x","==","y","=","EQ","|","otherwise","=","GT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L470-L472","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars'","parameters":"(Forall vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freevars' (Forall vs a) = coerce (P.filter (`notElem` map (\\v@(IFix (Var _ s)) -> DynamicallySorted s v) vs)) a","function_tokens":["freevars'","(","Forall","vs","a",")","=","coerce","(","P","filter","(","`","notElem","`","map","(","\\","v","@","(","IFix","(","Var","_","s",")",")","->","DynamicallySorted","s","v",")","vs",")",")","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L622-L622","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference","parameters":"t Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"difference t Nil       = t","function_tokens":["difference","t","Nil","=","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L407-L407","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"catalog","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"catalog = M.fromList\n    [ (\"imports\",             parseImports)\n    , (\"module_header\",       parseModuleHeader)\n    , (\"records\",             parseRecords)\n    , (\"language_pragmas\",    parseLanguagePragmas)\n    , (\"simple_align\",        parseSimpleAlign)\n    , (\"squash\",              parseSquash)\n    , (\"tabs\",                parseTabs)\n    , (\"trailing_whitespace\", parseTrailingWhitespace)\n    , (\"unicode_syntax\",      parseUnicodeSyntax)\n    ]","function_tokens":["catalog","=","M","fromList","[","(","\"imports\"",",","parseImports",")",",","(","\"module_header\"",",","parseModuleHeader",")",",","(","\"records\"",",","parseRecords",")",",","(","\"language_pragmas\"",",","parseLanguagePragmas",")",",","(","\"simple_align\"",",","parseSimpleAlign",")",",","(","\"squash\"",",","parseSquash",")",",","(","\"tabs\"",",","parseTabs",")",",","(","\"trailing_whitespace\"",",","parseTrailingWhitespace",")",",","(","\"unicode_syntax\"",",","parseUnicodeSyntax",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L166-L176","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookPullRequestReviewCommentEvent","function_tokens":["reflect","_","=","WebhookPullRequestReviewCommentEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L460-L460","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"totalCount","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"totalCount = fromIntegral (M.size m)","function_tokens":["totalCount","=","fromIntegral","(","M","size","m",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L635-L635","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"peerNum","parameters":"","argument_list":"","return_statement":"","docstring":"Don't select more than 7 peers","docstring_summary":"Don't select more than 7 peers","docstring_tokens":["Don","t","select","more","than","7","peers"],"function":"peerNum = if length polled > 7 then 7 else length polled","function_tokens":["peerNum","=","if","length","polled",">","7","then","7","else","length","polled"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L113-L113","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = mempty","function_tokens":["empty","=","mempty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L133-L133","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getBinary","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getBinary = do\n  len <- getInt32\n  t <- getTag\n  x <- getByteString (fromIntegral len)\n  return (t, x)\n\n{-putBinary :: Subtype -> ByteString -> Put\n-- When Binary subtype (0x02) insert extra length field before bytes\nputBinary t x = let len = toEnum (length x) in do\n  putInt32 $ len + if t == 0x02 then 4 else 0\n  putTag t\n  when (t == 0x02) (putInt32 len)\n  putByteString x-}\n\n{-getBinary :: Get (Subtype, ByteString)\n-- When Binary subtype (0x02) there is an extra length field before bytes\ngetBinary = do\n  len <- getInt32\n  t <- getTag\n  len' <- if t == 0x02 then getInt32 else return len\n  x <- getByteString (fromIntegral len')\n  return (t, x)-}","function_tokens":["getBinary","=","do","len","<-","getInt32","t","<-","getTag","x","<-","getByteString","(","fromIntegral","len",")","return","(","t",",","x",")","{-putBinary :: Subtype -> ByteString -> Put\n-- When Binary subtype (0x02) insert extra length field before bytes\nputBinary t x = let len = toEnum (length x) in do\n  putInt32 $ len + if t == 0x02 then 4 else 0\n  putTag t\n  when (t == 0x02) (putInt32 len)\n  putByteString x-}","{-getBinary :: Get (Subtype, ByteString)\n-- When Binary subtype (0x02) there is an extra length field before bytes\ngetBinary = do\n  len <- getInt32\n  t <- getTag\n  len' <- if t == 0x02 then getInt32 else return len\n  x <- getByteString (fromIntegral len')\n  return (t, x)-}"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L189-L212","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/StrUtils.hs","language":"haskell","identifier":"ensureNewline","parameters":"\"\"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ensureNewline \"\" = \"\"","function_tokens":["ensureNewline","\"\"","=","\"\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/StrUtils.hs#L17-L17","hash_key":"Peaker\/git-mediate:src\/StrUtils.hs","hash_val":9940,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"injLabelled","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"injLabelled = reassociateSumL . injLabelled","function_tokens":["injLabelled","=","reassociateSumL",".","injLabelled"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L92-L92","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"go","parameters":"tup@(_msg, _hdr, v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go tup@(_msg, _hdr, v) = do\n        keyM <- liftIO (unGitHubKey (getContextEntry context) keyIndex v)\n        case keyM of\n            Nothing -> delayedFailFatal err401\n            Just key -> verifySigWithKey tup key","function_tokens":["go","tup","@","(","_msg",",","_hdr",",","v",")","=","do","keyM","<-","liftIO","(","unGitHubKey","(","getContextEntry","context",")","keyIndex","v",")","case","keyM","of","Nothing","->","delayedFailFatal","err401","Just","key","->","verifySigWithKey","tup","key"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L310-L316","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"finish","parameters":"","argument_list":"","return_statement":"","docstring":"Return a success, when the operation finished cleanly","docstring_summary":"Return a success, when the operation finished cleanly","docstring_tokens":["Return","a","success","when","the","operation","finished","cleanly"],"function":"finish = return JoinSucces","function_tokens":["finish","=","return","JoinSucces"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L157-L157","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"show","parameters":"BZip2Unsupported","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show BZip2Unsupported =\n    \"Encountered a zipfile entry with BZip2 compression, but \" ++\n    \"the zip library has been built with bzip2 disabled.\"","function_tokens":["show","BZip2Unsupported","=","\"Encountered a zipfile entry with BZip2 compression, but \"","++","\"the zip library has been built with bzip2 disabled.\""],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L239-L241","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"show","parameters":"(EntryDoesNotExist file s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (EntryDoesNotExist file s) =\n    \"No such entry found: \" ++ show s ++ \" in \" ++ show file","function_tokens":["show","(","EntryDoesNotExist","file","s",")","=","\"No such entry found: \"","++","show","s","++","\" in \"","++","show","file"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L233-L234","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client\/Internal.hs","language":"haskell","identifier":"toRequestBody","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toRequestBody = RequestBodyLBS . A.encode . fromList . map A.toJSON","function_tokens":["toRequestBody","=","RequestBodyLBS",".","A","encode",".","fromList",".","map","A","toJSON"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client\/Internal.hs#L30-L30","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client\/Internal.hs","hash_val":6396,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"isSymmetric","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSymmetric = MG.isSymmetric","function_tokens":["isSymmetric","=","MG","isSymmetric"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L220-L220","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putLabel","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putLabel = putCString","function_tokens":["putLabel","=","putCString"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L118-L118","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"runState","parameters":"s (StateC runStateC)","argument_list":"","return_statement":"","docstring":"Run a 'State' effect starting from the passed value.  @ 'runState' s ('pure' a) = 'pure' (s, a) @ @ 'runState' s 'get' = 'pure' (s, s) @ @ 'runState' s ('put' t) = 'pure' (t, ()) @  @since 1.0.0.0","docstring_summary":"Run a 'State' effect starting from the passed value.","docstring_tokens":["Run","a","State","effect","starting","from","the","passed","value","."],"function":"runState s (StateC runStateC) = runStateC s","function_tokens":["runState","s","(","StateC","runStateC",")","=","runStateC","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L48-L48","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"renderToSGR","parameters":"t m f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderToSGR t m f =\n      [ RenderSGR (modToSGR m f),\n        RenderText t,\n        RenderSGR [ANSI.Reset]\n      ]","function_tokens":["renderToSGR","t","m","f","=","[","RenderSGR","(","modToSGR","m","f",")",",","RenderText","t",",","RenderSGR","[","ANSI","Reset","]","]"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L210-L214","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"convert","parameters":"w","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"convert w = foldr (\\i bits -> testBit w i : bits) [] [0..7]","function_tokens":["convert","w","=","foldr","(","\\","i","bits","->","testBit","w","i",":","bits",")","[","]","[","0","..","7","]"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L60-L60","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"(Store is es a i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' (Store is es a i e) = do\n        a' <- bind'' a\n        i' <- bind'' i\n        e' <- bind'' e\n        return . inject $ Store is es a' i' e'","function_tokens":["flatten'","(","Store","is","es","a","i","e",")","=","do","a'","<-","bind''","a","i'","<-","bind''","i","e'","<-","bind''","e","return",".","inject","$","Store","is","es","a'","i'","e'"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L836-L842","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Area _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Area _)                 = \"A\"","function_tokens":["go","(","Area","_",")","=","\"A\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L335-L335","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"ishow","parameters":"(IfThenElse _ i t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (IfThenElse _ i t e) = coerce $ \"(ite \" ++ coerce i ++ \" \" ++ coerce t ++ \" \" ++ coerce e ++ \")\"","function_tokens":["ishow","(","IfThenElse","_","i","t","e",")","=","coerce","$","\"(ite \"","++","coerce","i","++","\" \"","++","coerce","t","++","\" \"","++","coerce","e","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L59-L59","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"cache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cache = itCache","function_tokens":["cache","=","itCache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L37-L37","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zip3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip3 = MG.zip3","function_tokens":["zip3","=","MG","zip3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L315-L315","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra\/Handler.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Composition of handlers.  @since 1.1.0.0","docstring_summary":"Composition of handlers.","docstring_tokens":["Composition","of","handlers","."],"function":"hdl1 ~<~ hdl2 = fmap Compose . hdl1 . fmap hdl2 . getCompose","function_tokens":["hdl1","~<~","hdl2","=","fmap","Compose",".","hdl1",".","fmap","hdl2",".","getCompose"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra\/Handler.hs#L44-L44","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra\/Handler.hs","hash_val":32530,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"b","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b = runPut (putString x >> putDocument y)","function_tokens":["b","=","runPut","(","putString","x",">>","putDocument","y",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L236-L236","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putString","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putString x = let b = TE.encodeUtf8 x in do\n  putInt32 $ toEnum (SC.length b + 1)\n  putByteString b\n  putWord8 0","function_tokens":["putString","x","=","let","b","=","TE","encodeUtf8","x","in","do","putInt32","$","toEnum","(","SC","length","b","+","1",")","putByteString","b","putWord8","0"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L145-L150","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtToMapLens","parameters":"lens districts","argument_list":"","return_statement":"","docstring":"Given a list of districts, draw a map, with labels determined by a lens.","docstring_summary":"Given a list of districts, draw a map, with labels determined by a lens.","docstring_tokens":["Given","a","list","of","districts","draw","a","map","with","labels","determined","by","a","lens","."],"function":"districtToMapLens lens districts = labelledDistricts .~ dist $ def\n    where dist = zip (fmap (_shape) districts) (map (show . view lens) districts)\n\n-- | Given a list of districts, draw a map.","function_tokens":["districtToMapLens","lens","districts","=","labelledDistricts",".~","dist","$","def","where","dist","=","zip","(","fmap","(","_shape",")","districts",")","(","map","(","show",".","view","lens",")","districts",")","-- | Given a list of districts, draw a map."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L49-L53","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/SourceState.hs","language":"haskell","identifier":"unmarshalSourceState","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalSourceState x\n   | x == al_INITIAL = Initial\n   | x == al_PLAYING = Playing\n   | x == al_PAUSED = Paused\n   | x == al_STOPPED = Stopped\n   | otherwise = error (\"unmarshalSourceState: illegal value \" ++ show x)","function_tokens":["unmarshalSourceState","x","|","x","==","al_INITIAL","=","Initial","|","x","==","al_PLAYING","=","Playing","|","x","==","al_PAUSED","=","Paused","|","x","==","al_STOPPED","=","Stopped","|","otherwise","=","error","(","\"unmarshalSourceState: illegal value \"","++","show","x",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/SourceState.hs#L41-L46","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/SourceState.hs","hash_val":27781,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"exp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exp = fmap exp","function_tokens":["exp","=","fmap","exp"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L247-L247","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"ibs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ibs     = fmap (\\(a, _, _) -> a) chunks","function_tokens":["ibs","=","fmap","(","\\","(","a",",","_",",","_",")","->","a",")","chunks"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L39-L39","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"eq","parameters":"f g","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eq f g = False `fromMaybe` ((==) <$> name f <*> name g)","function_tokens":["eq","f","g","=","False","`","fromMaybe","`","(","(","==",")","<$>","name","f","<*>","name","g",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L325-L325","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty = string . showRatio . getDuration","function_tokens":["pretty","=","string",".","showRatio",".","getDuration"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L478-L478","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"go","parameters":"k coef e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go k coef e\n            | k < 30    = \n                let\n                    k'      = k + 1\n                    coef'   = coef * negate (x*x\/k)\n                    e'      =  e + coef' \/ (2 * k + 1)\n                in go k' coef' e'\n            | otherwise = 2 \/ sqrt pi * e","function_tokens":["go","k","coef","e","|","k","<","30","=","let","k'","=","k","+","1","coef'","=","coef","*","negate","(","x","*","x","\/","k",")","e'","=","e","+","coef'","\/","(","2","*","k","+","1",")","in","go","k'","coef'","e'","|","otherwise","=","2","\/","sqrt","pi","*","e"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L41-L48","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"sig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sig =\n              B16.encode $ convert $ hmacGetDigest (hmac key msg :: HMAC SHA1)","function_tokens":["sig","=","B16","encode","$","convert","$","hmacGetDigest","(","hmac","key","msg","::","HMAC","SHA1",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L321-L322","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_FORMAT_STEREO8","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_FORMAT_STEREO8                   = 0x1102","function_tokens":["al_FORMAT_STEREO8","=","0x1102"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L121-L121","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"showRatio","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showRatio x\n    | denominator x == 1  = show (numerator x)\n    | otherwise           = (show $ numerator x) ++ \"\/\" ++ (show $ denominator x)","function_tokens":["showRatio","x","|","denominator","x","==","1","=","show","(","numerator","x",")","|","otherwise","=","(","show","$","numerator","x",")","++","\"\/\"","++","(","show","$","denominator","x",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L590-L592","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getInt16BE","parameters":"","argument_list":"","return_statement":"","docstring":"16-bit big-endian Int","docstring_summary":"16-bit big-endian Int","docstring_tokens":["16","-","bit","big","-","endian","Int"],"function":"getInt16BE = fromIntegral <$> getWord16be","function_tokens":["getInt16BE","=","fromIntegral","<$>","getWord16be"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L24-L24","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(Var n s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Var n s) = F.Const (\"(\" ++ n ++ \" : \" ++ show s ++ \")\")","function_tokens":["ishow","(","Var","n","s",")","=","F","Const","(","\"(\"","++","n","++","\" : \"","++","show","s","++","\")\"",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L263-L263","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"lookup","parameters":"key@(Key k _)   (Vault m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookup key@(Key k _)   (Vault m) = unlock key =<< Map.lookup k m","function_tokens":["lookup","key","@","(","Key","k","_",")","(","Vault","m",")","=","unlock","key","=<<","Map","lookup","k","m"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L33-L33","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = arr show","function_tokens":["s","=","arr","show"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L116-L116","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"completions","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"completions = map (\\t -> Completion t t True)","function_tokens":["completions","=","map","(","\\","t","->","Completion","t","t","True",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L99-L99","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"multiWayIfToAlignable","parameters":"_conf _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"multiWayIfToAlignable _conf _ = []","function_tokens":["multiWayIfToAlignable","_conf","_","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L160-L160","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decodeText","parameters":"False","argument_list":"","return_statement":"","docstring":"Decode a 'ByteString'. The first argument indicates whether we should treat it as UTF-8 (in case bit 11 of general-purpose bit flag is set), otherwise the function assumes CP437. Note that since not every stream of bytes constitutes valid UTF-8 text, this function can fail. In that case 'Nothing' is returned.","docstring_summary":"Decode a 'ByteString'. The first argument indicates whether we should treat it as UTF-8 (in case bit 11 of general-purpose bit flag is set), otherwise the function assumes CP437. Note that since not every stream of bytes constitutes valid UTF-8 text, this function can fail. In that case 'Nothing' is returned.","docstring_tokens":["Decode","a","ByteString",".","The","first","argument","indicates","whether","we","should","treat","it","as","UTF","-","8","(","in","case","bit","11","of","general","-","purpose","bit","flag","is","set",")","otherwise","the","function","assumes","CP437",".","Note","that","since","not","every","stream","of","bytes","constitutes","valid","UTF","-","8","text","this","function","can","fail",".","In","that","case","Nothing","is","returned","."],"function":"decodeText False = Just . decodeCP437","function_tokens":["decodeText","False","=","Just",".","decodeCP437"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1079-L1079","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Words _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Words _)                = (False, True, True, False)","function_tokens":["go","(","Words","_",")","=","(","False",",","True",",","True",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L393-L393","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia.hs","language":"haskell","identifier":"create","parameters":"port id","argument_list":"","return_statement":"","docstring":"Create a new KademliaInstance corresponding to a given Id on a given port","docstring_summary":"Create a new KademliaInstance corresponding to a given Id on a given port","docstring_tokens":["Create","a","new","KademliaInstance","corresponding","to","a","given","Id","on","a","given","port"],"function":"create port id = do\n    rq <- emptyReplyQueue\n    h <- openOn (show port) id rq\n    inst <- newInstance id h\n    start inst rq\n    return inst\n\n-- | Stop a KademliaInstance by closing it","function_tokens":["create","port","id","=","do","rq","<-","emptyReplyQueue","h","<-","openOn","(","show","port",")","id","rq","inst","<-","newInstance","id","h","start","inst","rq","return","inst","-- | Stop a KademliaInstance by closing it"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia.hs#L143-L151","hash_key":"froozen\/kademlia:src\/Network\/Kademlia.hs","hash_val":2353,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"standardDeviation","parameters":"a","argument_list":"","return_statement":"","docstring":"Calculate the standard deviation of an Analysis.","docstring_summary":"Calculate the standard deviation of an Analysis.","docstring_tokens":["Calculate","the","standard","deviation","of","an","Analysis","."],"function":"standardDeviation a = sqrt (fromRational $ variance a) \/ biasCorrection\n  where biasCorrection\n          = 1\n          - 1\/(4*fromIntegral (samples a))\n          - 7\/(32*fromIntegral (samples a)**2)\n          - 19\/(128*fromIntegral (samples a)**3)\n\n-- | Calculate the standard error of an Analysis.","function_tokens":["standardDeviation","a","=","sqrt","(","fromRational","$","variance","a",")","\/","biasCorrection","where","biasCorrection","=","1","-","1","\/","(","4","*","fromIntegral","(","samples","a",")",")","-","7","\/","(","32","*","fromIntegral","(","samples","a",")","**","2",")","-","19","\/","(","128","*","fromIntegral","(","samples","a",")","**","3",")","-- | Calculate the standard error of an Analysis."],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L183-L191","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"var'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var' = do\n            _ <- char '('\n            n <- identifier\n            _ <- space *> char ':' *> space\n            s <- lift . lift $ parseSort\n            _ <- char ')'\n\n            assertSort n s\n\n            var''' n s","function_tokens":["var'","=","do","_","<-","char","'('","n","<-","identifier","_","<-","space","*>","char","':'","*>","space","s","<-","lift",".","lift","$","parseSort","_","<-","char","')'","assertSort","n","s","var'''","n","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L267-L278","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"prepAppImageFiles","parameters":"(ExeFile exeFp)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prepAppImageFiles (ExeFile exeFp) = do\n  -- Check and possibly create new icon\n  let iconPath = iconDir <\/> exeFp <.> \"svg\"\n  iconExists <- Dir.doesFileExist iconPath\n  unless iconExists $ do\n    Dir.createDirectoryIfMissing True iconDir\n    dumpStockIcon $ Just iconPath\n\n  -- Check desktop file, return status to caller\n  let desktopPath = desktopDir <\/> exeFp <.> \"desktop\"\n  desktopFileExists <- Dir.doesFileExist desktopPath\n  return $ if desktopFileExists then DesktopExists else CreateNewDesktop","function_tokens":["prepAppImageFiles","(","ExeFile","exeFp",")","=","do","-- Check and possibly create new icon","let","iconPath","=","iconDir","<\/>","exeFp","<.>","\"svg\"","iconExists","<-","Dir","doesFileExist","iconPath","unless","iconExists","$","do","Dir","createDirectoryIfMissing","True","iconDir","dumpStockIcon","$","Just","iconPath","-- Check desktop file, return status to caller","let","desktopPath","=","desktopDir","<\/>","exeFp","<.>","\"desktop\"","desktopFileExists","<-","Dir","doesFileExist","desktopPath","return","$","if","desktopFileExists","then","DesktopExists","else","CreateNewDesktop"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L35-L49","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotSVG.hs","language":"haskell","identifier":"makeLensMapSVG","parameters":"title filepath lens districts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeLensMapSVG title filepath lens districts = do\n    renderableToFile fileOptions filepath $ mkRenderableLens lens districts title\n    putStrLn (\"...output written to \" <> filepath)","function_tokens":["makeLensMapSVG","title","filepath","lens","districts","=","do","renderableToFile","fileOptions","filepath","$","mkRenderableLens","lens","districts","title","putStrLn","(","\"...output written to \"","<>","filepath",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotSVG.hs#L28-L30","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotSVG.hs","hash_val":9853,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"imap","parameters":"f (c `Divides`  a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (c `Divides`  a) = c `Divides` f a","function_tokens":["imap","f","(","c","`","Divides","`","a",")","=","c","`","Divides","`","f","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L72-L72","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"shittyCentroid","parameters":"poly","argument_list":"","return_statement":"","docstring":"averages the co\u00f6rdinates of a polygon, returning a point.","docstring_summary":"averages the co\u00f6rdinates of a polygon, returning a point.","docstring_tokens":["averages","the","co\u00f6rdinates","of","a","polygon","returning","a","point","."],"function":"shittyCentroid poly = (avg $ map fst poly, avg $ map snd poly)","function_tokens":["shittyCentroid","poly","=","(","avg","$","map","fst","poly",",","avg","$","map","snd","poly",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L15-L15","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parserA <|> parserB = catchError parserA $ \\ea ->\n    catchError parserB $ \\eb ->\n      throwError $ BothFailed ea eb","function_tokens":["parserA","<|>","parserB","=","catchError","parserA","$","\\","ea","->","catchError","parserB","$","\\","eb","->","throwError","$","BothFailed","ea","eb"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L72-L74","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(FileUrl a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (FileUrl a)              = a","function_tokens":["go","(","FileUrl","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L409-L409","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"bin\/Main.hs","language":"haskell","identifier":"opts","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"opts = info (arguments <**> helper)\n      ( fullDesc <> header \"chronos - a tool to comparatively benchmark programs with lazy precision\" )","function_tokens":["opts","=","info","(","arguments","<**>","helper",")","(","fullDesc","<>","header","\"chronos - a tool to comparatively benchmark programs with lazy precision\"",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/bin\/Main.hs#L14-L15","hash_key":"knupfer\/chronos:bin\/Main.hs","hash_val":24460,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"er","parameters":"k (Just m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"er k (Just m) =\n      let n = M.delete k m\n       in if M.null n then Nothing else Just n","function_tokens":["er","k","(","Just","m",")","=","let","n","=","M","delete","k","m","in","if","M","null","n","then","Nothing","else","Just","n"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L444-L446","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"go","parameters":"acc mbCurrentLine (x:xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go acc mbCurrentLine (x:xs) =\n      let\n        lStart = GHC.srcSpanStartLine (f x)\n        lEnd = GHC.srcSpanEndLine (f x) in\n      case mbCurrentLine of\n        Just lPrevEnd | lPrevEnd + 1 < lStart\n          -> ne acc ++ go [x] (Just lEnd) xs\n        _ -> go (acc ++ [x]) (Just lEnd) xs","function_tokens":["go","acc","mbCurrentLine","(","x",":","xs",")","=","let","lStart","=","GHC","srcSpanStartLine","(","f","x",")","lEnd","=","GHC","srcSpanEndLine","(","f","x",")","in","case","mbCurrentLine","of","Just","lPrevEnd","|","lPrevEnd","+","1","<","lStart","->","ne","acc","++","go","[","x","]","(","Just","lEnd",")","xs","_","->","go","(","acc","++","[","x","]",")","(","Just","lEnd",")","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L93-L102","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"InL a `ieq1` InL b = a `ieq1` b","function_tokens":["InL","a","`","ieq1","`","InL","b","=","a","`","ieq1","`","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L86-L86","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"prj","parameters":"(InR _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prj (InR _) = Nothing","function_tokens":["prj","(","InR","_",")","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L49-L49","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(Or os)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Or os) = coerce $ \"(or \"  ++ intercalate \" \" (coerce os) ++ \")\"","function_tokens":["ishow","(","Or","os",")","=","coerce","$","\"(or \"","++","intercalate","\" \"","(","coerce","os",")","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L389-L389","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"dChan","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dChan = defaultChan rq","function_tokens":["dChan","=","defaultChan","rq"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L112-L112","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"labelByLens","parameters":"lens districts","argument_list":"","return_statement":"","docstring":"Set labels via a lens field.","docstring_summary":"Set labels via a lens field.","docstring_tokens":["Set","labels","via","a","lens","field","."],"function":"labelByLens lens districts = zip (fmap (view shape) districts) (fmap (show . (view lens)) districts)","function_tokens":["labelByLens","lens","districts","=","zip","(","fmap","(","view","shape",")","districts",")","(","fmap","(","show",".","(","view","lens",")",")","districts",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L40-L40","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"deleteModifyConflictAddMarkers","parameters":"path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteModifyConflictAddMarkers path =\n    withAllStageFiles path $ \\baseTmp mLocalTmp mRemoteTmp ->\n    do  baseContent <- readFile baseTmp\n        localContent <- foldMap readFile mLocalTmp\n        remoteContent <- foldMap readFile mRemoteTmp\n        overwrite path $\n            concat\n            [ markerLine '<' \"LOCAL\"\n            , ensureNewline localContent\n            , markerLine '|' \"BASE\"\n            , ensureNewline baseContent\n            , markerLine '=' \"\"\n            , ensureNewline remoteContent\n            , markerLine '>' \"REMOTE\"\n            ]","function_tokens":["deleteModifyConflictAddMarkers","path","=","withAllStageFiles","path","$","\\","baseTmp","mLocalTmp","mRemoteTmp","->","do","baseContent","<-","readFile","baseTmp","localContent","<-","foldMap","readFile","mLocalTmp","remoteContent","<-","foldMap","readFile","mRemoteTmp","overwrite","path","$","concat","[","markerLine","'<'","\"LOCAL\"",",","ensureNewline","localContent",",","markerLine","'|'","\"BASE\"",",","ensureNewline","baseContent",",","markerLine","'='","\"\"",",","ensureNewline","remoteContent",",","markerLine","'>'","\"REMOTE\"","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L166-L182","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"g","parameters":"dt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g dt = do\n      leftover <- get\n      let\n        t = dt + leftover\n      if t == dur\n        then\n          put 0 >> return (Right (end, return end))\n        else\n          if t > dur\n          then\n            put (t - dur - dt) >> return (Left end)\n          else\n            put t >> return (Right (f c (t\/dur) b, SplineT g))\n\n\n-- | A version of 'tween' that discards the result. It is simply\n--\n-- @\n-- tween f a b c >> return ()\n-- @\n--","function_tokens":["g","dt","=","do","leftover","<-","get","let","t","=","dt","+","leftover","if","t","==","dur","then","put","0",">>","return","(","Right","(","end",",","return","end",")",")","else","if","t",">","dur","then","put","(","t","-","dur","-","dt",")",">>","return","(","Left","end",")","else","put","t",">>","return","(","Right","(","f","c","(","t","\/","dur",")","b",",","SplineT","g",")",")","-- | A version of 'tween' that discards the result. It is simply","--","-- @","-- tween f a b c >> return ()","-- @","--"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L298-L319","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"getGuardLStmts","parameters":"(Hs.GRHS _ guards _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getGuardLStmts (Hs.GRHS _ guards _) = guards","function_tokens":["getGuardLStmts","(","Hs","GRHS","_","guards","_",")","=","guards"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L256-L256","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"defaultCompFunc","parameters":"config (left, _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultCompFunc config (left, _) =\n  pure (\"\", completions matches)\n  where\n    -- All matching menu items.\n    matches =\n      if Text.null left\n        then toList (_menuItems config)\n        else matchOnPrefix config left\n    -- Convert a menu item to a String.\n    asText i = renderText Plain (toStylizedText i)\n    -- Convert menu items into Completion values.\n    completions = map (\\i -> Completion (asText i) (asText i) True)\n\n-- | Create a 'Menu' by giving a list of menu items and a function\n-- that can convert those items into stylized text.\n--\n-- @since 1.0.0.0","function_tokens":["defaultCompFunc","config","(","left",",","_",")","=","pure","(","\"\"",",","completions","matches",")","where","-- All matching menu items.","matches","=","if","Text","null","left","then","toList","(","_menuItems","config",")","else","matchOnPrefix","config","left","-- Convert a menu item to a String.","asText","i","=","renderText","Plain","(","toStylizedText","i",")","-- Convert menu items into Completion values.","completions","=","map","(","\\","i","->","Completion","(","asText","i",")","(","asText","i",")","True",")","-- | Create a 'Menu' by giving a list of menu items and a function","-- that can convert those items into stylized text.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L137-L154","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"end","parameters":"","argument_list":"","return_statement":"","docstring":"Run the lookup as long as possible, to make sure the nodes closest to the key were polled.","docstring_summary":"Run the lookup as long as possible, to make sure the nodes closest to the key were polled.","docstring_tokens":["Run","the","lookup","as","long","as","possible","to","make","sure","the","nodes","closest","to","the","key","were","polled","."],"function":"end = do\n            polled <- gets polled\n\n            unless (null polled) $ do\n                let h = handle inst\n                    -- Don't select more than 7 peers\n                    peerNum = if length polled > 7 then 7 else length polled\n                    -- Select the peers closest to the key\n                    storePeers =\n                        map peer . take peerNum . sortByDistanceTo polled $ key\n\n                -- Send them a STORE command\n                forM_ storePeers $\n                    \\storePeer -> liftIO . send h storePeer . STORE key $ val\n\n-- | The different possibel results of joinNetwork","function_tokens":["end","=","do","polled","<-","gets","polled","unless","(","null","polled",")","$","do","let","h","=","handle","inst","-- Don't select more than 7 peers","peerNum","=","if","length","polled",">","7","then","7","else","length","polled","-- Select the peers closest to the key","storePeers","=","map","peer",".","take","peerNum",".","sortByDistanceTo","polled","$","key","-- Send them a STORE command","forM_","storePeers","$","\\","storePeer","->","liftIO",".","send","h","storePeer",".","STORE","key","$","val","-- | The different possibel results of joinNetwork"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L107-L123","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"go","parameters":"config","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go config = do\n      answer <- askWithMenu config prompt\n      case answer of\n        Other _ -> go (config {_menuBeforePrompt = Just (toStylizedText errprompt)})\n        Match x -> pure x\n\n-- $usage\n--\n-- Menus are used to provide the user with a choice of acceptable\n-- values.  Each choice is labeled to make it easier for a user to\n-- select it, or the user may enter text that does not correspond to\n-- any of the menus items.\n--\n-- For an example see the @menu.hs@ file in the @examples@ directory.","function_tokens":["go","config","=","do","answer","<-","askWithMenu","config","prompt","case","answer","of","Other","_","->","go","(","config","{","_menuBeforePrompt","=","Just","(","toStylizedText","errprompt",")","}",")","Match","x","->","pure","x","-- $usage","--","-- Menus are used to provide the user with a choice of acceptable","-- values.  Each choice is labeled to make it easier for a user to","-- select it, or the user may enter text that does not correspond to","-- any of the menus items.","--","-- For an example see the @menu.hs@ file in the @examples@ directory."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L260-L273","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"desc0","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desc0 =\n        EntryDescription -- to write in local header\n          { edVersionMadeBy = zipVersion,\n            edVersionNeeded = zipVersion,\n            edCompression = compression,\n            edModTime = M.findWithDefault modTime s eaModTime,\n            edCRC32 = 0, -- to be overwritten after streaming\n            edCompressedSize = 0, -- \u2191\n            edUncompressedSize = 0, -- \u2191\n            edOffset = fromIntegral offset,\n            edComment = M.lookup s eaEntryComment <|> oldComment,\n            edExtraField = extraField,\n            edExternalFileAttrs = extFileAttr\n          }","function_tokens":["desc0","=","EntryDescription","-- to write in local header","{","edVersionMadeBy","=","zipVersion",",","edVersionNeeded","=","zipVersion",",","edCompression","=","compression",",","edModTime","=","M","findWithDefault","modTime","s","eaModTime",",","edCRC32","=","0",",","-- to be overwritten after streaming","edCompressedSize","=","0",",","-- \u2191","edUncompressedSize","=","0",",","-- \u2191","edOffset","=","fromIntegral","offset",",","edComment","=","M","lookup","s","eaEntryComment","<|>","oldComment",",","edExtraField","=","extraField",",","edExternalFileAttrs","=","extFileAttr","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L516-L529","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"fromList","parameters":"(r,c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromList (r,c) = fromVector (r,c) . G.fromList","function_tokens":["fromList","(","r",",","c",")","=","fromVector","(","r",",","c",")",".","G","fromList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L126-L126","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"shell","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shell =\n        Shell\n          { shellPrefs = O.defaultPrefs,\n            shellInfo = O.info parser (O.progDesc \"Simple shell\"),\n            shellPrompt = \"byline> \"\n          }","function_tokens":["shell","=","Shell","{","shellPrefs","=","O","defaultPrefs",",","shellInfo","=","O","info","parser","(","O","progDesc","\"Simple shell\"",")",",","shellPrompt","=","\"byline> \"","}"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L73-L78","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decompressingPipe","parameters":"Deflate","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decompressingPipe Deflate = Z.decompress $ Z.WindowBits (-15)","function_tokens":["decompressingPipe","Deflate","=","Z","decompress","$","Z","WindowBits","(","-","15",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1150-L1150","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"menuSuffix","parameters":"s m","argument_list":"","return_statement":"","docstring":"Change the menu item suffix.  It is displayed directly after the menu item prefix and just before the menu item itself.  Default: @\") \"@  @since 1.0.0.0","docstring_summary":"Change the menu item suffix.  It is displayed directly after the menu item prefix and just before the menu item itself.  Default:","docstring_tokens":["Change","the","menu","item","suffix",".","It","is","displayed","directly","after","the","menu","item","prefix","and","just","before","the","menu","item","itself",".","Default",":"],"function":"menuSuffix s m = m {_menuItemSuffix = s}","function_tokens":["menuSuffix","s","m","=","m","{","_menuItemSuffix","=","s","}"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L187-L187","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"desktopDir","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desktopDir = op TmplDir tmplDir <\/> \"share\" <\/> \"applications\"","function_tokens":["desktopDir","=","op","TmplDir","tmplDir","<\/>","\"share\"","<\/>","\"applications\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L28-L28","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/SideDiff.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Sides bodyA bodyBase bodyB = cBodies","function_tokens":["Sides","bodyA","bodyBase","bodyB","=","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/SideDiff.hs#L26-L26","hash_key":"Peaker\/git-mediate:src\/SideDiff.hs","hash_val":4146,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ma1 `mplus` ma2 = AccumC $ \\w -> runAccumC ma1 w `mplus` runAccumC ma2 w","function_tokens":["ma1","`","mplus","`","ma2","=","AccumC","$","\\","w","->","runAccumC","ma1","w","`","mplus","`","runAccumC","ma2","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L115-L115","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"or''","parameters":"os","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"or'' os = case mapM toStaticallySorted os of\n            Just os' -> return . toDynamicallySorted . or $ os'\n            Nothing  -> fail \"or of non-boolean arguments\"","function_tokens":["or''","os","=","case","mapM","toStaticallySorted","os","of","Just","os'","->","return",".","toDynamicallySorted",".","or","$","os'","Nothing","->","fail","\"or of non-boolean arguments\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L418-L422","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInSine","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease in sinusoidal.","docstring_summary":"Ease in sinusoidal.","docstring_tokens":["Ease","in","sinusoidal","."],"function":"easeInSine c t b =  let cos' = cos (realToFrac t * (pi \/ 2))\n                               in -c * cos' + c + b","function_tokens":["easeInSine","c","t","b","=","let","cos'","=","cos","(","realToFrac","t","*","(","pi","\/","2",")",")","in","-","c","*","cos'","+","c","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L124-L125","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Title _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Title _)                = \"T\"","function_tokens":["go","(","Title","_",")","=","\"T\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L355-L355","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"toColumns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toColumns = MG.toColumns","function_tokens":["toColumns","=","MG","toColumns"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L174-L174","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"k'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"k'      = k + 1","function_tokens":["k'","=","k","+","1"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L44-L44","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"boolToAlign","parameters":"True","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"boolToAlign True  = SimpleAlign.Always","function_tokens":["boolToAlign","True","=","SimpleAlign","Always"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L240-L240","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Exists as phi `ieq1` Exists bs psi = (foldr (&&) True $ zipWith ieq as bs) && phi `ieq` psi","function_tokens":["Exists","as","phi","`","ieq1","`","Exists","bs","psi","=","(","foldr","(","&&",")","True","$","zipWith","ieq","as","bs",")","&&","phi","`","ieq","`","psi"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L536-L536","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"continueLookup","parameters":"nodes sendSignal continue end","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"continueLookup nodes sendSignal continue end = do\n    known <- gets known\n    id <- gets targetId\n    pending <- gets pending\n    polled <- gets polled\n\n    -- Pick the k closest known nodes, that haven't been polled yet\n    let newKnown = take 7 . filter (`notElem` polled) $ nodes ++ known\n\n    -- If there the k closest nodes haven't been polled yet\n    closestPolled <- closestPolled newKnown\n    if (not . null $ newKnown) && not closestPolled\n        then do\n            -- Send signal to the closest node, that hasn't\n            -- been polled yet\n            let next = head . sortByDistanceTo newKnown $ id\n            sendSignal next\n\n            -- Update known\n            modify $ \\s -> s { known = newKnown }\n\n            -- Continue the lookup\n            continue\n\n        -- If there are still pending replies\n        else if not . null $ pending\n            -- Wait for the pending replies to finish\n            then continue\n            -- Stop recursive lookup\n            else end\n\n    where closestPolled known = do\n            polled <- gets polled\n            closest <- closest known\n\n            return . all (`elem` polled) $ closest\n\n          closest known = do\n            id <- gets targetId\n            polled <- gets polled\n\n            -- Return the 7 closest nodes, the lookup had contact with\n            return . take 7 . sortByDistanceTo (known ++ polled) $ id\n\n-- Send a signal to a node","function_tokens":["continueLookup","nodes","sendSignal","continue","end","=","do","known","<-","gets","known","id","<-","gets","targetId","pending","<-","gets","pending","polled","<-","gets","polled","-- Pick the k closest known nodes, that haven't been polled yet","let","newKnown","=","take","7",".","filter","(","`","notElem","`","polled",")","$","nodes","++","known","-- If there the k closest nodes haven't been polled yet","closestPolled","<-","closestPolled","newKnown","if","(","not",".","null","$","newKnown",")","&&","not","closestPolled","then","do","-- Send signal to the closest node, that hasn't","-- been polled yet","let","next","=","head",".","sortByDistanceTo","newKnown","$","id","sendSignal","next","-- Update known","modify","$","\\","s","->","s","{","known","=","newKnown","}","-- Continue the lookup","continue","-- If there are still pending replies","else","if","not",".","null","$","pending","-- Wait for the pending replies to finish","then","continue","-- Stop recursive lookup","else","end","where","closestPolled","known","=","do","polled","<-","gets","polled","closest","<-","closest","known","return",".","all","(","`","elem","`","polled",")","$","closest","closest","known","=","do","id","<-","gets","targetId","polled","<-","gets","polled","-- Return the 7 closest nodes, the lookup had contact with","return",".","take","7",".","sortByDistanceTo","(","known","++","polled",")","$","id","-- Send a signal to a node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L281-L326","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<|>) = mappend","function_tokens":["(","<|>",")","=","mappend"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L136-L136","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"toPeer","parameters":"(SockAddrInet port host)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toPeer (SockAddrInet port host) = do\n    hostname <- inet_ntoa host\n    return $ Just $ Peer hostname port","function_tokens":["toPeer","(","SockAddrInet","port","host",")","=","do","hostname","<-","inet_ntoa","host","return","$","Just","$","Peer","hostname","port"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L85-L88","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"targetPath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetPath = baseTargetPath <\/> relativePath","function_tokens":["targetPath","=","baseTargetPath","<\/>","relativePath"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L52-L52","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"isRedundant","parameters":"m \"BangPatterns\"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isRedundant m \"BangPatterns\" = isRedundantBangPatterns m","function_tokens":["isRedundant","m","\"BangPatterns\"","=","isRedundantBangPatterns","m"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L172-L172","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"warmup","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"warmup = void . foldr1 (>=>) (replicate 10 step) . benchIO \"warmup\" $ pure ()","function_tokens":["warmup","=","void",".","foldr1","(",">=>",")","(","replicate","10","step",")",".","benchIO","\"warmup\"","$","pure","(",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L317-L317","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"languagePragmas","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"languagePragmas = LanguagePragmas.step","function_tokens":["languagePragmas","=","LanguagePragmas","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L71-L71","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"gitAdd","parameters":"fileName","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"gitAdd fileName =\n    callProcess \"git\" [\"add\", \"--\", fileName]","function_tokens":["gitAdd","fileName","=","callProcess","\"git\"","[","\"add\"",",","\"--\"",",","fileName","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L39-L40","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseTabs","parameters":"_ o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseTabs _ o = Tabs.step\n    <$> o A..:? \"spaces\" A..!= 8","function_tokens":["parseTabs","_","o","=","Tabs","step","<$>","o","A",".:?","\"spaces\"","A",".!=","8"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L359-L360","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"trimDiff","parameters":"contextLen","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"trimDiff contextLen =\n    reverse . f . reverse . f\n    where\n        f l = drop (length (takeWhile both l) - contextLen) l\n        both Both{} = True\n        both _ = False","function_tokens":["trimDiff","contextLen","=","reverse",".","f",".","reverse",".","f","where","f","l","=","drop","(","length","(","takeWhile","both","l",")","-","contextLen",")","l","both","Both","{","}","=","True","both","_","=","False"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L43-L50","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = StateC (\\ s -> mfix (runState s . f . snd))","function_tokens":["mfix","f","=","StateC","(","\\","s","->","mfix","(","runState","s",".","f",".","snd",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L111-L111","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unzip5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip5 = MG.unzip5","function_tokens":["unzip5","=","MG","unzip5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L360-L360","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(pre, post) = nameAnnAdornments $\n            GHC.epAnnAnnsL $ GHC.ann $ GHC.getLoc rdrName","function_tokens":["(","pre",",","post",")","=","nameAnnAdornments","$","GHC","epAnnAnnsL","$","GHC","ann","$","GHC","getLoc","rdrName"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L157-L158","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fclabels","parameters":"decls","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fclabels decls =\n  do ds <- decls\n     ls <- forM (ds >>= labels) (mkLabelsWithForDec id True False False False)\n     return (concat ((delabelize <$> ds) : ls))\n  where\n\n  labels :: Dec -> [Dec]\n  labels dec =\n    case dec of\n      DataD    {} -> [dec]\n      NewtypeD {} -> [dec]\n      _           -> []\n\n  delabelize :: Dec -> Dec\n  delabelize dec =\n    case dec of\n#if MIN_VERSION_template_haskell(2,11,0)\n      DataD    ctx nm vars mk cs ns -> DataD    ctx nm vars mk (con <$> cs) ns\n      NewtypeD ctx nm vars mk c  ns -> NewtypeD ctx nm vars mk (con c)      ns\n#else\n      DataD    ctx nm vars cs ns -> DataD    ctx nm vars (con <$> cs) ns\n      NewtypeD ctx nm vars c  ns -> NewtypeD ctx nm vars (con c)      ns\n#endif\n      rest                       -> rest\n    where con (RecC n vst) = NormalC n (map (\\(_, s, t) -> (s, t)) vst)\n#if MIN_VERSION_template_haskell(2,11,0)\n          con (RecGadtC ns vst ty) = GadtC ns (map (\\(_, s, t) -> (s, t)) vst) ty\n#endif\n          con c            = c\n\n-------------------------------------------------------------------------------\n-- Intermediate data types.","function_tokens":["fclabels","decls","=","do","ds","<-","decls","ls","<-","forM","(","ds",">>=","labels",")","(","mkLabelsWithForDec","id","True","False","False","False",")","return","(","concat","(","(","delabelize","<$>","ds",")",":","ls",")",")","where","labels","::","Dec","->","[","Dec","]","labels","dec","=","case","dec","of","DataD","{","}","->","[","dec","]","NewtypeD","{","}","->","[","dec","]","_","->","[","]","delabelize","::","Dec","->","Dec","delabelize","dec","=","case","dec","of","#if MIN_VERSION_template_haskell(2,11,0)","DataD","ctx","nm","vars","mk","cs","ns","->","DataD","ctx","nm","vars","mk","(","con","<$>","cs",")","ns","NewtypeD","ctx","nm","vars","mk","c","ns","->","NewtypeD","ctx","nm","vars","mk","(","con","c",")","ns","#else\n      DataD    ctx nm vars cs ns -> DataD    ctx nm vars (con <$> cs) ns\n      NewtypeD ctx nm vars c  ns -> NewtypeD ctx nm vars (con c)      ns\n","#endif","rest","->","rest","where","con","(","RecC","n","vst",")","=","NormalC","n","(","map","(","\\","(","_",",","s",",","t",")","->","(","s",",","t",")",")","vst",")","#if MIN_VERSION_template_haskell(2,11,0)","con","(","RecGadtC","ns","vst","ty",")","=","GadtC","ns","(","map","(","\\","(","_",",","s",",","t",")","->","(","s",",","t",")",")","vst",")","ty","#endif","con","c","=","c","-------------------------------------------------------------------------------","-- Intermediate data types."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L204-L237","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"getUnderlining","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getUnderlining = case modUnderline mod of\n      Off -> Nothing\n      On -> Just ANSI.SingleUnderline","function_tokens":["getUnderlining","=","case","modUnderline","mod","of","Off","->","Nothing","On","->","Just","ANSI","SingleUnderline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L242-L245","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = UnderLabel","function_tokens":["lift","=","UnderLabel"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L145-L145","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"zip","parameters":"(SymMatrix n1 v1) (SymMatrix n2 v2)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip (SymMatrix n1 v1) (SymMatrix n2 v2)\n    | n1 \/= n2 = error \"imcompatible size\"\n    | otherwise = SymMatrix n1 $ G.zip v1 v2","function_tokens":["zip","(","SymMatrix","n1","v1",")","(","SymMatrix","n2","v2",")","|","n1","\/=","n2","=","error","\"imcompatible size\"","|","otherwise","=","SymMatrix","n1","$","G","zip","v1","v2"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L101-L103","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fresh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fresh = mkName <$> delete \"f\" freshNames","function_tokens":["fresh","=","mkName","<$>","delete","\"f\"","freshNames"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L515-L515","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"r1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r1 = rp `U.unsafeIndex` (i+1) - 1","function_tokens":["r1","=","rp","`","U","unsafeIndex","`","(","i","+","1",")","-","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L87-L87","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"makeCr","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeCr x = x <> \"\\r\"","function_tokens":["makeCr","x","=","x","<>","\"\\r\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L130-L130","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"diag","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_summary":"O(m*n) Create a square matrix with given diagonal, other entries default to 0","docstring_tokens":["O","(","m","*","n",")","Create","a","square","matrix","with","given","diagonal","other","entries","default","to","0"],"function":"diag = MG.diag","function_tokens":["diag","=","MG","diag"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L203-L203","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInOutSine","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease in and out sinusoidal.","docstring_summary":"Ease in and out sinusoidal.","docstring_tokens":["Ease","in","and","out","sinusoidal","."],"function":"easeInOutSine c t b =  let cos' = cos (pi * realToFrac t)\n                                  in (-c \/ 2) * (cos' - 1) + b","function_tokens":["easeInOutSine","c","t","b","=","let","cos'","=","cos","(","pi","*","realToFrac","t",")","in","(","-","c","\/","2",")","*","(","cos'","-","1",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L133-L134","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sourceVelocity","parameters":"","argument_list":"","return_statement":"","docstring":"'sourceVelocity' contains current velocity (speed and direction) of the source in the world coordinate system. Any 3-tuple of valid float values is allowed, and the initial velocity is ('Vector3' 0 0 0). 'sourceVelocity' does not affect 'sourcePosition'. OpenAL does not calculate the velocity from subsequent position updates, nor does it adjust the position over time based on the specified velocity. Any such calculation is left to the application. For the purposes of sound processing, position and velocity are independent parameters affecting different aspects of the sounds.  'sourceVelocity' is taken into account by the driver to synthesize the Doppler effect perceived by the listener for each source, based on the velocity of both source and listener, and the Doppler related parameters.","docstring_summary":"'sourceVelocity' contains current velocity (speed and direction) of the source in the world coordinate system. Any 3-tuple of valid float values is allowed, and the initial velocity is ('Vector3' 0 0 0). 'sourceVelocity' does not affect 'sourcePosition'. OpenAL does not calculate the velocity from subsequent position updates, nor does it adjust the position over time based on the specified velocity. Any such calculation is left to the application. For the purposes of sound processing, position and velocity are independent parameters affecting different aspects of the sounds.  'sourceVelocity' is taken into account by the driver to synthesize the Doppler effect perceived by the listener for each source, based on the velocity of both source and listener, and the Doppler related parameters.","docstring_tokens":["sourceVelocity","contains","current","velocity","(","speed","and","direction",")","of","the","source","in","the","world","coordinate","system",".","Any","3","-","tuple","of","valid","float","values","is","allowed","and","the","initial","velocity","is","(","Vector3","0","0","0",")",".","sourceVelocity","does","not","affect","sourcePosition",".","OpenAL","does","not","calculate","the","velocity","from","subsequent","position","updates","nor","does","it","adjust","the","position","over","time","based","on","the","specified","velocity",".","Any","such","calculation","is","left","to","the","application",".","For","the","purposes","of","sound","processing","position","and","velocity","are","independent","parameters","affecting","different","aspects","of","the","sounds",".","sourceVelocity","is","taken","into","account","by","the","driver","to","synthesize","the","Doppler","effect","perceived","by","the","listener","for","each","source","based","on","the","velocity","of","both","source","and","listener","and","the","Doppler","related","parameters","."],"function":"sourceVelocity = makeSourceStateVar dictVector3ALfloat GetVelocity","function_tokens":["sourceVelocity","=","makeSourceStateVar","dictVector3ALfloat","GetVelocity"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L166-L166","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"toList","parameters":"Menu {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toList Menu {..} = toList _menuItems","function_tokens":["toList","Menu","{","..","}","=","toList","_menuItems"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L65-L65","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"ifThenElse","parameters":"(DynamicallySorted s1 i)\n                   (DynamicallySorted s2 t)\n                   (DynamicallySorted s3 e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifThenElse (DynamicallySorted s1 i)\n                   (DynamicallySorted s2 t)\n                   (DynamicallySorted s3 e) = case s1 %~ SBooleanSort of\n            Proved Refl -> case s2 %~ s3 of\n                Proved Refl -> return . DynamicallySorted s2 $ inject (IfThenElse s2 i t e)\n                Disproved _ -> fail \"inconsistent sorts of then and else branches\"\n            Disproved _ -> fail \"branching on non-boolean expression\"\n\n-- | A smart constructor for an if-then-else expression","function_tokens":["ifThenElse","(","DynamicallySorted","s1","i",")","(","DynamicallySorted","s2","t",")","(","DynamicallySorted","s3","e",")","=","case","s1","%~","SBooleanSort","of","Proved","Refl","->","case","s2","%~","s3","of","Proved","Refl","->","return",".","DynamicallySorted","s2","$","inject","(","IfThenElse","s2","i","t","e",")","Disproved","_","->","fail","\"inconsistent sorts of then and else branches\"","Disproved","_","->","fail","\"branching on non-boolean expression\"","-- | A smart constructor for an if-then-else expression"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L73-L82","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/String.hs","language":"haskell","identifier":"peekALCString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"peekALCString = peekCString . castPtr","function_tokens":["peekALCString","=","peekCString",".","castPtr"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/String.hs#L33-L33","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/String.hs","hash_val":13294,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"unstore'","parameters":"a'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unstore' a' = fromMaybe (return a') (match a' >>= \\(Equals _ l r) -> instantiate l (unIFix r) <|> instantiate r (unIFix l))","function_tokens":["unstore'","a'","=","fromMaybe","(","return","a'",")","(","match","a'",">>=","\\","(","Equals","_","l","r",")","->","instantiate","l","(","unIFix","r",")","<|>","instantiate","r","(","unIFix","l",")",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L930-L930","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"closestPolled","parameters":"known","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"closestPolled known = do\n            polled <- gets polled\n            closest <- closest known\n\n            return . all (`elem` polled) $ closest","function_tokens":["closestPolled","known","=","do","polled","<-","gets","polled","closest","<-","closest","known","return",".","all","(","`","elem","`","polled",")","$","closest"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L312-L318","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"itCache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itCache = mkCache","function_tokens":["itCache","=","mkCache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L46-L46","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"showAbc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showAbc = error \"Not impl\"","function_tokens":["showAbc","=","error","\"Not impl\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L586-L586","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"freeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeze = MG.freeze","function_tokens":["freeze","=","MG","freeze"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L378-L378","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unzip","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip = MG.unzip","function_tokens":["unzip","=","MG","unzip"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L344-L344","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(History a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (History a)              = a","function_tokens":["go","(","History","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L411-L411","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"iter","parameters":"!tfm x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"iter !tfm x = case x of\n                Empty       -> Empty\n                Single a    -> Single (eventFromTfm tfm a)\n                TFun t a    -> iter (tfm `composeTfm` t) a\n                Append a b  -> Append (iter tfm a) (iter tfm b)","function_tokens":["iter","tfm","x","=","case","x","of","Empty","->","Empty","Single","a","->","Single","(","eventFromTfm","tfm","a",")","TFun","t","a","->","iter","(","tfm","`","composeTfm","`","t",")","a","Append","a","b","->","Append","(","iter","tfm","a",")","(","iter","tfm","b",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L338-L345","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"csi'","parameters":"[] b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"csi' [] b = B.char7 '\\ESC' <> B.char7 '[' <> B.char7 b","function_tokens":["csi'","[","]","b","=","B","char7","'\\ESC'","<>","B","char7","'['","<>","B","char7","b"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L392-L392","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' (InL fa) = bind' fa","function_tokens":["bind'","(","InL","fa",")","=","bind'","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L819-L819","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"f","parameters":"(pa, ea) a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f (pa, ea) a = case a of\n      SinkEntry m src s ->\n        ( pa\n            { paSinkEntry = M.insert s src (paSinkEntry pa),\n              paCopyEntry = M.map (M.filter (\/= s)) (paCopyEntry pa)\n            },\n          (clearEditingFor s ea)\n            { eaCompression = M.insert s m (eaCompression ea)\n            }\n        )\n      CopyEntry path os ns ->\n        ( pa\n            { paSinkEntry = M.delete ns (paSinkEntry pa),\n              paCopyEntry = M.alter (ef os ns) path (paCopyEntry pa)\n            },\n          clearEditingFor ns ea\n        )\n      RenameEntry os ns ->\n        ( pa\n            { paCopyEntry = M.map (M.map $ re os ns) (paCopyEntry pa),\n              paSinkEntry = renameKey os ns (paSinkEntry pa)\n            },\n          ea\n            { eaCompression = renameKey os ns (eaCompression ea),\n              eaEntryComment = renameKey os ns (eaEntryComment ea),\n              eaDeleteComment = renameKey os ns (eaDeleteComment ea),\n              eaModTime = renameKey os ns (eaModTime ea),\n              eaExtraField = renameKey os ns (eaExtraField ea),\n              eaDeleteField = renameKey os ns (eaDeleteField ea)\n            }\n        )\n      DeleteEntry s ->\n        ( pa\n            { paSinkEntry = M.delete s (paSinkEntry pa),\n              paCopyEntry = M.map (M.delete s) (paCopyEntry pa)\n            },\n          clearEditingFor s ea\n        )\n      Recompress m s ->\n        (pa, ea {eaCompression = M.insert s m (eaCompression ea)})\n      SetEntryComment txt s ->\n        ( pa,\n          ea\n            { eaEntryComment = M.insert s txt (eaEntryComment ea),\n              eaDeleteComment = M.delete s (eaDeleteComment ea)\n            }\n        )\n      DeleteEntryComment s ->\n        ( pa,\n          ea\n            { eaEntryComment = M.delete s (eaEntryComment ea),\n              eaDeleteComment = M.insert s () (eaDeleteComment ea)\n            }\n        )\n      SetModTime time s ->\n        (pa, ea {eaModTime = M.insert s time (eaModTime ea)})\n      AddExtraField n b s ->\n        ( pa,\n          ea\n            { eaExtraField = M.alter (ef n b) s (eaExtraField ea),\n              eaDeleteField = M.delete s (eaDeleteField ea)\n            }\n        )\n      DeleteExtraField n s ->\n        ( pa,\n          ea\n            { eaExtraField = M.alter (er n) s (eaExtraField ea),\n              eaDeleteField = M.alter (ef n ()) s (eaDeleteField ea)\n            }\n        )\n      SetExternalFileAttributes b s ->\n        ( pa,\n          ea {eaExtFileAttr = M.insert s b (eaExtFileAttr ea)}\n        )\n      _ -> (pa, ea)","function_tokens":["f","(","pa",",","ea",")","a","=","case","a","of","SinkEntry","m","src","s","->","(","pa","{","paSinkEntry","=","M","insert","s","src","(","paSinkEntry","pa",")",",","paCopyEntry","=","M","map","(","M","filter","(","\/=","s",")",")","(","paCopyEntry","pa",")","}",",","(","clearEditingFor","s","ea",")","{","eaCompression","=","M","insert","s","m","(","eaCompression","ea",")","}",")","CopyEntry","path","os","ns","->","(","pa","{","paSinkEntry","=","M","delete","ns","(","paSinkEntry","pa",")",",","paCopyEntry","=","M","alter","(","ef","os","ns",")","path","(","paCopyEntry","pa",")","}",",","clearEditingFor","ns","ea",")","RenameEntry","os","ns","->","(","pa","{","paCopyEntry","=","M","map","(","M","map","$","re","os","ns",")","(","paCopyEntry","pa",")",",","paSinkEntry","=","renameKey","os","ns","(","paSinkEntry","pa",")","}",",","ea","{","eaCompression","=","renameKey","os","ns","(","eaCompression","ea",")",",","eaEntryComment","=","renameKey","os","ns","(","eaEntryComment","ea",")",",","eaDeleteComment","=","renameKey","os","ns","(","eaDeleteComment","ea",")",",","eaModTime","=","renameKey","os","ns","(","eaModTime","ea",")",",","eaExtraField","=","renameKey","os","ns","(","eaExtraField","ea",")",",","eaDeleteField","=","renameKey","os","ns","(","eaDeleteField","ea",")","}",")","DeleteEntry","s","->","(","pa","{","paSinkEntry","=","M","delete","s","(","paSinkEntry","pa",")",",","paCopyEntry","=","M","map","(","M","delete","s",")","(","paCopyEntry","pa",")","}",",","clearEditingFor","s","ea",")","Recompress","m","s","->","(","pa",",","ea","{","eaCompression","=","M","insert","s","m","(","eaCompression","ea",")","}",")","SetEntryComment","txt","s","->","(","pa",",","ea","{","eaEntryComment","=","M","insert","s","txt","(","eaEntryComment","ea",")",",","eaDeleteComment","=","M","delete","s","(","eaDeleteComment","ea",")","}",")","DeleteEntryComment","s","->","(","pa",",","ea","{","eaEntryComment","=","M","delete","s","(","eaEntryComment","ea",")",",","eaDeleteComment","=","M","insert","s","(",")","(","eaDeleteComment","ea",")","}",")","SetModTime","time","s","->","(","pa",",","ea","{","eaModTime","=","M","insert","s","time","(","eaModTime","ea",")","}",")","AddExtraField","n","b","s","->","(","pa",",","ea","{","eaExtraField","=","M","alter","(","ef","n","b",")","s","(","eaExtraField","ea",")",",","eaDeleteField","=","M","delete","s","(","eaDeleteField","ea",")","}",")","DeleteExtraField","n","s","->","(","pa",",","ea","{","eaExtraField","=","M","alter","(","er","n",")","s","(","eaExtraField","ea",")",",","eaDeleteField","=","M","alter","(","ef","n","(",")",")","s","(","eaDeleteField","ea",")","}",")","SetExternalFileAttributes","b","s","->","(","pa",",","ea","{","eaExtFileAttr","=","M","insert","s","b","(","eaExtFileAttr","ea",")","}",")","_","->","(","pa",",","ea",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L356-L431","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"ifold","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (InL fa) = ifold fa","function_tokens":["ifold","(","InL","fa",")","=","ifold","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L91-L91","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"evalAccum","parameters":"","argument_list":"","return_statement":"","docstring":"Run an 'Accum' effect (typically with a 'Monoid'al log), producing the result value and discarding the final log.  @ 'evalAccum' = 'runAccum' ('const' '.' 'pure') @  @since 1.1.2.0","docstring_summary":"Run an 'Accum' effect (typically with a 'Monoid'al log), producing the result value and discarding the final log.","docstring_tokens":["Run","an","Accum","effect","(","typically","with","a","Monoid","al","log",")","producing","the","result","value","and","discarding","the","final","log","."],"function":"evalAccum = runAccum $ const pure","function_tokens":["evalAccum","=","runAccum","$","const","pure"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L75-L75","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"unintern","parameters":"(Tip _ j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (Tip _ j) = UTip j","function_tokens":["unintern","(","Tip","_","j",")","=","UTip","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L225-L225","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"some1","parameters":"a","argument_list":"","return_statement":"","docstring":"One or more, returning a 'NonEmpty' list of the results.  @ 'some1' m = (':|') '<$>' m '<*>' 'many' m @  @since 1.0.0.0","docstring_summary":"One or more, returning a 'NonEmpty' list of the results.","docstring_tokens":["One","or","more","returning","a","NonEmpty","list","of","the","results","."],"function":"some1 a = (:|) <$> a <*> many a","function_tokens":["some1","a","=","(",":|",")","<$>","a","<*>","many","a"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L113-L113","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"lam","parameters":"v t e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lam v t e = intern (BLam v t e)","function_tokens":["lam","v","t","e","=","intern","(","BLam","v","t","e",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L81-L81","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"cos'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cos' = cos (realToFrac t * (pi \/ 2))","function_tokens":["cos'","=","cos","(","realToFrac","t","*","(","pi","\/","2",")",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L124-L124","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"go","parameters":"_ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ [] = []","function_tokens":["go","_","[","]","=","[","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L90-L90","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"work","parameters":"x (z:zs) stk","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"work x (z:zs) stk = reduce z zs (branchMask z x) x (tip x) stk","function_tokens":["work","x","(","z",":","zs",")","stk","=","reduce","z","zs","(","branchMask","z","x",")","x","(","tip","x",")","stk"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L746-L746","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"scanTween","parameters":"(TweenT s) t dts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"scanTween (TweenT s) t dts =\n  evalStateT\n    (scanSpline s t dts)\n    0","function_tokens":["scanTween","(","TweenT","s",")","t","dts","=","evalStateT","(","scanSpline","s","t","dts",")","0"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L223-L226","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"fail","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail s = lift (Fail.fail s)","function_tokens":["fail","s","=","lift","(","Fail","fail","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L77-L77","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeOutSine","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease out sinusoidal.","docstring_summary":"Ease out sinusoidal.","docstring_tokens":["Ease","out","sinusoidal","."],"function":"easeOutSine c t b =  let cos' = cos (realToFrac t * (pi \/ 2)) in c * cos' + b","function_tokens":["easeOutSine","c","t","b","=","let","cos'","=","cos","(","realToFrac","t","*","(","pi","\/","2",")",")","in","c","*","cos'","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L129-L129","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"rows","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rows = MG.rows","function_tokens":["rows","=","MG","rows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L117-L117","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"pushCompletionFunction","parameters":"","argument_list":"","return_statement":"","docstring":"Add a 'CompletionFunc' to the stack.  @since 1.0.0.0","docstring_summary":"Add a 'CompletionFunc' to the stack.","docstring_tokens":["Add","a","CompletionFunc","to","the","stack","."],"function":"pushCompletionFunction = Prim.pushCompFunc >>> liftByline","function_tokens":["pushCompletionFunction","=","Prim","pushCompFunc",">>>","liftByline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L43-L43","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"iap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"iap = coerce $ (<*>) @m @a @b","function_tokens":["iap","=","coerce","$","(","<*>",")","@","m","@","a","@","b"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L46-L46","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"letter","parameters":"","argument_list":"","return_statement":"","docstring":"Matches any character.","docstring_summary":"Matches any character.","docstring_tokens":["Matches","any","character","."],"function":"letter = lift . lift $ A.letter","function_tokens":["letter","=","lift",".","lift","$","A","letter"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L97-L97","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"fromAdornment","parameters":"GHC.NameParens","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromAdornment GHC.NameParens     = (\"(\", \")\")","function_tokens":["fromAdornment","GHC","NameParens","=","(","\"(\"",",","\")\"",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L184-L184","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"readAbc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readAbc = error \"Not impl\"","function_tokens":["readAbc","=","error","\"Not impl\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L583-L583","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"modifyAdvice","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modifyAdvice = id","function_tokens":["modifyAdvice","=","id"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L74-L74","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"leftover","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"leftover = ConduitParser . lift . lift . Conduit.leftover","function_tokens":["leftover","=","ConduitParser",".","lift",".","lift",".","Conduit","leftover"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L180-L180","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fsTys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fsTys = map (typeVariables . snd) (delete f fs)","function_tokens":["fsTys","=","map","(","typeVariables",".","snd",")","(","delete","f","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L336-L336","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mapPred","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapPred = mapTypeVariables","function_tokens":["mapPred","=","mapTypeVariables"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L681-L681","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"stretchTfm","parameters":"k (Tfm str del)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stretchTfm k (Tfm str del) = Tfm (k*str)  (k*del)","function_tokens":["stretchTfm","k","(","Tfm","str","del",")","=","Tfm","(","k","*","str",")","(","k","*","del",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L358-L358","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"desktopPath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desktopPath = desktopDir <\/> exeFp <.> \"desktop\"","function_tokens":["desktopPath","=","desktopDir","<\/>","exeFp","<.>","\"desktop\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L44-L44","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"left","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"left       = foldl1' GHC.combineSrcSpans guardsLocs","function_tokens":["left","=","foldl1'","GHC","combineSrcSpans","guardsLocs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L170-L170","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"add","parameters":"[a]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"add [a] = a","function_tokens":["add","[","a","]","=","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L199-L199","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"patsLocs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"patsLocs = map GHC.getLocA pats","function_tokens":["patsLocs","=","map","GHC","getLocA","pats"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L135-L135","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(MkFixed x) = todSec tod","function_tokens":["(","MkFixed","x",")","=","todSec","tod"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1175-L1175","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"commentGroupHasComments","parameters":"CommentGroup {..}","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"commentGroupHasComments CommentGroup {..} = not $\n    null","function_tokens":["commentGroupHasComments","CommentGroup","{","..","}","=","not","$","null"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L137-L138","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"optnames","parameters":"opt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"optnames opt =\n          case O.optMain opt of\n            O.OptReader ns _ _ -> ns\n            O.FlagReader ns _ -> ns\n            _ -> mempty\n\n-- | Internal function to split user input into words similar to what\n-- a POSIX shell does.","function_tokens":["optnames","opt","=","case","O","optMain","opt","of","O","OptReader","ns","_","_","->","ns","O","FlagReader","ns","_","->","ns","_","->","mempty","-- | Internal function to split user input into words similar to what","-- a POSIX shell does."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L132-L140","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"i","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"i  = if power `mod` 2 == 1 then 1 else -1","function_tokens":["i","=","if","power","`","mod","`","2","==","1","then","1","else","-","1"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L119-L119","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"filterEvents","parameters":"","argument_list":"","return_statement":"","docstring":"Filter track.","docstring_summary":"Filter track.","docstring_tokens":["Filter","track","."],"function":"filterEvents = onEvents . filter","function_tokens":["filterEvents","=","onEvents",".","filter"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L232-L232","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"checkSignal","parameters":"(Signal _ (RETURN_NODES _ nodes))","argument_list":"","return_statement":"","docstring":"Check wether the Node we are looking for was found. If so, return it, otherwise continue the lookup.","docstring_summary":"Check wether the Node we are looking for was found. If so, return it, otherwise continue the lookup.","docstring_tokens":["Check","wether","the","Node","we","are","looking","for","was","found",".","If","so","return","it","otherwise","continue","the","lookup","."],"function":"checkSignal (Signal _ (RETURN_NODES _ nodes)) =\n                case find (\\(Node _ nId) -> nId == id) nodes of\n                    Just node -> return . Just $ node\n                    _ -> continueLookup nodes sendS continue end\n\n          -- Continuing always means waiting for the next signal","function_tokens":["checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","case","find","(","\\","(","Node","_","nId",")","->","nId","==","id",")","nodes","of","Just","node","->","return",".","Just","$","node","_","->","continueLookup","nodes","sendS","continue","end","-- Continuing always means waiting for the next signal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L170-L176","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"name","parameters":"(Field n _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"name (Field n _ _ _) = n","function_tokens":["name","(","Field","n","_","_","_",")","=","n"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L324-L324","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtLabels","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"districtLabels = fromJust $ (fmap labels) $ mapM (shpRecLabel) . shpRecs $ file","function_tokens":["districtLabels","=","fromJust","$","(","fmap","labels",")","$","mapM","(","shpRecLabel",")",".","shpRecs","$","file"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L69-L69","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"toByteStruct","parameters":"s","argument_list":"","return_statement":"","docstring":"Converts a Serialize into a ByteStruct","docstring_summary":"Converts a Serialize into a ByteStruct","docstring_tokens":["Converts","a","Serialize","into","a","ByteStruct"],"function":"toByteStruct s = B.foldr (\\w bits -> convert w ++ bits) [] $ toBS s\n    where convert w = foldr (\\i bits -> testBit w i : bits) [] [0..7]\n\n-- | Convert a ByteStruct back to its ByteString form","function_tokens":["toByteStruct","s","=","B","foldr","(","\\","w","bits","->","convert","w","++","bits",")","[","]","$","toBS","s","where","convert","w","=","foldr","(","\\","i","bits","->","testBit","w","i",":","bits",")","[","]","[","0","..","7","]","-- | Convert a ByteStruct back to its ByteString form"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L59-L63","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"recompression","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"recompression = compression \/= compressed","function_tokens":["recompression","=","compression","\/=","compressed"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L499-L499","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"imap","parameters":"f (Exists vs phi)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Exists vs phi) = Exists vs $ f phi","function_tokens":["imap","f","(","Exists","vs","phi",")","=","Exists","vs","$","f","phi"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L543-L543","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"matchGroupToAlignable","parameters":"conf (Hs.MG _ alts _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchGroupToAlignable conf (Hs.MG _ alts _) = cases' ++ patterns'\n  where\n    (cases, patterns) = partitionEithers . fromMaybe [] $ traverse matchToAlignable (GHC.unLoc alts)\n    cases' = groupAlign (cCases conf) cases\n    patterns' = groupAlign (cTopLevelPatterns conf) patterns\n\n\n--------------------------------------------------------------------------------","function_tokens":["matchGroupToAlignable","conf","(","Hs","MG","_","alts","_",")","=","cases'","++","patterns'","where","(","cases",",","patterns",")","=","partitionEithers",".","fromMaybe","[","]","$","traverse","matchToAlignable","(","GHC","unLoc","alts",")","cases'","=","groupAlign","(","cCases","conf",")","cases","patterns'","=","groupAlign","(","cTopLevelPatterns","conf",")","patterns","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L106-L114","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"usedVars","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"usedVars  = filter (`elem` fieldVars) varNames","function_tokens":["usedVars","=","filter","(","`","elem","`","fieldVars",")","varNames"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L567-L567","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"es","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge es  = inject $ Mul es","function_tokens":["merge","es","=","inject","$","Mul","es"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L189-L189","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = exists' <?> \"Existential\" where\n        var' :: Parser (DynamicallySorted Var)\n        var' = parser (Proxy :: Proxy VarF) var'\n\n        exists' = do\n            _   <- char '(' *> string \"exists\" *> space *> char '('\n            vs  <- var' `sepBy1` space\n            _   <- char ')' *> space\n            phi <- local (union (fromList $ map context vs)) r\n            _   <- char ')'\n            exists'' vs phi\n\n        exists'' [] _   = fail \"quantifying zero variables\"\n        exists'' vs phi = case (mapM toStaticallySorted vs :: Maybe [Var v]) of\n            Just vs' -> case toStaticallySorted phi of\n                Just phi' -> return . toDynamicallySorted . exists vs' $ phi'\n                Nothing   -> fail \"quantifying non-boolean expression\"\n            Nothing  -> fail \"ill-sorted quantifier\"\n\n        context (DynamicallySorted s v) = case match v of\n            Just (Var n _) -> (n, DynamicSort s)\n            _              -> error \"impossible error\"","function_tokens":["parser","_","r","=","exists'","<?>","\"Existential\"","where","var'","::","Parser","(","DynamicallySorted","Var",")","var'","=","parser","(","Proxy","::","Proxy","VarF",")","var'","exists'","=","do","_","<-","char","'('","*>","string","\"exists\"","*>","space","*>","char","'('","vs","<-","var'","`","sepBy1","`","space","_","<-","char","')'","*>","space","phi","<-","local","(","union","(","fromList","$","map","context","vs",")",")","r","_","<-","char","')'","exists''","vs","phi","exists''","[","]","_","=","fail","\"quantifying zero variables\"","exists''","vs","phi","=","case","(","mapM","toStaticallySorted","vs","::","Maybe","[","Var","v","]",")","of","Just","vs'","->","case","toStaticallySorted","phi","of","Just","phi'","->","return",".","toDynamicallySorted",".","exists","vs'","$","phi'","Nothing","->","fail","\"quantifying non-boolean expression\"","Nothing","->","fail","\"ill-sorted quantifier\"","context","(","DynamicallySorted","s","v",")","=","case","match","v","of","Just","(","Var","n","_",")","->","(","n",",","DynamicSort","s",")","_","->","error","\"impossible error\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L589-L612","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"defaultFileMode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultFileMode = 0","function_tokens":["defaultFileMode","=","0"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1219-L1219","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"makeFormat","parameters":"1 16","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeFormat 1 16 = Mono16","function_tokens":["makeFormat","1","16","=","Mono16"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L146-L146","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"avg","parameters":"list","argument_list":"","return_statement":"","docstring":"Average over a foldable container","docstring_summary":"Average over a foldable container","docstring_tokens":["Average","over","a","foldable","container"],"function":"avg list = sum list \/ (fromIntegral . length $ list)","function_tokens":["avg","list","=","sum","list","\/","(","fromIntegral",".","length","$","list",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L19-L19","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ifold","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold _ = F.Const mempty","function_tokens":["ifold","_","=","F","Const","mempty"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L257-L257","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"putExtraField","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putExtraField m = forM_ (M.keys m) $ \\headerId -> do\n  let b = B.take 0xffff (m ! headerId)\n  putWord16le headerId\n  putWord16le (fromIntegral $ B.length b)\n  putByteString b\n\n-- | Create 'ByteString' representing the entire central directory.","function_tokens":["putExtraField","m","=","forM_","(","M","keys","m",")","$","\\","headerId","->","do","let","b","=","B","take","0xffff","(","m","!","headerId",")","putWord16le","headerId","putWord16le","(","fromIntegral","$","B","length","b",")","putByteString","b","-- | Create 'ByteString' representing the entire central directory."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L791-L798","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"getBangPat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getBangPat = \\case\n      GHC.BangPat{} -> [()]\n      _             -> []","function_tokens":["getBangPat","=","\\","case","GHC","BangPat","{","}","->","[","(",")","]","_","->","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L195-L199","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"iso","parameters":"(Iso f _) (Iso _ y)","argument_list":"","return_statement":"","docstring":"Lift a polymorphic isomorphism into a `Lens`.  The isomorphism needs to be passed in twice to properly unify.","docstring_summary":"Lift a polymorphic isomorphism into a `Lens`.  The isomorphism needs to be passed in twice to properly unify.","docstring_tokens":["Lift","a","polymorphic","isomorphism","into","a","Lens",".","The","isomorphism","needs","to","be","passed","in","twice","to","properly","unify","."],"function":"iso (Iso f _) (Iso _ y) = lens f (app . arr (\\(m, v) -> (y . m . f, v)))","function_tokens":["iso","(","Iso","f","_",")","(","Iso","_","y",")","=","lens","f","(","app",".","arr","(","\\","(","m",",","v",")","->","(","y",".","m",".","f",",","v",")",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L82-L82","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"go","parameters":"mkSpace","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go mkSpace = hSetEcho stdin False *> mkSpace *> warmup *> (flip (runMain cfg) (S.fromList . zipWith (BenchmarkMeta 0 0) [1..] $ reverse pad) =<< now)","function_tokens":["go","mkSpace","=","hSetEcho","stdin","False","*>","mkSpace","*>","warmup","*>","(","flip","(","runMain","cfg",")","(","S","fromList",".","zipWith","(","BenchmarkMeta","0","0",")","[","1","..","]","$","reverse","pad",")","=<<","now",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L139-L139","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"(i, f@(_, ty))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one (i, f@(_, ty)) = Field Nothing mono ty (Context i c con, [])\n              where fsTys = map (typeVariables . snd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["one","(","i",",","f","@","(","_",",","ty",")",")","=","Field","Nothing","mono","ty","(","Context","i","c","con",",","[","]",")","where","fsTys","=","map","(","typeVariables",".","snd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L335-L339","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"steps","parameters":"(x1:x2:xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"steps (x1:x2:xs) = x2 - x1 : steps (x2:xs)","function_tokens":["steps","(","x1",":","x2",":","xs",")","=","x2","-","x1",":","steps","(","x2",":","xs",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L54-L54","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"lock","parameters":"(Key u ref) x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lock (Key u ref) x = x `seq` (Locker u $ writeIORef ref $ Just x)","function_tokens":["lock","(","Key","u","ref",")","x","=","x","`","seq","`","(","Locker","u","$","writeIORef","ref","$","Just","x",")"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L14-L14","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Mul as `ieq1` Mul bs | length as == length bs = foldr (&&) True $ zipWith ieq as bs","function_tokens":["Mul","as","`","ieq1","`","Mul","bs","|","length","as","==","length","bs","=","foldr","(","&&",")","True","$","zipWith","ieq","as","bs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L61-L61","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Transcription _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Transcription _)        = \"Z\"","function_tokens":["go","(","Transcription","_",")","=","\"Z\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L360-L360","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"write","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"write s = send (Write s)","function_tokens":["write","s","=","send","(","Write","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L52-L52","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Meter _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Meter _)                = (True, True, True, True)","function_tokens":["go","(","Meter","_",")","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L377-L377","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"fmap","parameters":"f v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f v = VarT $ (g <$>) . runVarT v\n    where g (b, vb) = (f b, f <$> vb)\n\n-- | A var is a category.\n--\n-- @\n--   id = var id\n--   f . g = g >>> f\n-- @\n--\n-- or\n--\n-- >  f . g = f <<< g\n--\n-- >>> let v = accumulate (+) 0 . 1\n-- >>> testVarOver v [(),(),()]\n-- 1\n-- 2\n-- 3","function_tokens":["fmap","f","v","=","VarT","$","(","g","<$>",")",".","runVarT","v","where","g","(","b",",","vb",")","=","(","f","b",",","f","<$>","vb",")","-- | A var is a category.","--","-- @","--   id = var id","--   f . g = g >>> f","-- @","--","-- or","--","-- >  f . g = f <<< g","--","-- >>> let v = accumulate (+) 0 . 1","-- >>> testVarOver v [(),(),()]","-- 1","-- 2","-- 3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L91-L110","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"identity","parameters":"(Lam i _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identity (Lam i _ _ _) = i","function_tokens":["identity","(","Lam","i","_","_","_",")","=","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L44-L44","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printSingleLineExportList","parameters":"conf exports","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printSingleLineExportList conf exports = do\n    space >> putText \"(\"\n    printExports exports\n    putText \")\" >> space >> putText \"where\"\n  where\n    printExports :: [GHC.LIE GHC.GhcPs] -> P ()\n    printExports = \\case\n        []     -> pure ()\n        [e]    -> putExport conf e\n        (e:es) -> putExport conf e >> comma >> space >> printExports es","function_tokens":["printSingleLineExportList","conf","exports","=","do","space",">>","putText","\"(\"","printExports","exports","putText","\")\"",">>","space",">>","putText","\"where\"","where","printExports","::","[","GHC","LIE","GHC","GhcPs","]","->","P","(",")","printExports","=","\\","case","[","]","->","pure","(",")","[","e","]","->","putExport","conf","e","(","e",":","es",")","->","putExport","conf","e",">>","comma",">>","space",">>","printExports","es"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L178-L189","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"unicodeSyntax","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"unicodeSyntax = UnicodeSyntax.step","function_tokens":["unicodeSyntax","=","UnicodeSyntax","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L89-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"pairStateVars","parameters":"var1 var2","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"pairStateVars var1 var2 =\n   makeStateVar\n      (liftM2 (,) (get var1) (get var2))\n      (\\(val1,val2) -> do var1 $= val1; var2 $= val2)","function_tokens":["pairStateVars","var1","var2","=","makeStateVar","(","liftM2","(",",",")","(","get","var1",")","(","get","var2",")",")","(","\\","(","val1",",","val2",")","->","do","var1","$=","val1",";","var2","$=","val2",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L494-L497","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = StateC (\\ s -> pure (s, a))","function_tokens":["pure","a","=","StateC","(","\\","s","->","pure","(","s",",","a",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L79-L79","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"isMonomorphic","parameters":"field vars","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isMonomorphic field vars =\n  let fieldVars = typeVariables field\n      varNames  = nameFromBinder <$> vars\n      usedVars  = filter (`elem` fieldVars) varNames\n   in null usedVars","function_tokens":["isMonomorphic","field","vars","=","let","fieldVars","=","typeVariables","field","varNames","=","nameFromBinder","<$>","vars","usedVars","=","filter","(","`","elem","`","fieldVars",")","varNames","in","null","usedVars"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L597-L601","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"a","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a = parser (Proxy :: Proxy f) a","function_tokens":["a","=","parser","(","Proxy","::","Proxy","f",")","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L74-L74","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","language":"haskell","identifier":"zipPadded","parameters":"a b (c:cs) (d:ds)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipPadded a b (c:cs) (d:ds) = (c, d):zipPadded a b cs ds","function_tokens":["zipPadded","a","b","(","c",":","cs",")","(","d",":","ds",")","=","(","c",",","d",")",":","zipPadded","a","b","cs","ds"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs#L6-L6","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","hash_val":30237,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(n, ns') = runCoiter ns","function_tokens":["(","n",",","ns'",")","=","runCoiter","ns"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L908-L908","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"idx","parameters":"n i j","argument_list":"","return_statement":"","docstring":"helper row major upper triangular indexing","docstring_summary":"helper row major upper triangular indexing","docstring_tokens":["helper","row","major","upper","triangular","indexing"],"function":"idx n i j | i <= j = (i * (2 * n - i - 1)) `shiftR` 1 + j\n          | otherwise = (j * (2 * n - j - 1)) `shiftR` 1 + i","function_tokens":["idx","n","i","j","|","i","<=","j","=","(","i","*","(","2","*","n","-","i","-","1",")",")","`","shiftR","`","1","+","j","|","otherwise","=","(","j","*","(","2","*","n","-","j","-","1",")",")","`","shiftR","`","1","+","i"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L118-L119","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"groups","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"groups = [(b, pgs) | (b, pgs) <- groupAdjacent' (convertFstToBlock languagePragmas)]","function_tokens":["groups","=","[","(","b",",","pgs",")","|","(","b",",","pgs",")","<-","groupAdjacent'","(","convertFstToBlock","languagePragmas",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L145-L145","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"allocate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allocate = openBinaryTempFile (takeDirectory fpath) \".zip\"","function_tokens":["allocate","=","openBinaryTempFile","(","takeDirectory","fpath",")","\".zip\""],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L310-L310","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"true","parameters":"","argument_list":"","return_statement":"","docstring":"Logical tautology","docstring_summary":"Logical tautology","docstring_tokens":["Logical","tautology"],"function":"true = inject $ And []","function_tokens":["true","=","inject","$","And","[","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L500-L500","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"unlock","parameters":"(Key k ref) (Locker k' m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unlock (Key k ref) (Locker k' m)\n    | k == k' = unsafePerformIO $ do\n        m\n        readIORef ref     -- FIXME: race condition!\n    | otherwise = Nothing","function_tokens":["unlock","(","Key","k","ref",")","(","Locker","k'","m",")","|","k","==","k'","=","unsafePerformIO","$","do","m","readIORef","ref","-- FIXME: race condition!","|","otherwise","=","Nothing"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L19-L23","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"unsafeFromVector","parameters":"(r,c) vec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFromVector (r,c) vec =\n        CSR r c (G.generate n (G.unsafeIndex vec . U.unsafeIndex nz))\n                (U.map (`mod` c) nz)\n                (U.fromList . g . U.foldr f ((r-1,n-1), [n]) $ nz)\n      where\n        nz = U.filter (\\i -> vec `G.unsafeIndex` i \/= zero) . U.enumFromN 0 $ (r*c)\n        f i ((!prev,!acc), xs) | stride == 0 = ((prev, acc-1), xs)\n                               | otherwise = ((current, acc-1), replicate stride (acc+1) ++ xs)\n          where\n            stride = prev - current\n            current = i `div` c\n        g ((a, _), xs) | a == 0 = 0 : xs\n                       | otherwise = replicate (a+1) 0 ++ xs\n        n = U.length nz","function_tokens":["unsafeFromVector","(","r",",","c",")","vec","=","CSR","r","c","(","G","generate","n","(","G","unsafeIndex","vec",".","U","unsafeIndex","nz",")",")","(","U","map","(","`","mod","`","c",")","nz",")","(","U","fromList",".","g",".","U","foldr","f","(","(","r","-","1",",","n","-","1",")",",","[","n","]",")","$","nz",")","where","nz","=","U","filter","(","\\","i","->","vec","`","G","unsafeIndex","`","i","\/=","zero",")",".","U","enumFromN","0","$","(","r","*","c",")","f","i","(","(","prev",",","acc",")",",","xs",")","|","stride","==","0","=","(","(","prev",",","acc","-","1",")",",","xs",")","|","otherwise","=","(","(","current",",","acc","-","1",")",",","replicate","stride","(","acc","+","1",")","++","xs",")","where","stride","=","prev","-","current","current","=","i","`","div","`","c","g","(","(","a",",","_",")",",","xs",")","|","a","==","0","=","0",":","xs","|","otherwise","=","replicate","(","a","+","1",")","0","++","xs","n","=","U","length","nz"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L90-L104","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Writer.hs","language":"haskell","identifier":"benchmark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark = bgroup \"Writer\"\n  [ bench \"(,) w\" $ whnf (fst . (tellLoop :: Int -> (Sum Int, ()))) n\n  , bgroup \"Identity\"\n    [ bench \"Church.WriterC\" $ whnf (run . C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnf (run . C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnf (run . T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnf (run . T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnf (run . T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  , bgroup \"IO\"\n    [ bench \"Church.WriterC\" $ whnfAppIO (C.Church.execWriter @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterC\" $ whnfAppIO (C.Strict.execWriter @(Sum Int) . tellLoop) n\n#if MIN_VERSION_transformers(0,5,6)\n    , bench \"CPS.WriterT\"    $ whnfAppIO (T.CPS.execWriterT @_ @(Sum Int) . tellLoop) n\n#endif\n    , bench \"Lazy.WriterT\"   $ whnfAppIO (T.Lazy.execWriterT @_ @(Sum Int) . tellLoop) n\n    , bench \"Strict.WriterT\" $ whnfAppIO (T.Strict.execWriterT @_ @(Sum Int) . tellLoop) n\n    ]\n  ]\n  where\n  n = 1000000","function_tokens":["benchmark","=","bgroup","\"Writer\"","[","bench","\"(,) w\"","$","whnf","(","fst",".","(","tellLoop","::","Int","->","(","Sum","Int",",","(",")",")",")",")","n",",","bgroup","\"Identity\"","[","bench","\"Church.WriterC\"","$","whnf","(","run",".","C","Church","execWriter","@","(","Sum","Int",")",".","tellLoop",")","n",",","bench","\"Strict.WriterC\"","$","whnf","(","run",".","C","Strict","execWriter","@","(","Sum","Int",")",".","tellLoop",")","n","#if MIN_VERSION_transformers(0,5,6)",",","bench","\"CPS.WriterT\"","$","whnf","(","run",".","T","CPS","execWriterT","@","_","@","(","Sum","Int",")",".","tellLoop",")","n","#endif",",","bench","\"Lazy.WriterT\"","$","whnf","(","run",".","T","Lazy","execWriterT","@","_","@","(","Sum","Int",")",".","tellLoop",")","n",",","bench","\"Strict.WriterT\"","$","whnf","(","run",".","T","Strict","execWriterT","@","_","@","(","Sum","Int",")",".","tellLoop",")","n","]",",","bgroup","\"IO\"","[","bench","\"Church.WriterC\"","$","whnfAppIO","(","C","Church","execWriter","@","(","Sum","Int",")",".","tellLoop",")","n",",","bench","\"Strict.WriterC\"","$","whnfAppIO","(","C","Strict","execWriter","@","(","Sum","Int",")",".","tellLoop",")","n","#if MIN_VERSION_transformers(0,5,6)",",","bench","\"CPS.WriterT\"","$","whnfAppIO","(","T","CPS","execWriterT","@","_","@","(","Sum","Int",")",".","tellLoop",")","n","#endif",",","bench","\"Lazy.WriterT\"","$","whnfAppIO","(","T","Lazy","execWriterT","@","_","@","(","Sum","Int",")",".","tellLoop",")","n",",","bench","\"Strict.WriterT\"","$","whnfAppIO","(","T","Strict","execWriterT","@","_","@","(","Sum","Int",")",".","tellLoop",")","n","]","]","where","n","=","1000000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Writer.hs#L19-L43","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Writer.hs","hash_val":8772,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"hasDeriving","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hasDeriving = not . null . GHC.dd_derivs . dataDefn","function_tokens":["hasDeriving","=","not",".","null",".","GHC","dd_derivs",".","dataDefn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L553-L553","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"a","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a = distanceRad x1 x2","function_tokens":["a","=","distanceRad","x1","x2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L27-L27","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"runAccum","parameters":"","argument_list":"","return_statement":"","docstring":"Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.  @ 'runAccum' w0 ('pure' a) = 'pure' (w0, a) @ @ 'runAccum' w0 ('add' w) = 'pure' (w0 <> w, ()) @ @ 'runAccum' w0 ('add' w >> 'look') = 'pure' (w0 <> w, w0 <> w) @  @since 1.1.2.0","docstring_summary":"Run an 'Accum' effect with a 'Monoid'al log, applying a continuation to the final log and result.","docstring_tokens":["Run","an","Accum","effect","with","a","Monoid","al","log","applying","a","continuation","to","the","final","log","and","result","."],"function":"runAccum = flip runAccumC","function_tokens":["runAccum","=","flip","runAccumC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L49-L49","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"putExport","parameters":"conf","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putExport conf = Imports.printImport (separateLists conf) . GHC.unLoc","function_tokens":["putExport","conf","=","Imports","printImport","(","separateLists","conf",")",".","GHC","unLoc"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L224-L224","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"grhsToAlignable","parameters":"(GHC.L _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"grhsToAlignable (GHC.L _ _)            = Nothing","function_tokens":["grhsToAlignable","(","GHC","L","_","_",")","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L180-L180","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"menu","parameters":"items","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"menu items =\n  Menu\n    { _menuItems = items,\n      _menuBanner = Nothing,\n      _menuItemPrefix = numbered,\n      _menuItemSuffix = text \") \",\n      _menuBeforePrompt = Nothing,\n      _menuItemFromChoiceFunc = defaultFromChoice\n    }","function_tokens":["menu","items","=","Menu","{","_menuItems","=","items",",","_menuBanner","=","Nothing",",","_menuItemPrefix","=","numbered",",","_menuItemSuffix","=","text","\") \"",",","_menuBeforePrompt","=","Nothing",",","_menuItemFromChoiceFunc","=","defaultFromChoice","}"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L155-L163","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Get     -> State.Lazy.gets (<$ ctx)\n    L (Put s) -> ctx <$ State.Lazy.put s\n    R other   -> State.Lazy.StateT $ \\ s -> getSwap <$> thread (fmap Swap . uncurry State.Lazy.runStateT . getSwap ~<~ hdl) other (Swap (ctx, s))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Get","->","State","Lazy","gets","(","<$","ctx",")","L","(","Put","s",")","->","ctx","<$","State","Lazy","put","s","R","other","->","State","Lazy","StateT","$","\\","s","->","getSwap","<$>","thread","(","fmap","Swap",".","uncurry","State","Lazy","runStateT",".","getSwap","~<~","hdl",")","other","(","Swap","(","ctx",",","s",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L296-L300","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"accumulate","parameters":"f b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"accumulate f b = VarT $ \\a -> do\n    let b' = f b a\n    return (b', accumulate f b')\n\n-- | Delays the given var by one sample using the argument as the first\n-- sample.\n--\n-- >>> testVarOver (delay 0 id) [1,2,3]\n-- 0\n-- 1\n-- 2\n--\n-- This enables the programmer to create vars that depend on\n-- themselves for values. For example:\n--\n-- >>> let v = delay 0 v + 1 in testVarOver v [1,1,1]\n-- 1\n-- 2\n-- 3","function_tokens":["accumulate","f","b","=","VarT","$","\\","a","->","do","let","b'","=","f","b","a","return","(","b'",",","accumulate","f","b'",")","-- | Delays the given var by one sample using the argument as the first","-- sample.","--","-- >>> testVarOver (delay 0 id) [1,2,3]","-- 0","-- 1","-- 2","--","-- This enables the programmer to create vars that depend on","-- themselves for values. For example:","--","-- >>> let v = delay 0 v + 1 in testVarOver v [1,1,1]","-- 1","-- 2","-- 3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L337-L356","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"derivingClauseTypes","parameters":"GHC.HsDerivingClause {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"derivingClauseTypes GHC.HsDerivingClause {..} =\n    case GHC.unLoc deriv_clause_tys of\n        GHC.DctSingle _ t -> [t]\n        GHC.DctMulti _ ts -> ts","function_tokens":["derivingClauseTypes","GHC","HsDerivingClause","{","..","}","=","case","GHC","unLoc","deriv_clause_tys","of","GHC","DctSingle","_","t","->","[","t","]","GHC","DctMulti","_","ts","->","ts"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L221-L226","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"b","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b = TE.encodeUtf8 x","function_tokens":["b","=","TE","encodeUtf8","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L145-L145","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"getSubitems'","parameters":"relPath","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getSubitems' relPath = do\n      let absPath = path <\/> relPath\n      isDir <- doesDirectoryExist absPath\n      children <- if isDir then getChildren absPath else return []\n      let relChildren = [relPath <\/> p | p <- children]\n      ((isDir, relPath) :) . concat <$> mapM getSubitems' relChildren","function_tokens":["getSubitems'","relPath","=","do","let","absPath","=","path","<\/>","relPath","isDir","<-","doesDirectoryExist","absPath","children","<-","if","isDir","then","getChildren","absPath","else","return","[","]","let","relChildren","=","[","relPath","<\/>","p","|","p","<-","children","]","(","(","isDir",",","relPath",")",":",")",".","concat","<$>","mapM","getSubitems'","relChildren"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L41-L49","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"closest","parameters":"known","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"closest known = do\n            id <- gets targetId\n            polled <- gets polled\n\n            -- Return the 7 closest nodes, the lookup had contact with\n            return . take 7 . sortByDistanceTo (known ++ polled) $ id\n\n-- Send a signal to a node","function_tokens":["closest","known","=","do","id","<-","gets","targetId","polled","<-","gets","polled","-- Return the 7 closest nodes, the lookup had contact with","return",".","take","7",".","sortByDistanceTo","(","known","++","polled",")","$","id","-- Send a signal to a node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L318-L326","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"mantissa","parameters":"[d]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mantissa [d] = B.intDec d","function_tokens":["mantissa","[","d","]","=","B","intDec","d"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L357-L357","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"endsWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"endsWith = \\c -> (startsWith c) . reverse","function_tokens":["endsWith","=","\\","c","->","(","startsWith","c",")",".","reverse"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L25-L25","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withTail","parameters":"_ []","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"withTail _ []       = []","function_tokens":["withTail","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L195-L195","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"checkEntry","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkEntry s = do\n  calculated <- sourceEntry s I.crc32Sink\n  given <- edCRC32 . (! s) <$> getEntries\n  -- NOTE We can assume that entry exists for sure because otherwise\n  -- 'sourceEntry' would have thrown 'EntryDoesNotExist' already.\n  return (calculated == given)\n\n-- | Unpack the archive into the specified directory. The directory will be\n-- created if it does not exist.","function_tokens":["checkEntry","s","=","do","calculated","<-","sourceEntry","s","I","crc32Sink","given","<-","edCRC32",".","(","!","s",")","<$>","getEntries","-- NOTE We can assume that entry exists for sure because otherwise","-- 'sourceEntry' would have thrown 'EntryDoesNotExist' already.","return","(","calculated","==","given",")","-- | Unpack the archive into the specified directory. The directory will be","-- created if it does not exist."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L394-L403","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"rhsBody","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rhsBody _ = Nothing","function_tokens":["rhsBody","_","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L237-L237","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkLabel","parameters":"","argument_list":"","return_statement":"","docstring":"Derive labels including type signatures for all the record selectors in a single datatype. The types will be polymorphic and can be used in an arbitrary context.","docstring_summary":"Derive labels including type signatures for all the record selectors in a single datatype. The types will be polymorphic and can be used in an arbitrary context.","docstring_tokens":["Derive","labels","including","type","signatures","for","all","the","record","selectors","in","a","single","datatype",".","The","types","will","be","polymorphic","and","can","be","used","in","an","arbitrary","context","."],"function":"mkLabel = mkLabels . return","function_tokens":["mkLabel","=","mkLabels",".","return"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L94-L94","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"isCpp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isCpp         = isMultiline || listToMaybe x == Just '#'","function_tokens":["isCpp","=","isMultiline","||","listToMaybe","x","==","Just","'#'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L45-L45","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/simple.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = void $\n  runBylineT $ do\n    -- Start with a simple message to standard output:\n    sayLn (\"I can use \" <> (\"color\" & fg blue) <> \"!\")\n\n    -- When not using any stylized modifiers you can use the `text'\n    -- helper function to avoid \"Ambiguous type variable\":\n    sayLn (text \"This is some plain text\")\n\n    -- Get user input with a stylized prompt:\n    let question =\n          \"What's your favorite \"\n            <> (\"language\" & bold & fg green)\n            <> \"? \"\n    language <- askLn question Nothing\n\n    if Text.null language\n      then Exit.die (\"Cat got your tongue?\" & fg (vivid magenta))\n      else sayLn (\"I see, you like \" <> (text language & fg red) <> \".\")\n\n    -- Keep prompting until a confirmation function indicates that the\n    -- user's input is sufficient:\n    let question =\n          \"What's your \"\n            <> (\"name\" & fg green & underline)\n            <> \"? \"\n    name <- askUntil question Nothing (pure . atLeastThreeChars)\n    sayLn $ \"Hey there \" <> text name & fg (rgb 108 113 196)\n\n-- | Example confirmation function that requires the input to be three\n-- or more characters long.","function_tokens":["main","=","void","$","runBylineT","$","do","-- Start with a simple message to standard output:","sayLn","(","\"I can use \"","<>","(","\"color\"","&","fg","blue",")","<>","\"!\"",")","-- When not using any stylized modifiers you can use the `text'","-- helper function to avoid \"Ambiguous type variable\":","sayLn","(","text","\"This is some plain text\"",")","-- Get user input with a stylized prompt:","let","question","=","\"What's your favorite \"","<>","(","\"language\"","&","bold","&","fg","green",")","<>","\"? \"","language","<-","askLn","question","Nothing","if","Text","null","language","then","Exit","die","(","\"Cat got your tongue?\"","&","fg","(","vivid","magenta",")",")","else","sayLn","(","\"I see, you like \"","<>","(","text","language","&","fg","red",")","<>","\".\"",")","-- Keep prompting until a confirmation function indicates that the","-- user's input is sufficient:","let","question","=","\"What's your \"","<>","(","\"name\"","&","fg","green","&","underline",")","<>","\"? \"","name","<-","askUntil","question","Nothing","(","pure",".","atLeastThreeChars",")","sayLn","$","\"Hey there \"","<>","text","name","&","fg","(","rgb","108","113","196",")","-- | Example confirmation function that requires the input to be three","-- or more characters long."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/simple.hs#L25-L56","hash_key":"pjones\/byline:examples\/simple.hs","hash_val":16333,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"fixable","parameters":"fields","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fixable fields = all singleLine containers && nonOverlapping containers\n  where\n    containers        = map aContainer fields\n    singleLine s      = GHC.srcSpanStartLine s == GHC.srcSpanEndLine s\n    nonOverlapping ss = length ss == length (nub $ map GHC.srcSpanStartLine ss)","function_tokens":["fixable","fields","=","all","singleLine","containers","&&","nonOverlapping","containers","where","containers","=","map","aContainer","fields","singleLine","s","=","GHC","srcSpanStartLine","s","==","GHC","srcSpanEndLine","s","nonOverlapping","ss","=","length","ss","==","length","(","nub","$","map","GHC","srcSpanStartLine","ss",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L94-L98","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"unintern","parameters":"(Pi _ v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (Pi _ v t e) = BPi v t e","function_tokens":["unintern","(","Pi","_","v","t","e",")","=","BPi","v","t","e"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L51-L51","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"h'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"h' = BS.drop 5 $ E.encodeUtf8 h","function_tokens":["h'","=","BS","drop","5","$","E","encodeUtf8","h"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L327-L327","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"(Exists vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' (Exists vs a) = do\n        (ns, qs) <- get\n\n        let (d, i) = partition (\\(vs', _) -> any (`elem` mapMaybe toStaticallySorted vs') vs) qs\n\n        put (ns, i)\n\n        return $ exists vs (foldr snd a d)","function_tokens":["flatten'","(","Exists","vs","a",")","=","do","(","ns",",","qs",")","<-","get","let","(","d",",","i",")","=","partition","(","\\","(","vs'",",","_",")","->","any","(","`","elem","`","mapMaybe","toStaticallySorted","vs'",")","vs",")","qs","put","(","ns",",","i",")","return","$","exists","vs","(","foldr","snd","a","d",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L853-L862","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = ()","function_tokens":["reflect","_","=","(",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L392-L392","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"p1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p1 = Proxy :: Proxy sublayout","function_tokens":["p1","=","Proxy","::","Proxy","sublayout"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L340-L340","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a ==> b = nnf (not a \\\/ b)","function_tokens":["a","==>","b","=","nnf","(","not","a","\\\/","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L239-L239","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"parseStylishArgs","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"parseStylishArgs = StylishArgs\n    <$> OA.switch (\n            OA.help  \"Show version information\" <>\n            OA.long  \"version\"                  <>\n            OA.hidden)\n    <*> OA.optional (OA.strOption $\n            OA.metavar \"CONFIG\"              <>\n            OA.help    \"Configuration file\"  <>\n            OA.long    \"config\"              <>\n            OA.short   'c'                   <>\n            OA.hidden)\n    <*> OA.switch (\n            OA.help    \"Recursive file search\" <>\n            OA.long    \"recursive\"             <>\n            OA.short   'r'                     <>\n            OA.hidden)\n    <*> OA.switch (\n            OA.help  \"Run in verbose mode\" <>\n            OA.long  \"verbose\"             <>\n            OA.short 'v'                   <>\n            OA.hidden)\n    <*> OA.switch (\n            OA.help  \"Dump default config and exit\" <>\n            OA.long  \"defaults\"                     <>\n            OA.short 'd'                            <>\n            OA.hidden)\n    <*> OA.switch (\n            OA.help  \"Overwrite the given files in place\" <>\n            OA.long  \"inplace\"                            <>\n            OA.short 'i'                                  <>\n            OA.hidden)\n    <*> OA.switch (\n            OA.help  \"Don't force UTF-8 stdin\/stdout\" <>\n            OA.long  \"no-utf8\"                        <>\n            OA.hidden)\n    <*> OA.many (OA.strArgument $\n            OA.metavar \"FILENAME\" <>\n            OA.help    \"Input file(s)\")","function_tokens":["parseStylishArgs","=","StylishArgs","<$>","OA","switch","(","OA","help","\"Show version information\"","<>","OA","long","\"version\"","<>","OA","hidden",")","<*>","OA","optional","(","OA","strOption","$","OA","metavar","\"CONFIG\"","<>","OA","help","\"Configuration file\"","<>","OA","long","\"config\"","<>","OA","short","'c'","<>","OA","hidden",")","<*>","OA","switch","(","OA","help","\"Recursive file search\"","<>","OA","long","\"recursive\"","<>","OA","short","'r'","<>","OA","hidden",")","<*>","OA","switch","(","OA","help","\"Run in verbose mode\"","<>","OA","long","\"verbose\"","<>","OA","short","'v'","<>","OA","hidden",")","<*>","OA","switch","(","OA","help","\"Dump default config and exit\"","<>","OA","long","\"defaults\"","<>","OA","short","'d'","<>","OA","hidden",")","<*>","OA","switch","(","OA","help","\"Overwrite the given files in place\"","<>","OA","long","\"inplace\"","<>","OA","short","'i'","<>","OA","hidden",")","<*>","OA","switch","(","OA","help","\"Don't force UTF-8 stdin\/stdout\"","<>","OA","long","\"no-utf8\"","<>","OA","hidden",")","<*>","OA","many","(","OA","strArgument","$","OA","metavar","\"FILENAME\"","<>","OA","help","\"Input file(s)\"",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L41-L78","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SOURCE_RELATIVE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SOURCE_RELATIVE                  = 0x0202","function_tokens":["al_SOURCE_RELATIVE","=","0x0202"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L77-L77","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/PPDiff.hs","language":"haskell","identifier":"ppDiff","parameters":"c (First x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ppDiff c (First x)  = wrap c Red   $ '-':x","function_tokens":["ppDiff","c","(","First","x",")","=","wrap","c","Red","$","'-'",":","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/PPDiff.hs#L16-L16","hash_key":"Peaker\/git-mediate:src\/PPDiff.hs","hash_val":5685,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"sourceEntry","parameters":"s sink","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sourceEntry s sink = do\n  src <- getEntrySource s\n  (liftIO . C.runConduitRes) (src .| sink)\n\n-- | Save a specific archive entry as a file in the file system.\n--\n-- Throws: 'EntryDoesNotExist'.","function_tokens":["sourceEntry","s","sink","=","do","src","<-","getEntrySource","s","(","liftIO",".","C","runConduitRes",")","(","src",".|","sink",")","-- | Save a specific archive entry as a file in the file system.","--","-- Throws: 'EntryDoesNotExist'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L366-L373","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"sin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sin = fmap sin","function_tokens":["sin","=","fmap","sin"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L249-L249","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"mkRenderableLens","parameters":"lens districts title","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkRenderableLens lens districts title = mkRenderableLabelled title (labelByLens lens districts)","function_tokens":["mkRenderableLens","lens","districts","title","=","mkRenderableLabelled","title","(","labelByLens","lens","districts",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L27-L27","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"loop","parameters":"limit","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop limit = do\n      sig <- getNum getWord32le 4\n      pos <- subtract 4 <$> hTell h\n      let again = hSeek h AbsoluteSeek (pos - 1) >> loop limit\n          done = pos <= limit\n      if sig == 0x06054b50\n        then do\n          result <-\n            runMaybeT $\n              MaybeT (checkComment pos)\n                >>= MaybeT . checkCDSig\n                >>= MaybeT . checkZip64\n          case result of\n            Nothing -> bool again (return Nothing) done\n            Just ecd -> return (Just ecd)\n        else bool again (return Nothing) done","function_tokens":["loop","limit","=","do","sig","<-","getNum","getWord32le","4","pos","<-","subtract","4","<$>","hTell","h","let","again","=","hSeek","h","AbsoluteSeek","(","pos","-","1",")",">>","loop","limit","done","=","pos","<=","limit","if","sig","==","0x06054b50","then","do","result","<-","runMaybeT","$","MaybeT","(","checkComment","pos",")",">>=","MaybeT",".","checkCDSig",">>=","MaybeT",".","checkZip64","case","result","of","Nothing","->","bool","again","(","return","Nothing",")","done","Just","ecd","->","return","(","Just","ecd",")","else","bool","again","(","return","Nothing",")","done"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L972-L988","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Mixolydian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Mixolydian   = \"mixolydian\"","function_tokens":["go","Mixolydian","=","\"mixolydian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L534-L534","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"intern","parameters":"!bt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intern !bt = unsafeDupablePerformIO $ modifyAdvice $ atomicModifyIORef slot go\n  where\n  slot = getCache cache ! r\n  !dt = describe bt\n  !hdt = hash dt\n  !wid = cacheWidth dt\n  r = hdt `mod` wid\n  go (CacheState i m) = case HashMap.lookup dt m of\n    Nothing -> let t = identify (wid * i + r) bt in (CacheState (i + 1) (HashMap.insert dt t m), t)\n    Just t -> (CacheState i m, t)\n\n-- given a description, go hunting for an entry in the cache","function_tokens":["intern","bt","=","unsafeDupablePerformIO","$","modifyAdvice","$","atomicModifyIORef","slot","go","where","slot","=","getCache","cache","!","r","dt","=","describe","bt","hdt","=","hash","dt","wid","=","cacheWidth","dt","r","=","hdt","`","mod","`","wid","go","(","CacheState","i","m",")","=","case","HashMap","lookup","dt","m","of","Nothing","->","let","t","=","identify","(","wid","*","i","+","r",")","bt","in","(","CacheState","(","i","+","1",")","(","HashMap","insert","dt","t","m",")",",","t",")","Just","t","->","(","CacheState","i","m",",","t",")","-- given a description, go hunting for an entry in the cache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L81-L93","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nOperators\n------------------------------------------------------------------} \/O(n+m)\/. See 'difference'.","docstring_summary":"{--------------------------------------------------------------------\nOperators\n------------------------------------------------------------------} \/O(n+m)\/. See 'difference'.","docstring_tokens":["{","--------------------------------------------------------------------","Operators","------------------------------------------------------------------","}","\/","O","(","n","+","m",")","\/",".","See","difference","."],"function":"m1 \\\\ m2 = difference m1 m2","function_tokens":["m1","\\\\","m2","=","difference","m1","m2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L153-L153","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"present","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"present       = concatMap (toList . snd) pragmas'","function_tokens":["present","=","concatMap","(","toList",".","snd",")","pragmas'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L161-L161","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"tfmFromEvent","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tfmFromEvent = Tfm <$> eventDur <*> eventStart","function_tokens":["tfmFromEvent","=","Tfm","<$>","eventDur","<*>","eventStart"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L365-L365","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a ==> b = nnf (not a \\\/ b)","function_tokens":["a","==>","b","=","nnf","(","not","a","\\\/","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L236-L236","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"some","parameters":"a","argument_list":"","return_statement":"","docstring":"One or more.  @ 'some' m = (:) '<$>' m '<*>' 'many' m @  @since 1.0.0.0","docstring_summary":"One or more.","docstring_tokens":["One","or","more","."],"function":"some a = (:) <$> a <*> many a","function_tokens":["some","a","=","(",":",")","<$>","a","<*>","many","a"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L102-L102","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unzip5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip5 = MG.unzip5","function_tokens":["unzip5","=","MG","unzip5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L360-L360","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"foldMap","parameters":"f Menu {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldMap f Menu {..} = foldMap f _menuItems","function_tokens":["foldMap","f","Menu","{","..","}","=","foldMap","f","_menuItems"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L64-L64","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"dim","parameters":"(CSR r c _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim (CSR r c _ _ _) = (r,c)","function_tokens":["dim","(","CSR","r","c","_","_","_",")","=","(","r",",","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L78-L78","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"go","parameters":"_ _ _ fptrRemBits fptrRemBitsLen  []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _ _ _ fptrRemBits fptrRemBitsLen  []       = do\n          resBpFptr  <- F.mallocForeignPtrBytes 8\n          let resBpPtr      = F.castPtr (F.unsafeForeignPtrToPtr resBpFptr  )\n          let ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits\n          let ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen\n          remBits     <- F.peek ptrRemBits\n          remBitsLen  <- F.peek ptrRemBitsLen\n          bpByteLen <- F.smWriteBpChunkFinal\n            remBits     -- remaining_bp_bits\n            remBitsLen  -- remaning_bp_bits_len\n            resBpPtr    -- out_buffer\n          return  [ ( BS.empty\n                    , BSI.fromForeignPtr resBpFptr 0 (fromIntegral bpByteLen * 8)\n                    )\n                  ]","function_tokens":["go","_","_","_","fptrRemBits","fptrRemBitsLen","[","]","=","do","resBpFptr","<-","F","mallocForeignPtrBytes","8","let","resBpPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBpFptr",")","let","ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits","let","ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen","remBits","<-","F","peek","ptrRemBits","remBitsLen","<-","F","peek","ptrRemBitsLen","bpByteLen","<-","F","smWriteBpChunkFinal","remBits","-- remaining_bp_bits","remBitsLen","-- remaning_bp_bits_len","resBpPtr","-- out_buffer","return","[","(","BS","empty",",","BSI","fromForeignPtr","resBpFptr","0","(","fromIntegral","bpByteLen","*","8",")",")","]"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L58-L73","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(bsFptr, bsOff, bsLen) = BSI.toForeignPtr bs","function_tokens":["(","bsFptr",",","bsOff",",","bsLen",")","=","BSI","toForeignPtr","bs"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L57-L57","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"askLn","parameters":"prompt def","argument_list":"","return_statement":"","docstring":"Read a line of input after printing the given stylized text as a prompt.  @since 1.0.0.0","docstring_summary":"Read a line of input after printing the given stylized text as a prompt.","docstring_tokens":["Read","a","line","of","input","after","printing","the","given","stylized","text","as","a","prompt","."],"function":"askLn prompt def = liftByline (Prim.askLn (toStylizedText prompt) def)","function_tokens":["askLn","prompt","def","=","liftByline","(","Prim","askLn","(","toStylizedText","prompt",")","def",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L104-L104","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeOutPow","parameters":"power c t b","argument_list":"","return_statement":"","docstring":"Ease out by some power.","docstring_summary":"Ease out by some power.","docstring_tokens":["Ease","out","by","some","power","."],"function":"easeOutPow power c t b =\n    let t' = realToFrac t - 1\n        c' = if power `mod` 2 == 1 then c else -c\n        i  = if power `mod` 2 == 1 then 1 else -1\n    in c' * ((t'^power) + i) + b","function_tokens":["easeOutPow","power","c","t","b","=","let","t'","=","realToFrac","t","-","1","c'","=","if","power","`","mod","`","2","==","1","then","c","else","-","c","i","=","if","power","`","mod","`","2","==","1","then","1","else","-","1","in","c'","*","(","(","t'","^","power",")","+","i",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L116-L120","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"defaultConfig","parameters":"","argument_list":"","return_statement":"","docstring":"TODO: pass in MaxColumns?","docstring_summary":"TODO: pass in MaxColumns?","docstring_tokens":["TODO",":","pass","in","MaxColumns?"],"function":"defaultConfig = Config\n    { cEquals          = Indent 4\n    , cFirstField      = Indent 4\n    , cFieldComment    = 2\n    , cDeriving        = 4\n    , cBreakEnums      = True\n    , cBreakSingleConstructors = False\n    , cVia             = Indent 4\n    , cSortDeriving    = True\n    , cMaxColumns      = NoMaxColumns\n    , cCurriedContext    = False\n    }","function_tokens":["defaultConfig","=","Config","{","cEquals","=","Indent","4",",","cFirstField","=","Indent","4",",","cFieldComment","=","2",",","cDeriving","=","4",",","cBreakEnums","=","True",",","cBreakSingleConstructors","=","False",",","cVia","=","Indent","4",",","cSortDeriving","=","True",",","cMaxColumns","=","NoMaxColumns",",","cCurriedContext","=","False","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L76-L87","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ma >>= f = AccumC $ \\k w -> runAccumC ma (\\w' a -> runAccumC (f a) (\\w'' -> k $ w' `mappend` w'') (w `mappend` w')) w","function_tokens":["ma",">>=","f","=","AccumC","$","\\","k","w","->","runAccumC","ma","(","\\","w'","a","->","runAccumC","(","f","a",")","(","\\","w''","->","k","$","w'","`","mappend","`","w''",")","(","w","`","mappend","`","w'",")",")","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L105-L105","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"search","parameters":"_ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"search _ []             = return Nothing","function_tokens":["search","_","[","]","=","return","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L109-L109","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"originalDeclBlock","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"originalDeclBlock = Editor.Block\n        (GHC.srcSpanStartLine dataLoc)\n        (GHC.srcSpanEndLine dataLoc)","function_tokens":["originalDeclBlock","=","Editor","Block","(","GHC","srcSpanStartLine","dataLoc",")","(","GHC","srcSpanEndLine","dataLoc",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L125-L127","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"insertValue","parameters":"key value (KI _ (KS _ values) _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"insertValue key value (KI _ (KS _ values) _) = atomically $ do\n    vals <- readTVar values\n    writeTVar values $ M.insert key value vals\n\n-- | Delete a value from the store","function_tokens":["insertValue","key","value","(","KI","_","(","KS","_","values",")","_",")","=","atomically","$","do","vals","<-","readTVar","values","writeTVar","values","$","M","insert","key","value","vals","-- | Delete a value from the store"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L90-L95","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"lgrhs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lgrhs = getLocGRHS grhss","function_tokens":["lgrhs","=","getLocGRHS","grhss"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L245-L245","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"hasConstructors","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hasConstructors = not . null . GHC.dd_cons . dataDefn","function_tokens":["hasConstructors","=","not",".","null",".","GHC","dd_cons",".","dataDefn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L547-L547","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"fieldName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldName = go\n    where\n        go (Area _)                 = \"A\"\n        go (Book _)                 = \"B\"\n        go (Composer _)             = \"C\"\n        go (Discography _)          = \"D\"\n        go (FileUrl _)              = \"F\"\n        go (Group _)                = \"G\"\n        go (History _)              = \"H\"\n        go (Instruction _)          = \"I\"\n        go (Key _)                  = \"K\"\n        go (UnitNoteLength _)       = \"L\"\n        go (Meter _)                = \"M\"\n        go Macro                    = \"m\"\n        go (Notes _)                = \"N\"\n        go (Origin _)               = \"O\"\n        go Parts                    = \"O\"\n        go (Tempo _)                = \"Q\"\n        go (Rhythm _)               = \"R\"\n        go Remark                   = \"r\"\n        go (Source _)               = \"S\"\n        go SymbolLine               = \"s\"\n        go (Title _)                = \"T\"\n        go UserDefined              = \"U\"\n        go (Voice _)                = \"V\"\n        go (Words _)                = \"W\"\n        go (ReferenceNumber _)      = \"X\"\n        go (Transcription _)        = \"Z\"\n\n-- (file header, tune header, tune body, inline)","function_tokens":["fieldName","=","go","where","go","(","Area","_",")","=","\"A\"","go","(","Book","_",")","=","\"B\"","go","(","Composer","_",")","=","\"C\"","go","(","Discography","_",")","=","\"D\"","go","(","FileUrl","_",")","=","\"F\"","go","(","Group","_",")","=","\"G\"","go","(","History","_",")","=","\"H\"","go","(","Instruction","_",")","=","\"I\"","go","(","Key","_",")","=","\"K\"","go","(","UnitNoteLength","_",")","=","\"L\"","go","(","Meter","_",")","=","\"M\"","go","Macro","=","\"m\"","go","(","Notes","_",")","=","\"N\"","go","(","Origin","_",")","=","\"O\"","go","Parts","=","\"O\"","go","(","Tempo","_",")","=","\"Q\"","go","(","Rhythm","_",")","=","\"R\"","go","Remark","=","\"r\"","go","(","Source","_",")","=","\"S\"","go","SymbolLine","=","\"s\"","go","(","Title","_",")","=","\"T\"","go","UserDefined","=","\"U\"","go","(","Voice","_",")","=","\"V\"","go","(","Words","_",")","=","\"W\"","go","(","ReferenceNumber","_",")","=","\"X\"","go","(","Transcription","_",")","=","\"Z\"","-- (file header, tune header, tune body, inline)"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L333-L363","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookIssuesEvent","function_tokens":["reflect","_","=","WebhookIssuesEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L445-L445","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Tip i _ `compare` Bin j _ _ _ _ _ = compare i j","function_tokens":["Tip","i","_","`","compare","`","Bin","j","_","_","_","_","_","=","compare","i","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L852-L852","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"f","parameters":"'y' 'x'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f 'y' 'x' = '|'","function_tokens":["f","'y'","'x'","=","'|'"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L72-L72","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"mkAppImage","parameters":"exeFile di CreateNewDesktop","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkAppImage exeFile di CreateNewDesktop = do\n  mkAppImage' exeFile di (Arg \"--create-desktop-file\")\n  -- Now copy the freshly-created .desktop file into the project sources\n  let desktopFile = op ExeFile exeFile <.> \"desktop\"\n  Dir.createDirectoryIfMissing True desktopDir\n  Dir.copyFile\n    ((op PrefixDir . prefixDir $ di) <\/> \"share\" <\/> \"applications\" <\/> desktopFile)\n    (desktopDir <\/> desktopFile)","function_tokens":["mkAppImage","exeFile","di","CreateNewDesktop","=","do","mkAppImage'","exeFile","di","(","Arg","\"--create-desktop-file\"",")","-- Now copy the freshly-created .desktop file into the project sources","let","desktopFile","=","op","ExeFile","exeFile","<.>","\"desktop\"","Dir","createDirectoryIfMissing","True","desktopDir","Dir","copyFile","(","(","op","PrefixDir",".","prefixDir","$","di",")","<\/>","\"share\"","<\/>","\"applications\"","<\/>","desktopFile",")","(","desktopDir","<\/>","desktopFile",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L58-L68","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"eqs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eqs = [ (a, b) | AppT (AppT EqualityT a) b <- y ]","function_tokens":["eqs","=","[","(","a",",","b",")","|","AppT","(","AppT","EqualityT","a",")","b","<-","y","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L351-L351","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty  = Track 0 mempty","function_tokens":["mempty","=","Track","0","mempty"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L84-L84","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Strict.asks (<$ ctx)\n    L (Local f m)      -> RWS.Strict.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Strict.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Strict.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Strict.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Strict.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Strict.put s\n    R (R (R other))    -> RWS.Strict.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Strict.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Ask","->","RWS","Strict","asks","(","<$","ctx",")","L","(","Local","f","m",")","->","RWS","Strict","local","f","(","hdl","(","m","<$","ctx",")",")","R","(","L","(","Tell","w",")",")","->","ctx","<$","RWS","Strict","tell","w","R","(","L","(","Listen","m",")",")","->","swapAndLift","<$>","RWS","Strict","listen","(","hdl","(","m","<$","ctx",")",")","R","(","L","(","Censor","f","m",")",")","->","RWS","Strict","censor","f","(","hdl","(","m","<$","ctx",")",")","R","(","R","(","L","Get",")",")","->","RWS","Strict","gets","(","<$","ctx",")","R","(","R","(","L","(","Put","s",")",")",")","->","ctx","<$","RWS","Strict","put","s","R","(","R","(","R","other",")",")","->","RWS","Strict","RWST","$","\\","r","s","->","unRWSTF","<$>","thread","(","(","\\","(","RWSTF","(","x",",","s",",","w",")",")","->","toRWSTF","w","<$>","RWS","Strict","runRWST","x","r","s",")","~<~","hdl",")","other","(","RWSTF","(","ctx",",","s",",","mempty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L283-L292","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"oldExtraFields","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"oldExtraFields = case o of\n        GenericOrigin -> M.empty\n        Borrowed ed -> edExtraField ed","function_tokens":["oldExtraFields","=","case","o","of","GenericOrigin","->","M","empty","Borrowed","ed","->","edExtraField","ed"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L506-L509","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"(Forall vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' (Forall vs a) = do\n        (ns, qs) <- get\n\n        let (d, i) = partition (\\(vs', _) -> any (`elem` mapMaybe toStaticallySorted vs') vs) qs\n\n        put (ns, i)\n\n        return $ forall vs (foldr snd a d)","function_tokens":["flatten'","(","Forall","vs","a",")","=","do","(","ns",",","qs",")","<-","get","let","(","d",",","i",")","=","partition","(","\\","(","vs'",",","_",")","->","any","(","`","elem","`","mapMaybe","toStaticallySorted","vs'",")","vs",")","qs","put","(","ns",",","i",")","return","$","forall","vs","(","foldr","snd","a","d",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L843-L852","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getTag","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getTag = getWord8","function_tokens":["getTag","=","getWord8"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L116-L116","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"isWhitespace","parameters":"'\\t'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isWhitespace '\\t' = True","function_tokens":["isWhitespace","'\\t'","=","True"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L8-L8","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"pushParserName","parameters":"name","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushParserName name = ConduitParser $ lift $ modify $ first (name :)","function_tokens":["pushParserName","name","=","ConduitParser","$","lift","$","modify","$","first","(","name",":",")"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L116-L116","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"marshalBuffer","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"marshalBuffer = bufferID . maybe nullBuffer id","function_tokens":["marshalBuffer","=","bufferID",".","maybe","nullBuffer","id"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L49-L49","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"events","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"events = reflect (Proxy :: Proxy events)","function_tokens":["events","=","reflect","(","Proxy","::","Proxy","events",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L357-L357","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"index","parameters":"Divides  {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Divides  {} = SBooleanSort","function_tokens":["index","Divides","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L78-L78","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"backAndForth","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"backAndForth =\n    -- Turn our splines into continuous output streams. We must provide\n    -- a starting value since splines are not guaranteed to be defined at\n    -- their edges.\n    let x = tweenStream tweenx 0\n        y = tweenStream tweeny 0\n    in\n    -- Construct a varying Point that takes time as an input.\n    (Point <$> x <*> y)","function_tokens":["backAndForth","=","-- Turn our splines into continuous output streams. We must provide","-- a starting value since splines are not guaranteed to be defined at","-- their edges.","let","x","=","tweenStream","tweenx","0","y","=","tweenStream","tweeny","0","in","-- Construct a varying Point that takes time as an input.","(","Point","<$>","x","<*>","y",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L49-L57","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_CAPTURE_DEVICE_SPECIFIER","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_CAPTURE_DEVICE_SPECIFIER        = 0x0310","function_tokens":["alc_CAPTURE_DEVICE_SPECIFIER","=","0x0310"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L154-L154","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"prettyScientific","parameters":"ascii x b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyScientific ascii x b = case floatToDigits 10 . min x <$> b of\n    Just (errSig,errExpo) | errSig \/= [0] && valLen errExpo > 0 -> mantissa (take (valLen errExpo) $ sig ++ repeat 0) <> showError errSig <> f expo\n    _ | x == 0 -> B.char7 '0'\n    _ -> mantissa (take 2 $ sig ++ repeat 0) <> f expo\n  where\n    showError err = B.char7 '(' <> foldMap B.intDec (take 2 $ err ++ repeat 0) <> B.char7 ')'\n    (sig,expo) = floatToDigits 10 x\n    valLen e = expo - e + 2\n    mantissa [d] = B.intDec d\n    mantissa (d:ds) = B.intDec d <> B.char7 '.' <> foldMap B.intDec ds\n    mantissa [] = mempty\n    f 1 = mempty\n    f e | ascii = B.char7 '*' <> B.intDec 10 <> mWhen (e\/=2) (B.char7 '^' <> B.intDec (e-1))\n        | otherwise = B.charUtf8 '\u00b7' <> B.intDec 10 <> mWhen (e\/=2) (showE (e-1))","function_tokens":["prettyScientific","ascii","x","b","=","case","floatToDigits","10",".","min","x","<$>","b","of","Just","(","errSig",",","errExpo",")","|","errSig","\/=","[","0","]","&&","valLen","errExpo",">","0","->","mantissa","(","take","(","valLen","errExpo",")","$","sig","++","repeat","0",")","<>","showError","errSig","<>","f","expo","_","|","x","==","0","->","B","char7","'0'","_","->","mantissa","(","take","2","$","sig","++","repeat","0",")","<>","f","expo","where","showError","err","=","B","char7","'('","<>","foldMap","B","intDec","(","take","2","$","err","++","repeat","0",")","<>","B","char7","')'","(","sig",",","expo",")","=","floatToDigits","10","x","valLen","e","=","expo","-","e","+","2","mantissa","[","d","]","=","B","intDec","d","mantissa","(","d",":","ds",")","=","B","intDec","d","<>","B","char7","'.'","<>","foldMap","B","intDec","ds","mantissa","[","]","=","mempty","f","1","=","mempty","f","e","|","ascii","=","B","char7","'*'","<>","B","intDec","10","<>","mWhen","(","e","\/=","2",")","(","B","char7","'^'","<>","B","intDec","(","e","-","1",")",")","|","otherwise","=","B","charUtf8","'\u00b7' ","> ",".","ntDec ","0 ","> ","When ","e","\/","=2",")"," ","s","howE ","e","-","1",")",")",""],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L349-L364","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookWildcardEvent","function_tokens":["reflect","_","=","WebhookWildcardEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L403-L403","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"cont","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cont    = if concrete\n                   then cxt []\n                   else ctx","function_tokens":["cont","=","if","concrete","then","cxt","[","]","else","ctx"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L452-L454","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"imzero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imzero = coerce $ mzero @m @a","function_tokens":["imzero","=","coerce","$","mzero","@","m","@","a"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L60-L60","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"failArrow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"failArrow = Kleisli (const Nothing)","function_tokens":["failArrow","=","Kleisli","(","const","Nothing",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L149-L149","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapMaybe","parameters":"(Just maxWidth)","argument_list":"","return_statement":"","docstring":"^ Resulting lines","docstring_summary":"^ Resulting lines","docstring_tokens":["^","Resulting","lines"],"function":"wrapMaybe (Just maxWidth) = wrap maxWidth","function_tokens":["wrapMaybe","(","Just","maxWidth",")","=","wrap","maxWidth"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L117-L117","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for disequality","docstring_summary":"A smart constructor for disequality","docstring_tokens":["A","smart","constructor","for","disequality"],"function":"a .\/=. b = not (a .=. b)","function_tokens":["a",".\/=.","b","=","not","(","a",".=.","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L489-L489","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"pitch","parameters":"","argument_list":"","return_statement":"","docstring":"'pitch' contains the desired pitch shift, where 1 (the initial value) equals identity. Each reduction by 50 percent equals a pitch shift of -12 semitones (one octave reduction). Each doubling equals a pitch shift of 12 semitones (one octave increase). Zero is not a legal value. Implementations may clamp the actual output pitch range to any values subject to the implementation's own limits.","docstring_summary":"'pitch' contains the desired pitch shift, where 1 (the initial value) equals identity. Each reduction by 50 percent equals a pitch shift of -12 semitones (one octave reduction). Each doubling equals a pitch shift of 12 semitones (one octave increase). Zero is not a legal value. Implementations may clamp the actual output pitch range to any values subject to the implementation's own limits.","docstring_tokens":["pitch","contains","the","desired","pitch","shift","where","1","(","the","initial","value",")","equals","identity",".","Each","reduction","by","50","percent","equals","a","pitch","shift","of","-","12","semitones","(","one","octave","reduction",")",".","Each","doubling","equals","a","pitch","shift","of","12","semitones","(","one","octave","increase",")",".","Zero","is","not","a","legal","value",".","Implementations","may","clamp","the","actual","output","pitch","range","to","any","values","subject","to","the","implementation","s","own","limits","."],"function":"pitch = makeSourceStateVar dictALfloat GetPitch","function_tokens":["pitch","=","makeSourceStateVar","dictALfloat","GetPitch"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L383-L383","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Instruction _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Instruction _)          = \"I\"","function_tokens":["go","(","Instruction","_",")","=","\"I\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L342-L342","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"popCompletionFunction","parameters":"","argument_list":"","return_statement":"","docstring":"Remove the top completion function from the stack.  @since 1.0.0.0","docstring_summary":"Remove the top completion function from the stack.","docstring_tokens":["Remove","the","top","completion","function","from","the","stack","."],"function":"popCompletionFunction = liftByline Prim.popCompFunc","function_tokens":["popCompletionFunction","=","liftByline","Prim","popCompFunc"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L49-L49","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"hour","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hour = 60 * 60 * 1000000","function_tokens":["hour","=","60","*","60","*","1000000"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L236-L236","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(Or os)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (Or os) = and (map (dual . unIFix) os)","function_tokens":["dual","(","Or","os",")","=","and","(","map","(","dual",".","unIFix",")","os",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L674-L674","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"notMember","parameters":"k","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"notMember k = not . member k","function_tokens":["notMember","k","=","not",".","member","k"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L274-L274","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"variance","parameters":"a","argument_list":"","return_statement":"","docstring":"Calculate the variance of an Analysis.","docstring_summary":"Calculate the variance of an Analysis.","docstring_tokens":["Calculate","the","variance","of","an","Analysis","."],"function":"variance a | samples a > 1 = qFactor a \/ fromIntegral (samples a - 1)\n           | otherwise = 0","function_tokens":["variance","a","|","samples","a",">","1","=","qFactor","a","\/","fromIntegral","(","samples","a","-","1",")","|","otherwise","=","0"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L197-L198","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"configFilePath","parameters":"_       (Just userSpecified)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"configFilePath _       (Just userSpecified) = return (Just userSpecified)","function_tokens":["configFilePath","_","(","Just","userSpecified",")","=","return","(","Just","userSpecified",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L99-L99","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"f'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f' = fmap (lock key . f) . unlock key","function_tokens":["f'","=","fmap","(","lock","key",".","f",")",".","unlock","key"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L38-L38","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"fail","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail s = StateC (const (Fail.fail s))","function_tokens":["fail","s","=","StateC","(","const","(","Fail","fail","s",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L107-L107","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"itraverse","parameters":"f (Exists vs b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Exists vs b) = Exists vs <$> f b","function_tokens":["itraverse","f","(","Exists","vs","b",")","=","Exists","vs","<$>","f","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L556-L556","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"joinedLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"joinedLine = (stripBreak line1) ++ line2","function_tokens":["joinedLine","=","(","stripBreak","line1",")","++","line2"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L32-L32","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Mono.hs","language":"haskell","identifier":"modify","parameters":"","argument_list":"","return_statement":"","docstring":"Get the modifier arrow from a lens.","docstring_summary":"Get the modifier arrow from a lens.","docstring_tokens":["Get","the","modifier","arrow","from","a","lens","."],"function":"modify = Poly.modify","function_tokens":["modify","=","Poly","modify"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Mono.hs#L63-L63","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Mono.hs","hash_val":24943,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseConfig","parameters":"(A.Object o)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseConfig (A.Object o) = do\n    -- First load the config without the actual steps\n    config <- Config\n        <$> pure []\n        <*> (o A..:! \"columns\"             A..!= Just 80)\n        <*> (o A..:? \"language_extensions\" A..!= [])\n        <*> (o A..:? \"newline\"             >>= parseEnum newlines IO.nativeNewline)\n        <*> (o A..:? \"cabal\"               A..!= True)\n        <*> (o A..:? \"exit_code\"           >>= parseEnum exitCodes NormalExitBehavior)\n\n    -- Then fill in the steps based on the partial config we already have\n    stepValues <- o A..: \"steps\" :: A.Parser [A.Value]\n    steps      <- mapM (parseSteps config) stepValues\n    return config {configSteps = concat steps}\n  where\n    newlines =\n        [ (\"native\", IO.nativeNewline)\n        , (\"lf\",     IO.LF)\n        , (\"crlf\",   IO.CRLF)\n        ]\n    exitCodes =\n        [ (\"normal\", NormalExitBehavior)\n        , (\"error_on_format\", ErrorOnFormatExitBehavior)\n        ]","function_tokens":["parseConfig","(","A","Object","o",")","=","do","-- First load the config without the actual steps","config","<-","Config","<$>","pure","[","]","<*>","(","o","A",".:!","\"columns\"","A",".!=","Just","80",")","<*>","(","o","A",".:?","\"language_extensions\"","A",".!=","[","]",")","<*>","(","o","A",".:?","\"newline\"",">>=","parseEnum","newlines","IO","nativeNewline",")","<*>","(","o","A",".:?","\"cabal\"","A",".!=","True",")","<*>","(","o","A",".:?","\"exit_code\"",">>=","parseEnum","exitCodes","NormalExitBehavior",")","-- Then fill in the steps based on the partial config we already have","stepValues","<-","o","A",".:","\"steps\"","::","A","Parser","[","A","Value","]","steps","<-","mapM","(","parseSteps","config",")","stepValues","return","config","{","configSteps","=","concat","steps","}","where","newlines","=","[","(","\"native\"",",","IO","nativeNewline",")",",","(","\"lf\"",",","IO","LF",")",",","(","\"crlf\"",",","IO","CRLF",")","]","exitCodes","=","[","(","\"normal\"",",","NormalExitBehavior",")",",","(","\"error_on_format\"",",","ErrorOnFormatExitBehavior",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L137-L161","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"whereLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"whereLine = keywordLine GHC.AnnWhere","function_tokens":["whereLine","=","keywordLine","GHC","AnnWhere"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L90-L90","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"askLn","parameters":"prompt def","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"askLn prompt def = Free.liftF (AskLn prompt def id)","function_tokens":["askLn","prompt","def","=","Free","liftF","(","AskLn","prompt","def","id",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L62-L62","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"finishCheck","parameters":"(Signal origin (RETURN_VALUE _ _))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"finishCheck (Signal origin (RETURN_VALUE _ _)) = do\n                known <- gets known\n                modify $ \\s -> s { known = origin:known }\n                finish","function_tokens":["finishCheck","(","Signal","origin","(","RETURN_VALUE","_","_",")",")","=","do","known","<-","gets","known","modify","$","\\","s","->","s","{","known","=","origin",":","known","}","finish"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L82-L86","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"get","parameters":"(Point g _)","argument_list":"","return_statement":"","docstring":"Get the getter category from a Point.","docstring_summary":"Get the getter category from a Point.","docstring_tokens":["Get","the","getter","category","from","a","Point","."],"function":"get (Point g _) = g","function_tokens":["get","(","Point","g","_",")","=","g"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L62-L62","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_ROLLOFF_FACTOR","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_ROLLOFF_FACTOR                   = 0x1021","function_tokens":["al_ROLLOFF_FACTOR","=","0x1021"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L86-L86","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Common","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Common           = \"C\"","function_tokens":["go","Common","=","\"C\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L492-L492","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putInt64","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putInt64 = putWord64le . fromIntegral","function_tokens":["putInt64","=","putWord64le",".","fromIntegral"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L131-L131","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"failArrow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"failArrow = Kleisli Left","function_tokens":["failArrow","=","Kleisli","Left"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L153-L153","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = A.choice [ parser (Proxy :: Proxy f) r, parser (Proxy :: Proxy g) r ]","function_tokens":["parser","_","r","=","A","choice","[","parser","(","Proxy","::","Proxy","f",")","r",",","parser","(","Proxy","::","Proxy","g",")","r","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L77-L77","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Tempo _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Tempo _)                = (False, True, True, True)","function_tokens":["go","(","Tempo","_",")","=","(","False",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L383-L383","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"fromAscList","parameters":"(x0 : xs0)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromAscList (x0 : xs0) = fromDistinctAscList (combineEq x0 xs0)\n  where\n    combineEq x' [] = [x']\n    combineEq x' (x:xs)\n      | x==x'     = combineEq x' xs\n      | otherwise = x' : combineEq x xs\n\n-- | \/O(n)\/. Build a set from an ascending list of distinct elements.\n-- \/The precondition (input list is strictly ascending) is not checked.\/","function_tokens":["fromAscList","(","x0",":","xs0",")","=","fromDistinctAscList","(","combineEq","x0","xs0",")","where","combineEq","x'","[","]","=","[","x'","]","combineEq","x'","(","x",":","xs",")","|","x","==","x'","=","combineEq","x'","xs","|","otherwise","=","x'",":","combineEq","x","xs","-- | \/O(n)\/. Build a set from an ascending list of distinct elements.","-- \/The precondition (input list is strictly ascending) is not checked.\/"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L732-L741","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"maxDistance","parameters":"","argument_list":"","return_statement":"","docstring":"'maxDistance' is used for distance attenuation calculations based on inverse distance with rolloff, if the inverse clamped distance model is used. In this case, distances greater than 'maxDistance' will be clamped to 'maxDistance'.  'maxDistance' based clamping is applied before minimum gain clamping (see 'gainBounds'), so if the effective gain at 'maxDistance' is larger than the minimum gain, the minimum gain will have no effect. No culling is supported. The initial value is the largest representable 'ALfloat'.","docstring_summary":"'maxDistance' is used for distance attenuation calculations based on inverse distance with rolloff, if the inverse clamped distance model is used. In this case, distances greater than 'maxDistance' will be clamped to 'maxDistance'.  'maxDistance' based clamping is applied before minimum gain clamping (see 'gainBounds'), so if the effective gain at 'maxDistance' is larger than the minimum gain, the minimum gain will have no effect. No culling is supported. The initial value is the largest representable 'ALfloat'.","docstring_tokens":["maxDistance","is","used","for","distance","attenuation","calculations","based","on","inverse","distance","with","rolloff","if","the","inverse","clamped","distance","model","is","used",".","In","this","case","distances","greater","than","maxDistance","will","be","clamped","to","maxDistance",".","maxDistance","based","clamping","is","applied","before","minimum","gain","clamping","(","see","gainBounds",")","so","if","the","effective","gain","at","maxDistance","is","larger","than","the","minimum","gain","the","minimum","gain","will","have","no","effect",".","No","culling","is","supported",".","The","initial","value","is","the","largest","representable","ALfloat","."],"function":"maxDistance = makeSourceStateVar dictALfloat GetMaxDistance","function_tokens":["maxDistance","=","makeSourceStateVar","dictALfloat","GetMaxDistance"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L371-L371","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Const a  `ieq1` Const b = a == b","function_tokens":["Const","a","`","ieq1","`","Const","b","=","a","==","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L58-L58","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ChooseC f <*> ChooseC a = ChooseC $ \\ fork leaf ->\n    f fork (\\ f' -> a fork (leaf . f'))","function_tokens":["ChooseC","f","<*>","ChooseC","a","=","ChooseC","$","\\","fork","leaf","->","f","fork","(","\\","f'","->","a","fork","(","leaf",".","f'",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L67-L68","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = mask px m","function_tokens":["p","=","mask","px","m"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L759-L759","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getUTC","parameters":"","argument_list":"","return_statement":"","docstring":"stored as milliseconds since Unix epoch","docstring_summary":"stored as milliseconds since Unix epoch","docstring_tokens":["stored","as","milliseconds","since","Unix","epoch"],"function":"getUTC = posixSecondsToUTCTime . (\/ 1000) . fromIntegral <$> getInt64","function_tokens":["getUTC","=","posixSecondsToUTCTime",".","(","\/","1000",")",".","fromIntegral","<$>","getInt64"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L233-L233","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_FALSE","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"al_FALSE                            = 0x0000","function_tokens":["al_FALSE","=","0x0000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L26-L26","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(l, r) = nameAnnAdornment nameAnn","function_tokens":["(","l",",","r",")","=","nameAnnAdornment","nameAnn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L172-L172","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = fieldLen field","function_tokens":["n","=","fieldLen","field"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs#L58-L58","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","hash_val":38792,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"distP","parameters":"(District _ label perimeter _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"distP (District _ label perimeter _ _) = (label, perimeter)","function_tokens":["distP","(","District","_","label","perimeter","_","_",")","=","(","label",",","perimeter",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L32-L32","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"fmap","parameters":"_ (Buffer Nothing)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap _ (Buffer Nothing)  = Buffer mempty","function_tokens":["fmap","_","(","Buffer","Nothing",")","=","Buffer","mempty"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L144-L144","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Lift.hs","language":"haskell","identifier":"alg","parameters":"hdl (LiftWith with)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl (LiftWith with) = LiftC . with (runM . hdl)","function_tokens":["alg","hdl","(","LiftWith","with",")","=","LiftC",".","with","(","runM",".","hdl",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Lift.hs#L41-L41","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Lift.hs","hash_val":12225,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getEntries","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getEntries = ZipArchive (gets zsEntries)","function_tokens":["getEntries","=","ZipArchive","(","gets","zsEntries",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L311-L311","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"imap","parameters":"_ (Var n s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap _ (Var n s) = Var n s","function_tokens":["imap","_","(","Var","n","s",")","=","Var","n","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L253-L253","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r1,r2) = partition predicate r","function_tokens":["(","r1",",","r2",")","=","partition","predicate","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L513-L513","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_RENDERER","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_RENDERER                         = 0xB003","function_tokens":["al_RENDERER","=","0xB003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L47-L47","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind _ _ = Nothing","function_tokens":["bind","_","_","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L798-L798","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"unions","parameters":"xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unions xs = foldlStrict union empty xs","function_tokens":["unions","xs","=","foldlStrict","union","empty","xs"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L357-L357","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"_ m@(Just (True, _))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge _ m@(Just (True, _)) = m","function_tokens":["merge","_","m","@","(","Just","(","True",",","_",")",")","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L793-L793","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ifold","parameters":"(Not n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Not n) = n","function_tokens":["ifold","(","Not","n",")","=","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L372-L372","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"listDirRecur","parameters":"path","argument_list":"","return_statement":"","docstring":"Recursively list a directory. Do not return paths to empty directories.","docstring_summary":"Recursively list a directory. Do not return paths to empty directories.","docstring_tokens":["Recursively","list","a","directory",".","Do","not","return","paths","to","empty","directories","."],"function":"listDirRecur path = DList.toList <$> go \"\"\n  where\n    go adir = do\n      let cdir = path <\/> adir\n      raw <- listDirectory cdir\n      fmap mconcat . forM raw $ \\case\n        \"\" -> return mempty\n        \".\" -> return mempty\n        \"..\" -> return mempty\n        x -> do\n          let fullx = cdir <\/> x\n              adir' = adir <\/> x\n          isFile <- doesFileExist fullx\n          isDir <- doesDirectoryExist fullx\n          if isFile\n            then return (DList.singleton adir')\n            else\n              if isDir\n                then go adir'\n                else return mempty\n\n-- | Perform an action ignoring IO exceptions it may throw.","function_tokens":["listDirRecur","path","=","DList","toList","<$>","go","\"\"","where","go","adir","=","do","let","cdir","=","path","<\/>","adir","raw","<-","listDirectory","cdir","fmap","mconcat",".","forM","raw","$","\\","case","\"\"","->","return","mempty","\".\"","->","return","mempty","\"..\"","->","return","mempty","x","->","do","let","fullx","=","cdir","<\/>","x","adir'","=","adir","<\/>","x","isFile","<-","doesFileExist","fullx","isDir","<-","doesDirectoryExist","fullx","if","isFile","then","return","(","DList","singleton","adir'",")","else","if","isDir","then","go","adir'","else","return","mempty","-- | Perform an action ignoring IO exceptions it may throw."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L690-L712","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs","language":"haskell","identifier":"mTypes","parameters":"","argument_list":"","return_statement":"","docstring":"Types with M values","docstring_summary":"Types with M values","docstring_tokens":["Types","with","M","values"],"function":"mTypes = [ShpPointM, ShpPolyLineM, ShpPolygonM, ShpMultiPointM]","function_tokens":["mTypes","=","[","ShpPointM",",","ShpPolyLineM",",","ShpPolygonM",",","ShpMultiPointM","]"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs#L55-L55","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Types.hs","hash_val":20255,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"nm","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nm = maybe (tupE []) (litE . StringL . nameBase) (guard failing >> mn)","function_tokens":["nm","=","maybe","(","tupE","[","]",")","(","litE",".","StringL",".","nameBase",")","(","guard","failing",">>","mn",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L525-L525","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Words _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Words _)                = \"W\"","function_tokens":["go","(","Words","_",")","=","\"W\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L358-L358","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"cache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cache = termCache","function_tokens":["cache","=","termCache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L40-L40","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith = MG.zipWith","function_tokens":["zipWith","=","MG","zipWith"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L258-L258","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"e","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"e = 4 * atan(sqrt(tan(s\/2) * tan((s - a)\/2) * tan((s - b)\/2) * tan((s - c)\/2)))","function_tokens":["e","=","4","*","atan","(","sqrt","(","tan","(","s","\/","2",")","*","tan","(","(","s","-","a",")","\/","2",")","*","tan","(","(","s","-","b",")","\/","2",")","*","tan","(","(","s","-","c",")","\/","2",")",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L25-L25","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"sendS","parameters":"","argument_list":"","return_statement":"","docstring":"Send a FIND_NODE command looking for the Node corresponding to the id","docstring_summary":"Send a FIND_NODE command looking for the Node corresponding to the id","docstring_tokens":["Send","a","FIND_NODE","command","looking","for","the","Node","corresponding","to","the","id"],"function":"sendS = sendSignal (FIND_NODE id)","function_tokens":["sendS","=","sendSignal","(","FIND_NODE","id",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L180-L180","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Common.hs","language":"haskell","identifier":"tmplDir","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tmplDir = pack $ \".\" <\/> \"hsinstall\"","function_tokens":["tmplDir","=","pack","$","\".\"","<\/>","\"hsinstall\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Common.hs#L26-L26","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Common.hs","hash_val":33449,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"sendSignal","parameters":"cmd node","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sendSignal cmd node = do\n    h <- fmap handle . gets $ inst\n    chan <- gets replyChan\n    polled <- gets polled\n    pending <- gets pending\n\n    -- Send the signal\n    liftIO . send h (peer node) $ cmd\n\n    -- Expect an appropriate reply to the command\n    liftIO . expect h regs $ chan\n\n    -- Mark the node as polled and pending\n    modify $ \\s -> s {\n          polled = node:polled\n        , pending = node:pending\n        }\n\n    -- Determine the appropriate ReplyRegistrations to the command\n    where regs = case cmd of\n                    (FIND_NODE id)  -> RR [R_RETURN_NODES id] (nodeId node)\n                    (FIND_VALUE id) ->\n                        RR [R_RETURN_NODES id, R_RETURN_VALUE id] (nodeId node)","function_tokens":["sendSignal","cmd","node","=","do","h","<-","fmap","handle",".","gets","$","inst","chan","<-","gets","replyChan","polled","<-","gets","polled","pending","<-","gets","pending","-- Send the signal","liftIO",".","send","h","(","peer","node",")","$","cmd","-- Expect an appropriate reply to the command","liftIO",".","expect","h","regs","$","chan","-- Mark the node as polled and pending","modify","$","\\","s","->","s","{","polled","=","node",":","polled",",","pending","=","node",":","pending","}","-- Determine the appropriate ReplyRegistrations to the command","where","regs","=","case","cmd","of","(","FIND_NODE","id",")","->","RR","[","R_RETURN_NODES","id","]","(","nodeId","node",")","(","FIND_VALUE","id",")","->","RR","[","R_RETURN_NODES","id",",","R_RETURN_VALUE","id","]","(","nodeId","node",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L328-L350","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"fromCompressionMethod","parameters":"Deflate","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromCompressionMethod Deflate = 8","function_tokens":["fromCompressionMethod","Deflate","=","8"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1119-L1119","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pool","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pool = [ [x] | x <- ['a'..'z'] ] ++ [ x ++ [y] | x <- pool, y <- ['a'..'z'] ]","function_tokens":["pool","=","[","[","x","]","|","x","<-","[","'a'","..","'z'","]","]","++","[","x","++","[","y","]","|","x","<-","pool",",","y","<-","[","'a'","..","'z'","]","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L709-L709","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"mappend","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappend = (<>)","function_tokens":["mappend","=","(","<>",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L328-L328","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"end","parameters":"","argument_list":"","return_statement":"","docstring":"Return Nothing on lookup failure","docstring_summary":"Return Nothing on lookup failure","docstring_tokens":["Return","Nothing","on","lookup","failure"],"function":"end = return Nothing","function_tokens":["end","=","return","Nothing"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L166-L166","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"defaultMainWith","parameters":"cfg bs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultMainWith cfg bs | printOnce cfg = go (pure ())\n                       | otherwise = bracket_ hideCursor showCursor\n                         . go . B.hPutBuilder stdout . fromString $ replicate (printHeight cfg*length bs) '\\n'\n  where go mkSpace = hSetEcho stdin False *> mkSpace *> warmup *> (flip (runMain cfg) (S.fromList . zipWith (BenchmarkMeta 0 0) [1..] $ reverse pad) =<< now)\n        pad | sameLine cfg = let len = maximum (map (length . name) bs) in map (\\x -> x{name = take len $ name x ++ repeat ' '}) bs\n            | otherwise = bs\n\n-- | Default configuration.  Use this combined with record updates to\n-- ensure compatibility with future releases.","function_tokens":["defaultMainWith","cfg","bs","|","printOnce","cfg","=","go","(","pure","(",")",")","|","otherwise","=","bracket_","hideCursor","showCursor",".","go",".","B","hPutBuilder","stdout",".","fromString","$","replicate","(","printHeight","cfg","*","length","bs",")","'\\n'","where","go","mkSpace","=","hSetEcho","stdin","False","*>","mkSpace","*>","warmup","*>","(","flip","(","runMain","cfg",")","(","S","fromList",".","zipWith","(","BenchmarkMeta","0","0",")","[","1","..","]","$","reverse","pad",")","=<<","now",")","pad","|","sameLine","cfg","=","let","len","=","maximum","(","map","(","length",".","name",")","bs",")","in","map","(","\\","x","->","x","{","name","=","take","len","$","name","x","++","repeat","' '","}",")","bs","|","otherwise","=","bs","-- | Default configuration.  Use this combined with record updates to","-- ensure compatibility with future releases."],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L136-L145","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"pi","parameters":"v t e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pi v t e = intern (BPi v t e)","function_tokens":["pi","v","t","e","=","intern","(","BPi","v","t","e",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L84-L84","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"subMatrix","parameters":"","argument_list":"","return_statement":"","docstring":"O(1) Extract sub matrix","docstring_summary":"O(1) Extract sub matrix","docstring_tokens":["O","(","1",")","Extract","sub","matrix"],"function":"subMatrix = MG.subMatrix","function_tokens":["subMatrix","=","MG","subMatrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L193-L193","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"freshNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freshNames = map pure ['a'..'z'] ++ map (('a':) . show) [0 :: Integer ..]","function_tokens":["freshNames","=","map","pure","[","'a'","..","'z'","]","++","map","(","(","'a'",":",")",".","show",")","[","0","::","Integer","..","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L555-L555","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Dorian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Dorian       = \"dorian\"","function_tokens":["go","Dorian","=","\"dorian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L531-L531","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified = coerce . isQuantified' . unIFix","function_tokens":["isQuantified","=","coerce",".","isQuantified'",".","unIFix"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L640-L640","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Common.hs","language":"haskell","identifier":"dumpStockIcon","parameters":"mbDestPath","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dumpStockIcon mbDestPath = do\n  shareDir <- getShareDir getDataDir\n  let iconFilename = \"unix-terminal\" <.> \"svg\"\n  let iconSourcePath = shareDir <\/> \"resources\" <\/> iconFilename\n  let destPath = fromMaybe iconFilename mbDestPath\n  copyFile iconSourcePath destPath","function_tokens":["dumpStockIcon","mbDestPath","=","do","shareDir","<-","getShareDir","getDataDir","let","iconFilename","=","\"unix-terminal\"","<.>","\"svg\"","let","iconSourcePath","=","shareDir","<\/>","\"resources\"","<\/>","iconFilename","let","destPath","=","fromMaybe","iconFilename","mbDestPath","copyFile","iconSourcePath","destPath"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Common.hs#L36-L41","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Common.hs","hash_val":33449,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"len","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"len = fromRational m * fromIntegral (width - 6) \/ 2","function_tokens":["len","=","fromRational","m","*","fromIntegral","(","width","-","6",")","\/","2"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L413-L413","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"dim","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim = MG.dim","function_tokens":["dim","=","MG","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L27-L27","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"re","parameters":"o n x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"re o n x = if x == o then n else x","function_tokens":["re","o","n","x","=","if","x","==","o","then","n","else","x"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L441-L441","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class\/Mutable.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,c) = dim mat","function_tokens":["(","r",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class\/Mutable.hs#L45-L45","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class\/Mutable.hs","hash_val":20157,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"fieldDeclSeparator","parameters":"GHC.EpAnn {..}","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"fieldDeclSeparator GHC.EpAnn {..} = listToMaybe $ do\n    GHC.AddEpAnn GHC.AnnDcolon (GHC.EpaSpan s) <- anns\n    pure s","function_tokens":["fieldDeclSeparator","GHC","EpAnn","{","..","}","=","listToMaybe","$","do","GHC","AddEpAnn","GHC","AnnDcolon","(","GHC","EpaSpan","s",")","<-","anns","pure","s"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L49-L52","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INVALID_ENUM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INVALID_ENUM                     = 0xA002","function_tokens":["al_INVALID_ENUM","=","0xA002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L33-L33","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"IfThenElse sa ia ta ea `ieq1` IfThenElse sb ib tb eb = ia `ieq` ib && case sa %~ sb of\n        Proved Refl -> ta `ieq` tb && ea `ieq` eb\n        Disproved _ -> False","function_tokens":["IfThenElse","sa","ia","ta","ea","`","ieq1","`","IfThenElse","sb","ib","tb","eb","=","ia","`","ieq","`","ib","&&","case","sa","%~","sb","of","Proved","Refl","->","ta","`","ieq","`","tb","&&","ea","`","ieq","`","eb","Disproved","_","->","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L43-L47","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"checkZip64","parameters":"pos","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkZip64 pos =\n      if pos < 20\n        then return (Just pos)\n        else do\n          hSeek h AbsoluteSeek (pos - 20)\n          zip64locatorSig <- getNum getWord32le 4\n          if zip64locatorSig == 0x07064b50\n            then do\n              hSeek h AbsoluteSeek (pos - 12)\n              Just . fromIntegral <$> getNum getWord64le 8\n            else return (Just pos)","function_tokens":["checkZip64","pos","=","if","pos","<","20","then","return","(","Just","pos",")","else","do","hSeek","h","AbsoluteSeek","(","pos","-","20",")","zip64locatorSig","<-","getNum","getWord32le","4","if","zip64locatorSig","==","0x07064b50","then","do","hSeek","h","AbsoluteSeek","(","pos","-","12",")","Just",".","fromIntegral","<$>","getNum","getWord64le","8","else","return","(","Just","pos",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1015-L1026","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"putT","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putT    = [| arr $(setter failing total field) |]","function_tokens":["putT","=","[","|"," arr $(setter failing total field) ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L437-L437","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"displayException","parameters":"(BothFailed ea eb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"displayException (BothFailed ea eb) = displayException ea ++ \"\\n\" ++ displayException eb","function_tokens":["displayException","(","BothFailed","ea","eb",")","=","displayException","ea","++","\"\\n\"","++","displayException","eb"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L198-L198","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"getGuards","parameters":"(Hs.Match _ _ _ grhss)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ get guards in a guarded rhs of a Match","docstring_summary":"------------------------------------------------------------------------------ get guards in a guarded rhs of a Match","docstring_tokens":["------------------------------------------------------------------------------","get","guards","in","a","guarded","rhs","of","a","Match"],"function":"getGuards (Hs.Match _ _ _ grhss) =\n  let\n    lgrhs = getLocGRHS grhss -- []\n    grhs  = map GHC.unLoc lgrhs\n  in\n    concatMap getGuardLStmts grhs","function_tokens":["getGuards","(","Hs","Match","_","_","_","grhss",")","=","let","lgrhs","=","getLocGRHS","grhss","-- []","grhs","=","map","GHC","unLoc","lgrhs","in","concatMap","getGuardLStmts","grhs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L243-L248","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mono","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L337-L337","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWith3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith3 = MG.zipWith3","function_tokens":["zipWith3","=","MG","zipWith3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L263-L263","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"askWithMenuRepeatedly","parameters":"m prompt errprompt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"askWithMenuRepeatedly m prompt errprompt = go m\n  where\n    go config = do\n      answer <- askWithMenu config prompt\n      case answer of\n        Other _ -> go (config {_menuBeforePrompt = Just (toStylizedText errprompt)})\n        Match x -> pure x\n\n-- $usage\n--\n-- Menus are used to provide the user with a choice of acceptable\n-- values.  Each choice is labeled to make it easier for a user to\n-- select it, or the user may enter text that does not correspond to\n-- any of the menus items.\n--\n-- For an example see the @menu.hs@ file in the @examples@ directory.","function_tokens":["askWithMenuRepeatedly","m","prompt","errprompt","=","go","m","where","go","config","=","do","answer","<-","askWithMenu","config","prompt","case","answer","of","Other","_","->","go","(","config","{","_menuBeforePrompt","=","Just","(","toStylizedText","errprompt",")","}",")","Match","x","->","pure","x","-- $usage","--","-- Menus are used to provide the user with a choice of acceptable","-- values.  Each choice is labeled to make it easier for a user to","-- select it, or the user may enter text that does not correspond to","-- any of the menus items.","--","-- For an example see the @menu.hs@ file in the @examples@ directory."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L258-L273","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = EvalT . lift . lift","function_tokens":["lift","=","EvalT",".","lift",".","lift"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L181-L181","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Utils.hs","language":"haskell","identifier":"labels","parameters":"","argument_list":"","return_statement":"","docstring":"Make sure labels on shapefile objects are suitable for human reading.","docstring_summary":"Make sure labels on shapefile objects are suitable for human reading.","docstring_tokens":["Make","sure","labels","on","shapefile","objects","are","suitable","for","human","reading","."],"function":"labels = map ((filter (\/=' ')) . (take 35) . (drop 11) . show . (!!3))","function_tokens":["labels","=","map","(","(","filter","(","\/=","' '",")",")",".","(","take","35",")",".","(","drop","11",")",".","show",".","(","!!","3",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Utils.hs#L16-L16","hash_key":"vmchale\/hgis:src\/GIS\/Utils.hs","hash_val":20401,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_CHANNELS","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_CHANNELS                         = 0x2003","function_tokens":["al_CHANNELS","=","0x2003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L115-L115","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"changeBit","parameters":"i w","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changeBit i w = if bs !! i\n                then setBit w (i `mod` 8)\n                else w","function_tokens":["changeBit","i","w","=","if","bs","!!","i","then","setBit","w","(","i","`","mod","`","8",")","else","w"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L72-L74","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"atanh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"atanh = fmap atanh","function_tokens":["atanh","=","fmap","atanh"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L251-L251","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"combineEq","parameters":"x' []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"combineEq x' [] = [x']","function_tokens":["combineEq","x'","[","]","=","[","x'","]"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L734-L734","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unsafeThaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeThaw = MG.unsafeThaw","function_tokens":["unsafeThaw","=","MG","unsafeThaw"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L375-L375","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"modToSGR","parameters":"mod colorF","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modToSGR mod colorF =\n  catMaybes\n    [ colorF ANSI.Foreground <$> getColor modColorFG,\n      colorF ANSI.Background <$> getColor modColorBG,\n      ANSI.SetConsoleIntensity <$> getIntensity,\n      ANSI.SetUnderlining <$> getUnderlining,\n      ANSI.SetSwapForegroundBackground <$> getSwapForegroundBackground\n    ]\n  where\n    getColor :: (Modifier -> OnlyOne Color) -> Maybe Color\n    getColor f = unOne (f mod)\n    getIntensity :: Maybe ANSI.ConsoleIntensity\n    getIntensity = case modBold mod of\n      Off -> Nothing\n      On -> Just ANSI.BoldIntensity\n    getUnderlining :: Maybe ANSI.Underlining\n    getUnderlining = case modUnderline mod of\n      Off -> Nothing\n      On -> Just ANSI.SingleUnderline\n    getSwapForegroundBackground :: Maybe Bool\n    getSwapForegroundBackground = case modSwapFgBg mod of\n      Off -> Nothing\n      On -> Just True","function_tokens":["modToSGR","mod","colorF","=","catMaybes","[","colorF","ANSI","Foreground","<$>","getColor","modColorFG",",","colorF","ANSI","Background","<$>","getColor","modColorBG",",","ANSI","SetConsoleIntensity","<$>","getIntensity",",","ANSI","SetUnderlining","<$>","getUnderlining",",","ANSI","SetSwapForegroundBackground","<$>","getSwapForegroundBackground","]","where","getColor","::","(","Modifier","->","OnlyOne","Color",")","->","Maybe","Color","getColor","f","=","unOne","(","f","mod",")","getIntensity","::","Maybe","ANSI","ConsoleIntensity","getIntensity","=","case","modBold","mod","of","Off","->","Nothing","On","->","Just","ANSI","BoldIntensity","getUnderlining","::","Maybe","ANSI","Underlining","getUnderlining","=","case","modUnderline","mod","of","Off","->","Nothing","On","->","Just","ANSI","SingleUnderline","getSwapForegroundBackground","::","Maybe","Bool","getSwapForegroundBackground","=","case","modSwapFgBg","mod","of","Off","->","Nothing","On","->","Just","True"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L226-L248","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"route","parameters":"Proxy context subserver","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"route Proxy context subserver\n    = route\n      (Proxy :: Proxy sublayout)\n      context\n      (addAuthCheck subserver go)\n    where\n      lookupGHEvent = lookup \"X-Github-Event\"\n\n      events :: [RepoWebhookEvent]\n      events = reflect (Proxy :: Proxy events)\n\n      eventNames :: String\n      eventNames = intercalate \", \" $ (cs . encode) <$> events\n\n      go :: DelayedIO RepoWebhookEvent\n      go = withRequest $ \\req -> do\n        case lookupGHEvent (requestHeaders req) of\n          Nothing -> delayedFail err401\n          Just h -> do\n            case catMaybes $ map (`matchEvent` h) events of\n              [] -> delayedFail err404\n                { errBody = cs $ \"supported events: \" <> eventNames }\n              (event:_) -> pure event\n\n-- | Type function that reflects a kind to a type.","function_tokens":["route","Proxy","context","subserver","=","route","(","Proxy","::","Proxy","sublayout",")","context","(","addAuthCheck","subserver","go",")","where","lookupGHEvent","=","lookup","\"X-Github-Event\"","events","::","[","RepoWebhookEvent","]","events","=","reflect","(","Proxy","::","Proxy","events",")","eventNames","::","String","eventNames","=","intercalate","\", \"","$","(","cs",".","encode",")","<$>","events","go","::","DelayedIO","RepoWebhookEvent","go","=","withRequest","$","\\","req","->","do","case","lookupGHEvent","(","requestHeaders","req",")","of","Nothing","->","delayedFail","err401","Just","h","->","do","case","catMaybes","$","map","(","`","matchEvent","`","h",")","events","of","[","]","->","delayedFail","err404","{","errBody","=","cs","$","\"supported events: \"","<>","eventNames","}","(","event",":","_",")","->","pure","event","-- | Type function that reflects a kind to a type."],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L348-L373","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ishow","parameters":"(a `LessThan` b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (a `LessThan` b) = coerce $ \"(< \" ++ coerce a ++ \" \" ++ coerce b ++ \")\"","function_tokens":["ishow","(","a","`","LessThan","`","b",")","=","coerce","$","\"(< \"","++","coerce","a","++","\" \"","++","coerce","b","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L100-L100","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = RSST $ \\r s -> mfix $ \\ ~(a, _) -> runRSST' (f a) r s","function_tokens":["mfix","f","=","RSST","$","\\","r","s","->","mfix","$","\\","~","(","a",",","_",")","->","runRSST'","(","f","a",")","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L157-L157","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Meter _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Meter _)                = \"M\"","function_tokens":["go","(","Meter","_",")","=","\"M\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L345-L345","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sourcePosition","parameters":"","argument_list":"","return_statement":"","docstring":"'sourcePosition' contains the current location of the source in the world coordinate system. Any 3-tuple of valid float values is allowed. Implementation behavior on encountering NaN and infinity is not defined. The initial position is ('Vertex3' 0 0 0).","docstring_summary":"'sourcePosition' contains the current location of the source in the world coordinate system. Any 3-tuple of valid float values is allowed. Implementation behavior on encountering NaN and infinity is not defined. The initial position is ('Vertex3' 0 0 0).","docstring_tokens":["sourcePosition","contains","the","current","location","of","the","source","in","the","world","coordinate","system",".","Any","3","-","tuple","of","valid","float","values","is","allowed",".","Implementation","behavior","on","encountering","NaN","and","infinity","is","not","defined",".","The","initial","position","is","(","Vertex3","0","0","0",")","."],"function":"sourcePosition = makeSourceStateVar dictVertex3ALfloat GetPosition","function_tokens":["sourcePosition","=","makeSourceStateVar","dictVertex3ALfloat","GetPosition"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L150-L150","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"commentTextWithoutMarks","parameters":"c","argument_list":"","return_statement":"","docstring":"The text of a comment, but with the comment marks removed.","docstring_summary":"The text of a comment, but with the comment marks removed.","docstring_tokens":["The","text","of","a","comment","but","with","the","comment","marks","removed","."],"function":"commentTextWithoutMarks c = stripCommentMarks fmt (commentText c)\n  where fmt = commentFormat c\n\n-- | Comments are ordered by position within files.","function_tokens":["commentTextWithoutMarks","c","=","stripCommentMarks","fmt","(","commentText","c",")","where","fmt","=","commentFormat","c","-- | Comments are ordered by position within files."],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L38-L42","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"recover","parameters":"!dt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"recover !dt = do\n  CacheState _ m <- readIORef $ getCache cache ! (hash dt `mod` cacheWidth dt)\n  return $ HashMap.lookup dt m","function_tokens":["recover","dt","=","do","CacheState","_","m","<-","readIORef","$","getCache","cache","!","(","hash","dt","`","mod","`","cacheWidth","dt",")","return","$","HashMap","lookup","dt","m"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L94-L96","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"describe","parameters":"(BLam v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe (BLam v t e) = DLam v (identity t) (identity e)","function_tokens":["describe","(","BLam","v","t","e",")","=","DLam","v","(","identity","t",")","(","identity","e",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L32-L32","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"q'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"q'         = c vs' . q","function_tokens":["q'","=","c","vs'",".","q"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L724-L724","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"_ Empty _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg _ Empty _ = Nothing","function_tokens":["alg","_","Empty","_","=","Nothing"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L158-L158","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"delabelize","parameters":"dec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delabelize dec =\n    case dec of\n#if MIN_VERSION_template_haskell(2,11,0)\n      DataD    ctx nm vars mk cs ns -> DataD    ctx nm vars mk (con <$> cs) ns\n      NewtypeD ctx nm vars mk c  ns -> NewtypeD ctx nm vars mk (con c)      ns\n#else\n      DataD    ctx nm vars cs ns -> DataD    ctx nm vars (con <$> cs) ns\n      NewtypeD ctx nm vars c  ns -> NewtypeD ctx nm vars (con c)      ns\n#endif\n      rest                       -> rest\n    where con (RecC n vst) = NormalC n (map (\\(_, s, t) -> (s, t)) vst)\n#if MIN_VERSION_template_haskell(2,11,0)\n          con (RecGadtC ns vst ty) = GadtC ns (map (\\(_, s, t) -> (s, t)) vst) ty\n#endif\n          con c            = c\n\n-------------------------------------------------------------------------------\n-- Intermediate data types.","function_tokens":["delabelize","dec","=","case","dec","of","#if MIN_VERSION_template_haskell(2,11,0)","DataD","ctx","nm","vars","mk","cs","ns","->","DataD","ctx","nm","vars","mk","(","con","<$>","cs",")","ns","NewtypeD","ctx","nm","vars","mk","c","ns","->","NewtypeD","ctx","nm","vars","mk","(","con","c",")","ns","#else\n      DataD    ctx nm vars cs ns -> DataD    ctx nm vars (con <$> cs) ns\n      NewtypeD ctx nm vars c  ns -> NewtypeD ctx nm vars (con c)      ns\n","#endif","rest","->","rest","where","con","(","RecC","n","vst",")","=","NormalC","n","(","map","(","\\","(","_",",","s",",","t",")","->","(","s",",","t",")",")","vst",")","#if MIN_VERSION_template_haskell(2,11,0)","con","(","RecGadtC","ns","vst","ty",")","=","GadtC","ns","(","map","(","\\","(","_",",","s",",","t",")","->","(","s",",","t",")",")","vst",")","ty","#endif","con","c","=","c","-------------------------------------------------------------------------------","-- Intermediate data types."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L218-L237","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"izipWith6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith6 = MG.izipWith6","function_tokens":["izipWith6","=","MG","izipWith6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L305-L305","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"findMin","parameters":"Nil","argument_list":"","return_statement":"","docstring":"\/O(min(n,W))\/. The minimal element of the set.","docstring_summary":"\/O(min(n,W))\/. The minimal element of the set.","docstring_tokens":["\/","O","(","min","(","n","W","))","\/",".","The","minimal","element","of","the","set","."],"function":"findMin Nil = error \"findMin: empty set has no minimal element\"","function_tokens":["findMin","Nil","=","error","\"findMin: empty set has no minimal element\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L639-L639","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"predictComment","parameters":"original xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"predictComment original xs =\n  case S.index xs <$> S.findIndexR (isNothing . targetEntry) xs of\n    Nothing -> original\n    Just DeleteArchiveComment -> Nothing\n    Just (SetArchiveComment txt) -> Just txt\n    Just _ -> Nothing\n\n-- | Transform a map representing existing entries into a collection of\n-- actions that re-create those entires.","function_tokens":["predictComment","original","xs","=","case","S","index","xs","<$>","S","findIndexR","(","isNothing",".","targetEntry",")","xs","of","Nothing","->","original","Just","DeleteArchiveComment","->","Nothing","Just","(","SetArchiveComment","txt",")","->","Just","txt","Just","_","->","Nothing","-- | Transform a map representing existing entries into a collection of","-- actions that re-create those entires."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L322-L331","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"checkSignal","parameters":"(Signal origin (RETURN_VALUE _ value))","argument_list":"","return_statement":"","docstring":"When receiving a RETURN_VALUE command, finish the lookup, then cache the value in the closest peer that didn't return it and finally return the value","docstring_summary":"When receiving a RETURN_VALUE command, finish the lookup, then cache the value in the closest peer that didn't return it and finally return the value","docstring_tokens":["When","receiving","a","RETURN_VALUE","command","finish","the","lookup","then","cache","the","value","in","the","closest","peer","that","didn","t","return","it","and","finally","return","the","value"],"function":"checkSignal (Signal origin (RETURN_VALUE _ value)) = do\n                -- Abuse the known list for saving the peers that are *known* to\n                -- store the value\n                modify $ \\s -> s { known = [origin] }\n\n                -- Finish the lookup, recording which nodes returned the value\n                finish\n\n                -- Store the value in the closest peer that didn't return the\n                -- value\n                known <- gets known\n                polled <- gets polled\n                let rest = polled \\\\ known\n                unless (null rest) $ do\n                    let cachePeer = peer . head . sortByDistanceTo rest $ id\n                    liftIO . send (handle inst) cachePeer . STORE id $ value\n\n                -- Return the value\n                return . Just $ (value, origin)\n\n          -- When receiving a RETURN_NODES command, throw the nodes into the\n          -- lookup loop and continue the lookup","function_tokens":["checkSignal","(","Signal","origin","(","RETURN_VALUE","_","value",")",")","=","do","-- Abuse the known list for saving the peers that are *known* to","-- store the value","modify","$","\\","s","->","s","{","known","=","[","origin","]","}","-- Finish the lookup, recording which nodes returned the value","finish","-- Store the value in the closest peer that didn't return the","-- value","known","<-","gets","known","polled","<-","gets","polled","let","rest","=","polled","\\\\","known","unless","(","null","rest",")","$","do","let","cachePeer","=","peer",".","head",".","sortByDistanceTo","rest","$","id","liftIO",".","send","(","handle","inst",")","cachePeer",".","STORE","id","$","value","-- Return the value","return",".","Just","$","(","value",",","origin",")","-- When receiving a RETURN_NODES command, throw the nodes into the","-- lookup loop and continue the lookup"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L45-L67","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"liftAll","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil","function_tokens":["liftAll","m","=","NonDetC","$","\\","fork","leaf","nil","->","m",">>=","foldr","(","fork",".","leaf",")","nil"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L113-L113","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(Exists vs phi)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Exists vs phi) = coerce $ \"(exists (\" ++ intercalate \" \" (map show vs) ++ \") \" ++ coerce phi ++ \")\"","function_tokens":["ishow","(","Exists","vs","phi",")","=","coerce","$","\"(exists (\"","++","intercalate","\" \"","(","map","show","vs",")","++","\") \"","++","coerce","phi","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L562-L562","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"[f]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge [f] = f","function_tokens":["merge","[","f","]","=","f"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L468-L468","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fresh\/Church.hs","language":"haskell","identifier":"runFresh","parameters":"k n","argument_list":"","return_statement":"","docstring":"Run a 'Fresh' effect counting up from 0.  @ 'runFresh' k n ('pure' a) = k n a @ @ 'runFresh' k n 'fresh' = k (n '+' 1) n @  @since 1.1.0.0","docstring_summary":"Run a 'Fresh' effect counting up from 0.","docstring_tokens":["Run","a","Fresh","effect","counting","up","from","0","."],"function":"runFresh k n = runState k n . runFreshC","function_tokens":["runFresh","k","n","=","runState","k","n",".","runFreshC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fresh\/Church.hs#L41-L41","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fresh\/Church.hs","hash_val":22500,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"liftIO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO = lift . liftIO","function_tokens":["liftIO","=","lift",".","liftIO"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L124-L124","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_CAPTURE_DEFAULT_DEVICE_SPECIFIER","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_CAPTURE_DEFAULT_DEVICE_SPECIFIER= 0x0311","function_tokens":["alc_CAPTURE_DEFAULT_DEVICE_SPECIFIER","=","0x0311"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L153-L153","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"writeQuads","parameters":"CayleyConnection{..}","argument_list":"","return_statement":"","docstring":"Write the given list of 'Quad'(s).","docstring_summary":"Write the given list of 'Quad'(s).","docstring_tokens":["Write","the","given","list","of","Quad","(","s",")","."],"function":"writeQuads CayleyConnection{..} =\n  writeQuads' manager cayleyConfig\n  where\n    writeQuads' m CayleyConfig{..} qs =\n      apiRequest\n        m (urlBase serverName apiVersion ++ \"\/write\")\n        serverPort (toRequestBody qs)\n\n-- | Delete the given list of 'Quad'(s).","function_tokens":["writeQuads","CayleyConnection","{","..","}","=","writeQuads'","manager","cayleyConfig","where","writeQuads'","m","CayleyConfig","{","..","}","qs","=","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/write\"",")","serverPort","(","toRequestBody","qs",")","-- | Delete the given list of 'Quad'(s)."],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L143-L152","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)","function_tokens":["alg","hdl","sig","ctx","=","StateC","$","\\","s","->","case","sig","of","L","Get","->","pure","(","s",",","s","<$","ctx",")","L","(","Put","s",")","->","pure","(","s",",","ctx",")","R","other","->","thread","(","uncurry","runState","~<~","hdl",")","other","(","s",",","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L123-L127","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"unit","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unit = Tfm 1 0","function_tokens":["unit","=","Tfm","1","0"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L355-L355","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"setBuffer","parameters":"buffer","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setBuffer buffer = withBuffer (const buffer)","function_tokens":["setBuffer","buffer","=","withBuffer","(","const","buffer",")"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L125-L125","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"state","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"state f = RSST $ \\_ (s,w) -> case f s of\n                                      (a,s') -> return (a, (s', w))","function_tokens":["state","f","=","RSST","$","\\","_","(","s",",","w",")","->","case","f","s","of","(","a",",","s'",")","->","return","(","a",",","(","s'",",","w",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L175-L177","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrRemBitsLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen","function_tokens":["ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L45-L45","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client\/Internal.hs","language":"haskell","identifier":"urlBase","parameters":"s a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"urlBase s a = \"http:\/\/\" ++ s ++ \"\/api\/v\" ++ show a","function_tokens":["urlBase","s","a","=","\"http:\/\/\"","++","s","++","\"\/api\/v\"","++","show","a"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client\/Internal.hs#L33-L33","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client\/Internal.hs","hash_val":6396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"mconcat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mconcat = unions","function_tokens":["mconcat","=","unions"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L241-L241","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class\/Mutable.hs","language":"haskell","identifier":"read","parameters":"mat (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"read mat (i,j)\n    | i <0 || i >= r || j < 0 || j >= c = error \"read: Index out of bounds\"\n    | otherwise = unsafeRead mat (i,j)\n  where\n    (r,c) = dim mat","function_tokens":["read","mat","(","i",",","j",")","|","i","<","0","||","i",">=","r","||","j","<","0","||","j",">=","c","=","error","\"read: Index out of bounds\"","|","otherwise","=","unsafeRead","mat","(","i",",","j",")","where","(","r",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class\/Mutable.hs#L41-L46","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class\/Mutable.hs","hash_val":20157,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"go","parameters":"_  _  []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _  _  []       = return []","function_tokens":["go","_","_","[","]","=","return","[","]"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L48-L48","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(d, i) = partition (\\(vs', _) -> any (`elem` mapMaybe toStaticallySorted vs') vs) qs","function_tokens":["(","d",",","i",")","=","partition","(","\\","(","vs'",",","_",")","->","any","(","`","elem","`","mapMaybe","toStaticallySorted","vs'",")","vs",")","qs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L846-L846","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"defaultCayleyConfig","parameters":"","argument_list":"","return_statement":"","docstring":"CayleyConfig { serverPort = 64210 , serverName = \"localhost\" , apiVersion = V1 , queryLang  = Gremlin }","docstring_summary":"CayleyConfig { serverPort = 64210 , serverName = \"localhost\" , apiVersion = V1 , queryLang  = Gremlin }","docstring_tokens":["CayleyConfig","{","serverPort","=","64210","serverName","=","localhost","apiVersion","=","V1","queryLang","=","Gremlin","}"],"function":"defaultCayleyConfig = CayleyConfig\n  { serverPort = 64210\n  , serverName = \"localhost\"\n  , apiVersion = V1\n  , queryLang  = Gremlin\n  }","function_tokens":["defaultCayleyConfig","=","CayleyConfig","{","serverPort","=","64210",",","serverName","=","\"localhost\"",",","apiVersion","=","V1",",","queryLang","=","Gremlin","}"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L35-L40","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseEnum","parameters":"_    def Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseEnum _    def Nothing  = return def","function_tokens":["parseEnum","_","def","Nothing","=","return","def"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L191-L191","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"isFasterThan","parameters":"b1 b2","argument_list":"","return_statement":"","docstring":"Determine whether a benchmark is faster than another. It runs each benchmark until their confidence intervals don't overlap or are no bigger than 1% of the mean. If the confidence intervals don't overlap and the mean of the first is lower True will be returned.  Otherwise False.  This function is meant to be used in test suites as infix function.  > benchShell \"echo\" \"echo\" `isFasterThan` benchShell \"sleep 0\" \"sleep 0\"","docstring_summary":"Determine whether a benchmark is faster than another. It runs each benchmark until their confidence intervals don't overlap or are no bigger than 1% of the mean. If the confidence intervals don't overlap and the mean of the first is lower True will be returned.  Otherwise False.  This function is meant to be used in test suites as infix function.  > benchShell \"echo\" \"echo\" `isFasterThan` benchShell \"sleep 0\" \"sleep 0\"","docstring_tokens":["Determine","whether","a","benchmark","is","faster","than","another",".","It","runs","each","benchmark","until","their","confidence","intervals","don","t","overlap","or","are","no","bigger","than","1%","of","the","mean",".","If","the","confidence","intervals","don","t","overlap","and","the","mean","of","the","first","is","lower","True","will","be","returned",".","Otherwise","False",".","This","function","is","meant","to","be","used","in","test","suites","as","infix","function",".",">","benchShell","echo","echo","isFasterThan","benchShell","sleep","0","sleep","0"],"function":"isFasterThan b1 b2 = (LT==) <$> compareBench defaultConfig 0.01 b1 b2","function_tokens":["isFasterThan","b1","b2","=","(","LT","==",")","<$>","compareBench","defaultConfig","0.01","b1","b2"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L179-L179","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"cols","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cols = MG.cols","function_tokens":["cols","=","MG","cols"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L120-L120","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step.hs","language":"haskell","identifier":"makeStep","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"makeStep = Step","function_tokens":["makeStep","=","Step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step.hs#L20-L20","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step.hs","hash_val":25615,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/simple.hs","language":"haskell","identifier":"atLeastThreeChars","parameters":"input","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"atLeastThreeChars input\n  | Text.length input < 3 = Left (\"You can do better.\" & bg red)\n  | otherwise = Right input","function_tokens":["atLeastThreeChars","input","|","Text","length","input","<","3","=","Left","(","\"You can do better.\"","&","bg","red",")","|","otherwise","=","Right","input"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/simple.hs#L57-L59","hash_key":"pjones\/byline:examples\/simple.hs","hash_val":16333,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"seedIdentity","parameters":"_","argument_list":"","return_statement":"","docstring":"a huge cache width!","docstring_summary":"a huge cache width!","docstring_tokens":["a","huge","cache","width!"],"function":"seedIdentity _ = 1","function_tokens":["seedIdentity","_","=","1"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L208-L208","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/simple.hs","language":"haskell","identifier":"question","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"question =\n          \"What's your \"\n            <> (\"name\" & fg green & underline)\n            <> \"? \"","function_tokens":["question","=","\"What's your \"","<>","(","\"name\"","&","fg","green","&","underline",")","<>","\"? \""],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/simple.hs#L47-L50","hash_key":"pjones\/byline:examples\/simple.hs","hash_val":16333,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookWatchEvent","function_tokens":["reflect","_","=","WebhookWatchEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L478-L478","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"var'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var' = parser (Proxy :: Proxy VarF) var'","function_tokens":["var'","=","parser","(","Proxy","::","Proxy","VarF",")","var'"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L591-L591","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"fxs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fxs    = filter (not . isRedundant') xs","function_tokens":["fxs","=","filter","(","not",".","isRedundant'",")","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L111-L111","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"column","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"column = GHC.srcSpanEndCol $ aLeft a","function_tokens":["column","=","GHC","srcSpanEndCol","$","aLeft","a"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L83-L83","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseImports","parameters":"config o","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"parseImports config o = fmap (Imports.step columns) $ Imports.Options\n      <$> (o A..:? \"align\" >>= parseEnum aligns (def Imports.importAlign))\n      <*> (o A..:? \"list_align\" >>= parseEnum listAligns (def Imports.listAlign))\n      <*> (o A..:? \"pad_module_names\" A..!= def Imports.padModuleNames)\n      <*> (o A..:? \"long_list_align\" >>= parseEnum longListAligns (def Imports.longListAlign))\n      <*> (o A..:? \"empty_list_align\" >>= parseEnum emptyListAligns (def Imports.emptyListAlign))\n      -- Note that padding has to be at least 1. Default is 4.\n      <*> (o A..:? \"list_padding\" >>= maybe (pure $ def Imports.listPadding) parseListPadding)\n      <*> o A..:? \"separate_lists\" A..!= def Imports.separateLists\n      <*> o A..:? \"space_surround\" A..!= def Imports.spaceSurround\n      <*> o A..:? \"post_qualify\" A..!= def Imports.postQualified\n  where\n    def f = f Imports.defaultOptions\n\n    columns = configColumns config\n\n    aligns =\n        [ (\"global\", Imports.Global)\n        , (\"file\",   Imports.File)\n        , (\"group\",  Imports.Group)\n        , (\"none\",   Imports.None)\n        ]\n\n    listAligns =\n        [ (\"new_line\",          Imports.NewLine)\n        , (\"with_module_name\",  Imports.WithModuleName)\n        , (\"with_alias\",        Imports.WithAlias)\n        , (\"after_alias\",       Imports.AfterAlias)\n        , (\"repeat\",            Imports.Repeat)\n        ]\n\n    longListAligns =\n        [ (\"inline\",             Imports.Inline)\n        , (\"new_line\",           Imports.InlineWithBreak)\n        , (\"new_line_multiline\", Imports.InlineToMultiline)\n        , (\"multiline\",          Imports.Multiline)\n        ]\n\n    emptyListAligns =\n        [ (\"inherit\", Imports.Inherit)\n        , (\"right_after\", Imports.RightAfter)\n        ]\n\n    parseListPadding = \\case\n        A.String \"module_name\" -> pure Imports.LPModuleName\n        A.Number n | n >= 1    -> pure $ Imports.LPConstant (truncate n)\n        v                      -> A.typeMismatch \"'module_name' or >=1 number\" v\n\n--------------------------------------------------------------------------------","function_tokens":["parseImports","config","o","=","fmap","(","Imports","step","columns",")","$","Imports","Options","<$>","(","o","A",".:?","\"align\"",">>=","parseEnum","aligns","(","def","Imports","importAlign",")",")","<*>","(","o","A",".:?","\"list_align\"",">>=","parseEnum","listAligns","(","def","Imports","listAlign",")",")","<*>","(","o","A",".:?","\"pad_module_names\"","A",".!=","def","Imports","padModuleNames",")","<*>","(","o","A",".:?","\"long_list_align\"",">>=","parseEnum","longListAligns","(","def","Imports","longListAlign",")",")","<*>","(","o","A",".:?","\"empty_list_align\"",">>=","parseEnum","emptyListAligns","(","def","Imports","emptyListAlign",")",")","-- Note that padding has to be at least 1. Default is 4.","<*>","(","o","A",".:?","\"list_padding\"",">>=","maybe","(","pure","$","def","Imports","listPadding",")","parseListPadding",")","<*>","o","A",".:?","\"separate_lists\"","A",".!=","def","Imports","separateLists","<*>","o","A",".:?","\"space_surround\"","A",".!=","def","Imports","spaceSurround","<*>","o","A",".:?","\"post_qualify\"","A",".!=","def","Imports","postQualified","where","def","f","=","f","Imports","defaultOptions","columns","=","configColumns","config","aligns","=","[","(","\"global\"",",","Imports","Global",")",",","(","\"file\"",",","Imports","File",")",",","(","\"group\"",",","Imports","Group",")",",","(","\"none\"",",","Imports","None",")","]","listAligns","=","[","(","\"new_line\"",",","Imports","NewLine",")",",","(","\"with_module_name\"",",","Imports","WithModuleName",")",",","(","\"with_alias\"",",","Imports","WithAlias",")",",","(","\"after_alias\"",",","Imports","AfterAlias",")",",","(","\"repeat\"",",","Imports","Repeat",")","]","longListAligns","=","[","(","\"inline\"",",","Imports","Inline",")",",","(","\"new_line\"",",","Imports","InlineWithBreak",")",",","(","\"new_line_multiline\"",",","Imports","InlineToMultiline",")",",","(","\"multiline\"",",","Imports","Multiline",")","]","emptyListAligns","=","[","(","\"inherit\"",",","Imports","Inherit",")",",","(","\"right_after\"",",","Imports","RightAfter",")","]","parseListPadding","=","\\","case","A","String","\"module_name\"","->","pure","Imports","LPModuleName","A","Number","n","|","n",">=","1","->","pure","$","Imports","LPConstant","(","truncate","n",")","v","->","A","typeMismatch","\"'module_name' or >=1 number\"","v","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L279-L328","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"shellSplit","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shellSplit t =\n  let input = Text.strip t\n   in if Text.null input\n        then pure []\n        else case Atto.parseOnly go input of\n          Left e -> do\n            sayLn ((\"invalid input\" & fg red) <> \": \" <> text (toText e))\n            pure []\n          Right ws ->\n            pure ws\n  where\n    go :: Atto.Parser [Text]\n    go = Atto.many1 (bare <|> quoted) <* expectEndOfInput\n\n    expectEndOfInput :: Atto.Parser ()\n    expectEndOfInput = (Atto.endOfInput <|>) $ do\n      leftover <- Atto.many1 Atto.anyChar\n      fail (\"unexpected input: \" <> leftover)\n\n    -- A bare word (not wrapped in quotes).\n    bare :: Atto.Parser Text\n    bare = (Atto.<?> \"unquoted word\") $ do\n      word <- Atto.many1 bareChar\n      void (Atto.many1 Atto.space) <|> Atto.endOfInput\n      pure (toText word)\n\n    -- A run of characters that may have quoted characters.\n    --\n    -- Just like with the POSIX shell, the quotes don't have to be on\n    -- the outsides of the final string.\n    quoted :: Atto.Parser Text\n    quoted = do\n      prefix <- many bareChar\n      quote <- Atto.satisfy (\\c -> c == '\\'' || c == '\"') Atto.<?> \"quote\"\n      (_, ScanState {..}) <-\n        Atto.runScanner (ScanState [] False) (quoteScanner quote)\n      when scanEscape (fail \"expecting a character after a backslash\")\n      _ <- Atto.char quote Atto.<?> \"closing quotation character\"\n      let str = toText prefix <> toText (reverse scanResult)\n      end <-\n        (Atto.many1 Atto.space $> True)\n          <|> (Atto.endOfInput $> True)\n          <|> pure False\n      if end then pure str else (str <>) <$> quoted\n\n    -- Parse a single character that might be escaped.\n    bareChar :: Atto.Parser Char\n    bareChar = do\n      char <-\n        Atto.satisfy\n          ( \\c ->\n              not (isSpace c)\n                && c \/= '\\''\n                && c \/= '\"'\n                && isPrint c\n          )\n      if char == '\\\\'\n        then Atto.anyChar Atto.<?> \"escaped character\"\n        else pure char\n\n-- | State needed to scan input looking for a closing quote.","function_tokens":["shellSplit","t","=","let","input","=","Text","strip","t","in","if","Text","null","input","then","pure","[","]","else","case","Atto","parseOnly","go","input","of","Left","e","->","do","sayLn","(","(","\"invalid input\"","&","fg","red",")","<>","\": \"","<>","text","(","toText","e",")",")","pure","[","]","Right","ws","->","pure","ws","where","go","::","Atto","Parser","[","Text","]","go","=","Atto","many1","(","bare","<|>","quoted",")","<*","expectEndOfInput","expectEndOfInput","::","Atto","Parser","(",")","expectEndOfInput","=","(","Atto","endOfInput","<|>",")","$","do","leftover","<-","Atto","many1","Atto","anyChar","fail","(","\"unexpected input: \"","<>","leftover",")","-- A bare word (not wrapped in quotes).","bare","::","Atto","Parser","Text","bare","=","(","Atto","<?>","\"unquoted word\"",")","$","do","word","<-","Atto","many1","bareChar","void","(","Atto","many1","Atto","space",")","<|>","Atto","endOfInput","pure","(","toText","word",")","-- A run of characters that may have quoted characters.","--","-- Just like with the POSIX shell, the quotes don't have to be on","-- the outsides of the final string.","quoted","::","Atto","Parser","Text","quoted","=","do","prefix","<-","many","bareChar","quote","<-","Atto","satisfy","(","\\","c","->","c","==","'\\''","||","c","==","'\"'",")","Atto","<?>","\"quote\"","(","_",",","ScanState","{","..","}",")","<-","Atto","runScanner","(","ScanState","[","]","False",")","(","quoteScanner","quote",")","when","scanEscape","(","fail","\"expecting a character after a backslash\"",")","_","<-","Atto","char","quote","Atto","<?>","\"closing quotation character\"","let","str","=","toText","prefix","<>","toText","(","reverse","scanResult",")","end","<-","(","Atto","many1","Atto","space","$>","True",")","<|>","(","Atto","endOfInput","$>","True",")","<|>","pure","False","if","end","then","pure","str","else","(","str","<>",")","<$>","quoted","-- Parse a single character that might be escaped.","bareChar","::","Atto","Parser","Char","bareChar","=","do","char","<-","Atto","satisfy","(","\\","c","->","not","(","isSpace","c",")","&&","c","\/=","'\\''","&&","c","\/=","'\"'","&&","isPrint","c",")","if","char","==","'\\\\'","then","Atto","anyChar","Atto","<?>","\"escaped character\"","else","pure","char","-- | State needed to scan input looking for a closing quote."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L141-L202","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"getFullName","parameters":"o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getFullName o =\n        do Object r <- HashMap.lookup \"repository\" o\n           String n <- HashMap.lookup \"full_name\" r\n           pure n\n\n-- |For use with 'github-webhooks' package types.  Routes would look like:\n--\n-- @\n--      api = \"github-webevent\" :>\n--          :> GitHubSignedReqBody '[JSON] (EventWithHookRepo IssuesEvent)\n--          :> Post '[JSON] ()\n-- @\n--\n-- And the handler would unwrap the event:\n--\n-- @\n-- handler :: EventWithHookRepo IssuesEvent -> Handler ()\n-- handler (eventOf -> e) = -- ... expr handling e :: IssuesEvent ...\n-- @","function_tokens":["getFullName","o","=","do","Object","r","<-","HashMap","lookup","\"repository\"","o","String","n","<-","HashMap","lookup","\"full_name\"","r","pure","n","-- |For use with 'github-webhooks' package types.  Routes would look like:","--","-- @","--      api = \"github-webevent\" :>","--          :> GitHubSignedReqBody '[JSON] (EventWithHookRepo IssuesEvent)","--          :> Post '[JSON] ()","-- @","--","-- And the handler would unwrap the event:","--","-- @","-- handler :: EventWithHookRepo IssuesEvent -> Handler ()","-- handler (eventOf -> e) = -- ... expr handling e :: IssuesEvent ...","-- @"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L227-L246","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"pi","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pi = pure pi","function_tokens":["pi","=","pure","pi"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L246-L246","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"buffersQueued","parameters":"","argument_list":"","return_statement":"","docstring":"'buffersQueued' contains the number of buffers in the queue of a given source. This includes those not yet played, the one currently playing, and the ones that have been played already. It will contain 0 if 'buffer' has been set to 'Nothing'.","docstring_summary":"'buffersQueued' contains the number of buffers in the queue of a given source. This includes those not yet played, the one currently playing, and the ones that have been played already. It will contain 0 if 'buffer' has been set to 'Nothing'.","docstring_tokens":["buffersQueued","contains","the","number","of","buffers","in","the","queue","of","a","given","source",".","This","includes","those","not","yet","played","the","one","currently","playing","and","the","ones","that","have","been","played","already",".","It","will","contain","0","if","buffer","has","been","set","to","Nothing","."],"function":"buffersQueued = makeSourceGettableStateVar dictALint GetBuffersQueued","function_tokens":["buffersQueued","=","makeSourceGettableStateVar","dictALint","GetBuffersQueued"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L297-L297","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getShpHeader","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getShpHeader = do\n  fc      <- getIntBE                 -- File code\n  when (fc \/= 9994) (error \"getShpHeader: Input file is not a SHP file\")\n  _       <- replicateM 5 getWord32be -- Unused data\n  shpLen  <- getIntBE                 -- File length\n  shpV    <- getIntLE                 -- Version (little-endian!)\n  shpT    <- getShpType               -- Shape type\n  shpbb   <- getShpBBox shpT          -- Bounding box\n  return ShpHeader { shpFileLength = shpLen,\n                shpVersion    = shpV,\n                shpType       = shpT,\n                shpBB         = shpbb }\n\n-- | Get type of the record(s)","function_tokens":["getShpHeader","=","do","fc","<-","getIntBE","-- File code","when","(","fc","\/=","9994",")","(","error","\"getShpHeader: Input file is not a SHP file\"",")","_","<-","replicateM","5","getWord32be","-- Unused data","shpLen","<-","getIntBE","-- File length","shpV","<-","getIntLE","-- Version (little-endian!)","shpT","<-","getShpType","-- Shape type","shpbb","<-","getShpBBox","shpT","-- Bounding box","return","ShpHeader","{","shpFileLength","=","shpLen",",","shpVersion","=","shpV",",","shpType","=","shpT",",","shpBB","=","shpbb","}","-- | Get type of the record(s)"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L37-L51","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"search","parameters":"verbose (f : fs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"search verbose (f : fs) = do\n    -- TODO Maybe catch an error here, dir might be unreadable\n    exists <- doesFileExist f\n    verbose $ f ++ if exists then \" exists\" else \" does not exist\"\n    if exists then return (Just f) else search verbose fs\n\n--------------------------------------------------------------------------------","function_tokens":["search","verbose","(","f",":","fs",")","=","do","-- TODO Maybe catch an error here, dir might be unreadable","exists","<-","doesFileExist","f","verbose","$","f","++","if","exists","then","\" exists\"","else","\" does not exist\"","if","exists","then","return","(","Just","f",")","else","search","verbose","fs","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L110-L117","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"joinNetwork","parameters":"inst node","argument_list":"","return_statement":"","docstring":"Make a KademliaInstance join the network a supplied Node is in","docstring_summary":"Make a KademliaInstance join the network a supplied Node is in","docstring_tokens":["Make","a","KademliaInstance","join","the","network","a","supplied","Node","is","in"],"function":"joinNetwork inst node = ownId >>= runLookup go inst\n    where go = do\n            -- Poll the supplied node\n            sendS node\n            -- Run a normal lookup from thereon out\n            waitForReply nodeDown checkSignal\n\n          -- No answer to the first signal means, that that Node is down\n          nodeDown = return NodeDown\n\n          -- Retrieve your own id\n          ownId =\n            fmap T.extractId . atomically . readTVar .  sTree . state $ inst\n\n          -- Check wether the own id was encountered. If so, return a IDClash\n          -- error, otherwise, continue the lookup.\n          checkSignal (Signal _ (RETURN_NODES _ nodes)) = do\n                tId <- gets targetId\n                case find (\\node -> nodeId node == tId) nodes of\n                    Just _ -> return IDClash\n                    _ -> continueLookup nodes sendS continue finish\n\n          -- Continuing always means waiting for the next signal\n          continue = waitForReply finish checkSignal\n\n          -- Send a FIND_NODE command, looking up your own id\n          sendS node = liftIO ownId >>= flip sendSignal node . FIND_NODE\n\n          -- Return a success, when the operation finished cleanly\n          finish = return JoinSucces\n\n-- | Lookup the Node corresponding to the supplied ID","function_tokens":["joinNetwork","inst","node","=","ownId",">>=","runLookup","go","inst","where","go","=","do","-- Poll the supplied node","sendS","node","-- Run a normal lookup from thereon out","waitForReply","nodeDown","checkSignal","-- No answer to the first signal means, that that Node is down","nodeDown","=","return","NodeDown","-- Retrieve your own id","ownId","=","fmap","T","extractId",".","atomically",".","readTVar",".","sTree",".","state","$","inst","-- Check wether the own id was encountered. If so, return a IDClash","-- error, otherwise, continue the lookup.","checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","do","tId","<-","gets","targetId","case","find","(","\\","node","->","nodeId","node","==","tId",")","nodes","of","Just","_","->","return","IDClash","_","->","continueLookup","nodes","sendS","continue","finish","-- Continuing always means waiting for the next signal","continue","=","waitForReply","finish","checkSignal","-- Send a FIND_NODE command, looking up your own id","sendS","node","=","liftIO","ownId",">>=","flip","sendSignal","node",".","FIND_NODE","-- Return a success, when the operation finished cleanly","finish","=","return","JoinSucces","-- | Lookup the Node corresponding to the supplied ID"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L128-L160","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Natural","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Natural      = \"=\"","function_tokens":["go","Natural","=","\"=\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L460-L460","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"writeQuads'","parameters":"m CayleyConfig{..} qs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"writeQuads' m CayleyConfig{..} qs =\n      apiRequest\n        m (urlBase serverName apiVersion ++ \"\/write\")\n        serverPort (toRequestBody qs)","function_tokens":["writeQuads'","m","CayleyConfig","{","..","}","qs","=","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/write\"",")","serverPort","(","toRequestBody","qs",")"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L146-L149","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"chunks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"chunks  = makeIbs lbs","function_tokens":["chunks","=","makeIbs","lbs"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L38-L38","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = choice [ false', or' ] <?> \"Disjunction\" where\n        false' = string \"false\" *> pure (toDynamicallySorted false)\n\n        or' = do\n            _  <- char '(' *> string \"or\" *> space\n            os <- r `sepBy1` space\n            _  <- char ')'\n            or'' os\n\n        or'' os = case mapM toStaticallySorted os of\n            Just os' -> return . toDynamicallySorted . or $ os'\n            Nothing  -> fail \"or of non-boolean arguments\"","function_tokens":["parser","_","r","=","choice","[","false'",",","or'","]","<?>","\"Disjunction\"","where","false'","=","string","\"false\"","*>","pure","(","toDynamicallySorted","false",")","or'","=","do","_","<-","char","'('","*>","string","\"or\"","*>","space","os","<-","r","`","sepBy1","`","space","_","<-","char","')'","or''","os","or''","os","=","case","mapM","toStaticallySorted","os","of","Just","os'","->","return",".","toDynamicallySorted",".","or","$","os'","Nothing","->","fail","\"or of non-boolean arguments\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L409-L422","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Utils.hs","language":"haskell","identifier":"flatten","parameters":"((x,y),z)","argument_list":"","return_statement":"","docstring":"Flatten a nested tuple.","docstring_summary":"Flatten a nested tuple.","docstring_tokens":["Flatten","a","nested","tuple","."],"function":"flatten ((x,y),z) = (x,y,z)","function_tokens":["flatten","(","(","x",",","y",")",",","z",")","=","(","x",",","y",",","z",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Utils.hs#L20-L20","hash_key":"vmchale\/hgis:src\/GIS\/Utils.hs","hash_val":20401,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allItemsWithLines :: [(LineBlock, a)]\n    allItemsWithLines = do\n        item <- allItems\n        s <- maybeToList $ getSpan item\n        pure (realSrcSpanToLineBlock s, item)","function_tokens":["allItemsWithLines","::","[","(","LineBlock",",","a",")","]","allItemsWithLines","=","do","item","<-","allItems","s","<-","maybeToList","$","getSpan","item","pure","(","realSrcSpanToLineBlock","s",",","item",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L55-L61","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"forkIOWithUnmask","parameters":"","argument_list":"","return_statement":"","docstring":"Same as @Control.Concurrent.Thread.'Thread.forkIOWithUnmask'@ but additionaly adds the thread to the group.","docstring_summary":"Same as","docstring_tokens":["Same","as"],"function":"forkIOWithUnmask = forkWithUnmask Control.Concurrent.forkIOWithUnmask","function_tokens":["forkIOWithUnmask","=","forkWithUnmask","Control","Concurrent","forkIOWithUnmask"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L162-L162","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"listItem","parameters":"cache (index, item)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"listItem cache (index, item) = do\n      let bullet = _menuItemPrefix m index\n          rendered = renderText Plain bullet\n      sayLn $\n        mconcat\n          [ text \"  \", -- Indent.\n            bullet, -- Unique identifier.\n            _menuItemSuffix m, -- Spacer or marker.\n            toStylizedText item -- The item.\n          ]\n      pure (one (Text.strip rendered, item) <> cache)\n\n-- | Like 'askWithMenu' except that arbitrary input is not allowed.\n-- If the user doesn't correctly select a menu item then the menu will\n-- be repeated and an error message will be displayed.\n--\n-- @since 1.0.0.0","function_tokens":["listItem","cache","(","index",",","item",")","=","do","let","bullet","=","_menuItemPrefix","m","index","rendered","=","renderText","Plain","bullet","sayLn","$","mconcat","[","text","\"  \"",",","-- Indent.","bullet",",","-- Unique identifier.","_menuItemSuffix","m",",","-- Spacer or marker.","toStylizedText","item","-- The item.","]","pure","(","one","(","Text","strip","rendered",",","item",")","<>","cache",")","-- | Like 'askWithMenu' except that arbitrary input is not allowed.","-- If the user doesn't correctly select a menu item then the menu will","-- be repeated and an error message will be displayed.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L231-L248","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"spaces","parameters":"i","argument_list":"","return_statement":"","docstring":"Print a number of spaces","docstring_summary":"Print a number of spaces","docstring_tokens":["Print","a","number","of","spaces"],"function":"spaces i = replicateM_ i space","function_tokens":["spaces","i","=","replicateM_","i","space"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L283-L283","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookPingEvent","function_tokens":["reflect","_","=","WebhookPingEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L454-L454","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"isBrokenLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isBrokenLine = (endsWith '\\\\') . stripTrailingWhitespace\n  where \n    startsWith _ [] = False\n    startsWith x (y:_) = x == y\n    endsWith = \\c -> (startsWith c) . reverse","function_tokens":["isBrokenLine","=","(","endsWith","'\\\\'",")",".","stripTrailingWhitespace","where","startsWith","_","[","]","=","False","startsWith","x","(","y",":","_",")","=","x","==","y","endsWith","=","\\","c","->","(","startsWith","c",")",".","reverse"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L21-L27","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"show","parameters":"Gremlin","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show Gremlin = \"gremlin\"","function_tokens":["show","Gremlin","=","\"gremlin\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L23-L23","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"branchMask","parameters":"p1 p2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"branchMask p1 p2\n  = intFromNat (highestBitMask (natFromInt p1 `xor` natFromInt p2))","function_tokens":["branchMask","p1","p2","=","intFromNat","(","highestBitMask","(","natFromInt","p1","`","xor","`","natFromInt","p2",")",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L934-L935","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"distC","parameters":"(District _ label _ _ compacticity)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"distC (District _ label _ _ compacticity) = (label, compacticity)","function_tokens":["distC","(","District","_","label","_","_","compacticity",")","=","(","label",",","compacticity",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L37-L37","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"makeFormat","parameters":"2  8","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeFormat 2  8 = Stereo8","function_tokens":["makeFormat","2","8","=","Stereo8"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L145-L145","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookInstallationRepositoriesEvent","function_tokens":["reflect","_","=","WebhookInstallationRepositoriesEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L439-L439","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"patterns'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"patterns' = groupAlign (cTopLevelPatterns conf) patterns","function_tokens":["patterns'","=","groupAlign","(","cTopLevelPatterns","conf",")","patterns"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L110-L110","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_DISTANCE_MODEL","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"al_DISTANCE_MODEL                   = 0xD000","function_tokens":["al_DISTANCE_MODEL","=","0xD000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L41-L41","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_REFERENCE_DISTANCE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_REFERENCE_DISTANCE               = 0x1020","function_tokens":["al_REFERENCE_DISTANCE","=","0x1020"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L85-L85","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"traceOutputableM","parameters":"title x","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"traceOutputableM title x = traceOutputable title x $ pure ()","function_tokens":["traceOutputableM","title","x","=","traceOutputable","title","x","$","pure","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L222-L222","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mergeL","parameters":"c d","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeL c d = merge (\\x y -> inject $ x `LessThan` y) c d","function_tokens":["mergeL","c","d","=","merge","(","\\","x","y","->","inject","$","x","`","LessThan","`","y",")","c","d"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L222-L222","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = BylineT . lift","function_tokens":["lift","=","BylineT",".","lift"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L82-L82","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"AndrasKovacs\/singleton-nats","sha":"ec2cd4d2284111047cf1a26ba070f593faf9c96a","path":"Data\/Nat.hs","language":"haskell","identifier":"sLit","parameters":"","argument_list":"","return_statement":"","docstring":"{-| Shorthand for 'SNat' literals using `TypeApplications`.\n\n>>> :set -XTypeApplications\n>>> sLit @5\nSS (SS (SS (SS (SS SZ))))\n\n-}","docstring_summary":"{-| Shorthand for 'SNat' literals using `TypeApplications`.","docstring_tokens":["{","-","|","Shorthand","for","SNat","literals","using","TypeApplications","."],"function":"sLit = sing","function_tokens":["sLit","=","sing"],"url":"https:\/\/github.com\/AndrasKovacs\/singleton-nats\/blob\/ec2cd4d2284111047cf1a26ba070f593faf9c96a\/Data\/Nat.hs#L130-L130","hash_key":"AndrasKovacs\/singleton-nats:Data\/Nat.hs","hash_val":3829,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"modTime","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modTime = toMsDosTime edModTime","function_tokens":["modTime","=","toMsDosTime","edModTime"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L825-L825","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"xStr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"xStr = replicate (round x) ' ' ++ \"x\" ++ replicate (50 - round x) ' '","function_tokens":["xStr","=","replicate","(","round","x",")","' '","++","\"x\"","++","replicate","(","50","-","round","x",")","' '"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L68-L68","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"shellCompletion","parameters":"shell input@(left, _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shellCompletion shell input@(left, _) = do\n  if Text.null left || Text.all (isSpace >>> not) left\n    then completionFromList CompHead (keys commands) input\n    else completionFromList CompTail flags input\n  where\n    -- Get a list of flags for the current subcommand.\n    flags :: [Text]\n    flags = fromMaybe [] $ do\n      cmd <- Text.words left & viaNonEmpty head\n      names <- lookup cmd commands\n      pure $\n        flip map names $ \\case\n          O.OptShort c -> toText ['-', c]\n          O.OptLong s -> \"--\" <> toText s\n\n    -- A map of command names and their flags.\n    commands :: HashMap Text [O.OptName]\n    commands =\n      fromList $\n        concat $\n          O.mapParser\n            (const nameAndFlags)\n            (O.infoParser $ shellInfo shell)\n      where\n        nameAndFlags opt =\n          case O.optMain opt of\n            O.CmdReader _ cmds p -> (`map` cmds) $ \\cmd ->\n              ( toText cmd,\n                maybe\n                  []\n                  ( O.infoParser\n                      >>> O.mapParser (const optnames)\n                      >>> concat\n                  )\n                  (p cmd)\n              )\n            _ -> mempty\n        optnames opt =\n          case O.optMain opt of\n            O.OptReader ns _ _ -> ns\n            O.FlagReader ns _ -> ns\n            _ -> mempty\n\n-- | Internal function to split user input into words similar to what\n-- a POSIX shell does.","function_tokens":["shellCompletion","shell","input","@","(","left",",","_",")","=","do","if","Text","null","left","||","Text","all","(","isSpace",">>>","not",")","left","then","completionFromList","CompHead","(","keys","commands",")","input","else","completionFromList","CompTail","flags","input","where","-- Get a list of flags for the current subcommand.","flags","::","[","Text","]","flags","=","fromMaybe","[","]","$","do","cmd","<-","Text","words","left","&","viaNonEmpty","head","names","<-","lookup","cmd","commands","pure","$","flip","map","names","$","\\","case","O","OptShort","c","->","toText","[","'-'",",","c","]","O","OptLong","s","->","\"--\"","<>","toText","s","-- A map of command names and their flags.","commands","::","HashMap","Text","[","O","OptName","]","commands","=","fromList","$","concat","$","O","mapParser","(","const","nameAndFlags",")","(","O","infoParser","$","shellInfo","shell",")","where","nameAndFlags","opt","=","case","O","optMain","opt","of","O","CmdReader","_","cmds","p","->","(","`","map","`","cmds",")","$","\\","cmd","->","(","toText","cmd",",","maybe","[","]","(","O","infoParser",">>>","O","mapParser","(","const","optnames",")",">>>","concat",")","(","p","cmd",")",")","_","->","mempty","optnames","opt","=","case","O","optMain","opt","of","O","OptReader","ns","_","_","->","ns","O","FlagReader","ns","_","->","ns","_","->","mempty","-- | Internal function to split user input into words similar to what","-- a POSIX shell does."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L95-L140","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"evalAccum","parameters":"w","argument_list":"","return_statement":"","docstring":"Run a 'Accum' effect (typically with a 'Monoid'al log), producing the result value and discarding the final log.  @ 'evalAccum' w = 'fmap' 'snd' . 'runAccum' w @  @since 1.1.2.0","docstring_summary":"Run a 'Accum' effect (typically with a 'Monoid'al log), producing the result value and discarding the final log.","docstring_tokens":["Run","a","Accum","effect","(","typically","with","a","Monoid","al","log",")","producing","the","result","value","and","discarding","the","final","log","."],"function":"evalAccum w = fmap snd . runAccum w","function_tokens":["evalAccum","w","=","fmap","snd",".","runAccum","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L73-L73","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"thaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"thaw = MG.thaw","function_tokens":["thaw","=","MG","thaw"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L372-L372","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"IFix a == IFix b = a `ieq1` b","function_tokens":["IFix","a","==","IFix","b","=","a","`","ieq1","`","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Functor.hs#L38-L38","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","hash_val":19560,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(SetArchiveComment _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (SetArchiveComment _) = Nothing","function_tokens":["targetEntry","(","SetArchiveComment","_",")","=","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1064-L1064","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"step","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"step = ((((makeStep \"LanguagePragmas\" .) .) .) .) . step'","function_tokens":["step","=","(","(","(","(","makeStep","\"LanguagePragmas\"",".",")",".",")",".",")",".",")",".","step'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L117-L117","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Opts.hs","language":"haskell","identifier":"opts","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"opts =\n    O.info (O.helper <*> parser) $\n    O.fullDesc\n    <> O.progDesc\n       \"Resolve any git conflicts that have become trivial by editing operations.\\n\\\n       \\Go to http:\/\/github.com\/Peaker\/git-mediate for example use.\"\n    <> O.header \"git-mediate - Become a conflicts hero\"","function_tokens":["opts","=","O","info","(","O","helper","<*>","parser",")","$","O","fullDesc","<>","O","progDesc","\"Resolve any git conflicts that have become trivial by editing operations.\\n\\\n       \\Go to http:\/\/github.com\/Peaker\/git-mediate for example use.\"","<>","O","header","\"git-mediate - Become a conflicts hero\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Opts.hs#L72-L78","hash_key":"Peaker\/git-mediate:src\/Opts.hs","hash_val":22726,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"cacheSize","parameters":"(Cache t)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cacheSize (Cache t) = foldrM\n   (\\a b -> do\n       v <- readIORef a\n       return $! HashMap.size (content v) + b\n   ) 0 t","function_tokens":["cacheSize","(","Cache","t",")","=","foldrM","(","\\","a","b","->","do","v","<-","readIORef","a","return","$!","HashMap","size","(","content","v",")","+","b",")","0","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L43-L47","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"ageByOneYear","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ageByOneYear = modify age (+1)","function_tokens":["ageByOneYear","=","modify","age","(","+","1",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L36-L36","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"izipWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith = MG.izipWith","function_tokens":["izipWith","=","MG","izipWith"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L283-L283","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty   = RSST $ \\_ _ -> empty","function_tokens":["empty","=","RSST","$","\\","_","_","->","empty"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L151-L151","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) = mappendTList","function_tokens":["(","<>",")","=","mappendTList"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L301-L301","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"char","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"char = lift . lift . A.char","function_tokens":["char","=","lift",".","lift",".","A","char"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L81-L81","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"go","parameters":"(v:vs) (AppT t1 t2)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (v:vs) (AppT t1 t2) = (typeFromBinder v, t2) : go vs t1","function_tokens":["go","(","v",":","vs",")","(","AppT","t1","t2",")","=","(","typeFromBinder","v",",","t2",")",":","go","vs","t1"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L371-L371","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"ifold","parameters":"(IfThenElse _ i t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (IfThenElse _ i t e) = coerce ((coerce i <> coerce t <> coerce e) :: m)","function_tokens":["ifold","(","IfThenElse","_","i","t","e",")","=","coerce","(","(","coerce","i","<>","coerce","t","<>","coerce","e",")","::","m",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L53-L53","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"vals","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vals  = concat (toList <$> fs)","function_tokens":["vals","=","concat","(","toList","<$>","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L316-L316","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"mappend","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappend = (S.<>)","function_tokens":["mappend","=","(","S","<>",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L129-L129","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"revBottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"revBottom = reverse . drop matchTop","function_tokens":["revBottom","=","reverse",".","drop","matchTop"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L46-L46","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"renameKey","parameters":"ok nk m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renameKey ok nk m = case M.lookup ok m of\n  Nothing -> m\n  Just e -> M.insert nk e (M.delete ok m)\n\n-- | Like 'fromIntegral', but with saturation when converting to bounded\n-- types.","function_tokens":["renameKey","ok","nk","m","=","case","M","lookup","ok","m","of","Nothing","->","m","Just","e","->","M","insert","nk","e","(","M","delete","ok","m",")","-- | Like 'fromIntegral', but with saturation when converting to bounded","-- types."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1037-L1043","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"pick","parameters":"(Program (Computation comp Nothing) infile)","argument_list":"","return_statement":"","docstring":"TODO fix this","docstring_summary":"TODO fix this","docstring_tokens":["TODO","fix","this"],"function":"pick (Program (Computation comp Nothing) infile) = --slightly wrong but eh. \n    case comp of\n        \"perimeter\" -> putStrLn =<< districtPerimeter <$> getDistricts infile\n        \"area\" -> putStrLn =<< districtArea <$> getDistricts infile\n        \"compactness\" -> putStrLn =<< districtCompactness <$> getDistricts infile\n        _ -> putStrLn \"computation not recognized\"","function_tokens":["pick","(","Program","(","Computation","comp","Nothing",")","infile",")","=","--slightly wrong but eh. ","case","comp","of","\"perimeter\"","->","putStrLn","=<<","districtPerimeter","<$>","getDistricts","infile","\"area\"","->","putStrLn","=<<","districtArea","<$>","getDistricts","infile","\"compactness\"","->","putStrLn","=<<","districtCompactness","<$>","getDistricts","infile","_","->","putStrLn","\"computation not recognized\""],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L38-L44","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a  = Point (const a) (arr snd)","function_tokens":["pure","a","=","Point","(","const","a",")","(","arr","snd",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L95-L95","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"x","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x = vec `G.unsafeIndex` n","function_tokens":["x","=","vec","`","G","unsafeIndex","`","n"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L113-L113","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"st","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"st =\n        ZipState\n          { zsFilePath = apath,\n            zsEntries = entries,\n            zsArchive = desc,\n            zsActions = S.empty\n          }","function_tokens":["st","=","ZipState","{","zsFilePath","=","apath",",","zsEntries","=","entries",",","zsArchive","=","desc",",","zsActions","=","S","empty","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L289-L295","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,gt) = split' x r","function_tokens":["(","lt",",","gt",")","=","split'","x","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L545-L545","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"settings","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"settings =\n        Haskeline.setComplete\n          (compFunc compRef)\n          Haskeline.defaultSettings","function_tokens":["settings","=","Haskeline","setComplete","(","compFunc","compRef",")","Haskeline","defaultSettings"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L144-L147","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getArray","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getArray = map value <$> getDocument","function_tokens":["getArray","=","map","value","<$>","getDocument"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L178-L178","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"parse","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parse = parseWith empty","function_tokens":["parse","=","parseWith","empty"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L70-L70","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"pos'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pos' = convertPosn file pos","function_tokens":["pos'","=","convertPosn","file","pos"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L51-L51","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/String.hs","language":"haskell","identifier":"withALString","parameters":"str action","argument_list":"","return_statement":"","docstring":"AL uses \"Ptr ALchar\" instead of \"CString\" for strings, so some wrappers are quite handy.","docstring_summary":"AL uses \"Ptr ALchar\" instead of \"CString\" for strings, so some wrappers are quite handy.","docstring_tokens":["AL","uses","Ptr","ALchar","instead","of","CString","for","strings","so","some","wrappers","are","quite","handy","."],"function":"withALString str action = withCString str (action . castPtr)","function_tokens":["withALString","str","action","=","withCString","str","(","action",".","castPtr",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/String.hs#L29-L29","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/String.hs","hash_val":42033,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"describe","parameters":"(UBin p m l r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe (UBin p m l r) = DBin p m (identity l) (identity r)","function_tokens":["describe","(","UBin","p","m","l","r",")","=","DBin","p","m","(","identity","l",")","(","identity","r",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L206-L206","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"inj","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"inj = InR . inj","function_tokens":["inj","=","InR",".","inj"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L51-L51","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vf <*> vx = VarT $ \\a ->\n      g <$> runVarT vf a <*> runVarT vx a\n      where g (f, vf1) (x, vx1) = (f x, vf1 <*> vx1)\n\n-- | Vars are arrows, which means you can use proc notation, among other\n-- meanings.\n--\n-- >>> :set -XArrows\n-- >>> :{\n-- let v = proc t -> do\n--           x <- accumulate (+) 0 -< t\n--           y <- accumulate (+) 1 -< t\n--           returnA -< x + y\n-- in testVarOver v [1,1,1]\n-- >>> :}\n-- 3\n-- 5\n-- 7\n--\n-- which is equivalent to\n--\n-- >>> let v = (+) <$> accumulate (+) 0 <*> accumulate (+) 1\n-- >>> testVarOver v [1,1,1]\n-- 3\n-- 5\n-- 7","function_tokens":["vf","<*>","vx","=","VarT","$","\\","a","->","g","<$>","runVarT","vf","a","<*>","runVarT","vx","a","where","g","(","f",",","vf1",")","(","x",",","vx1",")","=","(","f","x",",","vf1","<*>","vx1",")","-- | Vars are arrows, which means you can use proc notation, among other","-- meanings.","--","-- >>> :set -XArrows","-- >>> :{","-- let v = proc t -> do","--           x <- accumulate (+) 0 -< t","--           y <- accumulate (+) 1 -< t","--           returnA -< x + y","-- in testVarOver v [1,1,1]","-- >>> :}","-- 3","-- 5","-- 7","--","-- which is equivalent to","--","-- >>> let v = (+) <$> accumulate (+) 0 <*> accumulate (+) 1","-- >>> testVarOver v [1,1,1]","-- 3","-- 5","-- 7"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L126-L152","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Simple a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Simple a)       = string $ showRatio a","function_tokens":["go","(","Simple","a",")","=","string","$","showRatio","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L494-L494","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Composer _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Composer _)             = (True, True, False, False)","function_tokens":["go","(","Composer","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L368-L368","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(AbcFile version header elements)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (AbcFile version header elements) = mempty\n        <> \"%abc-\" <> string (fromMaybe \"2.1\" version) <> \"\\n\"\n        <> pretty header <> \"\\n\"\n        <> sepBy \"\\n\" (fmap pretty elements) <> \"\\n\"","function_tokens":["pretty","(","AbcFile","version","header","elements",")","=","mempty","<>","\"%abc-\"","<>","string","(","fromMaybe","\"2.1\"","version",")","<>","\"\\n\"","<>","pretty","header","<>","\"\\n\"","<>","sepBy","\"\\n\"","(","fmap","pretty","elements",")","<>","\"\\n\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L100-L103","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"find","parameters":"(Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"find (Tip _ x)          = x","function_tokens":["find","(","Tip","_","x",")","=","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L655-L655","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"isLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isLen = BS.length is","function_tokens":["isLen","=","BS","length","is"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L101-L101","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_ALL_ATTRIBUTES","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_ALL_ATTRIBUTES                  = 0x1003","function_tokens":["alc_ALL_ATTRIBUTES","=","0x1003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L159-L159","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DLam v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DLam v t e) = s `hashWithSalt` (1 :: Int) `hashWithSalt` v `hashWithSalt` t `hashWithSalt` e","function_tokens":["hashWithSalt","s","(","DLam","v","t","e",")","=","s","`","hashWithSalt","`","(","1","::","Int",")","`","hashWithSalt","`","v","`","hashWithSalt","`","t","`","hashWithSalt","`","e"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L67-L67","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = pickProjection projection","function_tokens":["p","=","pickProjection","projection"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L44-L44","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getZipVersion","parameters":"zip64 m","argument_list":"","return_statement":"","docstring":"Determine \u201cversion needed to extract\u201d that should be written to the headers given the need of the Zip64 feature and the compression method.","docstring_summary":"Determine \u201cversion needed to extract\u201d that should be written to the headers given the need of the Zip64 feature and the compression method.","docstring_tokens":["Determine","\u201cversion","needed","to","extract\u201d","that","should","be","written","to","the","headers","given","the","need","of","the","Zip64","feature","and","the","compression","method","."],"function":"getZipVersion zip64 m = max zip64ver mver\n  where\n    zip64ver = makeVersion (if zip64 then [4, 5] else [2, 0])\n    mver = makeVersion $ case m of\n      Nothing -> [2, 0]\n      Just Store -> [2, 0]\n      Just Deflate -> [2, 0]\n      Just BZip2 -> [4, 6]\n      Just Zstd -> [6, 3]\n\n-- | Return a decompressing 'Conduit' corresponding to the given compression\n-- method.","function_tokens":["getZipVersion","zip64","m","=","max","zip64ver","mver","where","zip64ver","=","makeVersion","(","if","zip64","then","[","4",",","5","]","else","[","2",",","0","]",")","mver","=","makeVersion","$","case","m","of","Nothing","->","[","2",",","0","]","Just","Store","->","[","2",",","0","]","Just","Deflate","->","[","2",",","0","]","Just","BZip2","->","[","4",",","6","]","Just","Zstd","->","[","6",",","3","]","-- | Return a decompressing 'Conduit' corresponding to the given compression","-- method."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1133-L1145","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"top","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"top = true","function_tokens":["top","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L223-L223","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,_,_,_) = fieldAllowed a","function_tokens":["(","r",",","_",",","_",",","_",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L397-L397","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"conIndices","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"conIndices _                  = fclError \"Non-AppT in conIndices. Please report this as a bug for fclabels.\"","function_tokens":["conIndices","_","=","fclError","\"Non-AppT in conIndices. Please report this as a bug for fclabels.\""],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L402-L402","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"acos","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"acos = fmap acos","function_tokens":["acos","=","fmap","acos"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L250-L250","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Reader.hs","language":"haskell","identifier":"locally","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"locally i = replicateM_ i (local @Char succ (ask @Char))","function_tokens":["locally","i","=","replicateM_","i","(","local","@","Char","succ","(","ask","@","Char",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Reader.hs#L44-L44","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Reader.hs","hash_val":22189,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label.hs","language":"haskell","identifier":"set","parameters":"","argument_list":"","return_statement":"","docstring":"Get the setter function from a lens.","docstring_summary":"Get the setter function from a lens.","docstring_tokens":["Get","the","setter","function","from","a","lens","."],"function":"set = curry . Mono.set","function_tokens":["set","=","curry",".","Mono","set"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label.hs#L210-L210","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label.hs","hash_val":23450,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"makeFoldersPng","parameters":"maps","argument_list":"","return_statement":"","docstring":"FIXME make it work with -a (generate-all) and make it not bind things together?? Make maps as png files.","docstring_summary":"FIXME make it work with -a (generate-all) and make it not bind things together?? Make maps as png files.","docstring_tokens":["FIXME","make","it","work","with","-","a","(","generate","-","all",")","and","make","it","not","bind","things","together??","Make","maps","as","png","files","."],"function":"makeFoldersPng maps = do\n    createDirectoryIfMissing False \"maps\"\n    mapM_ (\\m -> mkMapPng (\"maps\/\" <> (view title m) <> \".png\") m) maps","function_tokens":["makeFoldersPng","maps","=","do","createDirectoryIfMissing","False","\"maps\"","mapM_","(","\\","m","->","mkMapPng","(","\"maps\/\"","<>","(","view","title","m",")","<>","\".png\"",")","m",")","maps"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L49-L51","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zip5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip5 = MG.zip5","function_tokens":["zip5","=","MG","zip5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L326-L326","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"compactPragmas","parameters":"lg columns pragmas'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compactPragmas lg columns pragmas' = wrapMaybe columns (\"{-# \" ++ lg) 13 $\n    map (++ \",\") (init pragmas') ++ [last pragmas' ++ \" #-}\"]","function_tokens":["compactPragmas","lg","columns","pragmas'","=","wrapMaybe","columns","(","\"{-# \"","++","lg",")","13","$","map","(","++","\",\"",")","(","init","pragmas'",")","++","[","last","pragmas'","++","\" #-}\"","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L54-L55","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getShpRec","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getShpRec = do\n  recNum      <- getIntBE             -- Record number\n  recLen      <- getIntBE             -- Record length\n  recType     <- getShpType           -- Shape type\n  recContents <- if recType == ShpNull -- Record contents\n                    then return Nothing\n                    else Just <$> getRecContents recType\n  return ShpRec { shpRecNum      = recNum,\n             shpRecLen      = recLen,\n             shpRecContents = recContents,\n             shpRecLabel    = Nothing,\n             shpRecType     = recType }\n\n-- | Get record contents for record of given type","function_tokens":["getShpRec","=","do","recNum","<-","getIntBE","-- Record number","recLen","<-","getIntBE","-- Record length","recType","<-","getShpType","-- Shape type","recContents","<-","if","recType","==","ShpNull","-- Record contents","then","return","Nothing","else","Just","<$>","getRecContents","recType","return","ShpRec","{","shpRecNum","=","recNum",",","shpRecLen","=","recLen",",","shpRecContents","=","recContents",",","shpRecLabel","=","Nothing",",","shpRecType","=","recType","}","-- | Get record contents for record of given type"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L78-L92","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"ltys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ltys = GHC.unLoc lctx :: [GHC.LHsType GHC.GhcPs]","function_tokens":["ltys","=","GHC","unLoc","lctx","::","[","GHC","LHsType","GHC","GhcPs","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L490-L490","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"prompt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prompt = toString (renderText renderMode s)","function_tokens":["prompt","=","toString","(","renderText","renderMode","s",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L212-L212","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pretties","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretties  = mapTyVarBndr pretty <$> dtBinders","function_tokens":["pretties","=","mapTyVarBndr","pretty","<$>","dtBinders"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L569-L569","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"upd","parameters":"(Context a b c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"upd (Context a b c) = Context a b (ForallC x y c)","function_tokens":["upd","(","Context","a","b","c",")","=","Context","a","b","(","ForallC","x","y","c",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L356-L356","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"continue","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"continue = waitForReply finish checkSignal","function_tokens":["continue","=","waitForReply","finish","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L151-L151","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"pick","parameters":"(Program (MapLabel outfile False projection lensName) infile)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pick (Program (MapLabel outfile False projection lensName) infile) = let p = pickProjection projection in\n    mkLensMap \"\" outfile (pickLens lensName) =<< getDistricts infile","function_tokens":["pick","(","Program","(","MapLabel","outfile","False","projection","lensName",")","infile",")","=","let","p","=","pickProjection","projection","in","mkLensMap","\"\"","outfile","(","pickLens","lensName",")","=<<","getDistricts","infile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L44-L45","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"","parameters":"(Lens (Point f _)) (Lens l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(>-) (Lens (Point f _)) (Lens l) = Point (Point.get l) (Point.modify l . first (arr (f .)))","function_tokens":["(",">-",")","(","Lens","(","Point","f","_",")",")","(","Lens","l",")","=","Point","(","Point","get","l",")","(","Point","modify","l",".","first","(","arr","(","f",".",")",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L102-L102","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withLast","parameters":"f (x : xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withLast f (x : xs) = x : withLast f xs","function_tokens":["withLast","f","(","x",":","xs",")","=","x",":","withLast","f","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L183-L183","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Cut","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Cut              = \"C|\"","function_tokens":["go","Cut","=","\"C|\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L493-L493","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Writer.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = 1000000","function_tokens":["n","=","1000000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Writer.hs#L41-L41","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Writer.hs","hash_val":8772,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"prj","parameters":"(InR a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prj (InR a) = prj a","function_tokens":["prj","(","InR","a",")","=","prj","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L53-L53","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"cId","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cId  = commandId command","function_tokens":["cId","=","commandId","command"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L56-L56","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"fromAscAL","parameters":"(r,c) n al","argument_list":"","return_statement":"","docstring":"Construct CSR from ascending association list. Items must be sorted first by row index, and then by column index.","docstring_summary":"Construct CSR from ascending association list. Items must be sorted first by row index, and then by column index.","docstring_tokens":["Construct","CSR","from","ascending","association","list",".","Items","must","be","sorted","first","by","row","index","and","then","by","column","index","."],"function":"fromAscAL (r,c) n al = CSR r c values ci rp\n  where\n    (values, ci, rp) = runST $ do\n        v <- GM.new n\n        col <- GM.new n\n        row <- GM.new (r+1)\n\n        ((i,_),_) <- foldM (f v col row) ((-1,-1),0) al\n\n        let stride = r - i\n        forM_ [0..stride-1] $ \\s -> GM.write row (r-s) n\n        v' <- G.unsafeFreeze v\n        col' <- G.unsafeFreeze col\n        row' <- G.unsafeFreeze row\n        return (v', col', row')\n\n    f v col row ((i',j'), acc) ((i,j),x) =\n        if i > i' || (i == i' && j > j')\n           then do\n               GM.write v acc x\n               GM.write col acc j\n               let stride = i - i'\n               when (stride > 0) $ forM_ [0..stride-1] $ \\s -> GM.write row (i-s) acc\n\n               return ((i,j), acc+1)\n           else error $ printf \"Input must be sorted by row and then by column: (%d,%d) >= (%d,%d)\" i' j' i j","function_tokens":["fromAscAL","(","r",",","c",")","n","al","=","CSR","r","c","values","ci","rp","where","(","values",",","ci",",","rp",")","=","runST","$","do","v","<-","GM","new","n","col","<-","GM","new","n","row","<-","GM","new","(","r","+","1",")","(","(","i",",","_",")",",","_",")","<-","foldM","(","f","v","col","row",")","(","(","-","1",",","-","1",")",",","0",")","al","let","stride","=","r","-","i","forM_","[","0","..","stride","-","1","]","$","\\","s","->","GM","write","row","(","r","-","s",")","n","v'","<-","G","unsafeFreeze","v","col'","<-","G","unsafeFreeze","col","row'","<-","G","unsafeFreeze","row","return","(","v'",",","col'",",","row'",")","f","v","col","row","(","(","i'",",","j'",")",",","acc",")","(","(","i",",","j",")",",","x",")","=","if","i",">","i'","||","(","i","==","i'","&&","j",">","j'",")","then","do","GM","write","v","acc","x","GM","write","col","acc","j","let","stride","=","i","-","i'","when","(","stride",">","0",")","$","forM_","[","0","..","stride","-","1","]","$","\\","s","->","GM","write","row","(","i","-","s",")","acc","return","(","(","i",",","j",")",",","acc","+","1",")","else","error","$","printf","\"Input must be sorted by row and then by column: (%d,%d) >= (%d,%d)\"","i'","j'","i","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L128-L154","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = startLookup sendS end checkSignal","function_tokens":["go","=","startLookup","sendS","end","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L163-L163","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"res","parameters":"(InR a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"res (InR a) = res a","function_tokens":["res","(","InR","a",")","=","res","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L67-L67","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"moduleLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moduleLine = keywordLine GHC.AnnModule","function_tokens":["moduleLine","=","keywordLine","GHC","AnnModule"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L89-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"expirationProcess","parameters":"inst@(KI _ _ valueTs) key","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"expirationProcess inst@(KI _ _ valueTs) key = do\n    -- Map own ThreadId to the key\n    myTId <- myThreadId\n    oldTId <- atomically $ do\n        threadIds <- readTVar valueTs\n        writeTVar valueTs $ M.insert key myTId threadIds\n        return . M.lookup key $ threadIds\n\n    -- Kill the old timeout thread, if it exists\n    when (isJust oldTId) (killThread . fromJust $ oldTId)\n\n    threadDelay hour\n    deleteValue key inst\n\n    where hour = 60 * 60 * 1000000\n\n-- | Handles the differendt Kademlia Commands appropriately","function_tokens":["expirationProcess","inst","@","(","KI","_","_","valueTs",")","key","=","do","-- Map own ThreadId to the key","myTId","<-","myThreadId","oldTId","<-","atomically","$","do","threadIds","<-","readTVar","valueTs","writeTVar","valueTs","$","M","insert","key","myTId","threadIds","return",".","M","lookup","key","$","threadIds","-- Kill the old timeout thread, if it exists","when","(","isJust","oldTId",")","(","killThread",".","fromJust","$","oldTId",")","threadDelay","hour","deleteValue","key","inst","where","hour","=","60","*","60","*","1000000","-- | Handles the differendt Kademlia Commands appropriately"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L246-L263","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for @<@","docstring_summary":"A smart constructor for","docstring_tokens":["A","smart","constructor","for"],"function":"a .<. b = fromJust . getFirst $ First (mergeL a b) <> First (mergeR a b) <> First (Just . inject $ a `LessThan` b) where\n    merge :: (IFix f 'IntegralSort -> IFix f 'IntegralSort -> IFix f 'BooleanSort) -> IFix f 'IntegralSort -> IFix f 'IntegralSort -> Maybe (IFix f 'BooleanSort)\n    merge cmp c d = do\n       (Const v) <- match c\n       (Add as)  <- match d\n       return . (\\(v', r) -> cnst (-v') `cmp` add r) . foldr mergeConstAdd (0, []) $ cnst (-v) : as\n\n    mergeL c d = merge (\\x y -> inject $ x `LessThan` y) c d\n    mergeR d c = merge (\\x y -> inject $ y `LessThan` x) d c\n\n-- | A smart constructor for @>@","function_tokens":["a",".<.","b","=","fromJust",".","getFirst","$","First","(","mergeL","a","b",")","<>","First","(","mergeR","a","b",")","<>","First","(","Just",".","inject","$","a","`","LessThan","`","b",")","where","merge","::","(","IFix","f","'","IntegralSort","->","IFix","f","'","IntegralSort","->","IFix","f","'","BooleanSort",")","->","IFix","f","'","IntegralSort","->","IFix","f","'","IntegralSort","->","Maybe","(","IFix","f","'","BooleanSort",")","merge","cmp","c","d","=","do","(","Const","v",")","<-","match","c","(","Add","as",")","<-","match","d","return",".","(","\\","(","v'",",","r",")","->","cnst","(","-","v'",")","`","cmp","`","add","r",")",".","foldr","mergeConstAdd","(","0",",","[","]",")","$","cnst","(","-","v",")",":","as","mergeL","c","d","=","merge","(","\\","x","y","->","inject","$","x","`","LessThan","`","y",")","c","d","mergeR","d","c","=","merge","(","\\","x","y","->","inject","$","y","`","LessThan","`","x",")","d","c","-- | A smart constructor for @>@"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L215-L226","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"not''","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"not'' n = case toStaticallySorted n of\n            Just n' -> return . toDynamicallySorted . not $ n'\n            Nothing -> fail \"not of non-boolean arguments\"\n\n-- | `literals` decomposes a boolean combination (formed with conjunctions and disjunctions, preferably in negation normal form) into its constituents.","function_tokens":["not''","n","=","case","toStaticallySorted","n","of","Just","n'","->","return",".","toDynamicallySorted",".","not","$","n'","Nothing","->","fail","\"not of non-boolean arguments\"","-- | `literals` decomposes a boolean combination (formed with conjunctions and disjunctions, preferably in negation normal form) into its constituents."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L430-L435","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"deleteValue","parameters":"key (KI _ (KS _ values) _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteValue key (KI _ (KS _ values) _) = atomically $ do\n    vals <- readTVar values\n    writeTVar values $ M.delete key vals\n\n-- | Lookup a value in the store","function_tokens":["deleteValue","key","(","KI","_","(","KS","_","values",")","_",")","=","atomically","$","do","vals","<-","readTVar","values","writeTVar","values","$","M","delete","key","vals","-- | Lookup a value in the store"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L96-L101","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = \n  defaultMain\n    [ bench \"warmup\" $ whnf show \"Hello World\"\n    , bench \"ageByOneYear\" $ whnf ageByOneYear jan\n    , bench \"ageByOneYear'\" $ whnf ageByOneYear' jan\n    , bench \"moveToAmsterdam\" $ whnf moveToAmsterdam jan\n    , bench \"moveToAmsterdam'\" $ whnf moveToAmsterdam' jan\n    , bench \"moveAndAge\" $ whnf moveAndAge jan\n    , bench \"moveAndAge'\" $ whnf moveAndAge' jan\n    ]","function_tokens":["main","=","defaultMain","[","bench","\"warmup\"","$","whnf","show","\"Hello World\"",",","bench","\"ageByOneYear\"","$","whnf","ageByOneYear","jan",",","bench","\"ageByOneYear'\"","$","whnf","ageByOneYear'","jan",",","bench","\"moveToAmsterdam\"","$","whnf","moveToAmsterdam","jan",",","bench","\"moveToAmsterdam'\"","$","whnf","moveToAmsterdam'","jan",",","bench","\"moveAndAge\"","$","whnf","moveAndAge","jan",",","bench","\"moveAndAge'\"","$","whnf","moveAndAge'","jan","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L48-L57","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getNum","parameters":"f n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getNum f n = do\n      result <- runGet f <$> B.hGet h n\n      case result of\n        Left msg -> throwM (ParsingFailed path msg)\n        Right val -> return val\n\n----------------------------------------------------------------------------\n-- Helpers\n\n-- | Rename an entry (key) in a 'Map'.","function_tokens":["getNum","f","n","=","do","result","<-","runGet","f","<$>","B","hGet","h","n","case","result","of","Left","msg","->","throwM","(","ParsingFailed","path","msg",")","Right","val","->","return","val","----------------------------------------------------------------------------","-- Helpers","-- | Rename an entry (key) in a 'Map'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1026-L1036","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"lookup","parameters":"inst id","argument_list":"","return_statement":"","docstring":"Lookup the value corresponding to a key in the DHT and return it, together with the Node that was the first to answer the lookup","docstring_summary":"Lookup the value corresponding to a key in the DHT and return it, together with the Node that was the first to answer the lookup","docstring_tokens":["Lookup","the","value","corresponding","to","a","key","in","the","DHT","and","return","it","together","with","the","Node","that","was","the","first","to","answer","the","lookup"],"function":"lookup inst id = runLookup go inst id\n    where go = startLookup sendS cancel checkSignal\n\n          -- Return Nothing on lookup failure\n          cancel = return Nothing\n\n          -- When receiving a RETURN_VALUE command, finish the lookup, then\n          -- cache the value in the closest peer that didn't return it and\n          -- finally return the value\n          checkSignal (Signal origin (RETURN_VALUE _ value)) = do\n                -- Abuse the known list for saving the peers that are *known* to\n                -- store the value\n                modify $ \\s -> s { known = [origin] }\n\n                -- Finish the lookup, recording which nodes returned the value\n                finish\n\n                -- Store the value in the closest peer that didn't return the\n                -- value\n                known <- gets known\n                polled <- gets polled\n                let rest = polled \\\\ known\n                unless (null rest) $ do\n                    let cachePeer = peer . head . sortByDistanceTo rest $ id\n                    liftIO . send (handle inst) cachePeer . STORE id $ value\n\n                -- Return the value\n                return . Just $ (value, origin)\n\n          -- When receiving a RETURN_NODES command, throw the nodes into the\n          -- lookup loop and continue the lookup\n          checkSignal (Signal _ (RETURN_NODES _ nodes)) =\n                continueLookup nodes sendS continue cancel\n\n          -- Continuing always means waiting for the next signal\n          continue = waitForReply cancel checkSignal\n\n          -- Send a FIND_VALUE command, looking for the supplied id\n          sendS = sendSignal (FIND_VALUE id)\n\n          -- As long as there still are pending requests, wait for the next one\n          finish = do\n                pending <- gets pending\n                unless (null pending) $ waitForReply (return ()) finishCheck\n\n          -- Record the nodes which return the value\n          finishCheck (Signal origin (RETURN_VALUE _ _)) = do\n                known <- gets known\n                modify $ \\s -> s { known = origin:known }\n                finish\n          finishCheck _ = finish\n\n-- | Store assign a value to a key and store it in the DHT","function_tokens":["lookup","inst","id","=","runLookup","go","inst","id","where","go","=","startLookup","sendS","cancel","checkSignal","-- Return Nothing on lookup failure","cancel","=","return","Nothing","-- When receiving a RETURN_VALUE command, finish the lookup, then","-- cache the value in the closest peer that didn't return it and","-- finally return the value","checkSignal","(","Signal","origin","(","RETURN_VALUE","_","value",")",")","=","do","-- Abuse the known list for saving the peers that are *known* to","-- store the value","modify","$","\\","s","->","s","{","known","=","[","origin","]","}","-- Finish the lookup, recording which nodes returned the value","finish","-- Store the value in the closest peer that didn't return the","-- value","known","<-","gets","known","polled","<-","gets","polled","let","rest","=","polled","\\\\","known","unless","(","null","rest",")","$","do","let","cachePeer","=","peer",".","head",".","sortByDistanceTo","rest","$","id","liftIO",".","send","(","handle","inst",")","cachePeer",".","STORE","id","$","value","-- Return the value","return",".","Just","$","(","value",",","origin",")","-- When receiving a RETURN_NODES command, throw the nodes into the","-- lookup loop and continue the lookup","checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","continueLookup","nodes","sendS","continue","cancel","-- Continuing always means waiting for the next signal","continue","=","waitForReply","cancel","checkSignal","-- Send a FIND_VALUE command, looking for the supplied id","sendS","=","sendSignal","(","FIND_VALUE","id",")","-- As long as there still are pending requests, wait for the next one","finish","=","do","pending","<-","gets","pending","unless","(","null","pending",")","$","waitForReply","(","return","(",")",")","finishCheck","-- Record the nodes which return the value","finishCheck","(","Signal","origin","(","RETURN_VALUE","_","_",")",")","=","do","known","<-","gets","known","modify","$","\\","s","->","s","{","known","=","origin",":","known","}","finish","finishCheck","_","=","finish","-- | Store assign a value to a key and store it in the DHT"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L36-L89","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"makeSetter","parameters":"dict name source value","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeSetter dict name source value =\n   with (marshal dict value) $\n      alSetter dict source (marshalGetPName name) . castPtr","function_tokens":["makeSetter","dict","name","source","value","=","with","(","marshal","dict","value",")","$","alSetter","dict","source","(","marshalGetPName","name",")",".","castPtr"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L585-L587","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"rawName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rawName = T.encodeUtf8 entryName","function_tokens":["rawName","=","T","encodeUtf8","entryName"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L820-L820","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"vec","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vec = G.fromList xs","function_tokens":["vec","=","G","fromList","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L137-L137","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"bodyLoc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bodyLoc    = GHC.getLocA $ body","function_tokens":["bodyLoc","=","GHC","getLocA","$","body"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L169-L169","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/Capabilities.hs","language":"haskell","identifier":"runCapabilities","parameters":"_","argument_list":"","return_statement":"","docstring":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_summary":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_tokens":["{","-","HLINT","ignore","Reduce","duplication","-","}","{","-","HLINT","ignore","Redundant","do","-","}"],"function":"runCapabilities _ = do\n  IO.putStrLn \"Capabalities:\"\n  IO.putStrLn $ \"  standard indexing: \" <> show enabledMakeStandardJsonIbBps\n  IO.putStrLn $ \"  simple indexing: \"   <> show enabledMakeSimpleJsonIbBps","function_tokens":["runCapabilities","_","=","do","IO","putStrLn","\"Capabalities:\"","IO","putStrLn","$","\"  standard indexing: \"","<>","show","enabledMakeStandardJsonIbBps","IO","putStrLn","$","\"  simple indexing: \"","<>","show","enabledMakeSimpleJsonIbBps"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/Capabilities.hs#L17-L22","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/Capabilities.hs","hash_val":30166,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"defaultBylineSettings","parameters":"","argument_list":"","return_statement":"","docstring":"The default Byline settings.  @since 1.0.0.0","docstring_summary":"The default Byline settings.","docstring_tokens":["The","default","Byline","settings","."],"function":"defaultBylineSettings = Settings Nothing Nothing Nothing","function_tokens":["defaultBylineSettings","=","Settings","Nothing","Nothing","Nothing"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L131-L131","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"locateECD","parameters":"path h","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"locateECD path h = sizeCheck\n  where\n    sizeCheck = do\n      fsize <- hFileSize h\n      let limit = max 0 (fsize - 0xffff - 22)\n      if fsize < 22\n        then return Nothing\n        else hSeek h SeekFromEnd (-22) >> loop limit\n    loop limit = do\n      sig <- getNum getWord32le 4\n      pos <- subtract 4 <$> hTell h\n      let again = hSeek h AbsoluteSeek (pos - 1) >> loop limit\n          done = pos <= limit\n      if sig == 0x06054b50\n        then do\n          result <-\n            runMaybeT $\n              MaybeT (checkComment pos)\n                >>= MaybeT . checkCDSig\n                >>= MaybeT . checkZip64\n          case result of\n            Nothing -> bool again (return Nothing) done\n            Just ecd -> return (Just ecd)\n        else bool again (return Nothing) done\n    checkComment pos = do\n      size <- hFileSize h\n      hSeek h AbsoluteSeek (pos + 20)\n      l <- fromIntegral <$> getNum getWord16le 2\n      return $\n        if l + 22 == size - pos\n          then Just pos\n          else Nothing\n    checkCDSig pos = do\n      hSeek h AbsoluteSeek (pos + 16)\n      sigPos <- fromIntegral <$> getNum getWord32le 4\n      if sigPos == 0xffffffff -- Zip64 is probably used\n        then return (Just pos)\n        else do\n          hSeek h AbsoluteSeek sigPos\n          cdSig <- getNum getWord32le 4\n          return $\n            if cdSig == 0x02014b50\n              ||\n              -- \u2191 normal case: central directory file header signature\n              cdSig == 0x06064b50\n              ||\n              -- \u2191 happens when zip 64 archive is empty\n              cdSig == 0x06054b50\n              then -- \u2191 happens when vanilla archive is empty\n                Just pos\n              else Nothing\n    checkZip64 pos =\n      if pos < 20\n        then return (Just pos)\n        else do\n          hSeek h AbsoluteSeek (pos - 20)\n          zip64locatorSig <- getNum getWord32le 4\n          if zip64locatorSig == 0x07064b50\n            then do\n              hSeek h AbsoluteSeek (pos - 12)\n              Just . fromIntegral <$> getNum getWord64le 8\n            else return (Just pos)\n    getNum f n = do\n      result <- runGet f <$> B.hGet h n\n      case result of\n        Left msg -> throwM (ParsingFailed path msg)\n        Right val -> return val\n\n----------------------------------------------------------------------------\n-- Helpers\n\n-- | Rename an entry (key) in a 'Map'.","function_tokens":["locateECD","path","h","=","sizeCheck","where","sizeCheck","=","do","fsize","<-","hFileSize","h","let","limit","=","max","0","(","fsize","-","0xffff","-","22",")","if","fsize","<","22","then","return","Nothing","else","hSeek","h","SeekFromEnd","(","-","22",")",">>","loop","limit","loop","limit","=","do","sig","<-","getNum","getWord32le","4","pos","<-","subtract","4","<$>","hTell","h","let","again","=","hSeek","h","AbsoluteSeek","(","pos","-","1",")",">>","loop","limit","done","=","pos","<=","limit","if","sig","==","0x06054b50","then","do","result","<-","runMaybeT","$","MaybeT","(","checkComment","pos",")",">>=","MaybeT",".","checkCDSig",">>=","MaybeT",".","checkZip64","case","result","of","Nothing","->","bool","again","(","return","Nothing",")","done","Just","ecd","->","return","(","Just","ecd",")","else","bool","again","(","return","Nothing",")","done","checkComment","pos","=","do","size","<-","hFileSize","h","hSeek","h","AbsoluteSeek","(","pos","+","20",")","l","<-","fromIntegral","<$>","getNum","getWord16le","2","return","$","if","l","+","22","==","size","-","pos","then","Just","pos","else","Nothing","checkCDSig","pos","=","do","hSeek","h","AbsoluteSeek","(","pos","+","16",")","sigPos","<-","fromIntegral","<$>","getNum","getWord32le","4","if","sigPos","==","0xffffffff","-- Zip64 is probably used","then","return","(","Just","pos",")","else","do","hSeek","h","AbsoluteSeek","sigPos","cdSig","<-","getNum","getWord32le","4","return","$","if","cdSig","==","0x02014b50","||","-- \u2191 normal case: central directory file header signature","cdSig","==","0x06064b50","||","-- \u2191 happens when zip 64 archive is empty","cdSig","==","0x06054b50","then","-- \u2191 happens when vanilla archive is empty","Just","pos","else","Nothing","checkZip64","pos","=","if","pos","<","20","then","return","(","Just","pos",")","else","do","hSeek","h","AbsoluteSeek","(","pos","-","20",")","zip64locatorSig","<-","getNum","getWord32le","4","if","zip64locatorSig","==","0x07064b50","then","do","hSeek","h","AbsoluteSeek","(","pos","-","12",")","Just",".","fromIntegral","<$>","getNum","getWord64le","8","else","return","(","Just","pos",")","getNum","f","n","=","do","result","<-","runGet","f","<$>","B","hGet","h","n","case","result","of","Left","msg","->","throwM","(","ParsingFailed","path","msg",")","Right","val","->","return","val","----------------------------------------------------------------------------","-- Helpers","-- | Rename an entry (key) in a 'Map'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L964-L1036","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"verifySigWithKey","parameters":"(msg, hdr, v) key","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"verifySigWithKey (msg, hdr, v) key = do\n        let sig =\n              B16.encode $ convert $ hmacGetDigest (hmac key msg :: HMAC SHA1)\n\n        case parseHeaderMaybe =<< hdr of\n          Nothing -> delayedFailFatal err401\n          Just h -> do\n            let h' = BS.drop 5 $ E.encodeUtf8 h -- remove \"sha1=\" prefix\n            if constEq h' sig\n            then pure (keyIndex, v)\n            else delayedFailFatal err401","function_tokens":["verifySigWithKey","(","msg",",","hdr",",","v",")","key","=","do","let","sig","=","B16","encode","$","convert","$","hmacGetDigest","(","hmac","key","msg","::","HMAC","SHA1",")","case","parseHeaderMaybe","=<<","hdr","of","Nothing","->","delayedFailFatal","err401","Just","h","->","do","let","h'","=","BS","drop","5","$","E","encodeUtf8","h","-- remove \"sha1=\" prefix","if","constEq","h'","sig","then","pure","(","keyIndex",",","v",")","else","delayedFailFatal","err401"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L320-L332","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"readUTF8File","parameters":"fp","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"readUTF8File fp =\n     IO.withFile fp IO.ReadMode $ \\h -> do\n        IO.hSetEncoding h IO.utf8\n        IO.Strict.hGetContents h","function_tokens":["readUTF8File","fp","=","IO","withFile","fp","IO","ReadMode","$","\\","h","->","do","IO","hSetEncoding","h","IO","utf8","IO","Strict","hGetContents","h"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L176-L179","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Raw.hs","language":"haskell","identifier":"rawForkOn","parameters":"(I# cpu) action","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rawForkOn (I# cpu) action = IO $ \\s ->\n   case (forkOn# cpu action s) of (# s1, tid #) -> (# s1, ThreadId tid #)","function_tokens":["rawForkOn","(","I#","cpu",")","action","=","IO","$","\\","s","->","case","(","forkOn#","cpu","action","s",")","of","(# ","s1",",","tid","->","(# ","s1",",","ThreadId","tid"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Raw.hs#L20-L21","hash_key":"basvandijk\/threads:Control\/Concurrent\/Raw.hs","hash_val":7507,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"serialize","parameters":"id command","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"serialize id command = cId `B.cons` toBS id `B.append` args\n    where cId  = commandId command\n          args = commandArgs command","function_tokens":["serialize","id","command","=","cId","`","B","cons","`","toBS","id","`","B","append","`","args","where","cId","=","commandId","command","args","=","commandArgs","command"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L55-L57","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"modul","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modul = GHC.unLoc lmodul","function_tokens":["modul","=","GHC","unLoc","lmodul"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L70-L70","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"parseLines","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseLines = joinBrokenLines . lines","function_tokens":["parseLines","=","joinBrokenLines",".","lines"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L38-L38","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"toColumns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toColumns = MG.toColumns","function_tokens":["toColumns","=","MG","toColumns"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L174-L174","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"imap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap = MG.imap","function_tokens":["imap","=","MG","imap"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L232-L232","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"closeDevice","parameters":"","argument_list":"","return_statement":"","docstring":"inlined unmarshalALCboolean here to break dependency cycle","docstring_summary":"inlined unmarshalALCboolean here to break dependency cycle","docstring_tokens":["inlined","unmarshalALCboolean","here","to","break","dependency","cycle"],"function":"closeDevice = liftIO . fmap (\/= 0) . alcCloseDevice . marshalDevice","function_tokens":["closeDevice","=","liftIO",".","fmap","(","\/=","0",")",".","alcCloseDevice",".","marshalDevice"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L146-L146","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"bare","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bare = (Atto.<?> \"unquoted word\") $ do\n      word <- Atto.many1 bareChar\n      void (Atto.many1 Atto.space) <|> Atto.endOfInput\n      pure (toText word)\n\n    -- A run of characters that may have quoted characters.\n    --\n    -- Just like with the POSIX shell, the quotes don't have to be on\n    -- the outsides of the final string.","function_tokens":["bare","=","(","Atto","<?>","\"unquoted word\"",")","$","do","word","<-","Atto","many1","bareChar","void","(","Atto","many1","Atto","space",")","<|>","Atto","endOfInput","pure","(","toText","word",")","-- A run of characters that may have quoted characters.","--","-- Just like with the POSIX shell, the quotes don't have to be on","-- the outsides of the final string."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L162-L171","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"source","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"source = CB.sourceIOHandle $ do\n      h <- openFile path ReadMode\n      hSeek h AbsoluteSeek (fromIntegral edOffset)\n      localHeader <- B.hGet h 30\n      case runGet getLocalHeaderGap localHeader of\n        Left msg -> throwM (ParsingFailed path msg)\n        Right gap -> do\n          hSeek h RelativeSeek gap\n          return h","function_tokens":["source","=","CB","sourceIOHandle","$","do","h","<-","openFile","path","ReadMode","hSeek","h","AbsoluteSeek","(","fromIntegral","edOffset",")","localHeader","<-","B","hGet","h","30","case","runGet","getLocalHeaderGap","localHeader","of","Left","msg","->","throwM","(","ParsingFailed","path","msg",")","Right","gap","->","do","hSeek","h","RelativeSeek","gap","return","h"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L245-L254","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"boolToAlign","parameters":"False","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"boolToAlign False = SimpleAlign.Never","function_tokens":["boolToAlign","False","=","SimpleAlign","Never"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L241-L241","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/ALboolean.hs","language":"haskell","identifier":"marshalALboolean","parameters":"False","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"marshalALboolean False = al_FALSE","function_tokens":["marshalALboolean","False","=","al_FALSE"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/ALboolean.hs#L26-L26","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/ALboolean.hs","hash_val":20506,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"select''","parameters":"(DynamicallySorted (SArraySort is1 es) a)\n                 (DynamicallySorted is2                 i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"select'' (DynamicallySorted (SArraySort is1 es) a)\n                 (DynamicallySorted is2                 i) = case is1 %~ is2 of\n            Proved Refl -> return . DynamicallySorted es $ inject (Select is1 es a i)\n            Disproved _ -> fail \"ill-sorted select\"","function_tokens":["select''","(","DynamicallySorted","(","SArraySort","is1","es",")","a",")","(","DynamicallySorted","is2","i",")","=","case","is1","%~","is2","of","Proved","Refl","->","return",".","DynamicallySorted","es","$","inject","(","Select","is1","es","a","i",")","Disproved","_","->","fail","\"ill-sorted select\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L98-L102","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"addLanguagePragma","parameters":"lg prag modu","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"addLanguagePragma lg prag modu\n    | prag `elem` present = mempty\n    | otherwise           = Editor.insertLines line [\"{-# \" ++ lg ++ \" \" ++ prag ++ \" #-}\"]\n  where\n    pragmas'      = moduleLanguagePragmas modu\n    present       = concatMap (toList . snd) pragmas'\n    line          = if null pragmas' then 1 else firstLocation pragmas'\n    firstLocation :: [(GHC.RealSrcSpan, NonEmpty String)] -> Int\n    firstLocation = minimum . fmap (GHC.srcLocLine . GHC.realSrcSpanStart . fst)\n\n\n--------------------------------------------------------------------------------\n-- | Check if a language pragma is redundant. We can't do this for all pragmas,\n-- but we do a best effort.","function_tokens":["addLanguagePragma","lg","prag","modu","|","prag","`","elem","`","present","=","mempty","|","otherwise","=","Editor","insertLines","line","[","\"{-# \"","++","lg","++","\" \"","++","prag","++","\" #-}\"","]","where","pragmas'","=","moduleLanguagePragmas","modu","present","=","concatMap","(","toList",".","snd",")","pragmas'","line","=","if","null","pragmas'","then","1","else","firstLocation","pragmas'","firstLocation","::","[","(","GHC","RealSrcSpan",",","NonEmpty","String",")","]","->","Int","firstLocation","=","minimum",".","fmap","(","GHC","srcLocLine",".","GHC","realSrcSpanStart",".","fst",")","--------------------------------------------------------------------------------","-- | Check if a language pragma is redundant. We can't do this for all pragmas,","-- but we do a best effort."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L156-L170","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"matrix","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix construction","docstring_summary":"O(m*n) Matrix construction","docstring_tokens":["O","(","m","*","n",")","Matrix","construction"],"function":"matrix = MG.matrix","function_tokens":["matrix","=","MG","matrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L145-L145","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseJSON","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseJSON _            = mzero","function_tokens":["parseJSON","_","=","mzero"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L104-L104","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"liftBase","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftBase = liftIO","function_tokens":["liftBase","=","liftIO"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L205-L205","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getString","parameters":"l","argument_list":"","return_statement":"","docstring":"String of length `l`","docstring_summary":"String of length `l`","docstring_tokens":["String","of","length","l"],"function":"getString l = filter (\/= '\\NUL') . C.unpack <$> getByteString l","function_tokens":["getString","l","=","filter","(","\/=","'\\NUL'",")",".","C","unpack","<$>","getByteString","l"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L36-L36","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result,t') = maxViewUnsigned r","function_tokens":["(","result",",","t'",")","=","maxViewUnsigned","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L603-L603","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"isWhitespace","parameters":"' '","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isWhitespace ' ' = True","function_tokens":["isWhitespace","' '","=","True"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L7-L7","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"disjuncts","parameters":"e","argument_list":"","return_statement":"","docstring":"`disjuncts` decomposes a disjunction into disjuncts.","docstring_summary":"`disjuncts` decomposes a disjunction into disjuncts.","docstring_tokens":["disjuncts","decomposes","a","disjunction","into","disjuncts","."],"function":"disjuncts  e = fromMaybe [e] (disjuncts' e)","function_tokens":["disjuncts","e","=","fromMaybe","[","e","]","(","disjuncts'","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L451-L451","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"alignByZero","parameters":"es","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alignByZero es\n    | minT < 0  = alignEvent <$> es\n    | otherwise = es\n    where minT = minimum $ eventStart <$> es\n          alignEvent e = e{ eventStart = eventStart e - minT }\n\n-- | Sorts all events by start time.","function_tokens":["alignByZero","es","|","minT","<","0","=","alignEvent","<$>","es","|","otherwise","=","es","where","minT","=","minimum","$","eventStart","<$>","es","alignEvent","e","=","e","{","eventStart","=","eventStart","e","-","minT","}","-- | Sorts all events by start time."],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L267-L274","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"(InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' (InR gb) = bind' gb","function_tokens":["bind'","(","InR","gb",")","=","bind'","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L820-L820","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"temp","parameters":"","argument_list":"","return_statement":"","docstring":"'temp' constructs just an event. Value of type a lasts for one time unit and starts at zero.","docstring_summary":"'temp' constructs just an event. Value of type a lasts for one time unit and starts at zero.","docstring_tokens":["temp","constructs","just","an","event",".","Value","of","type","a","lasts","for","one","time","unit","and","starts","at","zero","."],"function":"temp = Track 1 . Single","function_tokens":["temp","=","Track","1",".","Single"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L179-L179","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"exceedsColumns","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exceedsColumns i = case maxColumns of\n      Nothing -> False\n      Just c  -> i > c\n\n    -- The longest thing in the left column","function_tokens":["exceedsColumns","i","=","case","maxColumns","of","Nothing","->","False","Just","c","->","i",">","c","-- The longest thing in the left column"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L68-L73","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"moveAndAge","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"moveAndAge = ageByOneYear . moveToAmsterdam . ageByOneYear . ageByOneYear . ageByOneYear","function_tokens":["moveAndAge","=","ageByOneYear",".","moveToAmsterdam",".","ageByOneYear",".","ageByOneYear",".","ageByOneYear"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L42-L42","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"insertR","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"insertR x t\n  = case t of\n      Bin _ _ p m l r\n        | nomatch x p m -> join x (tip x) p t\n        | zero x m      -> bin_ p m (insert x l) r\n        | otherwise     -> bin_ p m l (insert x r)\n      Tip _ y\n        | x==y          -> t\n        | otherwise     -> join x (tip x) y t\n      Nil -> tip x\n\n-- | \/O(min(n,W))\/. Delete a value in the set. Returns the\n-- original set when the value was not present.","function_tokens":["insertR","x","t","=","case","t","of","Bin","_","_","p","m","l","r","|","nomatch","x","p","m","->","join","x","(","tip","x",")","p","t","|","zero","x","m","->","bin_","p","m","(","insert","x","l",")","r","|","otherwise","->","bin_","p","m","l","(","insert","x","r",")","Tip","_","y","|","x","==","y","->","t","|","otherwise","->","join","x","(","tip","x",")","y","t","Nil","->","tip","x","-- | \/O(min(n,W))\/. Delete a value in the set. Returns the","-- original set when the value was not present."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L326-L339","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"fromCompressionMethod","parameters":"BZip2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromCompressionMethod BZip2 = 12","function_tokens":["fromCompressionMethod","BZip2","=","12"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1120-L1120","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"add''","parameters":"as","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"add'' as = case mapM toStaticallySorted as of\n            Just as' -> return . toDynamicallySorted . add $ as'\n            Nothing  -> fail \"add of non-integral arguments\"","function_tokens":["add''","as","=","case","mapM","toStaticallySorted","as","of","Just","as'","->","return",".","toDynamicallySorted",".","add","$","as'","Nothing","->","fail","\"add of non-integral arguments\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L134-L138","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"show","parameters":"(Quad s p o Nothing)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (Quad s p o Nothing)  = T.unpack s\n                               ++ \" -- \"\n                               ++ T.unpack p\n                               ++ \" -> \"\n                               ++ T.unpack o","function_tokens":["show","(","Quad","s","p","o","Nothing",")","=","T","unpack","s","++","\" -- \"","++","T","unpack","p","++","\" -> \"","++","T","unpack","o"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L65-L69","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"toJSON","parameters":"(Quad s p o l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toJSON (Quad s p o l) =\n    A.object [ \"subject\"   A..= s\n             , \"predicate\" A..= p\n             , \"object\"    A..= o\n             , \"label\"     A..= l\n             ]","function_tokens":["toJSON","(","Quad","s","p","o","l",")","=","A","object","[","\"subject\"","A",".=","s",",","\"predicate\"","A",".=","p",",","\"object\"","A",".=","o",",","\"label\"","A",".=","l","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L76-L81","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"change","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"change = end - start","function_tokens":["change","=","end","-","start"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L23-L23","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"store","parameters":"inst key val","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"store inst key val = runLookup go inst key\n    where go = startLookup sendS end checkSignal\n\n          -- Always add the nodes into the loop and continue the lookup\n          checkSignal (Signal _ (RETURN_NODES _ nodes)) =\n                continueLookup nodes sendS continue end\n\n          -- Continuing always means waiting for the next signal\n          continue = waitForReply end checkSignal\n\n          -- Send a FIND_NODE command, looking for the node corresponding to the\n          -- key\n          sendS = sendSignal (FIND_NODE key)\n\n          -- Run the lookup as long as possible, to make sure the nodes closest\n          -- to the key were polled.\n          end = do\n            polled <- gets polled\n\n            unless (null polled) $ do\n                let h = handle inst\n                    -- Don't select more than 7 peers\n                    peerNum = if length polled > 7 then 7 else length polled\n                    -- Select the peers closest to the key\n                    storePeers =\n                        map peer . take peerNum . sortByDistanceTo polled $ key\n\n                -- Send them a STORE command\n                forM_ storePeers $\n                    \\storePeer -> liftIO . send h storePeer . STORE key $ val\n\n-- | The different possibel results of joinNetwork","function_tokens":["store","inst","key","val","=","runLookup","go","inst","key","where","go","=","startLookup","sendS","end","checkSignal","-- Always add the nodes into the loop and continue the lookup","checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","continueLookup","nodes","sendS","continue","end","-- Continuing always means waiting for the next signal","continue","=","waitForReply","end","checkSignal","-- Send a FIND_NODE command, looking for the node corresponding to the","-- key","sendS","=","sendSignal","(","FIND_NODE","key",")","-- Run the lookup as long as possible, to make sure the nodes closest","-- to the key were polled.","end","=","do","polled","<-","gets","polled","unless","(","null","polled",")","$","do","let","h","=","handle","inst","-- Don't select more than 7 peers","peerNum","=","if","length","polled",">","7","then","7","else","length","polled","-- Select the peers closest to the key","storePeers","=","map","peer",".","take","peerNum",".","sortByDistanceTo","polled","$","key","-- Send them a STORE command","forM_","storePeers","$","\\","storePeer","->","liftIO",".","send","h","storePeer",".","STORE","key","$","val","-- | The different possibel results of joinNetwork"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L91-L123","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"tmapRel","parameters":"f x","argument_list":"","return_statement":"","docstring":"Relative tmap. Time values are normalized by argument's duration.","docstring_summary":"Relative tmap. Time values are normalized by argument's duration.","docstring_tokens":["Relative","tmap",".","Time","values","are","normalized","by","argument","s","duration","."],"function":"tmapRel f x = tmap (f . stretchEvent (1 \/ dur x)) x","function_tokens":["tmapRel","f","x","=","tmap","(","f",".","stretchEvent","(","1","\/","dur","x",")",")","x"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L244-L244","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"fmap","parameters":"f ma","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f ma = AccumC $ \\k w -> runAccumC ma (\\w a -> k w $ f a) w","function_tokens":["fmap","f","ma","=","AccumC","$","\\","k","w","->","runAccumC","ma","(","\\","w","a","->","k","w","$","f","a",")","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L86-L86","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"delete","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delete x t\n  = case t of\n      Bin _ _ p m l r\n        | nomatch x p m -> t\n        | zero x m      -> bin p m (delete x l) r\n        | otherwise     -> bin p m l (delete x r)\n      Tip _ y\n        | x==y          -> Nil\n        | otherwise     -> t\n      Nil -> Nil\n\n\n{--------------------------------------------------------------------\n  Union\n--------------------------------------------------------------------}\n-- | The union of a list of sets.","function_tokens":["delete","x","t","=","case","t","of","Bin","_","_","p","m","l","r","|","nomatch","x","p","m","->","t","|","zero","x","m","->","bin","p","m","(","delete","x","l",")","r","|","otherwise","->","bin","p","m","l","(","delete","x","r",")","Tip","_","y","|","x","==","y","->","Nil","|","otherwise","->","t","Nil","->","Nil","{--------------------------------------------------------------------\n  Union\n--------------------------------------------------------------------}","-- | The union of a list of sets."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L340-L356","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"findFilesRecursive","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findFilesRecursive = listDirectoryFiles findFilesRecursive","function_tokens":["findFilesRecursive","=","listDirectoryFiles","findFilesRecursive"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L139-L139","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"continue","parameters":"","argument_list":"","return_statement":"","docstring":"Continuing always means waiting for the next signal","docstring_summary":"Continuing always means waiting for the next signal","docstring_tokens":["Continuing","always","means","waiting","for","the","next","signal"],"function":"continue = waitForReply end checkSignal","function_tokens":["continue","=","waitForReply","end","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L99-L99","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/SideDiff.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Sides bodyA _ bodyB = cBodies","function_tokens":["Sides","bodyA","_","bodyB","=","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/SideDiff.hs#L33-L33","hash_key":"Peaker\/git-mediate:src\/SideDiff.hs","hash_val":4146,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Trace.hs","language":"haskell","identifier":"trace","parameters":"message","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"trace message = send (Trace message)","function_tokens":["trace","message","=","send","(","Trace","message",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Trace.hs#L35-L35","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Trace.hs","hash_val":42580,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookForkEvent","function_tokens":["reflect","_","=","WebhookForkEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L427-L427","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"resIbPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resIbPtr  = F.castPtr (F.unsafeForeignPtrToPtr resIbFptr)","function_tokens":["resIbPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resIbFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L54-L54","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"execState","parameters":"s","argument_list":"","return_statement":"","docstring":"Run a 'State' effect, yielding the final state and discarding the return value.  @ 'execState' s m = 'fmap' 'fst' ('runState' s m) @  @since 1.0.0.0","docstring_summary":"Run a 'State' effect, yielding the final state and discarding the return value.","docstring_tokens":["Run","a","State","effect","yielding","the","final","state","and","discarding","the","return","value","."],"function":"execState s = fmap fst . runState s","function_tokens":["execState","s","=","fmap","fst",".","runState","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L70-L70","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Utils.hs","language":"haskell","identifier":"radians","parameters":"","argument_list":"","return_statement":"","docstring":"Convert a `Double` from degrees to radians.","docstring_summary":"Convert a `Double` from degrees to radians.","docstring_tokens":["Convert","a","Double","from","degrees","to","radians","."],"function":"radians = (*(pi\/180))","function_tokens":["radians","=","(","*","(","pi","\/","180",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Utils.hs#L11-L11","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Utils.hs","hash_val":44272,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mul'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mul' = do\n            _  <- char '(' *> char '*' *> space\n            ms <- r `sepBy1` space\n            _  <- char ')'\n            mul'' ms","function_tokens":["mul'","=","do","_","<-","char","'('","*>","char","'*'","*>","space","ms","<-","r","`","sepBy1","`","space","_","<-","char","')'","mul''","ms"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L112-L118","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"expectEndOfInput","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"expectEndOfInput = (Atto.endOfInput <|>) $ do\n      leftover <- Atto.many1 Atto.anyChar\n      fail (\"unexpected input: \" <> leftover)\n\n    -- A bare word (not wrapped in quotes).","function_tokens":["expectEndOfInput","=","(","Atto","endOfInput","<|>",")","$","do","leftover","<-","Atto","many1","Atto","anyChar","fail","(","\"unexpected input: \"","<>","leftover",")","-- A bare word (not wrapped in quotes)."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L156-L161","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"find","parameters":"(Bin _ _ _ _ l' _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"find (Bin _ _ _ _ l' _) = find l'","function_tokens":["find","(","Bin","_","_","_","_","l'","_",")","=","find","l'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L645-L645","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"printerConfig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printerConfig = PrinterConfig\n        { columns = case cMaxColumns of\n            NoMaxColumns -> Nothing\n            MaxColumns n -> Just n\n        }","function_tokens":["printerConfig","=","PrinterConfig","{","columns","=","case","cMaxColumns","of","NoMaxColumns","->","Nothing","MaxColumns","n","->","Just","n","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L129-L133","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a ==> b = nnf (not a \\\/ b)","function_tokens":["a","==>","b","=","nnf","(","not","a","\\\/","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L227-L227","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printModuleHeader","parameters":"maxCols conf ls lmodul","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printModuleHeader maxCols conf ls lmodul =\n    let modul = GHC.unLoc lmodul\n        name = GHC.unLoc <$> GHC.hsmodName modul\n        haddocks = GHC.hsmodHaddockModHeader modul\n\n        startLine = fromMaybe 1 $ moduleLine <|>\n            (fmap GHC.srcSpanStartLine . GHC.srcSpanToRealSrcSpan $\n                GHC.getLoc lmodul)\n\n        endLine = fromMaybe 1 $ whereLine <|>\n            (do\n                loc <- GHC.getLocA <$> GHC.hsmodExports modul\n                GHC.srcSpanEndLine <$> GHC.srcSpanToRealSrcSpan loc)\n\n        keywordLine kw = listToMaybe $ do\n            GHC.EpAnn {..} <- pure $ GHC.hsmodAnn modul\n            GHC.AddEpAnn kw' (GHC.EpaSpan s) <- GHC.am_main anns\n            guard $ kw == kw'\n            pure $ GHC.srcSpanEndLine s\n\n        moduleLine = keywordLine GHC.AnnModule\n        whereLine = keywordLine GHC.AnnWhere\n\n        commentOnLine l = listToMaybe $ do\n            comment <- epAnnComments $ GHC.hsmodAnn modul\n            guard $ GHC.srcSpanStartLine (GHC.anchor $ GHC.getLoc comment) == l\n            pure comment\n\n        moduleComment = moduleLine >>= commentOnLine\n        whereComment =\n            guard (whereLine \/= moduleLine) >> whereLine >>= commentOnLine\n\n        exportGroups = case GHC.hsmodExports modul of\n            Nothing -> Nothing\n            Just lexports -> Just $ doSort $ commentGroups\n                (GHC.srcSpanToRealSrcSpan . GHC.getLocA)\n                (GHC.unLoc lexports)\n                (epAnnComments . GHC.ann $ GHC.getLoc lexports)\n\n        printedModuleHeader = runPrinter_\n            (PrinterConfig maxCols)\n            (printHeader\n                conf name exportGroups haddocks moduleComment whereComment)\n\n        changes = Editor.changeLines\n            (Editor.Block startLine endLine)\n            (const printedModuleHeader) in\n\n    Editor.apply changes ls\n  where\n    doSort = if sort conf then fmap (commentGroupSort compareLIE) else id","function_tokens":["printModuleHeader","maxCols","conf","ls","lmodul","=","let","modul","=","GHC","unLoc","lmodul","name","=","GHC","unLoc","<$>","GHC","hsmodName","modul","haddocks","=","GHC","hsmodHaddockModHeader","modul","startLine","=","fromMaybe","1","$","moduleLine","<|>","(","fmap","GHC","srcSpanStartLine",".","GHC","srcSpanToRealSrcSpan","$","GHC","getLoc","lmodul",")","endLine","=","fromMaybe","1","$","whereLine","<|>","(","do","loc","<-","GHC","getLocA","<$>","GHC","hsmodExports","modul","GHC","srcSpanEndLine","<$>","GHC","srcSpanToRealSrcSpan","loc",")","keywordLine","kw","=","listToMaybe","$","do","GHC","EpAnn","{","..","}","<-","pure","$","GHC","hsmodAnn","modul","GHC","AddEpAnn","kw'","(","GHC","EpaSpan","s",")","<-","GHC","am_main","anns","guard","$","kw","==","kw'","pure","$","GHC","srcSpanEndLine","s","moduleLine","=","keywordLine","GHC","AnnModule","whereLine","=","keywordLine","GHC","AnnWhere","commentOnLine","l","=","listToMaybe","$","do","comment","<-","epAnnComments","$","GHC","hsmodAnn","modul","guard","$","GHC","srcSpanStartLine","(","GHC","anchor","$","GHC","getLoc","comment",")","==","l","pure","comment","moduleComment","=","moduleLine",">>=","commentOnLine","whereComment","=","guard","(","whereLine","\/=","moduleLine",")",">>","whereLine",">>=","commentOnLine","exportGroups","=","case","GHC","hsmodExports","modul","of","Nothing","->","Nothing","Just","lexports","->","Just","$","doSort","$","commentGroups","(","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")","(","GHC","unLoc","lexports",")","(","epAnnComments",".","GHC","ann","$","GHC","getLoc","lexports",")","printedModuleHeader","=","runPrinter_","(","PrinterConfig","maxCols",")","(","printHeader","conf","name","exportGroups","haddocks","moduleComment","whereComment",")","changes","=","Editor","changeLines","(","Editor","Block","startLine","endLine",")","(","const","printedModuleHeader",")","in","Editor","apply","changes","ls","where","doSort","=","if","sort","conf","then","fmap","(","commentGroupSort","compareLIE",")","else","id"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L69-L121","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"languagePragmas","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"languagePragmas = moduleLanguagePragmas m","function_tokens":["languagePragmas","=","moduleLanguagePragmas","m"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L130-L130","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getInt64","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getInt64 = fromIntegral <$> getWord64le","function_tokens":["getInt64","=","fromIntegral","<$>","getWord64le"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L134-L134","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"maskW","parameters":"i m","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nBig endian operations\n------------------------------------------------------------------}","docstring_summary":"{--------------------------------------------------------------------\nBig endian operations\n------------------------------------------------------------------}","docstring_tokens":["{","--------------------------------------------------------------------","Big","endian","operations","------------------------------------------------------------------","}"],"function":"maskW i m\n  = intFromNat (i .&. (complement (m-1) `xor` m))","function_tokens":["maskW","i","m","=","intFromNat","(","i",".&.","(","complement","(","m","-","1",")","`","xor","`","m",")",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L926-L927","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withInit","parameters":"_ []","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"withInit _ []       = []","function_tokens":["withInit","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L188-L188","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"canMergeImport","parameters":"i0 i1","argument_list":"","return_statement":"","docstring":"Returns true if the two import declarations can be merged","docstring_summary":"Returns true if the two import declarations can be merged","docstring_tokens":["Returns","true","if","the","two","import","declarations","can","be","merged"],"function":"canMergeImport i0 i1 = and $ fmap (\\f -> f i0 i1)\n  [ (==) `on` unLoc . ideclName\n  , (==) `on` ideclPkgQual\n  , (==) `on` ideclSource\n  , hasMergableQualified `on` ideclQualified\n  , (==) `on` ideclImplicit\n  , (==) `on` fmap unLoc . ideclAs\n  , (==) `on` fmap fst . ideclHiding -- same 'hiding' flags\n  ]\n  where\n    hasMergableQualified QualifiedPre QualifiedPost = True\n    hasMergableQualified QualifiedPost QualifiedPre = True\n    hasMergableQualified q0 q1                      = q0 == q1\n\n-- | Comments associated with module","function_tokens":["canMergeImport","i0","i1","=","and","$","fmap","(","\\","f","->","f","i0","i1",")","[","(","==",")","`","on","`","unLoc",".","ideclName",",","(","==",")","`","on","`","ideclPkgQual",",","(","==",")","`","on","`","ideclSource",",","hasMergableQualified","`","on","`","ideclQualified",",","(","==",")","`","on","`","ideclImplicit",",","(","==",")","`","on","`","fmap","unLoc",".","ideclAs",",","(","==",")","`","on","`","fmap","fst",".","ideclHiding","-- same 'hiding' flags","]","where","hasMergableQualified","QualifiedPre","QualifiedPost","=","True","hasMergableQualified","QualifiedPost","QualifiedPre","=","True","hasMergableQualified","q0","q1","=","q0","==","q1","-- | Comments associated with module"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L63-L78","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"ifold","parameters":"(InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (InR gb) = ifold gb","function_tokens":["ifold","(","InR","gb",")","=","ifold","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L92-L92","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"jan","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"jan = Person \"Jan\" 71 (Place \"Utrecht\" \"The Netherlands\" \"Europe\") Nothing","function_tokens":["jan","=","Person","\"Jan\"","71","(","Place","\"Utrecht\"","\"The Netherlands\"","\"Europe\"",")","Nothing"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L24-L24","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_SYNC","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_SYNC                            = 0x1009","function_tokens":["alc_SYNC","=","0x1009"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L134-L134","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"unguardedRhsBody","parameters":"(Hs.GRHSs _ [grhs] _)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Utility: grab the body out of guarded RHSs if it's a single unguarded one.","docstring_summary":"------------------------------------------------------------------------------ Utility: grab the body out of guarded RHSs if it's a single unguarded one.","docstring_tokens":["------------------------------------------------------------------------------","Utility",":","grab","the","body","out","of","guarded","RHSs","if","it","s","a","single","unguarded","one","."],"function":"unguardedRhsBody (Hs.GRHSs _ [grhs] _)\n    | Hs.GRHS _ [] body <- GHC.unLoc grhs = Just body","function_tokens":["unguardedRhsBody","(","Hs","GRHSs","_","[","grhs","]","_",")","|","Hs","GRHS","_","[","]","body","<-","GHC","unLoc","grhs","=","Just","body"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L228-L229","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getLocalHeaderGap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getLocalHeaderGap = do\n  getSignature 0x04034b50\n  skip 2 -- version needed to extract\n  skip 2 -- general purpose bit flag\n  skip 2 -- compression method\n  skip 2 -- last mod file time\n  skip 2 -- last mod file date\n  skip 4 -- crc-32 check sum\n  skip 4 -- compressed size\n  skip 4 -- uncompressed size\n  fileNameSize <- fromIntegral <$> getWord16le -- file name length\n  extraFieldSize <- fromIntegral <$> getWord16le -- extra field length\n  return (fileNameSize + extraFieldSize)\n\n-- | Parse central directory file headers and put them into a 'Map'.","function_tokens":["getLocalHeaderGap","=","do","getSignature","0x04034b50","skip","2","-- version needed to extract","skip","2","-- general purpose bit flag","skip","2","-- compression method","skip","2","-- last mod file time","skip","2","-- last mod file date","skip","4","-- crc-32 check sum","skip","4","-- compressed size","skip","4","-- uncompressed size","fileNameSize","<-","fromIntegral","<$>","getWord16le","-- file name length","extraFieldSize","<-","fromIntegral","<$>","getWord16le","-- extra field length","return","(","fileNameSize","+","extraFieldSize",")","-- | Parse central directory file headers and put them into a 'Map'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L653-L668","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m >>= k = StateC $ \\ s -> do\n    ~(s', a) <- runState s m\n    runState s' (k a)","function_tokens":["m",">>=","k","=","StateC","$","\\","s","->","do","~","(","s'",",","a",")","<-","runState","s","m","runState","s'","(","k","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L94-L97","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"getPolygon","parameters":"(RecPolygon { recPolPoints = pt })","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getPolygon (RecPolygon { recPolPoints = pt }) = pt","function_tokens":["getPolygon","(","RecPolygon","{","recPolPoints","=","pt","}",")","=","pt"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L78-L78","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","language":"haskell","identifier":"replicate","parameters":"(r,c) x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"replicate (r,c) x\n        | r \/= c = error \"colmumns \/= rows\"\n        | otherwise = SymMMatrix r `liftM` GM.replicate ((r*(r+1)) `shiftR` 1) x","function_tokens":["replicate","(","r",",","c",")","x","|","r","\/=","c","=","error","\"colmumns \/= rows\"","|","otherwise","=","SymMMatrix","r","`","liftM","`","GM","replicate","(","(","r","*","(","r","+","1",")",")","`","shiftR","`","1",")","x"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs#L38-L40","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","hash_val":33107,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"isWhitespace","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isWhitespace _ = False","function_tokens":["isWhitespace","_","=","False"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L9-L9","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"mask","parameters":"i m","argument_list":"","return_statement":"","docstring":"Suppose a is largest such that 2^a divides 2*m. Then mask i m is i with the low a bits zeroed out.","docstring_summary":"Suppose a is largest such that 2^a divides 2*m. Then mask i m is i with the low a bits zeroed out.","docstring_tokens":["Suppose","a","is","largest","such","that","2^a","divides","2","*","m",".","Then","mask","i","m","is","i","with","the","low","a","bits","zeroed","out","."],"function":"mask i m\n  = maskW (natFromInt i) (natFromInt m)","function_tokens":["mask","i","m","=","maskW","(","natFromInt","i",")","(","natFromInt","m",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L916-L917","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"ownId","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ownId = T.extractId tree","function_tokens":["ownId","=","T","extractId","tree"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L152-L152","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Voice a)","argument_list":"","return_statement":"","docstring":"TODO","docstring_summary":"TODO","docstring_tokens":["TODO"],"function":"go (Voice a)                = show $ pretty a","function_tokens":["go","(","Voice","a",")","=","show","$","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L427-L427","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"handleCommand","parameters":"(FIND_VALUE key) peer inst","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"handleCommand (FIND_VALUE key) peer inst = do\n    result <- lookupValue key inst\n    case result of\n        Just value -> liftIO $ send (handle inst) peer $ RETURN_VALUE key value\n        Nothing    -> returnNodes peer key inst","function_tokens":["handleCommand","(","FIND_VALUE","key",")","peer","inst","=","do","result","<-","lookupValue","key","inst","case","result","of","Just","value","->","liftIO","$","send","(","handle","inst",")","peer","$","RETURN_VALUE","key","value","Nothing","->","returnNodes","peer","key","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L274-L279","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mapEvents","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapEvents = onEvents . fmap","function_tokens":["mapEvents","=","onEvents",".","fmap"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L225-L225","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookReleaseEvent","function_tokens":["reflect","_","=","WebhookReleaseEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L469-L469","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseRecords","parameters":"c o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseRecords c o = Data.step\n    <$> (Data.Config\n        <$> (o A..: \"equals\" >>= parseIndent)\n        <*> (o A..: \"first_field\" >>= parseIndent)\n        <*> (o A..: \"field_comment\")\n        <*> (o A..: \"deriving\")\n        <*> (o A..:? \"break_enums\" A..!= False)\n        <*> (o A..:? \"break_single_constructors\" A..!= True)\n        <*> (o A..: \"via\" >>= parseIndent)\n        <*> (o A..:? \"curried_context\" A..!= False)\n        <*> (o A..:? \"sort_deriving\" A..!= True)\n        <*> pure configMaxColumns)\n  where\n    configMaxColumns =\n      maybe Data.NoMaxColumns Data.MaxColumns (configColumns c)","function_tokens":["parseRecords","c","o","=","Data","step","<$>","(","Data","Config","<$>","(","o","A",".:","\"equals\"",">>=","parseIndent",")","<*>","(","o","A",".:","\"first_field\"",">>=","parseIndent",")","<*>","(","o","A",".:","\"field_comment\"",")","<*>","(","o","A",".:","\"deriving\"",")","<*>","(","o","A",".:?","\"break_enums\"","A",".!=","False",")","<*>","(","o","A",".:?","\"break_single_constructors\"","A",".!=","True",")","<*>","(","o","A",".:","\"via\"",">>=","parseIndent",")","<*>","(","o","A",".:?","\"curried_context\"","A",".!=","False",")","<*>","(","o","A",".:?","\"sort_deriving\"","A",".!=","True",")","<*>","pure","configMaxColumns",")","where","configMaxColumns","=","maybe","Data","NoMaxColumns","Data","MaxColumns","(","configColumns","c",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L246-L262","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"doQuery","parameters":"m CayleyConfig{..} q","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doQuery m CayleyConfig{..} q = do\n      r <- apiRequest\n             m (urlBase serverName apiVersion\n               ++ \"\/query\/\" ++ show queryLang)\n             serverPort (RequestBodyBS $ encodeUtf8 q)\n      return $\n        case r of\n          Just a  ->\n            case a ^? L.key \"result\" of\n              Just v  -> Right v\n              Nothing ->\n                case a ^? L.key \"error\" . L._String of\n                  Just e  -> Left (show e)\n                  Nothing -> Left \"No JSON response from Cayley server\"\n          Nothing -> Left \"Can't get any response from Cayley server\"\n\n-- | Return the description of the given executed query.","function_tokens":["doQuery","m","CayleyConfig","{","..","}","q","=","do","r","<-","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/query\/\"","++","show","queryLang",")","serverPort","(","RequestBodyBS","$","encodeUtf8","q",")","return","$","case","r","of","Just","a","->","case","a","^?","L","key","\"result\"","of","Just","v","->","Right","v","Nothing","->","case","a","^?","L","key","\"error\"",".","L","_String","of","Just","e","->","Left","(","show","e",")","Nothing","->","Left","\"No JSON response from Cayley server\"","Nothing","->","Left","\"Can't get any response from Cayley server\"","-- | Return the description of the given executed query."],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L67-L84","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"runState","parameters":"s (StateC runStateC)","argument_list":"","return_statement":"","docstring":"Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.  @ 'runState' s ('pure' a) = 'pure' (s, a) @ @ 'runState' s 'get' = 'pure' (s, s) @ @ 'runState' s ('put' t) = 'pure' (t, ()) @  @since 1.0.0.0","docstring_summary":"Run a lazy 'State' effect, yielding the result value and the final state. More programs terminate with lazy state than strict state, but injudicious use of lazy state may lead to thunk buildup.","docstring_tokens":["Run","a","lazy","State","effect","yielding","the","result","value","and","the","final","state",".","More","programs","terminate","with","lazy","state","than","strict","state","but","injudicious","use","of","lazy","state","may","lead","to","thunk","buildup","."],"function":"runState s (StateC runStateC) = runStateC s","function_tokens":["runState","s","(","StateC","runStateC",")","=","runStateC","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L48-L48","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bottom = false","function_tokens":["bottom","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L216-L216","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Ask              -> RWS.CPS.asks (<$ ctx)\n    L (Local f m)      -> RWS.CPS.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.CPS.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.CPS.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.CPS.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.CPS.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.CPS.put s\n    R (R (R other))    -> RWS.CPS.rwsT $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.CPS.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Ask","->","RWS","CPS","asks","(","<$","ctx",")","L","(","Local","f","m",")","->","RWS","CPS","local","f","(","hdl","(","m","<$","ctx",")",")","R","(","L","(","Tell","w",")",")","->","ctx","<$","RWS","CPS","tell","w","R","(","L","(","Listen","m",")",")","->","swapAndLift","<$>","RWS","CPS","listen","(","hdl","(","m","<$","ctx",")",")","R","(","L","(","Censor","f","m",")",")","->","RWS","CPS","censor","f","(","hdl","(","m","<$","ctx",")",")","R","(","R","(","L","Get",")",")","->","RWS","CPS","gets","(","<$","ctx",")","R","(","R","(","L","(","Put","s",")",")",")","->","ctx","<$","RWS","CPS","put","s","R","(","R","(","R","other",")",")","->","RWS","CPS","rwsT","$","\\","r","s","->","unRWSTF","<$>","thread","(","(","\\","(","RWSTF","(","x",",","s",",","w",")",")","->","toRWSTF","w","<$>","RWS","CPS","runRWST","x","r","s",")","~<~","hdl",")","other","(","RWSTF","(","ctx",",","s",",","mempty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L258-L267","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureNumSamples","parameters":"device","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"captureNumSamples device = makeGettableStateVar $\n   fmap fromIntegral (getInteger (Just device) CaptureSamples)","function_tokens":["captureNumSamples","device","=","makeGettableStateVar","$","fmap","fromIntegral","(","getInteger","(","Just","device",")","CaptureSamples",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L88-L89","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Key_ (tonic, mode))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (Key_ (tonic, mode)) = prettyTonic tonic <+> pretty mode\n        where\n            prettyTonic a = case a of\n                0 -> \"C\"","function_tokens":["pretty","(","Key_","(","tonic",",","mode",")",")","=","prettyTonic","tonic","<+>","pretty","mode","where","prettyTonic","a","=","case","a","of","0","->","\"C\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L508-L513","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection","parameters":"t1@(Tip _ x) t2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intersection t1@(Tip _ x) t2\n  | member x t2  = t1\n  | otherwise    = Nil","function_tokens":["intersection","t1","@","(","Tip","_","x",")","t2","|","member","x","t2","=","t1","|","otherwise","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L430-L432","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unzip3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip3 = MG.unzip3","function_tokens":["unzip3","=","MG","unzip3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L349-L349","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"cleanInput","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cleanInput = Text.strip input","function_tokens":["cleanInput","=","Text","strip","input"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L125-L125","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInCirc","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease in circular.","docstring_summary":"Ease in circular.","docstring_tokens":["Ease","in","circular","."],"function":"easeInCirc c t b = let s = realToFrac $ sqrt (1 - t*t) in -c * (s - 1) + b","function_tokens":["easeInCirc","c","t","b","=","let","s","=","realToFrac","$","sqrt","(","1","-","t","*","t",")","in","-","c","*","(","s","-","1",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L146-L146","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"PONG","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandArgs PONG                 = B.empty","function_tokens":["commandArgs","PONG","=","B","empty"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L37-L37","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_FALSE","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"alc_FALSE                           = 0x0000","function_tokens":["alc_FALSE","=","0x0000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L127-L127","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"fromList","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromList = MG.fromList","function_tokens":["fromList","=","MG","fromList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L148-L148","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s DNil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s DNil = s `hashWithSalt` (0 :: Int)","function_tokens":["hashWithSalt","s","DNil","=","s","`","hashWithSalt","`","(","0","::","Int",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L215-L215","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"takeEnd","parameters":"count xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeEnd count xs = drop (length xs - count) xs","function_tokens":["takeEnd","count","xs","=","drop","(","length","xs","-","count",")","xs"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L49-L49","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"compose","parameters":"(Point f m) (Point g n)","argument_list":"","return_statement":"","docstring":"Point composition.","docstring_summary":"Point composition.","docstring_tokens":["Point","composition","."],"function":"compose (Point f m) (Point g n)\n  = Point (f . g) (uncurry (curry n . curry m))","function_tokens":["compose","(","Point","f","m",")","(","Point","g","n",")","=","Point","(","f",".","g",")","(","uncurry","(","curry","n",".","curry","m",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L85-L86","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"eventNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eventNames = intercalate \", \" $ (cs . encode) <$> events","function_tokens":["eventNames","=","intercalate","\", \"","$","(","cs",".","encode",")","<$>","events"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L360-L360","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"allGood","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allGood = Resolution.fullySuccessful result","function_tokens":["allGood","=","Resolution","fullySuccessful","result"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L108-L108","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = AccumC $ const $ pure (mempty, a)","function_tokens":["pure","a","=","AccumC","$","const","$","pure","(","mempty",",","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L88-L88","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"compression","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compression = M.findWithDefault compressed s eaCompression","function_tokens":["compression","=","M","findWithDefault","compressed","s","eaCompression"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L498-L498","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty  = empty","function_tokens":["mempty","=","empty"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L237-L237","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fieldVars","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldVars = typeVariables fieldtype","function_tokens":["fieldVars","=","typeVariables","fieldtype"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L562-L562","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"f","parameters":"i v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f i v = (T.pack $! show i) := v","function_tokens":["f","i","v","=","(","T","pack","$!","show","i",")",":=","v"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L175-L175","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"mv","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mv x | sortByMean cfg || printOnce cfg = x\n             | otherwise = linesUp (printHeight cfg*position b) <> x <> linesDown (printHeight cfg*(position b-1))","function_tokens":["mv","x","|","sortByMean","cfg","||","printOnce","cfg","=","x","|","otherwise","=","linesUp","(","printHeight","cfg","*","position","b",")","<>","x","<>","linesDown","(","printHeight","cfg","*","(","position","b","-","1",")",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L211-L212","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \\\/ b = a .|. b","function_tokens":["a","\\\/","b","=","a",".|.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L195-L195","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"stop","parameters":"","argument_list":"","return_statement":"","docstring":"'stop' applied to an 'Initial' source is a legal NOP. 'stop' applied to a 'Playing' source will change its state to 'Stopped'. The source is exempt from processing, its current state is preserved. 'stop' applied to a 'Paused' source will change its state to 'Stopped', with the same consequences as on a 'Playing' source. 'stop' applied to a 'Stopped' source is a legal NOP.","docstring_summary":"'stop' applied to an 'Initial' source is a legal NOP. 'stop' applied to a 'Playing' source will change its state to 'Stopped'. The source is exempt from processing, its current state is preserved. 'stop' applied to a 'Paused' source will change its state to 'Stopped', with the same consequences as on a 'Playing' source. 'stop' applied to a 'Stopped' source is a legal NOP.","docstring_tokens":["stop","applied","to","an","Initial","source","is","a","legal","NOP",".","stop","applied","to","a","Playing","source","will","change","its","state","to","Stopped",".","The","source","is","exempt","from","processing","its","current","state","is","preserved",".","stop","applied","to","a","Paused","source","will","change","its","state","to","Stopped","with","the","same","consequences","as","on","a","Playing","source",".","stop","applied","to","a","Stopped","source","is","a","legal","NOP","."],"function":"stop = withArraySizei alSourceStopv","function_tokens":["stop","=","withArraySizei","alSourceStopv"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L757-L757","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"day","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"day = fromIntegral (msDosDate .&. 0x1f)","function_tokens":["day","=","fromIntegral","(","msDosDate",".&.","0x1f",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1193-L1193","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"get","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"get = RSST $ \\_ (s,w) -> return (s,(s,w))","function_tokens":["get","=","RSST","$","\\","_","(","s",",","w",")","->","return","(","s",",","(","s",",","w",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L171-L171","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"sourceEntry","parameters":"path EntryDescription {..} d","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sourceEntry path EntryDescription {..} d =\n  source .| CB.isolate (fromIntegral edCompressedSize) .| decompress\n  where\n    source = CB.sourceIOHandle $ do\n      h <- openFile path ReadMode\n      hSeek h AbsoluteSeek (fromIntegral edOffset)\n      localHeader <- B.hGet h 30\n      case runGet getLocalHeaderGap localHeader of\n        Left msg -> throwM (ParsingFailed path msg)\n        Right gap -> do\n          hSeek h RelativeSeek gap\n          return h\n    decompress =\n      if d\n        then decompressingPipe edCompression\n        else C.awaitForever C.yield\n\n-- | Undertake \/all\/ actions specified as the fourth argument of the\n-- function. This transforms the given pending actions so they can be\n-- performed in one pass, and then they are applied in the most efficient\n-- way.","function_tokens":["sourceEntry","path","EntryDescription","{","..","}","d","=","source",".|","CB","isolate","(","fromIntegral","edCompressedSize",")",".|","decompress","where","source","=","CB","sourceIOHandle","$","do","h","<-","openFile","path","ReadMode","hSeek","h","AbsoluteSeek","(","fromIntegral","edOffset",")","localHeader","<-","B","hGet","h","30","case","runGet","getLocalHeaderGap","localHeader","of","Left","msg","->","throwM","(","ParsingFailed","path","msg",")","Right","gap","->","do","hSeek","h","RelativeSeek","gap","return","h","decompress","=","if","d","then","decompressingPipe","edCompression","else","C","awaitForever","C","yield","-- | Undertake \/all\/ actions specified as the fourth argument of the","-- function. This transforms the given pending actions so they can be","-- performed in one pass, and then they are applied in the most efficient","-- way."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L242-L263","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"runShell","parameters":"dispatch Shell {..}","argument_list":"","return_statement":"","docstring":"Run a single iteration of the shell.  @since 1.1.0.0","docstring_summary":"Run a single iteration of the shell.","docstring_tokens":["Run","a","single","iteration","of","the","shell","."],"function":"runShell dispatch Shell {..} = do\n  input <- askLn shellPrompt Nothing\n  words <- shellSplit input\n  unless (null words) (go (map toString words))\n  where\n    go words = do\n      case O.execParserPure shellPrefs shellInfo words of\n        O.Success a ->\n          dispatch a\n        O.Failure help -> do\n          let str = fst (O.renderFailure help \"\")\n          sayLn (text $ toText str)\n        O.CompletionInvoked _ ->\n          pure ()\n\n-- | Print a list of shell commands.\n--\n-- @since 1.1.0.0","function_tokens":["runShell","dispatch","Shell","{","..","}","=","do","input","<-","askLn","shellPrompt","Nothing","words","<-","shellSplit","input","unless","(","null","words",")","(","go","(","map","toString","words",")",")","where","go","words","=","do","case","O","execParserPure","shellPrefs","shellInfo","words","of","O","Success","a","->","dispatch","a","O","Failure","help","->","do","let","str","=","fst","(","O","renderFailure","help","\"\"",")","sayLn","(","text","$","toText","str",")","O","CompletionInvoked","_","->","pure","(",")","-- | Print a list of shell commands.","--","-- @since 1.1.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L62-L80","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"desktopArg","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desktopArg = Arg (\"--desktop-file=\" <>\n        (desktopDir <\/> op ExeFile exeFile <.> \"desktop\"))","function_tokens":["desktopArg","=","Arg","(","\"--desktop-file=\"","<>","(","desktopDir","<\/>","op","ExeFile","exeFile","<.>","\"desktop\"",")",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L54-L55","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"makeFilesMatchingPrefixes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeFilesMatchingPrefixes =\n  do  statusPorcelain <- getStatusPorcelain\n      rootDir <- getGitRootDir\n      let rootRelativeFiles =\n              filterM (fmap not . isDirectory) . map (rootDir <\/>)\n      let decode x =\n              case reads x of\n              [(r, \"\")] -> r\n              _ -> x\n      let firstMatchingPrefix :: [String] -> String -> Maybe String\n          firstMatchingPrefix prefixes =\n              fmap decode . asum . traverse unprefix prefixes\n      let filesMatchingPrefixes :: [String] -> IO [FilePath]\n          filesMatchingPrefixes prefixes =\n              rootRelativeFiles . mapMaybe (firstMatchingPrefix prefixes)\n              $ lines statusPorcelain\n      pure filesMatchingPrefixes","function_tokens":["makeFilesMatchingPrefixes","=","do","statusPorcelain","<-","getStatusPorcelain","rootDir","<-","getGitRootDir","let","rootRelativeFiles","=","filterM","(","fmap","not",".","isDirectory",")",".","map","(","rootDir","<\/>",")","let","decode","x","=","case","reads","x","of","[","(","r",",","\"\"",")","]","->","r","_","->","x","let","firstMatchingPrefix","::","[","String","]","->","String","->","Maybe","String","firstMatchingPrefix","prefixes","=","fmap","decode",".","asum",".","traverse","unprefix","prefixes","let","filesMatchingPrefixes","::","[","String","]","->","IO","[","FilePath","]","filesMatchingPrefixes","prefixes","=","rootRelativeFiles",".","mapMaybe","(","firstMatchingPrefix","prefixes",")","$","lines","statusPorcelain","pure","filesMatchingPrefixes"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L215-L233","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"isSymmetric","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isSymmetric = MG.isSymmetric","function_tokens":["isSymmetric","=","MG","isSymmetric"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L220-L220","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Words a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Words a)                = a","function_tokens":["go","(","Words","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L428-L428","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Flat","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Flat         = \"_\"","function_tokens":["go","Flat","=","\"_\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L459-L459","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(FileUrl _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (FileUrl _)              = \"F\"","function_tokens":["go","(","FileUrl","_",")","=","\"F\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L339-L339","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtToMapFiles","parameters":"","argument_list":"","return_statement":"","docstring":"Given a list of districts, return a list of maps.","docstring_summary":"Given a list of districts, return a list of maps.","docstring_tokens":["Given","a","list","of","districts","return","a","list","of","maps","."],"function":"districtToMapFiles = map (\\(District polygons label _ area _) -> title .~ label ++ \"-\" ++ (show . sum $ area) $ labelledDistricts .~ (pure (polygons,\"\")) $ def)","function_tokens":["districtToMapFiles","=","map","(","\\","(","District","polygons","label","_","area","_",")","->","title",".~","label","++","\"-\"","++","(","show",".","sum","$","area",")","$","labelledDistricts",".~","(","pure","(","polygons",",","\"\"",")",")","$","def",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L62-L62","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"b","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b = B.take 0xffff (m ! headerId)","function_tokens":["b","=","B","take","0xffff","(","m","!","headerId",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L792-L792","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = Modifier mempty mempty mempty mempty mempty","function_tokens":["mempty","=","Modifier","mempty","mempty","mempty","mempty","mempty"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L91-L91","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ifold","parameters":"(a `LessThan` b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (a `LessThan` b) = coerce a <> coerce b","function_tokens":["ifold","(","a","`","LessThan","`","b",")","=","coerce","a","<>","coerce","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L86-L86","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_     `ieq1` _     = False","function_tokens":["_","`","ieq1","`","_","=","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L88-L88","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(words, rest) = B.splitAt 2 bs","function_tokens":["(","words",",","rest",")","=","B","splitAt","2","bs"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L98-L98","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"addPending","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"addPending a = modifyActions (|> a)","function_tokens":["addPending","a","=","modifyActions","(","|>","a",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L686-L686","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result,t') = maxViewUnsigned l","function_tokens":["(","result",",","t'",")","=","maxViewUnsigned","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L595-L595","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Source _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Source _)               = \"S\"","function_tokens":["go","(","Source","_",")","=","\"S\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L353-L353","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"set","parameters":"","argument_list":"","return_statement":"","docstring":"Get the setter arrow from a lens.","docstring_summary":"Get the setter arrow from a lens.","docstring_tokens":["Get","the","setter","arrow","from","a","lens","."],"function":"set = Point.set . unpack","function_tokens":["set","=","Point","set",".","unpack"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L75-L75","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"indices","parameters":"con","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"indices con =\n          case con of\n            NormalC {}      -> []\n            RecC    {}      -> []\n            InfixC  {}      -> []\n#if MIN_VERSION_template_haskell(2,11,0)\n            ForallC _ _ ty  -> indices ty\n#elif MIN_VERSION_template_haskell(2,10,0)\n            ForallC _ x _   -> [ c | AppT (AppT EqualityT _) c <- x ]\n#else\n            ForallC _ x _   -> [ c | EqualP _ c <- x ]\n#endif\n#if MIN_VERSION_template_haskell(2,11,0)\n            GadtC _ _ ty    -> conIndices ty\n            RecGadtC _ _ ty -> conIndices ty\n         where\n           conIndices (AppT (ConT _) ty) = [ty]\n           conIndices (AppT rest     ty) = conIndices rest ++ [ty]\n           conIndices _                  = fclError \"Non-AppT in conIndices. Please report this as a bug for fclabels.\"\n#endif","function_tokens":["indices","con","=","case","con","of","NormalC","{","}","->","[","]","RecC","{","}","->","[","]","InfixC","{","}","->","[","]","#if MIN_VERSION_template_haskell(2,11,0)","ForallC","_","_","ty","->","indices","ty","#elif MIN_VERSION_template_haskell(2,10,0)\n            ForallC _ x _   -> [ c | AppT (AppT EqualityT _) c <- x ]\n#else\n            ForallC _ x _   -> [ c | EqualP _ c <- x ]\n","#endif","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","_","_","ty","->","conIndices","ty","RecGadtC","_","_","ty","->","conIndices","ty","where","conIndices","(","AppT","(","ConT","_",")","ty",")","=","[","ty","]","conIndices","(","AppT","rest","ty",")","=","conIndices","rest","++","[","ty","]","conIndices","_","=","fclError","\"Non-AppT in conIndices. Please report this as a bug for fclabels.\"","#endif"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L384-L405","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"unsafeRead","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeRead = MG.unsafeRead","function_tokens":["unsafeRead","=","MG","unsafeRead"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L42-L42","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"guardsLocs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"guardsLocs = map GHC.getLocA guards","function_tokens":["guardsLocs","=","map","GHC","getLocA","guards"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L121-L121","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"pick","parameters":"(Program (MapLabel outfile False projection lensName) infile)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pick (Program (MapLabel outfile False projection lensName) infile) = let p = pickProjection projection in\n    mkMapSVG outfile =<< districtToMapLensP p (pickLens lensName) <$> getDistricts infile","function_tokens":["pick","(","Program","(","MapLabel","outfile","False","projection","lensName",")","infile",")","=","let","p","=","pickProjection","projection","in","mkMapSVG","outfile","=<<","districtToMapLensP","p","(","pickLens","lensName",")","<$>","getDistricts","infile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L24-L25","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_LINEAR_DISTANCE_CLAMPED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_LINEAR_DISTANCE_CLAMPED          = 0xD004","function_tokens":["al_LINEAR_DISTANCE_CLAMPED","=","0xD004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L58-L58","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"disjuncts'","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"disjuncts' e = (\\(Or  os) -> os) <$> match e","function_tokens":["disjuncts'","e","=","(","\\","(","Or","os",")","->","os",")","<$>","match","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L443-L443","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pretty","parameters":"tv","argument_list":"","return_statement":"","docstring":"Prettify a TH name.","docstring_summary":"Prettify a TH name.","docstring_tokens":["Prettify","a","TH","name","."],"function":"pretty tv = mkName (takeWhile (\/= '_') (show tv))","function_tokens":["pretty","tv","=","mkName","(","takeWhile","(","\/=","'_'",")","(","show","tv",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L700-L700","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"renderBenchmark","parameters":"cfg w maxDuration Benchmark{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderBenchmark cfg w maxDuration Benchmark{..}\n  = mUnless (simple cfg) (sgrBuilder $ SetColor Foreground Vivid Cyan)\n  <> fromString name\n  <> mUnless (simple cfg) (sgrBuilder Reset)\n  <> mUnless (sameLine cfg) (clear cfg <> B.char7 '\\n' <> B.char7 ' ')\n  <> B.char7 ' '\n  <> renderAnalysis cfg analysis\n  <> clear cfg\n  <> B.char7 '\\n'\n  <> mUnless (hideBar cfg)\n  ( mUnless (samples analysis <= 1)\n    ( barBuilder cfg w (mean analysis \/ maxDuration) (min 1 $ confidence cfg * standardError analysis \/ fromRational (mean analysis)) (min 1 $ standardDeviation analysis \/ fromRational (mean analysis))\n      <> clear cfg\n    ) <> B.char7 '\\n'\n  )","function_tokens":["renderBenchmark","cfg","w","maxDuration","Benchmark","{","..","}","=","mUnless","(","simple","cfg",")","(","sgrBuilder","$","SetColor","Foreground","Vivid","Cyan",")","<>","fromString","name","<>","mUnless","(","simple","cfg",")","(","sgrBuilder","Reset",")","<>","mUnless","(","sameLine","cfg",")","(","clear","cfg","<>","B","char7","'\\n'","<>","B","char7","' '",")","<>","B","char7","' '","<>","renderAnalysis","cfg","analysis","<>","clear","cfg","<>","B","char7","'\\n'","<>","mUnless","(","hideBar","cfg",")","(","mUnless","(","samples","analysis","<=","1",")","(","barBuilder","cfg","w","(","mean","analysis","\/","maxDuration",")","(","min","1","$","confidence","cfg","*","standardError","analysis","\/","fromRational","(","mean","analysis",")",")","(","min","1","$","standardDeviation","analysis","\/","fromRational","(","mean","analysis",")",")","<>","clear","cfg",")","<>","B","char7","'\\n'",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L233-L247","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"toLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) List of lists","docstring_summary":"O(m*n) List of lists","docstring_tokens":["O","(","m","*","n",")","List","of","lists"],"function":"toLists = map G.toList . toRows","function_tokens":["toLists","=","map","G","toList",".","toRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L195-L195","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"constructorFields","parameters":"vs con","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"constructorFields vs con =\n\n  case con of\n\n    NormalC c fs -> one <$> zip [0..] fs\n      where one (i, f@(_, ty)) = Field Nothing mono ty (Context i c con, [])\n              where fsTys = map (typeVariables . snd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)\n\n    RecC c fs -> one <$> zip [0..] fs\n      where one (i, f@(n, _, ty)) = Field (Just n) mono ty (Context i c con, [])\n              where fsTys = map (typeVariables . trd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)\n\n    InfixC a c b -> one <$> [(0, a), (1, b)]\n      where one (i, (_, ty)) = Field Nothing mono ty (Context i c con, [])\n              where fsTys = map (typeVariables . snd) [a, b]\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)\n\n    ForallC x y v -> setEqs <$> constructorFields vs v\n#if MIN_VERSION_template_haskell(2,10,0)\n      where eqs = [ (a, b) | AppT (AppT EqualityT a) b <- y ]\n#else\n      where eqs = [ (a, b) | EqualP a b <- y ]\n#endif\n            setEqs (Field a b c d) = Field a b c (first upd . second (eqs ++) $ d)\n            upd (Context a b c) = Context a b (ForallC x y c)\n#if MIN_VERSION_template_haskell(2,11,0)\n    GadtC cs fs resTy -> concatMap (\\c -> one c <$> zip [0..] fs) cs\n      where one c (i, f@(_, ty)) = Field Nothing mono ty (Context i c con, mkSubst vs resTy)\n              where fsTys = map (typeVariables . snd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)\n    RecGadtC cs fs resTy -> concatMap (\\c -> one c <$> zip [0..] fs) cs\n      where one c (i, f@(n, _, ty)) = Field (Just n) mono ty (Context i c con, mkSubst vs resTy)\n              where fsTys = map (typeVariables . trd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["constructorFields","vs","con","=","case","con","of","NormalC","c","fs","->","one","<$>","zip","[","0","..","]","fs","where","one","(","i",",","f","@","(","_",",","ty",")",")","=","Field","Nothing","mono","ty","(","Context","i","c","con",",","[","]",")","where","fsTys","=","map","(","typeVariables",".","snd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")","RecC","c","fs","->","one","<$>","zip","[","0","..","]","fs","where","one","(","i",",","f","@","(","n",",","_",",","ty",")",")","=","Field","(","Just","n",")","mono","ty","(","Context","i","c","con",",","[","]",")","where","fsTys","=","map","(","typeVariables",".","trd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")","InfixC","a","c","b","->","one","<$>","[","(","0",",","a",")",",","(","1",",","b",")","]","where","one","(","i",",","(","_",",","ty",")",")","=","Field","Nothing","mono","ty","(","Context","i","c","con",",","[","]",")","where","fsTys","=","map","(","typeVariables",".","snd",")","[","a",",","b","]","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")","ForallC","x","y","v","->","setEqs","<$>","constructorFields","vs","v","#if MIN_VERSION_template_haskell(2,10,0)","where","eqs","=","[","(","a",",","b",")","|","AppT","(","AppT","EqualityT","a",")","b","<-","y","]","#else\n      where eqs = [ (a, b) | EqualP a b <- y ]\n","#endif","setEqs","(","Field","a","b","c","d",")","=","Field","a","b","c","(","first","upd",".","second","(","eqs","++",")","$","d",")","upd","(","Context","a","b","c",")","=","Context","a","b","(","ForallC","x","y","c",")","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","cs","fs","resTy","->","concatMap","(","\\","c","->","one","c","<$>","zip","[","0","..","]","fs",")","cs","where","one","c","(","i",",","f","@","(","_",",","ty",")",")","=","Field","Nothing","mono","ty","(","Context","i","c","con",",","mkSubst","vs","resTy",")","where","fsTys","=","map","(","typeVariables",".","snd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")","RecGadtC","cs","fs","resTy","->","concatMap","(","\\","c","->","one","c","<$>","zip","[","0","..","]","fs",")","cs","where","one","c","(","i",",","f","@","(","n",",","_",",","ty",")",")","=","Field","(","Just","n",")","mono","ty","(","Context","i","c","con",",","mkSubst","vs","resTy",")","where","fsTys","=","map","(","typeVariables",".","trd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L330-L367","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"setModTime","parameters":"time s","argument_list":"","return_statement":"","docstring":"Set the last modification date\\\/time. The specified entry may be missing, in that case the action has no effect.","docstring_summary":"Set the last modification date\\\/time. The specified entry may be missing, in that case the action has no effect.","docstring_tokens":["Set","the","last","modification","date","\\","\/","time",".","The","specified","entry","may","be","missing","in","that","case","the","action","has","no","effect","."],"function":"setModTime time s = addPending (I.SetModTime time s)","function_tokens":["setModTime","time","s","=","addPending","(","I","SetModTime","time","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L568-L568","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"handleCommand","parameters":"PING peer inst","argument_list":"","return_statement":"","docstring":"Simply answer a PING with a PONG","docstring_summary":"Simply answer a PING with a PONG","docstring_tokens":["Simply","answer","a","PING","with","a","PONG"],"function":"handleCommand PING peer inst = send (handle inst) peer PONG","function_tokens":["handleCommand","PING","peer","inst","=","send","(","handle","inst",")","peer","PONG"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L266-L266","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pushQuantifier","parameters":"(Forall vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushQuantifier (Forall vs a) = pushQuantifier' forall vs a","function_tokens":["pushQuantifier","(","Forall","vs","a",")","=","pushQuantifier'","forall","vs","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L735-L735","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"peek","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"peek                  = peek1 Source . castPtr","function_tokens":["peek","=","peek1","Source",".","castPtr"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L119-L119","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"or'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"or' = do\n            _  <- char '(' *> string \"or\" *> space\n            os <- r `sepBy1` space\n            _  <- char ')'\n            or'' os","function_tokens":["or'","=","do","_","<-","char","'('","*>","string","\"or\"","*>","space","os","<-","r","`","sepBy1","`","space","_","<-","char","')'","or''","os"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L412-L418","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"try","parameters":"parser","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"try parser = parser","function_tokens":["try","parser","=","parser"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L78-L78","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"changes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changes = foldMap (formatDataDecl cfg) . dataDecls","function_tokens":["changes","=","foldMap","(","formatDataDecl","cfg",")",".","dataDecls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L93-L93","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"h","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"h = O.parserFailure shellPrefs shellInfo (O.ShowHelpText Nothing) mempty","function_tokens":["h","=","O","parserFailure","shellPrefs","shellInfo","(","O","ShowHelpText","Nothing",")","mempty"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L85-L85","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"f","parameters":"' ' b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f ' ' b   = b","function_tokens":["f","' '","b","=","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L74-L74","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SAMPLE_OFFSET","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SAMPLE_OFFSET                    = 0x1025","function_tokens":["al_SAMPLE_OFFSET","=","0x1025"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L94-L94","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Strict function composition","docstring_summary":"Strict function composition","docstring_tokens":["Strict","function","composition"],"function":"f .! g = \\x -> f $! g x","function_tokens":["f",".!","g","=","\\","x","->","f","$!","g","x"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L211-L211","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"sustainT","parameters":"a x","argument_list":"","return_statement":"","docstring":"Prolongated events can not exceed total track duration. All event are sustained but those that are close to end of the track are sliced. It resembles sustain on piano, when track ends you release the pedal.","docstring_summary":"Prolongated events can not exceed total track duration. All event are sustained but those that are close to end of the track are sliced. It resembles sustain on piano, when track ends you release the pedal.","docstring_tokens":["Prolongated","events","can","not","exceed","total","track","duration",".","All","event","are","sustained","but","those","that","are","close","to","end","of","the","track","are","sliced",".","It","resembles","sustain","on","piano","when","track","ends","you","release","the","pedal","."],"function":"sustainT a x = mapEvents (\\e -> truncate $ e{ eventDur = a + eventDur e }) x\n    where truncate e\n            | eventEnd e > d    = e{ eventDur = max 0 $ d - eventStart e }\n            | otherwise         = e\n          d = dur x\n\n\n-- | Shifts all events so that minimal start time\n--  equals to zero if first event has negative start time.","function_tokens":["sustainT","a","x","=","mapEvents","(","\\","e","->","truncate","$","e","{","eventDur","=","a","+","eventDur","e","}",")","x","where","truncate","e","|","eventEnd","e",">","d","=","e","{","eventDur","=","max","0","$","d","-","eventStart","e","}","|","otherwise","=","e","d","=","dur","x","-- | Shifts all events so that minimal start time","--  equals to zero if first event has negative start time."],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L257-L266","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(isFptr, _, _) = BSI.toForeignPtr is","function_tokens":["(","isFptr",",","_",",","_",")","=","BSI","toForeignPtr","is"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L104-L104","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Environment.hs","language":"haskell","identifier":"setConflictStyle","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setConflictStyle =\n    callProcess \"git\" [\"config\", \"--global\", \"merge.conflictstyle\", \"diff3\"]","function_tokens":["setConflictStyle","=","callProcess","\"git\"","[","\"config\"",",","\"--global\"",",","\"merge.conflictstyle\"",",","\"diff3\"","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Environment.hs#L37-L38","hash_key":"Peaker\/git-mediate:src\/Environment.hs","hash_val":17949,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"printMultiLineExportList","parameters":"conf exports","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printMultiLineExportList conf exports = do\n    newline\n    doIndent >> putText firstChar >> unless (null exports) space\n    mapM_ printExport $ flagEnds exports\n    when (null exports) $ newline >> doIndent\n    putText \")\" >> space >> putText \"where\"\n  where\n    printExport (CommentGroup {..}, firstGroup, _lastGroup) = do\n        forM_ (flagEnds cgPrior) $ \\(cmt, start, _end) -> do\n            unless (firstGroup && start) $ space >> space\n            putComment $ GHC.unLoc cmt\n            newline >> doIndent\n\n        forM_ (flagEnds cgItems) $ \\((export, mbComment), start, _end) -> do\n            if firstGroup && start then\n                unless (null cgPrior) $ space >> space\n            else\n                comma >> space\n            putExport conf export\n            putMaybeLineComment $ GHC.unLoc <$> mbComment\n            newline >> doIndent\n\n    firstChar = case openBracket conf of\n        SameLine -> \" \"\n        NextLine -> \"(\"\n\n    doIndent = spaces (indent conf)\n\n-- NOTE(jaspervdj): This code is almost the same as the import printing in\n-- 'Imports' and should be merged.","function_tokens":["printMultiLineExportList","conf","exports","=","do","newline","doIndent",">>","putText","firstChar",">>","unless","(","null","exports",")","space","mapM_","printExport","$","flagEnds","exports","when","(","null","exports",")","$","newline",">>","doIndent","putText","\")\"",">>","space",">>","putText","\"where\"","where","printExport","(","CommentGroup","{","..","}",",","firstGroup",",","_lastGroup",")","=","do","forM_","(","flagEnds","cgPrior",")","$","\\","(","cmt",",","start",",","_end",")","->","do","unless","(","firstGroup","&&","start",")","$","space",">>","space","putComment","$","GHC","unLoc","cmt","newline",">>","doIndent","forM_","(","flagEnds","cgItems",")","$","\\","(","(","export",",","mbComment",")",",","start",",","_end",")","->","do","if","firstGroup","&&","start","then","unless","(","null","cgPrior",")","$","space",">>","space","else","comma",">>","space","putExport","conf","export","putMaybeLineComment","$","GHC","unLoc","<$>","mbComment","newline",">>","doIndent","firstChar","=","case","openBracket","conf","of","SameLine","->","\" \"","NextLine","->","\"(\"","doIndent","=","spaces","(","indent","conf",")","-- NOTE(jaspervdj): This code is almost the same as the import printing in","-- 'Imports' and should be merged."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L193-L223","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"go","parameters":"(Right conflict)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Right conflict) =\n            case (resolveConflict . lineBreakFix . untabified) conflict of\n            NoResolution               -> NewContent (Result 0 0 1)\n                                          (Conflict.pretty (untabified conflict))\n            Resolution trivialLines    -> NewContent (Result 1 0 0) trivialLines\n            PartialResolution newLines -> NewContent (Result 0 1 0) newLines","function_tokens":["go","(","Right","conflict",")","=","case","(","resolveConflict",".","lineBreakFix",".","untabified",")","conflict","of","NoResolution","->","NewContent","(","Result","0","0","1",")","(","Conflict","pretty","(","untabified","conflict",")",")","Resolution","trivialLines","->","NewContent","(","Result","1","0","0",")","trivialLines","PartialResolution","newLines","->","NewContent","(","Result","0","1","0",")","newLines"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L138-L143","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(UnitNoteLength a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (UnitNoteLength a)       = show $ pretty a","function_tokens":["go","(","UnitNoteLength","a",")","=","show","$","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L414-L414","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"len","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"len = toEnum (SC.length x)","function_tokens":["len","=","toEnum","(","SC","length","x",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L183-L183","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"execAccum","parameters":"","argument_list":"","return_statement":"","docstring":"Run an 'Accum' effect (typically with a 'Monoid'al log), producing the final log and discarding the result value.  @ 'execAccum' = 'runAccum' ('const' '.' 'pure') @  @since 1.1.2.0","docstring_summary":"Run an 'Accum' effect (typically with a 'Monoid'al log), producing the final log and discarding the result value.","docstring_tokens":["Run","an","Accum","effect","(","typically","with","a","Monoid","al","log",")","producing","the","final","log","and","discarding","the","result","value","."],"function":"execAccum = runAccum (const . pure)","function_tokens":["execAccum","=","runAccum","(","const",".","pure",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L63-L63","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection","parameters":"t1@(Bin _ _ p1 m1 l1 r1) t2@(Bin _ _ p2 m2 l2 r2)","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nIntersection\n------------------------------------------------------------------} \/O(n+m)\/. The intersection of two sets.","docstring_summary":"{--------------------------------------------------------------------\nIntersection\n------------------------------------------------------------------} \/O(n+m)\/. The intersection of two sets.","docstring_tokens":["{","--------------------------------------------------------------------","Intersection","------------------------------------------------------------------","}","\/","O","(","n","+","m",")","\/",".","The","intersection","of","two","sets","."],"function":"intersection t1@(Bin _ _ p1 m1 l1 r1) t2@(Bin _ _ p2 m2 l2 r2)\n  | shorter m1 m2  = intersection1\n  | shorter m2 m1  = intersection2\n  | p1 == p2       = bin p1 m1 (intersection l1 l2) (intersection r1 r2)\n  | otherwise      = Nil\n  where\n    intersection1 | nomatch p2 p1 m1  = Nil\n                  | zero p2 m1        = intersection l1 t2\n                  | otherwise         = intersection r1 t2\n\n    intersection2 | nomatch p1 p2 m2  = Nil\n                  | zero p1 m2        = intersection t1 l2\n                  | otherwise         = intersection t1 r2","function_tokens":["intersection","t1","@","(","Bin","_","_","p1","m1","l1","r1",")","t2","@","(","Bin","_","_","p2","m2","l2","r2",")","|","shorter","m1","m2","=","intersection1","|","shorter","m2","m1","=","intersection2","|","p1","==","p2","=","bin","p1","m1","(","intersection","l1","l2",")","(","intersection","r1","r2",")","|","otherwise","=","Nil","where","intersection1","|","nomatch","p2","p1","m1","=","Nil","|","zero","p2","m1","=","intersection","l1","t2","|","otherwise","=","intersection","r1","t2","intersection2","|","nomatch","p1","p2","m2","=","Nil","|","zero","p1","m2","=","intersection","t1","l2","|","otherwise","=","intersection","t1","r2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L416-L430","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"foldMap","parameters":"_ (Buffer Nothing)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldMap _ (Buffer Nothing)  = mempty","function_tokens":["foldMap","_","(","Buffer","Nothing",")","=","mempty"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L148-L148","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"getLabelWith","parameters":"sigs concrete failing name","argument_list":"","return_statement":"","docstring":"Low level label as expression derivation function.","docstring_summary":"Low level label as expression derivation function.","docstring_tokens":["Low","level","label","as","expression","derivation","function","."],"function":"getLabelWith sigs concrete failing name =\n  do dec    <- reifyDec name\n     labels <- generateLabels id concrete failing dec\n     let bodies  =        map (\\(LabelExpr _ _ _ b) -> b) labels\n         types   =        map (\\(LabelExpr _ _ t _) -> t) labels\n         context = head $ map (\\(LabelExpr _ c _ _) -> c) labels\n         vars    = head $ map (\\(LabelExpr v _ _ _) -> v) labels\n     case bodies of\n       [b] -> if sigs then b `sigE` forallT vars context (head types) else b\n       _   -> if sigs\n          then tupE bodies `sigE`\n               forallT vars context (foldl appT (tupleT (length bodies)) types)\n          else tupE bodies\n\n-- | Low level standalone label derivation function.","function_tokens":["getLabelWith","sigs","concrete","failing","name","=","do","dec","<-","reifyDec","name","labels","<-","generateLabels","id","concrete","failing","dec","let","bodies","=","map","(","\\","(","LabelExpr","_","_","_","b",")","->","b",")","labels","types","=","map","(","\\","(","LabelExpr","_","_","t","_",")","->","t",")","labels","context","=","head","$","map","(","\\","(","LabelExpr","_","c","_","_",")","->","c",")","labels","vars","=","head","$","map","(","\\","(","LabelExpr","v","_","_","_",")","->","v",")","labels","case","bodies","of","[","b","]","->","if","sigs","then","b","`","sigE","`","forallT","vars","context","(","head","types",")","else","b","_","->","if","sigs","then","tupE","bodies","`","sigE","`","forallT","vars","context","(","foldl","appT","(","tupleT","(","length","bodies",")",")","types",")","else","tupE","bodies","-- | Low level standalone label derivation function."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L137-L153","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Version.hs","language":"haskell","identifier":"versionString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"versionString = showVersion version","function_tokens":["versionString","=","showVersion","version"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Version.hs#L8-L8","hash_key":"Peaker\/git-mediate:src\/Version.hs","hash_val":7664,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \/\\ b = a .&. b","function_tokens":["a","\/\\","b","=","a",".&.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L194-L194","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"indentation","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"indentation =\n      cDeriving + case cFirstField of\n        Indent x -> x\n        SameLine -> 0","function_tokens":["indentation","=","cDeriving","+","case","cFirstField","of","Indent","x","->","x","SameLine","->","0"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L290-L295","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"linfunRel","parameters":"dur xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"linfunRel dur xs = linfun $ init $ f =<< xs\n    where dt  = dur \/ (fromIntegral $ length xs)\n          f x = [x, dt]","function_tokens":["linfunRel","dur","xs","=","linfun","$","init","$","f","=<<","xs","where","dt","=","dur","\/","(","fromIntegral","$","length","xs",")","f","x","=","[","x",",","dt","]"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L408-L410","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putRdrName","parameters":"rdrName","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putRdrName rdrName = case GHC.unLoc rdrName of\n    Unqual name -> do\n      let (pre, post) = nameAnnAdornments $\n            GHC.epAnnAnnsL $ GHC.ann $ GHC.getLoc rdrName\n      putText pre\n      putText (showOutputable name)\n      putText post\n    Qual modulePrefix name ->\n      putModuleName modulePrefix >> dot >> putText (showOutputable name)\n    Orig _ name ->\n      putText (showOutputable name)\n    Exact name ->\n      putText (showOutputable name)","function_tokens":["putRdrName","rdrName","=","case","GHC","unLoc","rdrName","of","Unqual","name","->","do","let","(","pre",",","post",")","=","nameAnnAdornments","$","GHC","epAnnAnnsL","$","GHC","ann","$","GHC","getLoc","rdrName","putText","pre","putText","(","showOutputable","name",")","putText","post","Qual","modulePrefix","name","->","putModuleName","modulePrefix",">>","dot",">>","putText","(","showOutputable","name",")","Orig","_","name","->","putText","(","showOutputable","name",")","Exact","name","->","putText","(","showOutputable","name",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L155-L169","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"prettyPragmas","parameters":"lp cols _       _     Compact","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyPragmas lp cols _       _     Compact         = compactPragmas lp cols","function_tokens":["prettyPragmas","lp","cols","_","_","Compact","=","compactPragmas","lp","cols"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L94-L94","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"unsafeRead","parameters":"(MMatrix _ _ tda offset v) (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeRead (MMatrix _ _ tda offset v) (i,j) = GM.unsafeRead v idx\n      where idx = offset + i * tda + j","function_tokens":["unsafeRead","(","MMatrix","_","_","tda","offset","v",")","(","i",",","j",")","=","GM","unsafeRead","v","idx","where","idx","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L34-L36","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInQuad","parameters":"c t b","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ $lerping These pure functions take a `c` (total change in value, ie end - start), `t` (percent of duration completion) and `b` (start value) and result in an interpolation of a value. To see what these look like please check out http:\/\/www.gizma.com\/easing\/. ------------------------------------------------------------------------------ Ease in quadratic.","docstring_summary":"------------------------------------------------------------------------------ $lerping These pure functions take a `c` (total change in value, ie end - start), `t` (percent of duration completion) and `b` (start value) and result in an interpolation of a value. To see what these look like please check out http:\/\/www.gizma.com\/easing\/. ------------------------------------------------------------------------------ Ease in quadratic.","docstring_tokens":["------------------------------------------------------------------------------","$lerping","These","pure","functions","take","a","c","(","total","change","in","value","ie","end","-","start",")","t","(","percent","of","duration","completion",")","and","b","(","start","value",")","and","result","in","an","interpolation","of","a","value",".","To","see","what","these","look","like","please","check","out","http",":","\/\/","www",".","gizma",".","com","\/","easing","\/",".","------------------------------------------------------------------------------","Ease","in","quadratic","."],"function":"easeInQuad c t b =  c * realToFrac (t*t) + b","function_tokens":["easeInQuad","c","t","b","=","c","*","realToFrac","(","t","*","t",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L96-L96","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"untabifyStr","parameters":"size","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"untabifyStr size =\n    go 0\n    where\n        cyclicInc col\n            | col >= size - 1 = 0\n            | otherwise = col + 1\n        go !col ('\\t':rest) = replicate (size - col) ' ' ++ go 0 rest\n        go !col (x:rest) = x : go (cyclicInc col) rest\n        go _ [] = []","function_tokens":["untabifyStr","size","=","go","0","where","cyclicInc","col","|","col",">=","size","-","1","=","0","|","otherwise","=","col","+","1","go","col","(","'\\t'",":","rest",")","=","replicate","(","size","-","col",")","' '","++","go","0","rest","go","col","(","x",":","rest",")","=","x",":","go","(","cyclicInc","col",")","rest","go","_","[","]","=","[","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L82-L92","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"peek","parameters":"","argument_list":"","return_statement":"","docstring":"'Conduit.peek' wrapped as a 'ConduitParser'.","docstring_summary":"'Conduit.peek' wrapped as a 'ConduitParser'.","docstring_tokens":["Conduit",".","peek","wrapped","as","a","ConduitParser","."],"function":"peek = ConduitParser $ lift $ lift Conduit.peek","function_tokens":["peek","=","ConduitParser","$","lift","$","lift","Conduit","peek"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L184-L184","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookStatusEvent","function_tokens":["reflect","_","=","WebhookStatusEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L472-L472","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = pickProjection projection","function_tokens":["p","=","pickProjection","projection"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L36-L36","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"CullC l <|> CullC r = CullC $ ReaderC $ \\ cull ->\n    if cull then\n      NonDetC $ \\ fork leaf nil ->\n        runNonDet fork leaf (runNonDet fork leaf nil (runReader cull r)) (runReader cull l)\n    else\n      runReader cull l <|> runReader cull r","function_tokens":["CullC","l","<|>","CullC","r","=","CullC","$","ReaderC","$","\\","cull","->","if","cull","then","NonDetC","$","\\","fork","leaf","nil","->","runNonDet","fork","leaf","(","runNonDet","fork","leaf","nil","(","runReader","cull","r",")",")","(","runReader","cull","l",")","else","runReader","cull","l","<|>","runReader","cull","r"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L71-L76","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Parts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Parts                    = \"O\"","function_tokens":["go","Parts","=","\"O\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L349-L349","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrState","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrState      = F.unsafeForeignPtrToPtr fptrState","function_tokens":["ptrState","=","F","unsafeForeignPtrToPtr","fptrState"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L81-L81","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"deleteFindMin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteFindMin = fromMaybe (error \"deleteFindMin: empty set has no minimal element\") . minView","function_tokens":["deleteFindMin","=","fromMaybe","(","error","\"deleteFindMin: empty set has no minimal element\"",")",".","minView"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L628-L628","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Discography _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Discography _)          = (True, True, False, False)","function_tokens":["go","(","Discography","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L369-L369","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freevars' = ifold","function_tokens":["freevars'","=","ifold"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L636-L636","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"errMsg","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"errMsg = printf \"fromVector: incorrect length (%d * %d != %d)\" r c n","function_tokens":["errMsg","=","printf","\"fromVector: incorrect length (%d * %d != %d)\"","r","c","n"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L121-L121","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrRemBitsLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen","function_tokens":["ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L83-L83","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"ishow","parameters":"(Select _ _ a i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Select _ _ a i)   = coerce $ \"(select \" ++ coerce a ++ \" \" ++ coerce i ++ \")\"","function_tokens":["ishow","(","Select","_","_","a","i",")","=","coerce","$","\"(select \"","++","coerce","a","++","\" \"","++","coerce","i","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L75-L75","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","language":"haskell","identifier":"allocWorkBuffers","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"allocWorkBuffers n = do\n  (fptr, ptr) <- F.mallocForeignPtrBytesWithAlignedCastPtr 32 (3 * n)\n  return WorkBuffers\n    { workBuffersF = fptr\n    , workBuffersP = ptr `F.plusPtr`  0\n    , workBuffersO = ptr `F.plusPtr`  n\n    , workBuffersC = ptr `F.plusPtr` (n * 2)\n    }","function_tokens":["allocWorkBuffers","n","=","do","(","fptr",",","ptr",")","<-","F","mallocForeignPtrBytesWithAlignedCastPtr","32","(","3","*","n",")","return","WorkBuffers","{","workBuffersF","=","fptr",",","workBuffersP","=","ptr","`","F","plusPtr","`","0",",","workBuffersO","=","ptr","`","F","plusPtr","`","n",",","workBuffersC","=","ptr","`","F","plusPtr","`","(","n","*","2",")","}"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs#L32-L41","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","hash_val":16990,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfc_x510_cs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfc_x510_cs =\n    [  1.11684990123545698684297865808 \/ 2\n    ,  0.003736240359381998520654927536\n    , -0.000916623948045470238763619870\n    ,  0.000199094325044940833965078819\n    , -0.000040276384918650072591781859\n    ,  7.76515264697061049477127605790e-6\n    , -1.44464794206689070402099225301e-6\n    ,  2.61311930343463958393485241947e-7\n    , -4.61833026634844152345304095560e-8\n    ,  8.00253111512943601598732144340e-9\n    , -1.36291114862793031395712122089e-9\n    ,  2.28570483090160869607683087722e-10\n    , -3.78022521563251805044056974560e-11\n    ,  6.17253683874528285729910462130e-12\n    , -9.96019290955316888445830597430e-13\n    ,  1.58953143706980770269506726000e-13\n    , -2.51045971047162509999527428316e-14\n    ,  3.92607828989125810013581287560e-15\n    , -6.07970619384160374392535453420e-16\n    ,  9.12600607264794717315507477670e-17\n    ]","function_tokens":["erfc_x510_cs","=","[","1.11684990123545698684297865808","\/","2",",","0.003736240359381998520654927536",",","-","0.000916623948045470238763619870",",","0.000199094325044940833965078819",",","-","0.000040276384918650072591781859",",","7.76515264697061049477127605790e-6",",","-","1.44464794206689070402099225301e-6",",","2.61311930343463958393485241947e-7",",","-","4.61833026634844152345304095560e-8",",","8.00253111512943601598732144340e-9",",","-","1.36291114862793031395712122089e-9",",","2.28570483090160869607683087722e-10",",","-","3.78022521563251805044056974560e-11",",","6.17253683874528285729910462130e-12",",","-","9.96019290955316888445830597430e-13",",","1.58953143706980770269506726000e-13",",","-","2.51045971047162509999527428316e-14",",","3.92607828989125810013581287560e-15",",","-","6.07970619384160374392535453420e-16",",","9.12600607264794717315507477670e-17","]"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L146-L167","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"fromLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_summary":"O(m*n) Create matrix from list of lists, it doesn't check if the list of list is a valid matrix","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","list","of","lists","it","doesn","t","check","if","the","list","of","list","is","a","valid","matrix"],"function":"fromLists = MG.fromLists","function_tokens":["fromLists","=","MG","fromLists"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L153-L153","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for if-and-only-if connective","docstring_summary":"A smart constructor for if-and-only-if connective","docstring_tokens":["A","smart","constructor","for","if","-","and","-","only","-","if","connective"],"function":"a .<->. b = (a .->. b) .&. (a .<-. b)","function_tokens":["a",".<->.","b","=","(","a",".->.","b",")",".&.","(","a",".<-.","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L485-L485","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty  = Empty","function_tokens":["mempty","=","Empty"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L304-L304","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Book _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Book _)                 = \"B\"","function_tokens":["go","(","Book","_",")","=","\"B\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L336-L336","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erf","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erf x\n    | abs x < 1 = erfseries x\n    | otherwise = 1 - erfc x","function_tokens":["erf","x","|","abs","x","<","1","=","erfseries","x","|","otherwise","=","1","-","erfc","x"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L34-L36","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"decode","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decode x =\n              case reads x of\n              [(r, \"\")] -> r\n              _ -> x","function_tokens":["decode","x","=","case","reads","x","of","[","(","r",",","\"\"",")","]","->","r","_","->","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L220-L224","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureStart","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"captureStart = captureStartStop \"alcCaptureStart\"","function_tokens":["captureStart","=","captureStartStop","\"alcCaptureStart\""],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L75-L75","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getPointsData","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getPointsData = do\n  bb      <- getRecBBox\n  nPoints <- getIntLE\n  points  <- replicateM nPoints getPoint\n  return (bb, nPoints, points)\n\n-- | Recurring pattern of a bounding box with polygon data","function_tokens":["getPointsData","=","do","bb","<-","getRecBBox","nPoints","<-","getIntLE","points","<-","replicateM","nPoints","getPoint","return","(","bb",",","nPoints",",","points",")","-- | Recurring pattern of a bounding box with polygon data"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L211-L218","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"matches","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matches = matchOnPrefix config cleanInput","function_tokens":["matches","=","matchOnPrefix","config","cleanInput"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L128-L128","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"getStringRaw","parameters":"maybeDevice","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getStringRaw maybeDevice =\n   alcGetString (marshalMaybeDevice maybeDevice) . marshalStringQuery","function_tokens":["getStringRaw","maybeDevice","=","alcGetString","(","marshalMaybeDevice","maybeDevice",")",".","marshalStringQuery"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L62-L63","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"mode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mode = IO.NewlineMode IO.nativeNewline nl","function_tokens":["mode","=","IO","NewlineMode","IO","nativeNewline","nl"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L171-L171","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pats","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pats  = replicate i wildP ++ [pats1 !! i] ++ repeat wildP","function_tokens":["pats","=","replicate","i","wildP","++","[","pats1","!!","i","]","++","repeat","wildP"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L517-L517","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"str","parameters":"k (Track d es)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"str k (Track d es) = Track (k*d) $ stretchTList k es","function_tokens":["str","k","(","Track","d","es",")","=","Track","(","k","*","d",")","$","stretchTList","k","es"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L105-L105","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"lStart","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lStart = GHC.srcSpanStartLine (f x)","function_tokens":["lStart","=","GHC","srcSpanStartLine","(","f","x",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L95-L95","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"x","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"x = var n","function_tokens":["x","=","var","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L777-L777","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Choosing m1 <> Choosing m2 = Choosing (m1 <|> m2)","function_tokens":["Choosing","m1","<>","Choosing","m2","=","Choosing","(","m1","<|>","m2",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L122-L122","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f ||| g = VarT $ \\case\n    Left b -> do\n      (d, f1) <- runVarT f b\n      return (d, f1 ||| g)\n    Right c -> do\n      (d, g1) <- runVarT g c\n      return (d, f ||| g1)\n\n-- | Inputs can depend on outputs as long as no time-travel is required.\n--\n-- This isn't the best example but it does make a good test case:\n--\n-- >>> :{\n-- let\n--   testVar :: VarT IO Double (Maybe Double)\n--   testVar = proc val -> do\n--     rec _ <- returnA -< 0.5\n--     returnA -< Just 5.0\n-- in\n--   testVarOver testVar [5.0]\n-- >>> :}\n-- Just 5.0","function_tokens":["f","|||","g","=","VarT","$","\\","case","Left","b","->","do","(","d",",","f1",")","<-","runVarT","f","b","return","(","d",",","f1","|||","g",")","Right","c","->","do","(","d",",","g1",")","<-","runVarT","g","c","return","(","d",",","f","|||","g1",")","-- | Inputs can depend on outputs as long as no time-travel is required.","--","-- This isn't the best example but it does make a good test case:","--","-- >>> :{","-- let","--   testVar :: VarT IO Double (Maybe Double)","--   testVar = proc val -> do","--     rec _ <- returnA -< 0.5","--     returnA -< Just 5.0","-- in","--   testVarOver testVar [5.0]","-- >>> :}","-- Just 5.0"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L168-L190","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mapTyVarBndr","parameters":"f (KindedTV n a flag)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapTyVarBndr f (KindedTV n a flag) = KindedTV (f n) a flag","function_tokens":["mapTyVarBndr","f","(","KindedTV","n","a","flag",")","=","KindedTV","(","f","n",")","a","flag"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L691-L691","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m *> k = m >>= const k","function_tokens":["m","*>","k","=","m",">>=","const","k"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L90-L90","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Empty.hs","language":"haskell","identifier":"guard","parameters":"True","argument_list":"","return_statement":"","docstring":"Conditional failure, returning only if the condition is 'True'.  @since 1.0.0.0","docstring_summary":"Conditional failure, returning only if the condition is 'True'.","docstring_tokens":["Conditional","failure","returning","only","if","the","condition","is","True","."],"function":"guard True  = pure ()","function_tokens":["guard","True","=","pure","(",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Empty.hs#L46-L46","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Empty.hs","hash_val":17478,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"e","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"e = 10 * (realToFrac t - 1)","function_tokens":["e","=","10","*","(","realToFrac","t","-","1",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L138-L138","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fsTys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fsTys = map (typeVariables . snd) (delete f fs)","function_tokens":["fsTys","=","map","(","typeVariables",".","snd",")","(","delete","f","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L360-L360","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"stepMany","parameters":"v (e:es) x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stepMany v (e:es) x = snd <$> runVarT v e >>= \\v1 -> stepMany v1 es x","function_tokens":["stepMany","v","(","e",":","es",")","x","=","snd","<$>","runVarT","v","e",">>=","\\","v1","->","stepMany","v1","es","x"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L387-L387","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"deleteArchiveComment","parameters":"","argument_list":"","return_statement":"","docstring":"Delete the archive's comment if it's present.","docstring_summary":"Delete the archive's comment if it's present.","docstring_tokens":["Delete","the","archive","s","comment","if","it","s","present","."],"function":"deleteArchiveComment = addPending I.DeleteArchiveComment","function_tokens":["deleteArchiveComment","=","addPending","I","DeleteArchiveComment"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L620-L620","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Store _ _ aa ia va `ieq1` Store _ _ ab ib vb = aa `ieq` ab && ia `ieq` ib && va `ieq` vb","function_tokens":["Store","_","_","aa","ia","va","`","ieq1","`","Store","_","_","ab","ib","vb","=","aa","`","ieq","`","ab","&&","ia","`","ieq","`","ib","&&","va","`","ieq","`","vb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L56-L56","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","language":"haskell","identifier":"readDbfFile","parameters":"fp","argument_list":"","return_statement":"","docstring":"Read dbf file at `fp` into resident data format `DbfData`","docstring_summary":"Read dbf file at `fp` into resident data format `DbfData`","docstring_tokens":["Read","dbf","file","at","fp","into","resident","data","format","DbfData"],"function":"readDbfFile fp = readDbfData <$> BL.readFile fp","function_tokens":["readDbfFile","fp","=","readDbfData","<$>","BL","readFile","fp"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs#L24-L24","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","hash_val":38792,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"go","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go []       = 0","function_tokens":["go","[","]","=","0"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L94-L94","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"dur","parameters":"","argument_list":"","return_statement":"","docstring":"The duration (in seconds) to tween in each direction.","docstring_summary":"The duration (in seconds) to tween in each direction.","docstring_tokens":["The","duration","(","in","seconds",")","to","tween","in","each","direction","."],"function":"dur = 3","function_tokens":["dur","=","3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L17-L17","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"totalEventDur","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"totalEventDur = (+) <$> eventStart <*> eventDur","function_tokens":["totalEventDur","=","(","+",")","<$>","eventStart","<*>","eventDur"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L320-L320","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Utils.hs","language":"haskell","identifier":"testProperty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"testProperty = Leaf","function_tokens":["testProperty","=","Leaf"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Utils.hs#L20-L20","hash_key":"fused-effects\/fused-effects:examples\/Utils.hs","hash_val":7652,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"ty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ty      = if concrete\n                   then concTy\n                   else if mono\n                        then [t| Mono.Lens $cat $tyI $tyO |]\n                        else [t| Poly.Lens $cat $tyI $tyO |]","function_tokens":["ty","=","if","concrete","then","concTy","else","if","mono","then","[","t","|"," Mono.Lens $cat $tyI $tyO ","|]","else","[","t","|"," Poly.Lens $cat $tyI $tyO ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L465-L469","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"tyClDecls","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tyClDecls       = [ tyClDecl | Hs.TyClD _ tyClDecl <- decls ]","function_tokens":["tyClDecls","=","[","tyClDecl","|","Hs","TyClD","_","tyClDecl","<-","decls","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L69-L69","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"aligns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"aligns =\n        [ (\"global\", Imports.Global)\n        , (\"file\",   Imports.File)\n        , (\"group\",  Imports.Group)\n        , (\"none\",   Imports.None)\n        ]","function_tokens":["aligns","=","[","(","\"global\"",",","Imports","Global",")",",","(","\"file\"",",","Imports","File",")",",","(","\"group\"",",","Imports","Group",")",",","(","\"none\"",",","Imports","None",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L295-L300","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"toStaticallySortedArrayAccess","parameters":"","argument_list":"","return_statement":"","docstring":"Tries to convert access to an array of some sort to an access to an array of a specific sort","docstring_summary":"Tries to convert access to an array of some sort to an access to an array of a specific sort","docstring_tokens":["Tries","to","convert","access","to","an","array","of","some","sort","to","an","access","to","an","array","of","a","specific","sort"],"function":"toStaticallySortedArrayAccess = elementSort <=< indexSort where\n  elementSort :: DynamicallySorted (ArrayAccess f i) -> Maybe (Array f e i, Index f i)\n  elementSort = fmap getAA . toStaticallySorted\n\n  indexSort :: DynamicArrayAccess f -> Maybe (DynamicallySorted (ArrayAccess f i))\n  indexSort = fmap getDVAA . toStaticallySorted\n\n-- | Collects pairs of arrays and indices that appear together in some @select@ and\/or @store@ within an expression","function_tokens":["toStaticallySortedArrayAccess","=","elementSort","<=<","indexSort","where","elementSort","::","DynamicallySorted","(","ArrayAccess","f","i",")","->","Maybe","(","Array","f","e","i",",","Index","f","i",")","elementSort","=","fmap","getAA",".","toStaticallySorted","indexSort","::","DynamicArrayAccess","f","->","Maybe","(","DynamicallySorted","(","ArrayAccess","f","i",")",")","indexSort","=","fmap","getDVAA",".","toStaticallySorted","-- | Collects pairs of arrays and indices that appear together in some @select@ and\/or @store@ within an expression"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L129-L137","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"go","parameters":"[] _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go [] _ = []","function_tokens":["go","[","]","_","=","[","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L370-L370","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union","parameters":"t (Tip _ x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"union t (Tip _ x) = insertR x t","function_tokens":["union","t","(","Tip","_","x",")","=","insertR","x","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L377-L377","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result,t') = minViewUnsigned l","function_tokens":["(","result",",","t'",")","=","minViewUnsigned","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L613-L613","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"izipWith3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith3 = MG.izipWith3","function_tokens":["izipWith3","=","MG","izipWith3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L288-L288","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"cnsts","parameters":"","argument_list":"","return_statement":"","docstring":"Collects a list of all constants occurring in an expression.","docstring_summary":"Collects a list of all constants occurring in an expression.","docstring_tokens":["Collects","a","list","of","all","constants","occurring","in","an","expression","."],"function":"cnsts = nub . F.getConst . icata cnsts' where\n    cnsts' :: forall (s' :: Sort). f (F.Const [IFix f 'IntegralSort]) s' -> F.Const [IFix f 'IntegralSort] s'\n    cnsts' a = case prj a of\n        Just (Const c) -> F.Const [cnst c]\n        _              -> ifold a","function_tokens":["cnsts","=","nub",".","F","getConst",".","icata","cnsts'","where","cnsts'","::","forall","(","s'","::","Sort",")",".","f","(","F","Const","[","IFix","f","'","IntegralSort","]",")","s'","->","F","Const","[","IFix","f","'","IntegralSort","]","s'","cnsts'","a","=","case","prj","a","of","Just","(","Const","c",")","->","F","Const","[","cnst","c","]","_","->","ifold","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L156-L162","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Chord a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Chord a) = pretty a","function_tokens":["go","(","Chord","a",")","=","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L186-L186","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"izipWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith = MG.izipWith","function_tokens":["izipWith","=","MG","izipWith"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L283-L283","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' v = Just (True, return . inject $ v)","function_tokens":["bind'","v","=","Just","(","True",",","return",".","inject","$","v",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L804-L804","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"index","parameters":"Or {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Or {} = SBooleanSort","function_tokens":["index","Or","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L357-L357","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"files'","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"files' x = case (saRecursive sa, null x) of\n      (True,True) -> []         -- No file to format and recursive enabled.\n      (_,True)    -> [Nothing]  -- Involving IO.stdin.\n      (_,False)   -> map Just x -- Process available files.","function_tokens":["files'","x","=","case","(","saRecursive","sa",",","null","x",")","of","(","True",",","True",")","->","[","]","-- No file to format and recursive enabled.","(","_",",","True",")","->","[","Nothing","]","-- Involving IO.stdin.","(","_",",","False",")","->","map","Just","x","-- Process available files."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L125-L130","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"opts","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"opts = info (configParser Config <**> helper) fullDesc","function_tokens":["opts","=","info","(","configParser","Config","<**>","helper",")","fullDesc"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L108-L108","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"cdSize","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cdSize = fromIntegral (B.length cd)","function_tokens":["cdSize","=","fromIntegral","(","B","length","cd",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L636-L636","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Empty -> Maybe.MaybeT (pure Nothing)\n    R other -> Maybe.MaybeT $ thread (maybe (pure Nothing) Maybe.runMaybeT ~<~ hdl) other (Just ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Empty","->","Maybe","MaybeT","(","pure","Nothing",")","R","other","->","Maybe","MaybeT","$","thread","(","maybe","(","pure","Nothing",")","Maybe","runMaybeT","~<~","hdl",")","other","(","Just","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L228-L231","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Forall as phi `ieq1` Forall bs psi = (foldr (&&) True $ zipWith ieq as bs) && phi `ieq` psi","function_tokens":["Forall","as","phi","`","ieq1","`","Forall","bs","psi","=","(","foldr","(","&&",")","True","$","zipWith","ieq","as","bs",")","&&","phi","`","ieq","`","psi"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L533-L533","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mf <*> ma = AccumC $ \\k w ->\n    runAccumC mf (\\w' f -> runAccumC ma (\\w'' a -> k (w' `mappend` w'') $ f a) (w `mappend` w')) w","function_tokens":["mf","<*>","ma","=","AccumC","$","\\","k","w","->","runAccumC","mf","(","\\","w'","f","->","runAccumC","ma","(","\\","w''","a","->","k","(","w'","`","mappend","`","w''",")","$","f","a",")","(","w","`","mappend","`","w'",")",")","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L93-L94","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_                  `ieq1` _                  = False","function_tokens":["_","`","ieq1","`","_","=","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L57-L57","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"q","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"q = [ 3.3690752069827527677\n            , 9.608965327192787870698\n            , 17.08144074746600431571095\n            , 12.0489519278551290360340491\n            , 9.396034016235054150430579648\n            , 2.260528520767326969591866945\n            , 1.0\n            ]","function_tokens":["q","=","[","3.3690752069827527677",",","9.608965327192787870698",",","17.08144074746600431571095",",","12.0489519278551290360340491",",","9.396034016235054150430579648",",","2.260528520767326969591866945",",","1.0","]"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L81-L88","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"r0","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r0 = rp `U.unsafeIndex` i","function_tokens":["r0","=","rp","`","U","unsafeIndex","`","i"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L86-L86","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"signed","parameters":"m","argument_list":"","return_statement":"","docstring":"Matches a signed number.","docstring_summary":"Matches a signed number.","docstring_tokens":["Matches","a","signed","number","."],"function":"signed m = (*) <$> (lift . lift) (A.signed (pure 1)) <*> m","function_tokens":["signed","m","=","(","*",")","<$>","(","lift",".","lift",")","(","A","signed","(","pure","1",")",")","<*>","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L109-L109","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"modifyCurrentLine","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modifyCurrentLine f = do\n    s0 <- get\n    put s0 {currentLine = f $ currentLine s0}","function_tokens":["modifyCurrentLine","f","=","do","s0","<-","get","put","s0","{","currentLine","=","f","$","currentLine","s0","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L326-L330","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"ishow","parameters":"(Store  _ _ a i v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Store  _ _ a i v) = coerce $ \"(store \" ++ coerce a ++ \" \" ++ coerce i ++ \" \" ++ coerce v ++ \")\"","function_tokens":["ishow","(","Store","_","_","a","i","v",")","=","coerce","$","\"(store \"","++","coerce","a","++","\" \"","++","coerce","i","++","\" \"","++","coerce","v","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L76-L76","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = RSST $ \\_ s -> pure (a, s)","function_tokens":["pure","a","=","RSST","$","\\","_","s","->","pure","(","a",",","s",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L145-L145","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"genObjectNames","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"genObjectNames n = liftIO $\n      allocaArray n $ \\buf -> do\n        alGenBuffers (fromIntegral n) buf\n        peekArray n buf","function_tokens":["genObjectNames","n","=","liftIO","$","allocaArray","n","$","\\","buf","->","do","alGenBuffers","(","fromIntegral","n",")","buf","peekArray","n","buf"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L72-L77","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"makeStandardJsonIbBps","parameters":"lbs","argument_list":"","return_statement":"","docstring":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_summary":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_tokens":["{","-","HLINT","ignore","Reduce","duplication","-","}","{","-","HLINT","ignore","Redundant","do","-","}"],"function":"makeStandardJsonIbBps lbs = if enabledMakeStandardJsonIbBps\n  then Right (makeStandardJsonIbBpsUnsafe lbs)\n  else Left \"makeStandardJsonIbBps function is disabled\"","function_tokens":["makeStandardJsonIbBps","lbs","=","if","enabledMakeStandardJsonIbBps","then","Right","(","makeStandardJsonIbBpsUnsafe","lbs",")","else","Left","\"makeStandardJsonIbBps function is disabled\""],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L32-L34","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"fg","parameters":"c (StylizedList l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fg c (StylizedList l) = StylizedList (map (fg c) l)","function_tokens":["fg","c","(","StylizedList","l",")","=","StylizedList","(","map","(","fg","c",")","l",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L97-L97","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"nameAndFlags","parameters":"opt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nameAndFlags opt =\n          case O.optMain opt of\n            O.CmdReader _ cmds p -> (`map` cmds) $ \\cmd ->\n              ( toText cmd,\n                maybe\n                  []\n                  ( O.infoParser\n                      >>> O.mapParser (const optnames)\n                      >>> concat\n                  )\n                  (p cmd)\n              )\n            _ -> mempty","function_tokens":["nameAndFlags","opt","=","case","O","optMain","opt","of","O","CmdReader","_","cmds","p","->","(","`","map","`","cmds",")","$","\\","cmd","->","(","toText","cmd",",","maybe","[","]","(","O","infoParser",">>>","O","mapParser","(","const","optnames",")",">>>","concat",")","(","p","cmd",")",")","_","->","mempty"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L119-L132","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"startsWith","parameters":"_ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"startsWith _ [] = False","function_tokens":["startsWith","_","[","]","=","False"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L23-L23","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"find","parameters":"(Bin _ _ _ _ _ r')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"find (Bin _ _ _ _ _ r') = find r'","function_tokens":["find","(","Bin","_","_","_","_","_","r'",")","=","find","r'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L656-L656","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = StateC (const empty)","function_tokens":["empty","=","StateC","(","const","empty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L92-L92","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"z'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"z' = f z x","function_tokens":["z'","=","f","z","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L997-L997","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_INVALID_DEVICE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_INVALID_DEVICE                  = 0xA001","function_tokens":["alc_INVALID_DEVICE","=","0xA001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L141-L141","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"echoP","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"echoP =\n      Echo\n        <$> many\n          ( O.strArgument $\n              mconcat\n                [ O.metavar \"STR\",\n                  O.help \"A string to print\"\n                ]\n          )","function_tokens":["echoP","=","Echo","<$>","many","(","O","strArgument","$","mconcat","[","O","metavar","\"STR\"",",","O","help","\"A string to print\"","]",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L39-L47","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"err","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"err = error \"moduleImportGroups: import without soure span\"","function_tokens":["err","=","error","\"moduleImportGroups: import without soure span\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L86-L86","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Tip _ _ `compare` Nil = GT","function_tokens":["Tip","_","_","`","compare","`","Nil","=","GT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L850-L850","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"result","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"result =\n        runSteps (configLanguageExtensions conf) mfp (configSteps conf) inputLines","function_tokens":["result","=","runSteps","(","configLanguageExtensions","conf",")","mfp","(","configSteps","conf",")","inputLines"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L151-L152","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"areaPolyCalc","parameters":"(sum,(x1,y1)) (x2, y2)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"areaPolyCalc (sum,(x1,y1)) (x2, y2) = (sum + (x1 * y2 - x2 * y1),(x2,y2))","function_tokens":["areaPolyCalc","(","sum",",","(","x1",",","y1",")",")","(","x2",",","y2",")","=","(","sum","+","(","x1","*","y2","-","x2","*","y1",")",",","(","x2",",","y2",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L65-L65","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"point","parameters":"","argument_list":"","return_statement":"","docstring":"Create lens from a `Point`.","docstring_summary":"Create lens from a `Point`.","docstring_tokens":["Create","lens","from","a","Point","."],"function":"point = Lens","function_tokens":["point","=","Lens"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L60-L60","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"izipWith5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith5 = MG.izipWith5","function_tokens":["izipWith5","=","MG","izipWith5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L298-L298","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"inject","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"inject = IFix . inj","function_tokens":["inject","=","IFix",".","inj"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L71-L71","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unsafeFreeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFreeze = MG.unsafeFreeze","function_tokens":["unsafeFreeze","=","MG","unsafeFreeze"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L381-L381","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/PPDiff.hs","language":"haskell","identifier":"ppDiff","parameters":"_ (Both x _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ppDiff _ (Both x _) =                ' ':x","function_tokens":["ppDiff","_","(","Both","x","_",")","=","' '",":","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/PPDiff.hs#L18-L18","hash_key":"Peaker\/git-mediate:src\/PPDiff.hs","hash_val":5685,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"takeDiag","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeDiag = MG.takeDiag","function_tokens":["takeDiag","=","MG","takeDiag"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L135-L135","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"format","parameters":"maybeConfigPath maybeFilePath contents","argument_list":"","return_statement":"","docstring":"Formats given contents optionally using the config provided as first param. The second file path is the location from which the contents were read. If provided, it's going to be printed out in the error message.","docstring_summary":"Formats given contents optionally using the config provided as first param. The second file path is the location from which the contents were read. If provided, it's going to be printed out in the error message.","docstring_tokens":["Formats","given","contents","optionally","using","the","config","provided","as","first","param",".","The","second","file","path","is","the","location","from","which","the","contents","were","read",".","If","provided","it","s","going","to","be","printed","out","in","the","error","message","."],"function":"format maybeConfigPath maybeFilePath contents = do\n  conf <- loadConfig (makeVerbose True) (fmap unConfigPath maybeConfigPath)\n  pure $ runSteps (configLanguageExtensions conf) maybeFilePath (configSteps conf) $ lines contents\n\n\n--------------------------------------------------------------------------------\n-- | Searches Haskell source files in any given folder recursively.","function_tokens":["format","maybeConfigPath","maybeFilePath","contents","=","do","conf","<-","loadConfig","(","makeVerbose","True",")","(","fmap","unConfigPath","maybeConfigPath",")","pure","$","runSteps","(","configLanguageExtensions","conf",")","maybeFilePath","(","configSteps","conf",")","$","lines","contents","--------------------------------------------------------------------------------","-- | Searches Haskell source files in any given folder recursively."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L114-L121","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"mRemoteTmp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mRemoteTmp = maybePath remoteTmpRaw","function_tokens":["mRemoteTmp","=","maybePath","remoteTmpRaw"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L157-L157","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"getFullName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getFullName = Just . whRepoFullName . repoForEvent . eventOf","function_tokens":["getFullName","=","Just",".","whRepoFullName",".","repoForEvent",".","eventOf"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L252-L252","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"sep","parameters":"s (first : rest)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sep s (first : rest) = first >> forM_ rest ((>>) s)","function_tokens":["sep","s","(","first",":","rest",")","=","first",">>","forM_","rest","(","(",">>",")","s",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L300-L300","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Environment.hs","language":"haskell","identifier":"stdin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stdin = \"\"","function_tokens":["stdin","=","\"\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Environment.hs#L34-L34","hash_key":"Peaker\/git-mediate:src\/Environment.hs","hash_val":17949,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"isSubsetOf","parameters":"t1@(Bin _ _ p1 m1 l1 r1) (Bin _ _ p2 m2 l2 r2)","argument_list":"","return_statement":"","docstring":"\/O(n+m)\/. Is this a subset? @(s1 `isSubsetOf` s2)@ tells whether @s1@ is a subset of @s2@.","docstring_summary":"\/O(n+m)\/. Is this a subset?","docstring_tokens":["\/","O","(","n","+","m",")","\/",".","Is","this","a","subset?"],"function":"isSubsetOf t1@(Bin _ _ p1 m1 l1 r1) (Bin _ _ p2 m2 l2 r2)\n  | shorter m1 m2  = False\n  | shorter m2 m1  = match p1 p2 m2 && (if zero p1 m2 then isSubsetOf t1 l2\n                                                      else isSubsetOf t1 r2)\n  | otherwise      = (p1==p2) && isSubsetOf l1 l2 && isSubsetOf r1 r2","function_tokens":["isSubsetOf","t1","@","(","Bin","_","_","p1","m1","l1","r1",")","(","Bin","_","_","p2","m2","l2","r2",")","|","shorter","m1","m2","=","False","|","shorter","m2","m1","=","match","p1","p2","m2","&&","(","if","zero","p1","m2","then","isSubsetOf","t1","l2","else","isSubsetOf","t1","r2",")","|","otherwise","=","(","p1","==","p2",")","&&","isSubsetOf","l1","l2","&&","isSubsetOf","r1","r2"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L483-L487","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_FORMAT_MONO16","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_FORMAT_MONO16                    = 0x1101","function_tokens":["al_FORMAT_MONO16","=","0x1101"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L120-L120","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(DeleteEntryComment s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (DeleteEntryComment s) = Just s","function_tokens":["targetEntry","(","DeleteEntryComment","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1059-L1059","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Composer a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Composer a)             = a","function_tokens":["go","(","Composer","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L407-L407","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"liftIO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO = lift . liftIO","function_tokens":["liftIO","=","lift",".","liftIO"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L167-L167","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"forEntries","parameters":"action","argument_list":"","return_statement":"","docstring":"Perform an action on every entry in the archive.","docstring_summary":"Perform an action on every entry in the archive.","docstring_tokens":["Perform","an","action","on","every","entry","in","the","archive","."],"function":"forEntries action = getEntries >>= mapM_ action . M.keysSet","function_tokens":["forEntries","action","=","getEntries",">>=","mapM_","action",".","M","keysSet"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L612-L612","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Reader.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = 100000","function_tokens":["n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Reader.hs#L37-L37","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Reader.hs","hash_val":22189,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"null","parameters":"Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"null Nil = True","function_tokens":["null","Nil","=","True"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L249-L249","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"haddocks","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"haddocks = GHC.hsmodHaddockModHeader modul","function_tokens":["haddocks","=","GHC","hsmodHaddockModHeader","modul"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L72-L72","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INVALID_NAME","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INVALID_NAME                     = 0xA001","function_tokens":["al_INVALID_NAME","=","0xA001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L32-L32","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual = not . inject","function_tokens":["dual","=","not",".","inject"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L687-L687","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label.hs","language":"haskell","identifier":"lens","parameters":"g s","argument_list":"","return_statement":"","docstring":"Create a total lens from a getter and a modifier.  We expect the following law to hold:  > get l (modify l m f) == m (get l f)","docstring_summary":"Create a total lens from a getter and a modifier.  We expect the following law to hold:  > get l (modify l m f) == m (get l f)","docstring_tokens":["Create","a","total","lens","from","a","getter","and","a","modifier",".","We","expect","the","following","law","to","hold",":",">","get","l","(","modify","l","m","f",")","==","m","(","get","l","f",")"],"function":"lens g s = Mono.lens g (uncurry s)","function_tokens":["lens","g","s","=","Mono","lens","g","(","uncurry","s",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label.hs#L195-L195","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label.hs","hash_val":23450,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"longestLeft","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"longestLeft = maximum $ map (GHC.srcSpanEndCol . aLeft) alignment","function_tokens":["longestLeft","=","maximum","$","map","(","GHC","srcSpanEndCol",".","aLeft",")","alignment"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L73-L73","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Utils.hs","language":"haskell","identifier":"toRadians","parameters":"","argument_list":"","return_statement":"","docstring":"Convert both co\u00f6rdinates to radians.","docstring_summary":"Convert both co\u00f6rdinates to radians.","docstring_tokens":["Convert","both","co\u00f6rdinates","to","radians","."],"function":"toRadians = (over _1 radians) . (over _2 radians)","function_tokens":["toRadians","=","(","over","_1","radians",")",".","(","over","_2","radians",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Utils.hs#L15-L15","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Utils.hs","hash_val":44272,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"local","parameters":"f rw","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"local f rw = RSST $ \\r s -> runRSST' rw (f r) s","function_tokens":["local","f","rw","=","RSST","$","\\","r","s","->","runRSST'","rw","(","f","r",")","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L182-L182","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m <|> n = RSST $ \\r s -> runRSST' m r s <|> runRSST' n r s","function_tokens":["m","<|>","n","=","RSST","$","\\","r","s","->","runRSST'","m","r","s","<|>","runRSST'","n","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L153-L153","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"update","parameters":"l m","argument_list":"","return_statement":"","docstring":"Like `modify`, but update allows, depending on the underlying lens, to remove items by modifying to `Nothing`.","docstring_summary":"Like `modify`, but update allows, depending on the underlying lens, to remove items by modifying to `Nothing`.","docstring_tokens":["Like","modify","but","update","allows","depending","on","the","underlying","lens","to","remove","items","by","modifying","to","Nothing","."],"function":"update l m = runKleisli (Poly.modify l . arr ((,) (Kleisli m)))","function_tokens":["update","l","m","=","runKleisli","(","Poly","modify","l",".","arr","(","(",",",")","(","Kleisli","m",")",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L100-L100","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getShpBBox","parameters":"t","argument_list":"","return_statement":"","docstring":"Read a bounding box for relevant record type. Not all bounding boxes have Z\/M coordinates.","docstring_summary":"Read a bounding box for relevant record type. Not all bounding boxes have Z\/M coordinates.","docstring_tokens":["Read","a","bounding","box","for","relevant","record","type",".","Not","all","bounding","boxes","have","Z","\/","M","coordinates","."],"function":"getShpBBox t = do\n  [xMin, yMin, xMax, yMax] <- replicateM 4 getFloat64le\n  [zMin, zMax]             <- let ds = replicateM 2 getFloat64le\n                               in if t `elem` zTypes\n                                     then map Just <$> ds\n                                     else ds >> return [Nothing, Nothing]\n  [mMin, mMax]             <- let ds = replicateM 2 getFloat64le\n                               in if t `elem` mTypes\n                                     then map Just <$> ds\n                                     else ds >> return [Nothing, Nothing]\n  return ShpBBox { shpXMin = xMin,\n              shpXMax = xMax,\n              shpYMin = yMin,\n              shpYMax = yMax,\n              shpZMin = zMin,\n              shpZMax = zMax,\n              shpMMin = mMin,\n              shpMMax = mMax }\n\n-- | Read a single record","function_tokens":["getShpBBox","t","=","do","[","xMin",",","yMin",",","xMax",",","yMax","]","<-","replicateM","4","getFloat64le","[","zMin",",","zMax","]","<-","let","ds","=","replicateM","2","getFloat64le","in","if","t","`","elem","`","zTypes","then","map","Just","<$>","ds","else","ds",">>","return","[","Nothing",",","Nothing","]","[","mMin",",","mMax","]","<-","let","ds","=","replicateM","2","getFloat64le","in","if","t","`","elem","`","mTypes","then","map","Just","<$>","ds","else","ds",">>","return","[","Nothing",",","Nothing","]","return","ShpBBox","{","shpXMin","=","xMin",",","shpXMax","=","xMax",",","shpYMin","=","yMin",",","shpYMax","=","yMax",",","shpZMin","=","zMin",",","shpZMax","=","zMax",",","shpMMin","=","mMin",",","shpMMax","=","mMax","}","-- | Read a single record"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L57-L77","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mono","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L347-L347","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"align'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"align' a = Editor.changeLine (GHC.srcSpanStartLine $ aContainer a) $ \\str ->\n      let column = GHC.srcSpanEndCol $ aLeft a\n          (pre, post) = splitAt column str\n      in [padRight longestLeft (trimRight pre) ++ trimLeft post]","function_tokens":["align'","a","=","Editor","changeLine","(","GHC","srcSpanStartLine","$","aContainer","a",")","$","\\","str","->","let","column","=","GHC","srcSpanEndCol","$","aLeft","a","(","pre",",","post",")","=","splitAt","column","str","in","[","padRight","longestLeft","(","trimRight","pre",")","++","trimLeft","post","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L82-L85","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"changes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changes = mconcat\n      [ Editor.changeLines b (const $ prettyPragmas lngPrefix columns longest align style pg)\n      | (b, pg) <- filterRedundant isRedundant' groups\n      ]","function_tokens":["changes","=","mconcat","[","Editor","changeLines","b","(","const","$","prettyPragmas","lngPrefix","columns","longest","align","style","pg",")","|","(","b",",","pg",")","<-","filterRedundant","isRedundant'","groups","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L147-L150","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"apps","parameters":"f as","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"apps f as = foldl appE f as","function_tokens":["apps","f","as","=","foldl","appE","f","as"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L551-L551","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"go","parameters":"(BLam v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (BLam v t e) = Lam i v t e","function_tokens":["go","(","BLam","v","t","e",")","=","Lam","i","v","t","e"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L37-L37","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Add w) -> ctx <$ Accum.add w\n    L Look    -> Accum.looks (<$ ctx)\n    R other   -> Accum.AccumT $ \\w -> getSwap <$> thread ((\\(Swap (x, s)) -> Swap . fmap (mappend s) <$> Accum.runAccumT x s) ~<~ hdl) other (Swap (ctx, w))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Add","w",")","->","ctx","<$","Accum","add","w","L","Look","->","Accum","looks","(","<$","ctx",")","R","other","->","Accum","AccumT","$","\\","w","->","getSwap","<$>","thread","(","(","\\","(","Swap","(","x",",","s",")",")","->","Swap",".","fmap","(","mappend","s",")","<$>","Accum","runAccumT","x","s",")","~<~","hdl",")","other","(","Swap","(","ctx",",","w",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L338-L342","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"parenthesize","parameters":"action","argument_list":"","return_statement":"","docstring":"Add parens around a printed action","docstring_summary":"Add parens around a printed action","docstring_tokens":["Add","parens","around","a","printed","action"],"function":"parenthesize action = putText \"(\" *> action <* putText \")\"","function_tokens":["parenthesize","action","=","putText","\"(\"","*>","action","<*","putText","\")\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L295-L295","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getShpType","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getShpType = shpTypeFromId <$> getIntLE","function_tokens":["getShpType","=","shpTypeFromId","<$>","getIntLE"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L52-L52","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"modify","parameters":"","argument_list":"","return_statement":"","docstring":"Get the modifier arrow from a lens.","docstring_summary":"Get the modifier arrow from a lens.","docstring_tokens":["Get","the","modifier","arrow","from","a","lens","."],"function":"modify = Point.modify . unpack","function_tokens":["modify","=","Point","modify",".","unpack"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L70-L70","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"and","parameters":"[a]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"and [a] = a","function_tokens":["and","[","a","]","=","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L509-L509","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getExtraField","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getExtraField = do\n  header <- getWord16le -- header id\n  size <- getWord16le -- data size\n  body <- getBytes (fromIntegral size) -- content\n  return (header, body)\n\n-- | Get signature. If the extracted data is not equal to the provided\n-- signature, fail.","function_tokens":["getExtraField","=","do","header","<-","getWord16le","-- header id","size","<-","getWord16le","-- data size","body","<-","getBytes","(","fromIntegral","size",")","-- content","return","(","header",",","body",")","-- | Get signature. If the extracted data is not equal to the provided","-- signature, fail."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L740-L748","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"delayEvent","parameters":"d e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delayEvent d e = e{ eventStart = eventStart e + d }","function_tokens":["delayEvent","d","e","=","e","{","eventStart","=","eventStart","e","+","d","}"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L214-L214","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"configured","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"configured =\n            changes records (recordToAlignable config) <>\n            changes everything (matchGroupToAlignable config) <>\n            changes everything (multiWayIfToAlignable config)","function_tokens":["configured","=","changes","records","(","recordToAlignable","config",")","<>","changes","everything","(","matchGroupToAlignable","config",")","<>","changes","everything","(","multiWayIfToAlignable","config",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L195-L198","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"catchError","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"catchError = liftCatch catchError","function_tokens":["catchError","=","liftCatch","catchError"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L208-L208","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified' _ = coerce True","function_tokens":["isQuantified'","_","=","coerce","True"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L625-L625","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"rnf","parameters":"(MMatrix _ _ _ _ vec)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rnf (MMatrix _ _ _ _ vec) = rnf vec","function_tokens":["rnf","(","MMatrix","_","_","_","_","vec",")","=","rnf","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L28-L28","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWithM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM_ = MG.zipWithM_","function_tokens":["zipWithM_","=","MG","zipWithM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L340-L340","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"addEntry","parameters":"t b s","argument_list":"","return_statement":"","docstring":"-------------------------------------------------------------------------- Modifying archive Add a new entry to the archive given its contents in binary form.","docstring_summary":"-------------------------------------------------------------------------- Modifying archive Add a new entry to the archive given its contents in binary form.","docstring_tokens":["--------------------------------------------------------------------------","Modifying","archive","Add","a","new","entry","to","the","archive","given","its","contents","in","binary","form","."],"function":"addEntry t b s = addPending (I.SinkEntry t (C.yield b) s)","function_tokens":["addEntry","t","b","s","=","addPending","(","I","SinkEntry","t","(","C","yield","b",")","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L434-L434","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"decimal","parameters":"","argument_list":"","return_statement":"","docstring":"Matches a given decimal number.","docstring_summary":"Matches a given decimal number.","docstring_tokens":["Matches","a","given","decimal","number","."],"function":"decimal = lift . lift $ A.decimal","function_tokens":["decimal","=","lift",".","lift","$","A","decimal"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L89-L89","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"f","parameters":"(outs, v') a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f (outs, v') a = do (b, v'') <- runVarT v' a\n                              return (outs ++ [b], v'')\n--------------------------------------------------------------------------------\n-- Testing and debugging\n--------------------------------------------------------------------------------\n-- | Trace the sample value of a var and pass it along as output. This is\n-- very useful for debugging graphs of vars. The (v|vs|vf)trace family of\n-- vars use 'Debug.Trace.trace' under the hood, so the value is only traced\n-- when evaluated.\n--\n-- >>> let v = id >>> vtrace\n-- >>> testVarOver v [1,2,3]\n-- 1\n-- 1\n-- 2\n-- 2\n-- 3\n-- 3","function_tokens":["f","(","outs",",","v'",")","a","=","do","(","b",",","v''",")","<-","runVarT","v'","a","return","(","outs","++","[","b","]",",","v''",")","--------------------------------------------------------------------------------","-- Testing and debugging","--------------------------------------------------------------------------------","-- | Trace the sample value of a var and pass it along as output. This is","-- very useful for debugging graphs of vars. The (v|vs|vf)trace family of","-- vars use 'Debug.Trace.trace' under the hood, so the value is only traced","-- when evaluated.","--","-- >>> let v = id >>> vtrace","-- >>> testVarOver v [1,2,3]","-- 1","-- 1","-- 2","-- 2","-- 3","-- 3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L397-L415","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"r","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r = 6371","function_tokens":["r","=","6371"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L24-L24","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty = go\n        where\n            go Common           = \"C\"\n            go Cut              = \"C|\"\n            go (Simple a)       = string $ showRatio a\n            go (Compound as a)  = sepBy \"+\" (fmap integer as) <> \"\/\" <> integer a","function_tokens":["pretty","=","go","where","go","Common","=","\"C\"","go","Cut","=","\"C|\"","go","(","Simple","a",")","=","string","$","showRatio","a","go","(","Compound","as","a",")","=","sepBy","\"+\"","(","fmap","integer","as",")","<>","\"\/\"","<>","integer","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L490-L504","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"await","parameters":"","argument_list":"","return_statement":"","docstring":"'Conduit.await' wrapped as a 'ConduitParser'.  If no data is available, 'UnexpectedEndOfInput' is thrown.","docstring_summary":"'Conduit.await' wrapped as a 'ConduitParser'.  If no data is available, 'UnexpectedEndOfInput' is thrown.","docstring_tokens":["Conduit",".","await","wrapped","as","a","ConduitParser",".","If","no","data","is","available","UnexpectedEndOfInput","is","thrown","."],"function":"await = do\n  event <- ConduitParser $ lift $ lift Conduit.await\n  e     <- maybe (throwError UnexpectedEndOfInput) return event\n  withBuffer $ prependItem e\n  return e\n\n-- | 'Conduit.leftover' wrapped as a 'ConduitParser'.","function_tokens":["await","=","do","event","<-","ConduitParser","$","lift","$","lift","Conduit","await","e","<-","maybe","(","throwError","UnexpectedEndOfInput",")","return","event","withBuffer","$","prependItem","e","return","e","-- | 'Conduit.leftover' wrapped as a 'ConduitParser'."],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L172-L179","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"desc2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desc2 =\n        desc1\n          { edVersionNeeded =\n              getZipVersion (needsZip64 desc1) (Just compression)\n          }","function_tokens":["desc2","=","desc1","{","edVersionNeeded","=","getZipVersion","(","needsZip64","desc1",")","(","Just","compression",")","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L556-L560","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"match","parameters":"","argument_list":"","return_statement":"","docstring":"Try to unpack a sum into a component.","docstring_summary":"Try to unpack a sum into a component.","docstring_tokens":["Try","to","unpack","a","sum","into","a","component","."],"function":"match = prj . unIFix","function_tokens":["match","=","prj",".","unIFix"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L75-L75","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"underline","parameters":"(StylizedList l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"underline (StylizedList l) = StylizedList (map underline l)","function_tokens":["underline","(","StylizedList","l",")","=","StylizedList","(","map","underline","l",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L118-L118","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(History _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (History _)              = \"H\"","function_tokens":["go","(","History","_",")","=","\"H\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L341-L341","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mappendTrack","parameters":"(Track d es) (Track d' es')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappendTrack (Track d es) (Track d' es') =\n    Track (maxB d d') $ mappend es es'","function_tokens":["mappendTrack","(","Track","d","es",")","(","Track","d'","es'",")","=","Track","(","maxB","d","d'",")","$","mappend","es","es'"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L95-L96","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"fmap","parameters":"f m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f m = StateC $ \\ s -> (\\ ~(s', a) -> (s', f a)) <$> runState s m","function_tokens":["fmap","f","m","=","StateC","$","\\","s","->","(","\\","~","(","s'",",","a",")","->","(","s'",",","f","a",")",")","<$>","runState","s","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L77-L77","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"newQFactor","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newQFactor = qFactor + diffWeight * (time - newMean)","function_tokens":["newQFactor","=","qFactor","+","diffWeight","*","(","time","-","newMean",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L382-L382","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"prettyPragmas","parameters":"lp cols _       align CompactLine","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyPragmas lp cols _       align CompactLine     = compactLinePragmas lp cols align","function_tokens":["prettyPragmas","lp","cols","_","align","CompactLine","=","compactLinePragmas","lp","cols","align"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L95-L95","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"comment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"comment = B.take 0xffff (maybe B.empty T.encodeUtf8 edComment)","function_tokens":["comment","=","B","take","0xffff","(","maybe","B","empty","T","encodeUtf8","edComment",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L821-L821","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"h","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"h = handle inst","function_tokens":["h","=","handle","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L161-L161","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(And as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (And as) = coerce $ \"(and \" ++ intercalate \" \" (coerce as) ++ \")\"","function_tokens":["ishow","(","And","as",")","=","coerce","$","\"(and \"","++","intercalate","\" \"","(","coerce","as",")","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L385-L385","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/SideDiff.hs","language":"haskell","identifier":"getConflictDiff2s","parameters":"Conflict{cMarkers, cBodies}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getConflictDiff2s Conflict{cMarkers, cBodies} =\n    (markerA, markerB, getDiff bodyA bodyB)\n    where\n        Sides markerA _ markerB = cMarkers\n        Sides bodyA _ bodyB = cBodies","function_tokens":["getConflictDiff2s","Conflict","{","cMarkers",",","cBodies","}","=","(","markerA",",","markerB",",","getDiff","bodyA","bodyB",")","where","Sides","markerA","_","markerB","=","cMarkers","Sides","bodyA","_","bodyB","=","cBodies"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/SideDiff.hs#L29-L33","hash_key":"Peaker\/git-mediate:src\/SideDiff.hs","hash_val":4146,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"configMaxColumns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"configMaxColumns =\n      maybe Data.NoMaxColumns Data.MaxColumns (configColumns c)","function_tokens":["configMaxColumns","=","maybe","Data","NoMaxColumns","Data","MaxColumns","(","configColumns","c",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L259-L260","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"tys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tys = (if cSortDeriving then sortBy compareOutputableCI else id) $\n            map (GHC.sig_body . GHC.unLoc) $\n            derivingClauseTypes clause","function_tokens":["tys","=","(","if","cSortDeriving","then","sortBy","compareOutputableCI","else","id",")","$","map","(","GHC","sig_body",".","GHC","unLoc",")","$","derivingClauseTypes","clause"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L229-L231","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DPi v t e    == DPi v' t' e'  = v == v' && t == t' && e == e'","function_tokens":["DPi","v","t","e","==","DPi","v'","t'","e'","=","v","==","v'","&&","t","==","t'","&&","e","==","e'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L61-L61","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"length","parameters":"Menu {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"length Menu {..} = length _menuItems","function_tokens":["length","Menu","{","..","}","=","length","_menuItems"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L67-L67","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Trace\/Ignoring.hs","language":"haskell","identifier":"alg","parameters":"hdl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl = \\case\n    L (Trace _) -> pure\n    R other     -> TraceC . alg (runTrace . hdl) other","function_tokens":["alg","hdl","=","\\","case","L","(","Trace","_",")","->","pure","R","other","->","TraceC",".","alg","(","runTrace",".","hdl",")","other"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Trace\/Ignoring.hs#L52-L55","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Trace\/Ignoring.hs","hash_val":10926,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"typeFromBinder","parameters":"(KindedTV tv _ kind)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"typeFromBinder (KindedTV tv _ kind) = SigT (VarT tv) kind","function_tokens":["typeFromBinder","(","KindedTV","tv","_","kind",")","=","SigT","(","VarT","tv",")","kind"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L618-L618","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = StateC $ \\ s -> case sig of\n    L Get     -> pure (s, s <$ ctx)\n    L (Put s) -> pure (s, ctx)\n    R other   -> thread (uncurry runState ~<~ hdl) other (s, ctx)","function_tokens":["alg","hdl","sig","ctx","=","StateC","$","\\","s","->","case","sig","of","L","Get","->","pure","(","s",",","s","<$","ctx",")","L","(","Put","s",")","->","pure","(","s",",","ctx",")","R","other","->","thread","(","uncurry","runState","~<~","hdl",")","other","(","s",",","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L125-L129","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(asFptr, _, _) = BSI.toForeignPtr as","function_tokens":["(","asFptr",",","_",",","_",")","=","BSI","toForeignPtr","as"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L105-L105","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"dt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dt  = dur \/ (fromIntegral $ length xs)","function_tokens":["dt","=","dur","\/","(","fromIntegral","$","length","xs",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L409-L409","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"asinh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"asinh = fmap asinh","function_tokens":["asinh","=","fmap","asinh"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L249-L249","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"vftrace","parameters":"f","argument_list":"","return_statement":"","docstring":"Trace the sample value using a custom show-like function. This is useful when you would like to debug a var that uses values that don't have show instances.  >>> newtype NotShowableInt = NotShowableInt { unNotShowableInt :: Int } >>> let v = id >>> vftrace ((\"NotShowableInt: \" ++) . show . unNotShowableInt) >>> let as = map NotShowableInt [1,1,1] >>> bs <- fst <$> scanVar v as >>> -- We need to do something to evaluate these output values... >>> print $ sum $ map unNotShowableInt bs NotShowableInt: 1 NotShowableInt: 1 NotShowableInt: 1 3","docstring_summary":"Trace the sample value using a custom show-like function. This is useful when you would like to debug a var that uses values that don't have show instances.  >>> newtype NotShowableInt = NotShowableInt { unNotShowableInt :: Int } >>> let v = id >>> vftrace ((\"NotShowableInt: \" ++) . show . unNotShowableInt) >>> let as = map NotShowableInt [1,1,1] >>> bs <- fst <$> scanVar v as >>> -- We need to do something to evaluate these output values... >>> print $ sum $ map unNotShowableInt bs NotShowableInt: 1 NotShowableInt: 1 NotShowableInt: 1 3","docstring_tokens":["Trace","the","sample","value","using","a","custom","show","-","like","function",".","This","is","useful","when","you","would","like","to","debug","a","var","that","uses","values","that","don","t","have","show","instances",".",">>>","newtype","NotShowableInt","=","NotShowableInt","{","unNotShowableInt","::","Int","}",">>>","let","v","=","id",">>>","vftrace","((","NotShowableInt",":","++",")",".","show",".","unNotShowableInt",")",">>>","let","as","=","map","NotShowableInt","[","1","1","1","]",">>>","bs","<","-","fst","<$",">","scanVar","v","as",">>>","--","We","need","to","do","something","to","evaluate","these","output","values","...",">>>","print","$","sum","$","map","unNotShowableInt","bs","NotShowableInt",":","1","NotShowableInt",":","1","NotShowableInt",":","1","3"],"function":"vftrace f = var $ \\b -> trace (f b) b","function_tokens":["vftrace","f","=","var","$","\\","b","->","trace","(","f","b",")","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L448-L448","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"len","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"len = maximum (map (length . name) bs)","function_tokens":["len","=","maximum","(","map","(","length",".","name",")","bs",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L140-L140","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"go","parameters":"!col ('\\t':rest)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go !col ('\\t':rest) = replicate (size - col) ' ' ++ go 0 rest","function_tokens":["go","col","(","'\\t'",":","rest",")","=","replicate","(","size","-","col",")","' '","++","go","0","rest"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L88-L88","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"takeColumn","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeColumn = MG.takeColumn","function_tokens":["takeColumn","=","MG","takeColumn"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L132-L132","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"typeFromBinder","parameters":"(PlainTV  tv      _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"typeFromBinder (PlainTV  tv      _) = VarT tv","function_tokens":["typeFromBinder","(","PlainTV","tv","_",")","=","VarT","tv"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L611-L611","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"pickProjection","parameters":"str","argument_list":"","return_statement":"","docstring":"Parse a `Maybe String` into the appropriate `Projection`, doing nothing for a `Nothing`","docstring_summary":"Parse a `Maybe String` into the appropriate `Projection`, doing nothing for a `Nothing`","docstring_tokens":["Parse","a","Maybe","String","into","the","appropriate","Projection","doing","nothing","for","a","Nothing"],"function":"pickProjection str = case str of\n    Just \"mercator\" -> mercator\n    Just \"bonne\" -> bonne\n    Just \"albers\" -> albers washingtonDC\n    Just \"winkel3\" -> winkel3\n    Just \"littow\" -> littow\n    Nothing -> id","function_tokens":["pickProjection","str","=","case","str","of","Just","\"mercator\"","->","mercator","Just","\"bonne\"","->","bonne","Just","\"albers\"","->","albers","washingtonDC","Just","\"winkel3\"","->","winkel3","Just","\"littow\"","->","littow","Nothing","->","id"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L98-L104","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictSourceType","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictSourceType = Dictionary {\n   alGetter  = alGetSourceiv,\n   alSetter  = undefined,\n   size      = 1,\n   peekSize  = peek1 unmarshalSourceType,\n   marshal   = undefined }","function_tokens":["dictSourceType","=","Dictionary","{","alGetter","=","alGetSourceiv",",","alSetter","=","undefined",",","size","=","1",",","peekSize","=","peek1","unmarshalSourceType",",","marshal","=","undefined","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L531-L536","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"maybeKindSig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maybeKindSig = GHC.dd_kindSig dataDefn","function_tokens":["maybeKindSig","=","GHC","dd_kindSig","dataDefn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L324-L324","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"res","parameters":"(InR a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"res (InR a) = Just a","function_tokens":["res","(","InR","a",")","=","Just","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L62-L62","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"imap","parameters":"f (Mul ms)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Mul ms)         = Mul $ map f ms","function_tokens":["imap","f","(","Mul","ms",")","=","Mul","$","map","f","ms"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L71-L71","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"split","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"split x t\n  = case t of\n      Bin _ _ _ m l r\n        | m < 0       -> if x >= 0 then let (lt,gt) = split' x l in (union r lt, gt)\n                                   else let (lt,gt) = split' x r in (lt, union gt l)\n                                   -- handle negative numbers.\n        | otherwise   -> split' x t\n      Tip _ y\n        | x>y         -> (t,Nil)\n        | x<y         -> (Nil,t)\n        | otherwise   -> (Nil,Nil)\n      Nil             -> (Nil, Nil)","function_tokens":["split","x","t","=","case","t","of","Bin","_","_","_","m","l","r","|","m","<","0","->","if","x",">=","0","then","let","(","lt",",","gt",")","=","split'","x","l","in","(","union","r","lt",",","gt",")","else","let","(","lt",",","gt",")","=","split'","x","r","in","(","lt",",","union","gt","l",")","-- handle negative numbers.","|","otherwise","->","split'","x","t","Tip","_","y","|","x",">","y","->","(","t",",","Nil",")","|","x","<","y","->","(","Nil",",","t",")","|","otherwise","->","(","Nil",",","Nil",")","Nil","->","(","Nil",",","Nil",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L527-L540","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"optimize","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"optimize =\n  foldl'\n    f\n    ( ProducingActions M.empty M.empty,\n      EditingActions M.empty M.empty M.empty M.empty M.empty M.empty M.empty\n    )\n  where\n    f (pa, ea) a = case a of\n      SinkEntry m src s ->\n        ( pa\n            { paSinkEntry = M.insert s src (paSinkEntry pa),\n              paCopyEntry = M.map (M.filter (\/= s)) (paCopyEntry pa)\n            },\n          (clearEditingFor s ea)\n            { eaCompression = M.insert s m (eaCompression ea)\n            }\n        )\n      CopyEntry path os ns ->\n        ( pa\n            { paSinkEntry = M.delete ns (paSinkEntry pa),\n              paCopyEntry = M.alter (ef os ns) path (paCopyEntry pa)\n            },\n          clearEditingFor ns ea\n        )\n      RenameEntry os ns ->\n        ( pa\n            { paCopyEntry = M.map (M.map $ re os ns) (paCopyEntry pa),\n              paSinkEntry = renameKey os ns (paSinkEntry pa)\n            },\n          ea\n            { eaCompression = renameKey os ns (eaCompression ea),\n              eaEntryComment = renameKey os ns (eaEntryComment ea),\n              eaDeleteComment = renameKey os ns (eaDeleteComment ea),\n              eaModTime = renameKey os ns (eaModTime ea),\n              eaExtraField = renameKey os ns (eaExtraField ea),\n              eaDeleteField = renameKey os ns (eaDeleteField ea)\n            }\n        )\n      DeleteEntry s ->\n        ( pa\n            { paSinkEntry = M.delete s (paSinkEntry pa),\n              paCopyEntry = M.map (M.delete s) (paCopyEntry pa)\n            },\n          clearEditingFor s ea\n        )\n      Recompress m s ->\n        (pa, ea {eaCompression = M.insert s m (eaCompression ea)})\n      SetEntryComment txt s ->\n        ( pa,\n          ea\n            { eaEntryComment = M.insert s txt (eaEntryComment ea),\n              eaDeleteComment = M.delete s (eaDeleteComment ea)\n            }\n        )\n      DeleteEntryComment s ->\n        ( pa,\n          ea\n            { eaEntryComment = M.delete s (eaEntryComment ea),\n              eaDeleteComment = M.insert s () (eaDeleteComment ea)\n            }\n        )\n      SetModTime time s ->\n        (pa, ea {eaModTime = M.insert s time (eaModTime ea)})\n      AddExtraField n b s ->\n        ( pa,\n          ea\n            { eaExtraField = M.alter (ef n b) s (eaExtraField ea),\n              eaDeleteField = M.delete s (eaDeleteField ea)\n            }\n        )\n      DeleteExtraField n s ->\n        ( pa,\n          ea\n            { eaExtraField = M.alter (er n) s (eaExtraField ea),\n              eaDeleteField = M.alter (ef n ()) s (eaDeleteField ea)\n            }\n        )\n      SetExternalFileAttributes b s ->\n        ( pa,\n          ea {eaExtFileAttr = M.insert s b (eaExtFileAttr ea)}\n        )\n      _ -> (pa, ea)\n    clearEditingFor s ea =\n      ea\n        { eaCompression = M.delete s (eaCompression ea),\n          eaEntryComment = M.delete s (eaEntryComment ea),\n          eaDeleteComment = M.delete s (eaDeleteComment ea),\n          eaModTime = M.delete s (eaModTime ea),\n          eaExtraField = M.delete s (eaExtraField ea),\n          eaDeleteField = M.delete s (eaDeleteField ea),\n          eaExtFileAttr = M.delete s (eaExtFileAttr ea)\n        }\n    re o n x = if x == o then n else x\n    ef k v (Just m) = Just (M.insert k v m)\n    ef k v Nothing = Just (M.singleton k v)\n    er k (Just m) =\n      let n = M.delete k m\n       in if M.null n then Nothing else Just n\n    er _ Nothing = Nothing\n\n-- | Copy entries from another archive and write them into the file\n-- associated with the given handle. This can throw 'EntryDoesNotExist' if\n-- there is no such entry in that archive.","function_tokens":["optimize","=","foldl'","f","(","ProducingActions","M","empty","M","empty",",","EditingActions","M","empty","M","empty","M","empty","M","empty","M","empty","M","empty","M","empty",")","where","f","(","pa",",","ea",")","a","=","case","a","of","SinkEntry","m","src","s","->","(","pa","{","paSinkEntry","=","M","insert","s","src","(","paSinkEntry","pa",")",",","paCopyEntry","=","M","map","(","M","filter","(","\/=","s",")",")","(","paCopyEntry","pa",")","}",",","(","clearEditingFor","s","ea",")","{","eaCompression","=","M","insert","s","m","(","eaCompression","ea",")","}",")","CopyEntry","path","os","ns","->","(","pa","{","paSinkEntry","=","M","delete","ns","(","paSinkEntry","pa",")",",","paCopyEntry","=","M","alter","(","ef","os","ns",")","path","(","paCopyEntry","pa",")","}",",","clearEditingFor","ns","ea",")","RenameEntry","os","ns","->","(","pa","{","paCopyEntry","=","M","map","(","M","map","$","re","os","ns",")","(","paCopyEntry","pa",")",",","paSinkEntry","=","renameKey","os","ns","(","paSinkEntry","pa",")","}",",","ea","{","eaCompression","=","renameKey","os","ns","(","eaCompression","ea",")",",","eaEntryComment","=","renameKey","os","ns","(","eaEntryComment","ea",")",",","eaDeleteComment","=","renameKey","os","ns","(","eaDeleteComment","ea",")",",","eaModTime","=","renameKey","os","ns","(","eaModTime","ea",")",",","eaExtraField","=","renameKey","os","ns","(","eaExtraField","ea",")",",","eaDeleteField","=","renameKey","os","ns","(","eaDeleteField","ea",")","}",")","DeleteEntry","s","->","(","pa","{","paSinkEntry","=","M","delete","s","(","paSinkEntry","pa",")",",","paCopyEntry","=","M","map","(","M","delete","s",")","(","paCopyEntry","pa",")","}",",","clearEditingFor","s","ea",")","Recompress","m","s","->","(","pa",",","ea","{","eaCompression","=","M","insert","s","m","(","eaCompression","ea",")","}",")","SetEntryComment","txt","s","->","(","pa",",","ea","{","eaEntryComment","=","M","insert","s","txt","(","eaEntryComment","ea",")",",","eaDeleteComment","=","M","delete","s","(","eaDeleteComment","ea",")","}",")","DeleteEntryComment","s","->","(","pa",",","ea","{","eaEntryComment","=","M","delete","s","(","eaEntryComment","ea",")",",","eaDeleteComment","=","M","insert","s","(",")","(","eaDeleteComment","ea",")","}",")","SetModTime","time","s","->","(","pa",",","ea","{","eaModTime","=","M","insert","s","time","(","eaModTime","ea",")","}",")","AddExtraField","n","b","s","->","(","pa",",","ea","{","eaExtraField","=","M","alter","(","ef","n","b",")","s","(","eaExtraField","ea",")",",","eaDeleteField","=","M","delete","s","(","eaDeleteField","ea",")","}",")","DeleteExtraField","n","s","->","(","pa",",","ea","{","eaExtraField","=","M","alter","(","er","n",")","s","(","eaExtraField","ea",")",",","eaDeleteField","=","M","alter","(","ef","n","(",")",")","s","(","eaDeleteField","ea",")","}",")","SetExternalFileAttributes","b","s","->","(","pa",",","ea","{","eaExtFileAttr","=","M","insert","s","b","(","eaExtFileAttr","ea",")","}",")","_","->","(","pa",",","ea",")","clearEditingFor","s","ea","=","ea","{","eaCompression","=","M","delete","s","(","eaCompression","ea",")",",","eaEntryComment","=","M","delete","s","(","eaEntryComment","ea",")",",","eaDeleteComment","=","M","delete","s","(","eaDeleteComment","ea",")",",","eaModTime","=","M","delete","s","(","eaModTime","ea",")",",","eaExtraField","=","M","delete","s","(","eaExtraField","ea",")",",","eaDeleteField","=","M","delete","s","(","eaDeleteField","ea",")",",","eaExtFileAttr","=","M","delete","s","(","eaExtFileAttr","ea",")","}","re","o","n","x","=","if","x","==","o","then","n","else","x","ef","k","v","(","Just","m",")","=","Just","(","M","insert","k","v","m",")","ef","k","v","Nothing","=","Just","(","M","singleton","k","v",")","er","k","(","Just","m",")","=","let","n","=","M","delete","k","m","in","if","M","null","n","then","Nothing","else","Just","n","er","_","Nothing","=","Nothing","-- | Copy entries from another archive and write them into the file","-- associated with the given handle. This can throw 'EntryDoesNotExist' if","-- there is no such entry in that archive."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L349-L452","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"recompress","parameters":"t s","argument_list":"","return_statement":"","docstring":"Change compression method of an entry, if it does not exist, nothing will happen.","docstring_summary":"Change compression method of an entry, if it does not exist, nothing will happen.","docstring_tokens":["Change","compression","method","of","an","entry","if","it","does","not","exist","nothing","will","happen","."],"function":"recompress t s = addPending (I.Recompress t s)","function_tokens":["recompress","t","s","=","addPending","(","I","Recompress","t","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L542-L542","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"unpack","parameters":"(Lens p)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unpack (Lens p) = p","function_tokens":["unpack","(","Lens","p",")","=","p"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L120-L120","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"m _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge m _ = m","function_tokens":["merge","m","_","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L795-L795","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putTag","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putTag = putWord8","function_tokens":["putTag","=","putWord8"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L115-L115","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"popCompFunc","parameters":"","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"popCompFunc = Free.liftF (PopCompFunc ())","function_tokens":["popCompFunc","=","Free","liftF","(","PopCompFunc","(",")",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L86-L86","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"id","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"id = toBS . nodeId $ node","function_tokens":["id","=","toBS",".","nodeId","$","node"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L47-L47","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"compactLinePragmas","parameters":"_  _ _ []","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"compactLinePragmas _  _ _ [] = []","function_tokens":["compactLinePragmas","_","_","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L60-L60","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"optsCreateIndex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"optsCreateIndex = CreateIndexOptions\n  <$> strOption\n        (   long \"input\"\n        <>  short 'i'\n        <>  help \"Input JSON file\"\n        <>  metavar \"STRING\"\n        )\n  <*> optional\n        ( strOption\n          (   long \"output-ib-file\"\n          <>  help \"Filename for output ib index\"\n          <>  metavar \"STRING\"\n          )\n        )\n  <*> optional\n        ( strOption\n          (   long \"output-bp-file\"\n          <>  help \"Filename for output bp index\"\n          <>  metavar \"STRING\"\n          )\n        )\n  <*> strOption\n        (   long \"method\"\n        <>  help \"Method\"\n        <>  value \"simple\"\n        <>  metavar \"STRING\"\n        )","function_tokens":["optsCreateIndex","=","CreateIndexOptions","<$>","strOption","(","long","\"input\"","<>","short","'i'","<>","help","\"Input JSON file\"","<>","metavar","\"STRING\"",")","<*>","optional","(","strOption","(","long","\"output-ib-file\"","<>","help","\"Filename for output ib index\"","<>","metavar","\"STRING\"",")",")","<*>","optional","(","strOption","(","long","\"output-bp-file\"","<>","help","\"Filename for output bp index\"","<>","metavar","\"STRING\"",")",")","<*>","strOption","(","long","\"method\"","<>","help","\"Method\"","<>","value","\"simple\"","<>","metavar","\"STRING\"",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L61-L87","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Cut.hs","language":"haskell","identifier":"cutfail","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cutfail = send Cutfail","function_tokens":["cutfail","=","send","Cutfail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Cut.hs#L50-L50","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Cut.hs","hash_val":25056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"takeRow","parameters":"(MMatrix _ c tda offset vec) i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeRow (MMatrix _ c tda offset vec) i = GM.slice i' c vec\n  where\n    i' = offset + i * tda","function_tokens":["takeRow","(","MMatrix","_","c","tda","offset","vec",")","i","=","GM","slice","i'","c","vec","where","i'","=","offset","+","i","*","tda"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L49-L52","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Notes a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Notes a)                = a","function_tokens":["go","(","Notes","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L417-L417","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"groupFields","parameters":"mk vs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"groupFields mk vs\n  = map (rename mk)\n  . concatMap (\\fs -> let vals  = concat (toList <$> fs)\n                          cons  = fst <$> vals\n                          subst = concat (snd <$> vals)\n                       in nub (fmap (const (cons, subst)) <$> fs)\n              )\n  . groupBy eq\n  . sortBy (comparing name)\n  . concatMap (constructorFields vs)\n  where name (Field n _ _ _) = n\n        eq f g = False `fromMaybe` ((==) <$> name f <*> name g)\n        rename f (Field n a b c) =\n          Field (mkName . f . nameBase <$> n) a b c","function_tokens":["groupFields","mk","vs","=","map","(","rename","mk",")",".","concatMap","(","\\","fs","->","let","vals","=","concat","(","toList","<$>","fs",")","cons","=","fst","<$>","vals","subst","=","concat","(","snd","<$>","vals",")","in","nub","(","fmap","(","const","(","cons",",","subst",")",")","<$>","fs",")",")",".","groupBy","eq",".","sortBy","(","comparing","name",")",".","concatMap","(","constructorFields","vs",")","where","name","(","Field","n","_","_","_",")","=","n","eq","f","g","=","False","`","fromMaybe","`","(","(","==",")","<$>","name","f","<*>","name","g",")","rename","f","(","Field","n","a","b","c",")","=","Field","(","mkName",".","f",".","nameBase","<$>","n",")","a","b","c"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L314-L329","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"setExternalFileAttrs","parameters":"attrs s","argument_list":"","return_statement":"","docstring":"Set external file attributes. This function can be used to set file permissions.  See also: \"Codec.Archive.Zip.Unix\".  @since 1.2.0","docstring_summary":"Set external file attributes. This function can be used to set file permissions.  See also: \"Codec.Archive.Zip.Unix\".","docstring_tokens":["Set","external","file","attributes",".","This","function","can","be","used","to","set","file","permissions",".","See","also",":","Codec",".","Archive",".","Zip",".","Unix","."],"function":"setExternalFileAttrs attrs s =\n  addPending (I.SetExternalFileAttributes attrs s)","function_tokens":["setExternalFileAttrs","attrs","s","=","addPending","(","I","SetExternalFileAttributes","attrs","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L604-L605","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"p1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p1 = Proxy :: Proxy sublayout","function_tokens":["p1","=","Proxy","::","Proxy","sublayout"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L270-L270","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"not'","parameters":"(Not a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"not' (Not a) = return . dual . unIFix $ a","function_tokens":["not'","(","Not","a",")","=","return",".","dual",".","unIFix","$","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L702-L702","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"quantify","parameters":"_ s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"quantify _ s = case s %~ (sing :: Sing v) of\n        Proved Refl -> Just forall\n        Disproved _ -> Nothing","function_tokens":["quantify","_","s","=","case","s","%~","(","sing","::","Sing","v",")","of","Proved","Refl","->","Just","forall","Disproved","_","->","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L887-L891","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Mono.hs","language":"haskell","identifier":"set","parameters":"","argument_list":"","return_statement":"","docstring":"Get the setter arrow from a lens.","docstring_summary":"Get the setter arrow from a lens.","docstring_tokens":["Get","the","setter","arrow","from","a","lens","."],"function":"set = Poly.set","function_tokens":["set","=","Poly","set"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Mono.hs#L68-L68","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Mono.hs","hash_val":24943,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dynvar","parameters":"n s","argument_list":"","return_statement":"","docstring":"Like @var@ except it hides the sort inside @DynamicallySortedFix@","docstring_summary":"Like","docstring_tokens":["Like"],"function":"dynvar n s = DynamicallySorted s $ withSort s $ var n","function_tokens":["dynvar","n","s","=","DynamicallySorted","s","$","withSort","s","$","var","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L299-L299","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"extraField","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"extraField =\n        B.take 0xffff . runPut . putExtraField $\n          if needsZip64 entry\n            then M.insert 1 zip64ef edExtraField\n            else edExtraField","function_tokens":["extraField","=","B","take","0xffff",".","runPut",".","putExtraField","$","if","needsZip64","entry","then","M","insert","1","zip64ef","edExtraField","else","edExtraField"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L843-L847","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"makeZip64ExtraField","parameters":"headerType Zip64ExtraField {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeZip64ExtraField headerType Zip64ExtraField {..} = runPut $ do\n  when (headerType == LocalHeader || z64efUncompressedSize >= ffffffff) $\n    putWord64le (fromIntegral z64efUncompressedSize) -- uncompressed size\n  when (headerType == LocalHeader || z64efCompressedSize >= ffffffff) $\n    putWord64le (fromIntegral z64efCompressedSize) -- compressed size\n  when (headerType == CentralDirHeader && z64efOffset >= ffffffff) $\n    putWord64le (fromIntegral z64efOffset) -- offset of local file header\n\n-- | Create 'ByteString' representing an extra field.","function_tokens":["makeZip64ExtraField","headerType","Zip64ExtraField","{","..","}","=","runPut","$","do","when","(","headerType","==","LocalHeader","||","z64efUncompressedSize",">=","ffffffff",")","$","putWord64le","(","fromIntegral","z64efUncompressedSize",")","-- uncompressed size","when","(","headerType","==","LocalHeader","||","z64efCompressedSize",">=","ffffffff",")","$","putWord64le","(","fromIntegral","z64efCompressedSize",")","-- compressed size","when","(","headerType","==","CentralDirHeader","&&","z64efOffset",">=","ffffffff",")","$","putWord64le","(","fromIntegral","z64efOffset",")","-- offset of local file header","-- | Create 'ByteString' representing an extra field."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L781-L790","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkCase","parameters":"(Context i _ c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkCase (Context i _ c) = map (\\(pat, var) -> match pat (normalB (rght var)) []) (case1 i c)","function_tokens":["mkCase","(","Context","i","_","c",")","=","map","(","\\","(","pat",",","var",")","->","match","pat","(","normalB","(","rght","var",")",")","[","]",")","(","case1","i","c",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L528-L528","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"ds","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ds = replicateM 2 getFloat64le","function_tokens":["ds","=","replicateM","2","getFloat64le"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L63-L63","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand _ = throwE \"Invalid id\"","function_tokens":["parseCommand","_","=","throwE","\"Invalid id\""],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L131-L131","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"isRedundant","parameters":"m \"ViewPatterns\"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isRedundant m \"ViewPatterns\" = isRedundantViewPatterns m","function_tokens":["isRedundant","m","\"ViewPatterns\"","=","isRedundantViewPatterns","m"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L171-L171","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_POSITION","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"al_POSITION                         = 0x1004","function_tokens":["al_POSITION","=","0x1004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L65-L65","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"extFileAttr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"extFileAttr = case o of\n        GenericOrigin -> M.findWithDefault defaultFileMode s eaExtFileAttr\n        Borrowed _ -> M.findWithDefault defaultFileMode s eaExtFileAttr","function_tokens":["extFileAttr","=","case","o","of","GenericOrigin","->","M","findWithDefault","defaultFileMode","s","eaExtFileAttr","Borrowed","_","->","M","findWithDefault","defaultFileMode","s","eaExtFileAttr"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L503-L506","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"getECD","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getECD = do\n  sig <- getWord32le -- end of central directory signature\n  let zip64 = sig == 0x06064b50\n  unless (sig == 0x06054b50 || sig == 0x06064b50) $\n    fail \"Cannot locate end of central directory\"\n  zip64size <-\n    if zip64\n      then do\n        x <- getWord64le -- size of zip64 end of central directory record\n        skip 2 -- version made by\n        skip 2 -- version needed to extract\n        return (Just x)\n      else return Nothing\n  thisDisk <- bool (fromIntegral <$> getWord16le) getWord32le zip64\n  -- \u2191 number of this disk\n  cdDisk <- bool (fromIntegral <$> getWord16le) getWord32le zip64\n  -- \u2191 number of the disk with the start of the central directory\n  unless (thisDisk == 0 && cdDisk == 0) $\n    fail \"No support for multi-disk archives\"\n  skip (bool 2 8 zip64)\n  -- \u2191 total number of entries in the central directory on this disk\n  skip (bool 2 8 zip64)\n  -- \u2191 total number of entries in the central directory\n  cdSize <- bool (fromIntegral <$> getWord32le) getWord64le zip64\n  -- \u2191 size of the central directory\n  cdOffset <- bool (fromIntegral <$> getWord32le) getWord64le zip64\n  -- \u2191 offset of start of central directory with respect to the starting\n  -- disk number\n  when zip64 . skip . fromIntegral $ fromJust zip64size - 4 -- obviously\n  commentSize <- getWord16le -- .ZIP file comment length\n  comment <- decodeText True <$> getBytes (fromIntegral commentSize)\n  -- \u2191 archive comment, it's uncertain how we should decide on encoding here\n  return\n    ArchiveDescription\n      { adComment = if commentSize == 0 then Nothing else comment,\n        adCDOffset = fromIntegral cdOffset,\n        adCDSize = fromIntegral cdSize\n      }\n\n-- | Create a 'ByteString' representing the end of central directory record.","function_tokens":["getECD","=","do","sig","<-","getWord32le","-- end of central directory signature","let","zip64","=","sig","==","0x06064b50","unless","(","sig","==","0x06054b50","||","sig","==","0x06064b50",")","$","fail","\"Cannot locate end of central directory\"","zip64size","<-","if","zip64","then","do","x","<-","getWord64le","-- size of zip64 end of central directory record","skip","2","-- version made by","skip","2","-- version needed to extract","return","(","Just","x",")","else","return","Nothing","thisDisk","<-","bool","(","fromIntegral","<$>","getWord16le",")","getWord32le","zip64","-- \u2191 number of this disk","cdDisk","<-","bool","(","fromIntegral","<$>","getWord16le",")","getWord32le","zip64","-- \u2191 number of the disk with the start of the central directory","unless","(","thisDisk","==","0","&&","cdDisk","==","0",")","$","fail","\"No support for multi-disk archives\"","skip","(","bool","2","8","zip64",")","-- \u2191 total number of entries in the central directory on this disk","skip","(","bool","2","8","zip64",")","-- \u2191 total number of entries in the central directory","cdSize","<-","bool","(","fromIntegral","<$>","getWord32le",")","getWord64le","zip64","-- \u2191 size of the central directory","cdOffset","<-","bool","(","fromIntegral","<$>","getWord32le",")","getWord64le","zip64","-- \u2191 offset of start of central directory with respect to the starting","-- disk number","when","zip64",".","skip",".","fromIntegral","$","fromJust","zip64size","-","4","-- obviously","commentSize","<-","getWord16le","-- .ZIP file comment length","comment","<-","decodeText","True","<$>","getBytes","(","fromIntegral","commentSize",")","-- \u2191 archive comment, it's uncertain how we should decide on encoding here","return","ArchiveDescription","{","adComment","=","if","commentSize","==","0","then","Nothing","else","comment",",","adCDOffset","=","fromIntegral","cdOffset",",","adCDSize","=","fromIntegral","cdSize","}","-- | Create a 'ByteString' representing the end of central directory record."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L898-L938","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"top","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"top = true","function_tokens":["top","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L221-L221","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A simple constructor of substitutions that replaces the latter expression with the former.","docstring_summary":"A simple constructor of substitutions that replaces the latter expression with the former.","docstring_tokens":["A","simple","constructor","of","substitutions","that","replaces","the","latter","expression","with","the","former","."],"function":"b `for` a = Substitution $ \\c -> case index (unIFix a) %~ index (unIFix c) of\n    Proved Refl -> if a == c then Just b else Nothing\n    Disproved _ -> Nothing\n\n-- | Executes a substitution.","function_tokens":["b","`","for","`","a","=","Substitution","$","\\","c","->","case","index","(","unIFix","a",")","%~","index","(","unIFix","c",")","of","Proved","Refl","->","if","a","==","c","then","Just","b","else","Nothing","Disproved","_","->","Nothing","-- | Executes a substitution."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L313-L318","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"map","parameters":"f (SymMatrix n vec)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"map f (SymMatrix n vec) = SymMatrix n $ G.map f vec","function_tokens":["map","f","(","SymMatrix","n","vec",")","=","SymMatrix","n","$","G","map","f","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L79-L79","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Throw\/Either.hs","language":"haskell","identifier":"runThrow","parameters":"(ThrowC m)","argument_list":"","return_statement":"","docstring":"Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.","docstring_summary":"Run a 'Throw' effect, returning failures in 'Left' and successful computations\u2019 results in 'Right'.","docstring_tokens":["Run","a","Throw","effect","returning","failures","in","Left","and","successful","computations\u2019","results","in","Right","."],"function":"runThrow (ThrowC m) = runError m","function_tokens":["runThrow","(","ThrowC","m",")","=","runError","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Throw\/Either.hs#L30-L30","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Throw\/Either.hs","hash_val":29621,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getBool","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getBool = (> 0) <$> getWord8","function_tokens":["getBool","=","(",">","0",")","<$>","getWord8"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L225-L225","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intSetCache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intSetCache = mkCache","function_tokens":["intSetCache","=","mkCache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L220-L220","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"storePeers","parameters":"","argument_list":"","return_statement":"","docstring":"Select the peers closest to the key","docstring_summary":"Select the peers closest to the key","docstring_tokens":["Select","the","peers","closest","to","the","key"],"function":"storePeers =\n                        map peer . take peerNum . sortByDistanceTo polled $ key","function_tokens":["storePeers","=","map","peer",".","take","peerNum",".","sortByDistanceTo","polled","$","key"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L115-L116","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"displayException","parameters":"(UnexpectedFollowedBy t)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"displayException (UnexpectedFollowedBy t) = \"Should not be followed by \" ++ unpack t","function_tokens":["displayException","(","UnexpectedFollowedBy","t",")","=","\"Should not be followed by \"","++","unpack","t"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L202-L202","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"index","parameters":"(Equals _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index (Equals _ _ _) = SBooleanSort","function_tokens":["index","(","Equals","_","_","_",")","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L48-L48","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = GHC.anchor $ GHC.getLoc comment","function_tokens":["s","=","GHC","anchor","$","GHC","getLoc","comment"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L64-L64","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/String.hs","language":"haskell","identifier":"withALCString","parameters":"str action","argument_list":"","return_statement":"","docstring":"AL uses \"Ptr ALCchar\" instead of \"CString\" for strings, so some wrappers are quite handy.","docstring_summary":"AL uses \"Ptr ALCchar\" instead of \"CString\" for strings, so some wrappers are quite handy.","docstring_tokens":["AL","uses","Ptr","ALCchar","instead","of","CString","for","strings","so","some","wrappers","are","quite","handy","."],"function":"withALCString str action = withCString str (action . castPtr)","function_tokens":["withALCString","str","action","=","withCString","str","(","action",".","castPtr",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/String.hs#L30-L30","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/String.hs","hash_val":13294,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"itraverse","parameters":"f (Store  is es a i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Store  is es a i e) = Store  is es <$> f a <*> f i <*> f e","function_tokens":["itraverse","f","(","Store","is","es","a","i","e",")","=","Store","is","es","<$>","f","a","<*>","f","i","<*>","f","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L72-L72","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWith","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith = MG.zipWith","function_tokens":["zipWith","=","MG","zipWith"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L258-L258","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"ds","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ds = replicateM 2 getFloat64le","function_tokens":["ds","=","replicateM","2","getFloat64le"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L59-L59","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"mappend","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappend = liftA2 mappend","function_tokens":["mappend","=","liftA2","mappend"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L221-L221","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"breakWhere","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"breakWhere =\n        [ (\"exports\", ModuleHeader.Exports)\n        , (\"single\",  ModuleHeader.Single)\n        , (\"inline\",  ModuleHeader.Inline)\n        , (\"always\",  ModuleHeader.Always)\n        ]","function_tokens":["breakWhere","=","[","(","\"exports\"",",","ModuleHeader","Exports",")",",","(","\"single\"",",","ModuleHeader","Single",")",",","(","\"inline\"",",","ModuleHeader","Inline",")",",","(","\"always\"",",","ModuleHeader","Always",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L210-L215","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"putHeader","parameters":"headerType s entry@EntryDescription {..}","argument_list":"","return_statement":"","docstring":"Create 'ByteString' representing either a local file header or a central directory file header.","docstring_summary":"Create 'ByteString' representing either a local file header or a central directory file header.","docstring_tokens":["Create","ByteString","representing","either","a","local","file","header","or","a","central","directory","file","header","."],"function":"putHeader headerType s entry@EntryDescription {..} = do\n  let isCentralDirHeader = headerType == CentralDirHeader\n  putWord32le (bool 0x04034b50 0x02014b50 isCentralDirHeader)\n  -- \u2191 local\/central file header signature\n  when isCentralDirHeader $\n    putWord16le (fromVersion edVersionMadeBy) -- version made by\n  putWord16le (fromVersion edVersionNeeded) -- version needed to extract\n  let entryName = getEntryName s\n      rawName = T.encodeUtf8 entryName\n      comment = B.take 0xffff (maybe B.empty T.encodeUtf8 edComment)\n      unicode =\n        needsUnicode entryName\n          || maybe False needsUnicode edComment\n      modTime = toMsDosTime edModTime\n  putWord16le (if unicode then setBit 0 11 else 0)\n  -- \u2191 general purpose bit-flag\n  putWord16le (fromCompressionMethod edCompression) -- compression method\n  putWord16le (msDosTime modTime) -- last mod file time\n  putWord16le (msDosDate modTime) -- last mod file date\n  putWord32le edCRC32 -- CRC-32 checksum\n  putWord32le (withSaturation edCompressedSize) -- compressed size\n  putWord32le (withSaturation edUncompressedSize) -- uncompressed size\n  putWord16le (fromIntegral $ B.length rawName) -- file name length\n  let zip64ef =\n        makeZip64ExtraField\n          headerType\n          Zip64ExtraField\n            { z64efUncompressedSize = edUncompressedSize,\n              z64efCompressedSize = edCompressedSize,\n              z64efOffset = edOffset\n            }\n      extraField =\n        B.take 0xffff . runPut . putExtraField $\n          if needsZip64 entry\n            then M.insert 1 zip64ef edExtraField\n            else edExtraField\n  putWord16le (fromIntegral $ B.length extraField) -- extra field length\n  when isCentralDirHeader $ do\n    putWord16le (fromIntegral $ B.length comment) -- file comment length\n    putWord16le 0 -- disk number start\n    putWord16le 0 -- internal file attributes\n    putWord32le edExternalFileAttrs -- external file attributes\n    putWord32le (withSaturation edOffset) -- relative offset of local header\n  putByteString rawName -- file name (variable size)\n  putByteString extraField -- extra field (variable size)\n  when isCentralDirHeader (putByteString comment) -- file comment (variable size)\n\n-- | Create 'ByteString' representing Zip64 end of central directory record.","function_tokens":["putHeader","headerType","s","entry","@","EntryDescription","{","..","}","=","do","let","isCentralDirHeader","=","headerType","==","CentralDirHeader","putWord32le","(","bool","0x04034b50","0x02014b50","isCentralDirHeader",")","-- \u2191 local\/central file header signature","when","isCentralDirHeader","$","putWord16le","(","fromVersion","edVersionMadeBy",")","-- version made by","putWord16le","(","fromVersion","edVersionNeeded",")","-- version needed to extract","let","entryName","=","getEntryName","s","rawName","=","T","encodeUtf8","entryName","comment","=","B","take","0xffff","(","maybe","B","empty","T","encodeUtf8","edComment",")","unicode","=","needsUnicode","entryName","||","maybe","False","needsUnicode","edComment","modTime","=","toMsDosTime","edModTime","putWord16le","(","if","unicode","then","setBit","0","11","else","0",")","-- \u2191 general purpose bit-flag","putWord16le","(","fromCompressionMethod","edCompression",")","-- compression method","putWord16le","(","msDosTime","modTime",")","-- last mod file time","putWord16le","(","msDosDate","modTime",")","-- last mod file date","putWord32le","edCRC32","-- CRC-32 checksum","putWord32le","(","withSaturation","edCompressedSize",")","-- compressed size","putWord32le","(","withSaturation","edUncompressedSize",")","-- uncompressed size","putWord16le","(","fromIntegral","$","B","length","rawName",")","-- file name length","let","zip64ef","=","makeZip64ExtraField","headerType","Zip64ExtraField","{","z64efUncompressedSize","=","edUncompressedSize",",","z64efCompressedSize","=","edCompressedSize",",","z64efOffset","=","edOffset","}","extraField","=","B","take","0xffff",".","runPut",".","putExtraField","$","if","needsZip64","entry","then","M","insert","1","zip64ef","edExtraField","else","edExtraField","putWord16le","(","fromIntegral","$","B","length","extraField",")","-- extra field length","when","isCentralDirHeader","$","do","putWord16le","(","fromIntegral","$","B","length","comment",")","-- file comment length","putWord16le","0","-- disk number start","putWord16le","0","-- internal file attributes","putWord32le","edExternalFileAttrs","-- external file attributes","putWord32le","(","withSaturation","edOffset",")","-- relative offset of local header","putByteString","rawName","-- file name (variable size)","putByteString","extraField","-- extra field (variable size)","when","isCentralDirHeader","(","putByteString","comment",")","-- file comment (variable size)","-- | Create 'ByteString' representing Zip64 end of central directory record."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L812-L860","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"imap","parameters":"f (Forall vs phi)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Forall vs phi) = Forall vs $ f phi","function_tokens":["imap","f","(","Forall","vs","phi",")","=","Forall","vs","$","f","phi"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L539-L539","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"tweenStream","parameters":"s0 t0","argument_list":"","return_statement":"","docstring":"Converts a tween into a continuous value stream. This is the tween version of 'Control.Varying.Spline.outputStream'. This is the preferred way to run your tweens.  >>> :{ let x :: TweenT Float Float IO Float x = tween linear 0 1 1 y :: TweenT Float Float IO Float y = tween linear 0 1 2 v :: VarT IO Float (Float, Float) v = (,) <$> tweenStream x 0 <*> tweenStream y 0 in testVarOver v [0.5, 0.5, 0.5, 0.5] >>> :} (0.5,0.25) (1.0,0.5) (1.0,0.75) (1.0,1.0)","docstring_summary":"Converts a tween into a continuous value stream. This is the tween version of 'Control.Varying.Spline.outputStream'. This is the preferred way to run your tweens.  >>> :{ let x :: TweenT Float Float IO Float x = tween linear 0 1 1 y :: TweenT Float Float IO Float y = tween linear 0 1 2 v :: VarT IO Float (Float, Float) v = (,) <$> tweenStream x 0 <*> tweenStream y 0 in testVarOver v [0.5, 0.5, 0.5, 0.5] >>> :} (0.5,0.25) (1.0,0.5) (1.0,0.75) (1.0,1.0)","docstring_tokens":["Converts","a","tween","into","a","continuous","value","stream",".","This","is","the","tween","version","of","Control",".","Varying",".","Spline",".","outputStream",".","This","is","the","preferred","way","to","run","your","tweens",".",">>>",":","{","let","x","::","TweenT","Float","Float","IO","Float","x","=","tween","linear","0","1","1","y","::","TweenT","Float","Float","IO","Float","y","=","tween","linear","0","1","2","v","::","VarT","IO","Float","(","Float","Float",")","v","=","(",")","<$",">","tweenStream","x","0","<","*",">","tweenStream","y","0","in","testVarOver","v","[","0",".","5","0",".","5","0",".","5","0",".","5","]",">>>",":","}","(","0",".","5","0",".","25",")","(","1",".","0","0",".","5",")","(","1",".","0","0",".","75",")","(","1",".","0","1",".","0",")"],"function":"tweenStream s0 t0 = VarT $ go s0 t0 0\n  where\n    go ::\n         TweenT f t m x -- The Tween\n      -> t -- the last output value\n      -> f -- the leftover time delta from last fram\n      -> f -- the input time delta\n      -> m (t, VarT m f t)\n    go s t l i = do\n      (e, l1) <- runTweenT s i l\n      case e of\n        Left _        -> return (t, done t)\n        Right (b, s1) -> return (b, VarT $ go s1 b l1)\n\n\n--------------------------------------------------------------------------------\n-- $creation\n-- The most direct route toward tweening values is to use 'tween'\n-- along with an interpolation function such as 'easeInExpo'. For example,\n-- @tween easeInExpo 0 100 10@, this will create a spline that produces a\n-- number interpolated from 0 to 100 over 10 seconds. At the end of the\n-- tween the spline will return the result value.\n--------------------------------------------------------------------------------\n\n-- | Creates a spline that produces a value interpolated between a start and\n-- end value using an easing equation ('Easing') over a duration.  The\n-- resulting spline will take a time delta as input.\n-- Keep in mind that `tween` must be fed time deltas, not absolute time or\n-- duration. This is mentioned because the author has made that mistake\n-- more than once ;)\n--\n-- `tween` concludes returning the latest output value.","function_tokens":["tweenStream","s0","t0","=","VarT","$","go","s0","t0","0","where","go","::","TweenT","f","t","m","x","-- The Tween","->","t","-- the last output value","->","f","-- the leftover time delta from last fram","->","f","-- the input time delta","->","m","(","t",",","VarT","m","f","t",")","go","s","t","l","i","=","do","(","e",",","l1",")","<-","runTweenT","s","i","l","case","e","of","Left","_","->","return","(","t",",","done","t",")","Right","(","b",",","s1",")","->","return","(","b",",","VarT","$","go","s1","b","l1",")","--------------------------------------------------------------------------------","-- $creation","-- The most direct route toward tweening values is to use 'tween'","-- along with an interpolation function such as 'easeInExpo'. For example,","-- @tween easeInExpo 0 100 10@, this will create a spline that produces a","-- number interpolated from 0 to 100 over 10 seconds. At the end of the","-- tween the spline will return the result value.","--------------------------------------------------------------------------------","-- | Creates a spline that produces a value interpolated between a start and","-- end value using an easing equation ('Easing') over a duration.  The","-- resulting spline will take a time delta as input.","-- Keep in mind that `tween` must be fed time deltas, not absolute time or","-- duration. This is mentioned because the author has made that mistake","-- more than once ;)","--","-- `tween` concludes returning the latest output value."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L258-L290","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"create","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"create m = runST $ unsafeFreeze =<< m","function_tokens":["create","m","=","runST","$","unsafeFreeze","=<<","m"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L199-L199","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"cachePeer","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cachePeer = peer . head . sortByDistanceTo rest $ id","function_tokens":["cachePeer","=","peer",".","head",".","sortByDistanceTo","rest","$","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L59-L59","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"isRedundantBangPatterns","parameters":"modul","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isRedundantBangPatterns modul =\n    (null $ queryModule getBangPat modul) &&\n    (null $ queryModule getMatchStrict modul)\n  where\n    getBangPat :: GHC.Pat GHC.GhcPs -> [()]\n    getBangPat = \\case\n      GHC.BangPat{} -> [()]\n      _             -> []\n\n    getMatchStrict :: GHC.Match GHC.GhcPs (GHC.LHsExpr GHC.GhcPs) -> [()]\n    getMatchStrict (GHC.Match _ ctx _ _) = case ctx of\n      GHC.FunRhs _ _ GHC.SrcStrict -> [()]\n      _                            -> []","function_tokens":["isRedundantBangPatterns","modul","=","(","null","$","queryModule","getBangPat","modul",")","&&","(","null","$","queryModule","getMatchStrict","modul",")","where","getBangPat","::","GHC","Pat","GHC","GhcPs","->","[","(",")","]","getBangPat","=","\\","case","GHC","BangPat","{","}","->","[","(",")","]","_","->","[","]","getMatchStrict","::","GHC","Match","GHC","GhcPs","(","GHC","LHsExpr","GHC","GhcPs",")","->","[","(",")","]","getMatchStrict","(","GHC","Match","_","ctx","_","_",")","=","case","ctx","of","GHC","FunRhs","_","_","GHC","SrcStrict","->","[","(",")","]","_","->","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L190-L202","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"flatten","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten e = case match e of\n        Just (Const 0) -> []\n        Just (Add as)  -> as\n        _              -> [e]","function_tokens":["flatten","e","=","case","match","e","of","Just","(","Const","0",")","->","[","]","Just","(","Add","as",")","->","as","_","->","[","e","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L174-L179","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC m >>= f = StateC $ \\ s -> do\n    (s', a) <- m s\n    runState s' (f a)","function_tokens":["StateC","m",">>=","f","=","StateC","$","\\","s","->","do","(","s'",",","a",")","<-","m","s","runState","s'","(","f","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L99-L102","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs","language":"haskell","identifier":"readShpWithDbf","parameters":"fp","argument_list":"","return_statement":"","docstring":"Read a shp-file from `fp`, and a dbf file from the same path but with modified extension.","docstring_summary":"Read a shp-file from `fp`, and a dbf file from the same path but with modified extension.","docstring_tokens":["Read","a","shp","-","file","from","fp","and","a","dbf","file","from","the","same","path","but","with","modified","extension","."],"function":"readShpWithDbf fp = do\n  shpData <- readShpData <$> BL.readFile fp\n  let dbfPath = dropExtension fp ++ \".dbf\"\n  dbfData <- readDbfData <$> BL.readFile dbfPath\n  return shpData {\n      dbfFieldDescs = Just $ dbfFields dbfData,\n      shpRecs = zipWith addRecLabel (shpRecs shpData) (dbfRecords dbfData)\n    }","function_tokens":["readShpWithDbf","fp","=","do","shpData","<-","readShpData","<$>","BL","readFile","fp","let","dbfPath","=","dropExtension","fp","++","\".dbf\"","dbfData","<-","readDbfData","<$>","BL","readFile","dbfPath","return","shpData","{","dbfFieldDescs","=","Just","$","dbfFields","dbfData",",","shpRecs","=","zipWith","addRecLabel","(","shpRecs","shpData",")","(","dbfRecords","dbfData",")","}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs#L20-L29","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs","hash_val":12976,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Environment.hs","language":"haskell","identifier":"checkConflictStyle","parameters":"opts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkConflictStyle opts =\n    do  conflictStyle <- getConflictStyle\n        unless (conflictStyle `elem` [\"diff3\", \"zdiff3\"]) $\n            do  unless (shouldSetConflictStyle opts) $\n                    fail $ concat\n                    [ \"merge.conflictstyle must be diff3 but is \"\n                    , show conflictStyle\n                    , \". Use -s to automatically set it globally\"\n                    ]\n                setConflictStyle\n\n                newConflictStyle <- getConflictStyle\n                when (newConflictStyle \/= \"diff3\") $\n                    fail $ concat\n                    [ \"Attempt to set conflict style failed. Perhaps you have\"\n                    , \" an incorrect merge.conflictstyle configuration \"\n                    , \"specified in your per-project .git\/config?\"\n                    ]","function_tokens":["checkConflictStyle","opts","=","do","conflictStyle","<-","getConflictStyle","unless","(","conflictStyle","`","elem","`","[","\"diff3\"",",","\"zdiff3\"","]",")","$","do","unless","(","shouldSetConflictStyle","opts",")","$","fail","$","concat","[","\"merge.conflictstyle must be diff3 but is \"",",","show","conflictStyle",",","\". Use -s to automatically set it globally\"","]","setConflictStyle","newConflictStyle","<-","getConflictStyle","when","(","newConflictStyle","\/=","\"diff3\"",")","$","fail","$","concat","[","\"Attempt to set conflict style failed. Perhaps you have\"",",","\" an incorrect merge.conflictstyle configuration \"",",","\"specified in your per-project .git\/config?\"","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Environment.hs#L41-L60","hash_key":"Peaker\/git-mediate:src\/Environment.hs","hash_val":17949,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"st","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"st =\n        ZipState\n          { zsFilePath = apath,\n            zsEntries = M.empty,\n            zsArchive = ArchiveDescription Nothing 0 0,\n            zsActions = S.empty\n          }","function_tokens":["st","=","ZipState","{","zsFilePath","=","apath",",","zsEntries","=","M","empty",",","zsArchive","=","ArchiveDescription","Nothing","0","0",",","zsActions","=","S","empty","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L245-L251","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (InternedText i _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (InternedText i _) = hashWithSalt s i","function_tokens":["hashWithSalt","s","(","InternedText","i","_",")","=","hashWithSalt","s","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L30-L30","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"putStrNewline","parameters":"txt","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putStrNewline txt = setNewlineMode IO.stdout >> putStr txt","function_tokens":["putStrNewline","txt","=","setNewlineMode","IO","stdout",">>","putStr","txt"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L173-L173","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Tempo a)","argument_list":"","return_statement":"","docstring":"TODO","docstring_summary":"TODO","docstring_tokens":["TODO"],"function":"go (Tempo a)                = show $ pretty a","function_tokens":["go","(","Tempo","a",")","=","show","$","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L420-L420","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"(InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' (InR gb) = flatten' gb","function_tokens":["flatten'","(","InR","gb",")","=","flatten'","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L864-L864","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"bodies","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bodies  =        map (\\(LabelExpr _ _ _ b) -> b) labels","function_tokens":["bodies","=","map","(","\\","(","LabelExpr","_","_","_","b",")","->","b",")","labels"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L140-L140","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Sharp","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Sharp        = \"^\"","function_tokens":["go","Sharp","=","\"^\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L461-L461","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sourceRelative","parameters":"","argument_list":"","return_statement":"","docstring":"If 'sourceRelative' contains 'Listener', it indicates indicates that the values specified by 'sourcePosition', 'sourceVelocity' and 'direction' are to be interpreted relative to the listener position. The initial value is 'World', indicating that those source attributes are to be interpreted relative to the world, i.e. they are considered absolute.","docstring_summary":"If 'sourceRelative' contains 'Listener', it indicates indicates that the values specified by 'sourcePosition', 'sourceVelocity' and 'direction' are to be interpreted relative to the listener position. The initial value is 'World', indicating that those source attributes are to be interpreted relative to the world, i.e. they are considered absolute.","docstring_tokens":["If","sourceRelative","contains","Listener","it","indicates","indicates","that","the","values","specified","by","sourcePosition","sourceVelocity","and","direction","are","to","be","interpreted","relative","to","the","listener","position",".","The","initial","value","is","World","indicating","that","those","source","attributes","are","to","be","interpreted","relative","to","the","world","i",".","e",".","they","are","considered","absolute","."],"function":"sourceRelative = makeSourceStateVar dictSourceRelative GetSourceRelative","function_tokens":["sourceRelative","=","makeSourceStateVar","dictSourceRelative","GetSourceRelative"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L207-L207","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"cos","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cos = fmap cos","function_tokens":["cos","=","fmap","cos"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L250-L250","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"tweenx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tweenx = do\n    -- Tween from 0 to 50 over 'dur' seconds\n    easeMiddle 0 50 dur\n    -- Chain another tween back to the starting position\n    easeMiddle 50 0 dur\n    -- Loop forever\n    tweenx\n\n-- A quadratic tween back and forth from 0 to 50 over 1 seconds that never\n-- ends.","function_tokens":["tweenx","=","do","-- Tween from 0 to 50 over 'dur' seconds","easeMiddle","0","50","dur","-- Chain another tween back to the starting position","easeMiddle","50","0","dur","-- Loop forever","tweenx","-- A quadratic tween back and forth from 0 to 50 over 1 seconds that never","-- ends."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L31-L41","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"f","parameters":"x y","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f x y = fromRational (mean x) + confidence cfg*standardError x < fromRational (mean y) - confidence cfg*standardError y","function_tokens":["f","x","y","=","fromRational","(","mean","x",")","+","confidence","cfg","*","standardError","x","<","fromRational","(","mean","y",")","-","confidence","cfg","*","standardError","y"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L337-L337","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"unsafeTakeRow","parameters":"(CSR _ c vec ci rp) i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeTakeRow (CSR _ c vec ci rp) i = G.fromList $ loop (-1) r0\n      where\n        loop !prev !n\n            | n > r1 = replicate (c-prev-1) zero\n            | otherwise = replicate (cur-prev-1) zero ++ (x : loop cur (n+1))\n          where\n            cur = ci `U.unsafeIndex` n\n            x = vec `G.unsafeIndex` n\n        r0 = rp `U.unsafeIndex` i\n        r1 = rp `U.unsafeIndex` (i+1) - 1","function_tokens":["unsafeTakeRow","(","CSR","_","c","vec","ci","rp",")","i","=","G","fromList","$","loop","(","-","1",")","r0","where","loop","prev","n","|","n",">","r1","=","replicate","(","c","-","prev","-","1",")","zero","|","otherwise","=","replicate","(","cur","-","prev","-","1",")","zero","++","(","x",":","loop","cur","(","n","+","1",")",")","where","cur","=","ci","`","U","unsafeIndex","`","n","x","=","vec","`","G","unsafeIndex","`","n","r0","=","rp","`","U","unsafeIndex","`","i","r1","=","rp","`","U","unsafeIndex","`","(","i","+","1",")","-","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L106-L116","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(And as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (And as) = or (map (dual . unIFix) as)","function_tokens":["dual","(","And","as",")","=","or","(","map","(","dual",".","unIFix",")","as",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L671-L671","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"singleEvent","parameters":"start duration content","argument_list":"","return_statement":"","docstring":"Constructs a track that contains a single event.  > singleEvent start duration content","docstring_summary":"Constructs a track that contains a single event.  > singleEvent start duration content","docstring_tokens":["Constructs","a","track","that","contains","a","single","event",".",">","singleEvent","start","duration","content"],"function":"singleEvent start duration content = del start $ str duration $ temp content","function_tokens":["singleEvent","start","duration","content","=","del","start","$","str","duration","$","temp","content"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L189-L189","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWithM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWithM = MG.zipWithM","function_tokens":["zipWithM","=","MG","zipWithM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L336-L336","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"poke","parameters":"ptr   (Source b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"poke ptr   (Source b) = poke1 (castPtr ptr) b","function_tokens":["poke","ptr","(","Source","b",")","=","poke1","(","castPtr","ptr",")","b"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L120-L120","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"f","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f x = withCreateProcess (shell (intercalate \";\" $ replicate x cmd)) {std_out = CreatePipe, std_err = CreatePipe} $ \\_ _ _ p ->\n          waitForProcess p >> threadDelay 0","function_tokens":["f","x","=","withCreateProcess","(","shell","(","intercalate","\";\"","$","replicate","x","cmd",")",")","{","std_out","=","CreatePipe",",","std_err","=","CreatePipe","}","$","\\","_","_","_","p","->","waitForProcess","p",">>","threadDelay","0"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L128-L129","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/String.hs","language":"haskell","identifier":"peekALString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"peekALString = peekCString . castPtr","function_tokens":["peekALString","=","peekCString",".","castPtr"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/String.hs#L32-L32","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/String.hs","hash_val":42033,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"moduleImportGroups","parameters":"","argument_list":"","return_statement":"","docstring":"Get groups of imports from module","docstring_summary":"Get groups of imports from module","docstring_tokens":["Get","groups","of","imports","from","module"],"function":"moduleImportGroups =\n    groupByLine (fromMaybe err . GHC.srcSpanToRealSrcSpan . GHC.getLocA) .\n    GHC.hsmodImports . GHC.unLoc\n  where\n    err = error \"moduleImportGroups: import without soure span\"\n\n-- The same logic as 'Language.Haskell.Stylish.Module.moduleImportGroups'.","function_tokens":["moduleImportGroups","=","groupByLine","(","fromMaybe","err",".","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")",".","GHC","hsmodImports",".","GHC","unLoc","where","err","=","error","\"moduleImportGroups: import without soure span\"","-- The same logic as 'Language.Haskell.Stylish.Module.moduleImportGroups'."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L82-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"quantify","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"quantify _ _ = Nothing","function_tokens":["quantify","_","_","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L895-L895","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"distance","parameters":"idA idB","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"distance idA idB = let bsA = toByteStruct idA\n                       bsB = toByteStruct idB\n                   in  zipWith xor bsA bsB\n    where xor a b = not (a && b) && (a || b)\n\n-- | Try to convert a SockAddr to a Peer","function_tokens":["distance","idA","idB","=","let","bsA","=","toByteStruct","idA","bsB","=","toByteStruct","idB","in","zipWith","xor","bsA","bsB","where","xor","a","b","=","not","(","a","&&","b",")","&&","(","a","||","b",")","-- | Try to convert a SockAddr to a Peer"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L78-L84","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"set'","parameters":"l v f","argument_list":"","return_statement":"","docstring":"Like 'set' but return behaves like the identity function when the field could not be set.","docstring_summary":"Like 'set' but return behaves like the identity function when the field could not be set.","docstring_tokens":["Like","set","but","return","behaves","like","the","identity","function","when","the","field","could","not","be","set","."],"function":"set' l v f = f `fromMaybe` set l v f","function_tokens":["set'","l","v","f","=","f","`","fromMaybe","`","set","l","v","f"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L94-L94","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"newOrData","parameters":"decl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newOrData decl = if isNewtype decl then \"newtype\" else \"data\"","function_tokens":["newOrData","decl","=","if","isNewtype","decl","then","\"newtype\"","else","\"data\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L522-L522","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SEC_OFFSET","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SEC_OFFSET                       = 0x1024","function_tokens":["al_SEC_OFFSET","=","0x1024"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L93-L93","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putBool","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putBool x = putWord8 (if x then 1 else 0)","function_tokens":["putBool","x","=","putWord8","(","if","x","then","1","else","0",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L224-L224","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"suffix","parameters":"pa pb","argument_list":"","return_statement":"","docstring":"Suffix a printer with another one","docstring_summary":"Suffix a printer with another one","docstring_tokens":["Suffix","a","printer","with","another","one"],"function":"suffix pa pb = pb >> pa","function_tokens":["suffix","pa","pb","=","pb",">>","pa"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L308-L308","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"rename","parameters":"pool","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rename pool = foldl (\\(vs, ns) (IFix (Var _ s)) -> let (n', ns') = runCoiter ns in (IFix (Var n' s) : vs, ns')) ([], pool)","function_tokens":["rename","pool","=","foldl","(","\\","(","vs",",","ns",")","(","IFix","(","Var","_","s",")",")","->","let","(","n'",",","ns'",")","=","runCoiter","ns","in","(","IFix","(","Var","n'","s",")",":","vs",",","ns'",")",")","(","[","]",",","pool",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L714-L714","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \/\\ b = a .&. b","function_tokens":["a","\/\\","b","=","a",".&.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L198-L198","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"prags","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prags = map truncateComma $ wrapMaybe maxWidth \"\" 1 $\n      map (++ \",\") (init pragmas') ++ [last pragmas']","function_tokens":["prags","=","map","truncateComma","$","wrapMaybe","maxWidth","\"\"","1","$","map","(","++","\",\"",")","(","init","pragmas'",")","++","[","last","pragmas'","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L69-L70","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ifold","parameters":"(_ `Divides` a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (_ `Divides` a)  = coerce a","function_tokens":["ifold","(","_","`","Divides","`","a",")","=","coerce","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L85-L85","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"groupAdjacent'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"groupAdjacent' =\n      fmap turnSndBackToNel . groupAdjacent . fmap (fmap toList)\n      where\n        turnSndBackToNel (a, bss) = (a, fromList . concat $ bss)","function_tokens":["groupAdjacent'","=","fmap","turnSndBackToNel",".","groupAdjacent",".","fmap","(","fmap","toList",")","where","turnSndBackToNel","(","a",",","bss",")","=","(","a",",","fromList",".","concat","$","bss",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L136-L141","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ls","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ls = bind (Proxy :: Proxy f) a","function_tokens":["ls","=","bind","(","Proxy","::","Proxy","f",")","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L786-L786","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"getPolygon","parameters":"(RecPolygonZ { recPolZPoints = pt })","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getPolygon (RecPolygonZ { recPolZPoints = pt }) = pt","function_tokens":["getPolygon","(","RecPolygonZ","{","recPolZPoints","=","pt","}",")","=","pt"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L80-L80","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Attenuation.hs","language":"haskell","identifier":"unmarshalDistanceModel","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalDistanceModel x\n   | x == al_NONE = NoAttenuation\n   | x == al_INVERSE_DISTANCE = InverseDistance\n   | x == al_INVERSE_DISTANCE_CLAMPED = InverseDistanceClamped\n   | x == al_LINEAR_DISTANCE = LinearDistance\n   | x == al_LINEAR_DISTANCE_CLAMPED = LinearDistanceClamped\n   | x == al_EXPONENT_DISTANCE = ExponentDistance\n   | x == al_EXPONENT_DISTANCE_CLAMPED = ExponentDistanceClamped\n   | otherwise = error (\"unmarshalDistanceModel: illegal value \" ++ show x)","function_tokens":["unmarshalDistanceModel","x","|","x","==","al_NONE","=","NoAttenuation","|","x","==","al_INVERSE_DISTANCE","=","InverseDistance","|","x","==","al_INVERSE_DISTANCE_CLAMPED","=","InverseDistanceClamped","|","x","==","al_LINEAR_DISTANCE","=","LinearDistance","|","x","==","al_LINEAR_DISTANCE_CLAMPED","=","LinearDistanceClamped","|","x","==","al_EXPONENT_DISTANCE","=","ExponentDistance","|","x","==","al_EXPONENT_DISTANCE_CLAMPED","=","ExponentDistanceClamped","|","otherwise","=","error","(","\"unmarshalDistanceModel: illegal value \"","++","show","x",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Attenuation.hs#L188-L196","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Attenuation.hs","hash_val":13566,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"displayException","parameters":"(Unexpected t)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"displayException (Unexpected t) = unpack t","function_tokens":["displayException","(","Unexpected","t",")","=","unpack","t"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L203-L203","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"size","parameters":"t","argument_list":"","return_statement":"","docstring":"\/O(1)\/. Cardinality of the set.","docstring_summary":"\/O(1)\/. Cardinality of the set.","docstring_tokens":["\/","O","(","1",")","\/",".","Cardinality","of","the","set","."],"function":"size t\n  = case t of\n      Bin _ s _ _ _ _ -> s\n      Tip _ _ -> 1\n      Nil   -> 0\n\n\n-- | \/O(min(n,W))\/. Is the value a member of the set?","function_tokens":["size","t","=","case","t","of","Bin","_","s","_","_","_","_","->","s","Tip","_","_","->","1","Nil","->","0","-- | \/O(min(n,W))\/. Is the value a member of the set?"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L254-L262","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"classP","parameters":"cla tys","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"classP cla tys\n  = do tysl <- sequence tys\n       return (foldl AppT (ConT cla) tysl)\n#endif","function_tokens":["classP","cla","tys","=","do","tysl","<-","sequence","tys","return","(","foldl","AppT","(","ConT","cla",")","tysl",")","#endif"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L723-L728","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"itraverse","parameters":"f (InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (InL fa) = InL <$> itraverse f fa","function_tokens":["itraverse","f","(","InL","fa",")","=","InL","<$>","itraverse","f","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L95-L95","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtToMapFilesP","parameters":"p","argument_list":"","return_statement":"","docstring":"Given a projection and list of districts, return a list of maps.","docstring_summary":"Given a projection and list of districts, return a list of maps.","docstring_tokens":["Given","a","projection","and","list","of","districts","return","a","list","of","maps","."],"function":"districtToMapFilesP p = fmap (projectMap p) . districtToMapFiles","function_tokens":["districtToMapFilesP","p","=","fmap","(","projectMap","p",")",".","districtToMapFiles"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L58-L58","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"runBylineT'","parameters":"Settings {..} m","argument_list":"","return_statement":"","docstring":"Like 'runBylineT' except you can override the settings.  @since 1.0.0.0","docstring_summary":"Like 'runBylineT' except you can override the settings.","docstring_tokens":["Like","runBylineT","except","you","can","override","the","settings","."],"function":"runBylineT' Settings {..} m = do\n  compRef <- newIORef []\n  let settings =\n        Haskeline.setComplete\n          (compFunc compRef)\n          Haskeline.defaultSettings\n  let behavior =\n        maybe\n          Haskeline.defaultBehavior\n          Haskeline.useFileHandle\n          bylineInput\n  let hOut = fromMaybe stdout bylineOutput\n  Haskeline.runInputTBehavior behavior settings (go compRef hOut)\n  where\n    compFunc :: CompRef IO -> Haskeline.CompletionFunc m\n    compFunc compRef input = liftIO $\n      readIORef compRef >>= \\case\n        [] -> Haskeline.completeFilename input\n        fs -> runCompletionFunctions fs input\n    go ::\n      CompRef IO ->\n      Handle ->\n      Haskeline.InputT m (Maybe a)\n    go compRef hOut = do\n      mode <- maybe (liftIO (defaultRenderMode hOut)) pure bylineMode\n      unBylineT m\n        & evalPrimF mode hOut compRef\n        & unEvalT\n        & runMaybeT\n\n-- | Internal transformer for evaluating primitive operations in the\n-- 'Haskeline.InputT' transformer with EOF handling.\n--\n-- @since 1.0.0.0","function_tokens":["runBylineT'","Settings","{","..","}","m","=","do","compRef","<-","newIORef","[","]","let","settings","=","Haskeline","setComplete","(","compFunc","compRef",")","Haskeline","defaultSettings","let","behavior","=","maybe","Haskeline","defaultBehavior","Haskeline","useFileHandle","bylineInput","let","hOut","=","fromMaybe","stdout","bylineOutput","Haskeline","runInputTBehavior","behavior","settings","(","go","compRef","hOut",")","where","compFunc","::","CompRef","IO","->","Haskeline","CompletionFunc","m","compFunc","compRef","input","=","liftIO","$","readIORef","compRef",">>=","\\","case","[","]","->","Haskeline","completeFilename","input","fs","->","runCompletionFunctions","fs","input","go","::","CompRef","IO","->","Handle","->","Haskeline","InputT","m","(","Maybe","a",")","go","compRef","hOut","=","do","mode","<-","maybe","(","liftIO","(","defaultRenderMode","hOut",")",")","pure","bylineMode","unBylineT","m","&","evalPrimF","mode","hOut","compRef","&","unEvalT","&","runMaybeT","-- | Internal transformer for evaluating primitive operations in the","-- 'Haskeline.InputT' transformer with EOF handling.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L142-L176","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"bench-app\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = do\n  [operation, input, output] <- getArgs\n  case operation of\n    \"compress\" -> do\n      selector <- mkEntrySelector (takeFileName input)\n      createArchive output (loadEntry Deflate selector input)\n    \"uncompress\" ->\n      withArchive input (unpackInto output)\n    _ -> do\n      putStrLn \"Unknown command.\"\n      exitFailure","function_tokens":["main","=","do","[","operation",",","input",",","output","]","<-","getArgs","case","operation","of","\"compress\"","->","do","selector","<-","mkEntrySelector","(","takeFileName","input",")","createArchive","output","(","loadEntry","Deflate","selector","input",")","\"uncompress\"","->","withArchive","input","(","unpackInto","output",")","_","->","do","putStrLn","\"Unknown command.\"","exitFailure"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/bench-app\/Main.hs#L9-L19","hash_key":"mrkkrp\/zip:bench-app\/Main.hs","hash_val":28360,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"sinh","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sinh = fmap sinh","function_tokens":["sinh","=","fmap","sinh"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L249-L249","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mul","parameters":"[]","argument_list":"","return_statement":"","docstring":"A smart constructor for a variadic multiplication","docstring_summary":"A smart constructor for a variadic multiplication","docstring_tokens":["A","smart","constructor","for","a","variadic","multiplication"],"function":"mul []  = cnst 1","function_tokens":["mul","[","]","=","cnst","1"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L204-L204","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/Setup.hs#L2-L2","hash_key":"haskell-works\/hw-json-simd:Setup.hs","hash_val":38429,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"fieldPos","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldPos = bracePos + 2","function_tokens":["fieldPos","=","bracePos","+","2"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L379-L379","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"giveup","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"giveup = throwM (InvalidEntrySelector path)","function_tokens":["giveup","=","throwM","(","InvalidEntrySelector","path",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L102-L102","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Result x0 y0 z0 <> Result x1 y1 z1 = Result (x0+x1) (y0+y1) (z0+z1)","function_tokens":["Result","x0","y0","z0","<>","Result","x1","y1","z1","=","Result","(","x0","+","x1",")","(","y0","+","y1",")","(","z0","+","z1",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L65-L65","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_CONE_OUTER_ANGLE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_CONE_OUTER_ANGLE                 = 0x1002","function_tokens":["al_CONE_OUTER_ANGLE","=","0x1002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L91-L91","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"undoEntryChanges","parameters":"s","argument_list":"","return_statement":"","docstring":"Undo the changes to a specific archive entry.","docstring_summary":"Undo the changes to a specific archive entry.","docstring_tokens":["Undo","the","changes","to","a","specific","archive","entry","."],"function":"undoEntryChanges s = modifyActions f\n  where\n    f = S.filter ((\/= Just s) . I.targetEntry)\n\n-- | Undo the changes to the archive as a whole (archive's comment).","function_tokens":["undoEntryChanges","s","=","modifyActions","f","where","f","=","S","filter","(","(","\/=","Just","s",")",".","I","targetEntry",")","-- | Undo the changes to the archive as a whole (archive's comment)."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L624-L629","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"step'","parameters":"columns style align removeRedundant lngPrefix ls m","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"step' columns style align removeRedundant lngPrefix ls m\n  | null languagePragmas = ls\n  | otherwise = Editor.apply changes ls\n  where\n    isRedundant'\n        | removeRedundant = isRedundant m\n        | otherwise       = const False\n\n    languagePragmas = moduleLanguagePragmas m\n\n    convertFstToBlock :: [(GHC.RealSrcSpan, a)] -> [(Block String, a)]\n    convertFstToBlock = fmap \\(rspan, a) ->\n      (Block (GHC.srcSpanStartLine rspan) (GHC.srcSpanEndLine rspan), a)\n\n    groupAdjacent' =\n      fmap turnSndBackToNel . groupAdjacent . fmap (fmap toList)\n      where\n        turnSndBackToNel (a, bss) = (a, fromList . concat $ bss)\n\n    longest :: Int\n    longest  = maximum $ map length $ toList . snd =<< languagePragmas\n\n    groups :: [(Block String, NonEmpty String)]\n    groups = [(b, pgs) | (b, pgs) <- groupAdjacent' (convertFstToBlock languagePragmas)]\n\n    changes = mconcat\n      [ Editor.changeLines b (const $ prettyPragmas lngPrefix columns longest align style pg)\n      | (b, pg) <- filterRedundant isRedundant' groups\n      ]\n\n\n--------------------------------------------------------------------------------\n-- | Add a LANGUAGE pragma to a module if it is not present already.","function_tokens":["step'","columns","style","align","removeRedundant","lngPrefix","ls","m","|","null","languagePragmas","=","ls","|","otherwise","=","Editor","apply","changes","ls","where","isRedundant'","|","removeRedundant","=","isRedundant","m","|","otherwise","=","const","False","languagePragmas","=","moduleLanguagePragmas","m","convertFstToBlock","::","[","(","GHC","RealSrcSpan",",","a",")","]","->","[","(","Block","String",",","a",")","]","convertFstToBlock","=","fmap","\\","(","rspan",",","a",")","->","(","Block","(","GHC","srcSpanStartLine","rspan",")","(","GHC","srcSpanEndLine","rspan",")",",","a",")","groupAdjacent'","=","fmap","turnSndBackToNel",".","groupAdjacent",".","fmap","(","fmap","toList",")","where","turnSndBackToNel","(","a",",","bss",")","=","(","a",",","fromList",".","concat","$","bss",")","longest","::","Int","longest","=","maximum","$","map","length","$","toList",".","snd","=<<","languagePragmas","groups","::","[","(","Block","String",",","NonEmpty","String",")","]","groups","=","[","(","b",",","pgs",")","|","(","b",",","pgs",")","<-","groupAdjacent'","(","convertFstToBlock","languagePragmas",")","]","changes","=","mconcat","[","Editor","changeLines","b","(","const","$","prettyPragmas","lngPrefix","columns","longest","align","style","pg",")","|","(","b",",","pg",")","<-","filterRedundant","isRedundant'","groups","]","--------------------------------------------------------------------------------","-- | Add a LANGUAGE pragma to a module if it is not present already."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L122-L155","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"AndrasKovacs\/singleton-nats","sha":"ec2cd4d2284111047cf1a26ba070f593faf9c96a","path":"Data\/Nat.hs","language":"haskell","identifier":"someNatVal","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"someNatVal n = case Lit.someNatVal n of\n  Just (Lit.SomeNat (_ :: Proxy n)) -> Just (SomeSing (sFromInteger (sing :: Sing n)))\n  Nothing -> Nothing\n\n{-| Provides a shorthand for 'Nat'-s using \"GHC.TypeLits\", for example:\n\n>>> :kind! Lit 3\nLit 3 :: Nat\n= 'S ('S ('S 'Z))\n-}","function_tokens":["someNatVal","n","=","case","Lit","someNatVal","n","of","Just","(","Lit","SomeNat","(","_","::","Proxy","n",")",")","->","Just","(","SomeSing","(","sFromInteger","(","sing","::","Sing","n",")",")",")","Nothing","->","Nothing","{-| Provides a shorthand for 'Nat'-s using \"GHC.TypeLits\", for example:\n\n>>> :kind! Lit 3\nLit 3 :: Nat\n= 'S ('S ('S 'Z))\n-}"],"url":"https:\/\/github.com\/AndrasKovacs\/singleton-nats\/blob\/ec2cd4d2284111047cf1a26ba070f593faf9c96a\/Data\/Nat.hs#L103-L114","hash_key":"AndrasKovacs\/singleton-nats:Data\/Nat.hs","hash_val":3829,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = ChooseC $ \\ fork leaf -> case sig of\n    L Choose -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other  -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runChoose (coerce fork) (coerce leaf)\n    where\n    dst :: Applicative m => ChooseC Identity (ChooseC m a) -> m (ChooseC Identity a)\n    dst = run . runChoose (liftA2 (liftA2 (<|>))) (pure . runChoose (liftA2 (<|>)) (pure . pure))","function_tokens":["alg","hdl","sig","ctx","=","ChooseC","$","\\","fork","leaf","->","case","sig","of","L","Choose","->","leaf","(","True","<$","ctx",")","`","fork","`","leaf","(","False","<$","ctx",")","R","other","->","thread","(","dst","~<~","hdl",")","other","(","pure","ctx",")",">>=","run",".","runChoose","(","coerce","fork",")","(","coerce","leaf",")","where","dst","::","Applicative","m","=>","ChooseC","Identity","(","ChooseC","m","a",")","->","m","(","ChooseC","Identity","a",")","dst","=","run",".","runChoose","(","liftA2","(","liftA2","(","<|>",")",")",")","(","pure",".","runChoose","(","liftA2","(","<|>",")",")","(","pure",".","pure",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L100-L106","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_MINOR_VERSION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_MINOR_VERSION                   = 0x1001","function_tokens":["alc_MINOR_VERSION","=","0x1001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L161-L161","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"pad","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pad | sameLine cfg = let len = maximum (map (length . name) bs) in map (\\x -> x{name = take len $ name x ++ repeat ' '}) bs\n            | otherwise = bs","function_tokens":["pad","|","sameLine","cfg","=","let","len","=","maximum","(","map","(","length",".","name",")","bs",")","in","map","(","\\","x","->","x","{","name","=","take","len","$","name","x","++","repeat","' '","}",")","bs","|","otherwise","=","bs"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L140-L141","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(!) = (MG.!)","function_tokens":["(","!",")","=","(","MG","!",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L126-L126","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"index","parameters":"Not {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Not {} = SBooleanSort","function_tokens":["index","Not","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L361-L361","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInCubic","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease in cubic.","docstring_summary":"Ease in cubic.","docstring_tokens":["Ease","in","cubic","."],"function":"easeInCubic c t b =  c * realToFrac (t*t*t) + b","function_tokens":["easeInCubic","c","t","b","=","c","*","realToFrac","(","t","*","t","*","t",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L104-L104","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"needsZip64","parameters":"EntryDescription {..}","argument_list":"","return_statement":"","docstring":"Check if an entry with these parameters needs the Zip64 extension.","docstring_summary":"Check if an entry with these parameters needs the Zip64 extension.","docstring_tokens":["Check","if","an","entry","with","these","parameters","needs","the","Zip64","extension","."],"function":"needsZip64 EntryDescription {..} =\n  any\n    (>= ffffffff)\n    [edOffset, edCompressedSize, edUncompressedSize]","function_tokens":["needsZip64","EntryDescription","{","..","}","=","any","(",">=","ffffffff",")","[","edOffset",",","edCompressedSize",",","edUncompressedSize","]"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1125-L1128","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"behavior","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"behavior =\n        maybe\n          Haskeline.defaultBehavior\n          Haskeline.useFileHandle\n          bylineInput","function_tokens":["behavior","=","maybe","Haskeline","defaultBehavior","Haskeline","useFileHandle","bylineInput"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L148-L152","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/Setup.hs#L4-L4","hash_key":"ghulette\/language-c-comments:Setup.hs","hash_val":33268,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"generateLabel","parameters":"failing concrete datatype dtVars allCons\n              field@(Field name forcedMono fieldtype (contexts, subst))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"generateLabel failing concrete datatype dtVars allCons\n              field@(Field name forcedMono fieldtype (contexts, subst)) =\n\n  do let total = length contexts == length (prune contexts allCons)\n\n     (Typing mono tyI tyO _)\n        <- computeTypes forcedMono fieldtype datatype dtVars subst\n\n     let cat     = varT (mkName \"cat\")\n         failE   = if failing\n                   then [| failArrow |]\n                   else [| zeroArrow |]\n         getT    = [| arr $(getter failing total field) |]\n         putT    = [| arr $(setter failing total field) |]\n         getP    = [| $(failE) ||| id <<< $getT |]\n         putP    = [| $(failE) ||| id <<< $putT |]\n         failP   = if failing\n                   then classP ''ArrowFail [ [t| String |], cat]\n                   else classP ''ArrowZero [cat]\n         ctx     = if total\n                   then cxt [ classP ''ArrowApply  [cat] ]\n                   else cxt [ classP ''ArrowChoice [cat]\n                            , classP ''ArrowApply  [cat]\n                            , failP\n                            ]\n         body    = if total\n                   then [| Poly.point $ Point $getT (modifier $getT $putT) |]\n                   else [| Poly.point $ Point $getP (modifier $getP $putP) |]\n         cont    = if concrete\n                   then cxt []\n                   else ctx\n         partial = if failing\n                   then [t| Failing String |]\n                   else [t| Partial |]\n         concTy  = if total\n                   then if mono\n                        then [t| Mono.Lens Total $tyI $tyO |]\n                        else [t| Poly.Lens Total $tyI $tyO |]\n                   else if mono\n                        then [t| Mono.Lens $partial $tyI $tyO |]\n                        else [t| Poly.Lens $partial $tyI $tyO |]\n         ty      = if concrete\n                   then concTy\n                   else if mono\n                        then [t| Mono.Lens $cat $tyI $tyO |]\n                        else [t| Poly.Lens $cat $tyI $tyO |]\n\n     tvs <- nub . binderFromType <$> ty\n     return $\n       case name of\n         Nothing -> LabelExpr tvs cont ty body\n         Just n  ->\n\n#if MIN_VERSION_template_haskell(2,8,0)\n           -- Generate an inline declaration for the label.\n           -- Type of InlineSpec removed in TH-2.8.0 (GHC 7.6)\n           let inline = InlineP n Inline FunLike (FromPhase 0)\n#else\n           let inline = InlineP n (InlineSpec True True (Just (True, 0)))\n#endif\n            in LabelDecl n (return (PragmaD inline)) tvs cont ty body\n\n-- Build a total polymorphic modification function from a getter and setter.","function_tokens":["generateLabel","failing","concrete","datatype","dtVars","allCons","field","@","(","Field","name","forcedMono","fieldtype","(","contexts",",","subst",")",")","=","do","let","total","=","length","contexts","==","length","(","prune","contexts","allCons",")","(","Typing","mono","tyI","tyO","_",")","<-","computeTypes","forcedMono","fieldtype","datatype","dtVars","subst","let","cat","=","varT","(","mkName","\"cat\"",")","failE","=","if","failing","then","[","|"," failArrow ","|]","else","[","|"," zeroArrow ","|]","getT","=","[","|"," arr $(getter failing total field) ","|]","putT","=","[","|"," arr $(setter failing total field) ","|]","getP","=","[","|"," $(failE) ||| id <<< $getT ","|]","putP","=","[","|"," $(failE) ||| id <<< $putT ","|]","failP","=","if","failing","then","classP","''","ArrowFail","[","[","t","|"," String ","|]",",","cat","]","else","classP","''","ArrowZero","[","cat","]","ctx","=","if","total","then","cxt","[","classP","''","ArrowApply","[","cat","]","]","else","cxt","[","classP","''","ArrowChoice","[","cat","]",",","classP","''","ArrowApply","[","cat","]",",","failP","]","body","=","if","total","then","[","|"," Poly.point $ Point $getT (modifier $getT $putT) ","|]","else","[","|"," Poly.point $ Point $getP (modifier $getP $putP) ","|]","cont","=","if","concrete","then","cxt","[","]","else","ctx","partial","=","if","failing","then","[","t","|"," Failing String ","|]","else","[","t","|"," Partial ","|]","concTy","=","if","total","then","if","mono","then","[","t","|"," Mono.Lens Total $tyI $tyO ","|]","else","[","t","|"," Poly.Lens Total $tyI $tyO ","|]","else","if","mono","then","[","t","|"," Mono.Lens $partial $tyI $tyO ","|]","else","[","t","|"," Poly.Lens $partial $tyI $tyO ","|]","ty","=","if","concrete","then","concTy","else","if","mono","then","[","t","|"," Mono.Lens $cat $tyI $tyO ","|]","else","[","t","|"," Poly.Lens $cat $tyI $tyO ","|]","tvs","<-","nub",".","binderFromType","<$>","ty","return","$","case","name","of","Nothing","->","LabelExpr","tvs","cont","ty","body","Just","n","->","#if MIN_VERSION_template_haskell(2,8,0)","-- Generate an inline declaration for the label.","-- Type of InlineSpec removed in TH-2.8.0 (GHC 7.6)","let","inline","=","InlineP","n","Inline","FunLike","(","FromPhase","0",")","#else\n           let inline = InlineP n (InlineSpec True True (Just (True, 0)))\n","#endif","in","LabelDecl","n","(","return","(","PragmaD","inline",")",")","tvs","cont","ty","body","-- Build a total polymorphic modification function from a getter and setter."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L424-L488","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"modifyAndGet","parameters":"l f","argument_list":"","return_statement":"","docstring":"Modify a value with a function somewhere in the state, pointed to by the specified lens. Additionally return a separate value based on the modification.","docstring_summary":"Modify a value with a function somewhere in the state, pointed to by the specified lens. Additionally return a separate value based on the modification.","docstring_tokens":["Modify","a","value","with","a","function","somewhere","in","the","state","pointed","to","by","the","specified","lens",".","Additionally","return","a","separate","value","based","on","the","modification","."],"function":"modifyAndGet l f =\n  do (b, a) <- f `liftM` gets l\n     puts l a\n     return b","function_tokens":["modifyAndGet","l","f","=","do","(","b",",","a",")","<-","f","`","liftM","`","gets","l","puts","l","a","return","b"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L72-L75","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"truncateComma","parameters":"\"\"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"truncateComma \"\"     = \"\"","function_tokens":["truncateComma","\"\"","=","\"\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L85-L85","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"id","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"id              = Id","function_tokens":["id","=","Id"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L89-L89","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"singleton","parameters":"x","argument_list":"","return_statement":"","docstring":"\/O(1)\/. A set of one element.","docstring_summary":"\/O(1)\/. A set of one element.","docstring_tokens":["\/","O","(","1",")","\/",".","A","set","of","one","element","."],"function":"singleton x = tip x","function_tokens":["singleton","x","=","tip","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L302-L302","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"verticalCompactPragmas","parameters":"lg pragmas'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"verticalCompactPragmas lg pragmas' =\n  [ \"{-# \" <> lg\n  , \"    \" <> head pragmas'\n  ]\n  <> [ \"  , \"  <> pragma | pragma <- tail pragmas']\n  <> [ \"  #-}\"]","function_tokens":["verticalCompactPragmas","lg","pragmas'","=","[","\"{-# \"","<>","lg",",","\"    \"","<>","head","pragmas'","]","<>","[","\"  , \"","<>","pragma","|","pragma","<-","tail","pragmas'","]","<>","[","\"  #-}\"","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L75-L80","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"deleteQuads","parameters":"CayleyConnection{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteQuads CayleyConnection{..} =\n  doDeletions manager cayleyConfig\n  where\n    doDeletions m CayleyConfig{..} qs =\n      apiRequest\n        m (urlBase serverName apiVersion ++ \"\/delete\")\n        serverPort (toRequestBody qs)\n\n-- | Write a N-Quad file.\n--\n-- >\u03bb> writeNQuadFile conn \"testdata.nq\"\n-- >Just (Object (fromList [(\"result\",String \"Successfully wrote 11 quads.\")]))\n--","function_tokens":["deleteQuads","CayleyConnection","{","..","}","=","doDeletions","manager","cayleyConfig","where","doDeletions","m","CayleyConfig","{","..","}","qs","=","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/delete\"",")","serverPort","(","toRequestBody","qs",")","-- | Write a N-Quad file.","--","-- >\u03bb> writeNQuadFile conn \"testdata.nq\"","-- >Just (Object (fromList [(\"result\",String \"Successfully wrote 11 quads.\")]))","--"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L155-L168","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(Not a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (Not a) = a","function_tokens":["dual","(","Not","a",")","=","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L668-L668","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zip6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip6 = MG.zip6","function_tokens":["zip6","=","MG","zip6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L332-L332","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookPullRequestEvent","function_tokens":["reflect","_","=","WebhookPullRequestEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L463-L463","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a =:\/ b = slice 0 (dur a `minB` dur b) $ a <> b","function_tokens":["a","=:\/","b","=","slice","0","(","dur","a","`","minB","`","dur","b",")","$","a","<>","b"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L115-L115","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference","parameters":"Nil _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"difference Nil _       = Nil","function_tokens":["difference","Nil","_","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L405-L405","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"stylishHaskellVersion","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"stylishHaskellVersion = \"stylish-haskell \" <> showVersion version","function_tokens":["stylishHaskellVersion","=","\"stylish-haskell \"","<>","showVersion","version"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L83-L83","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"h","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"h = handle inst","function_tokens":["h","=","handle","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L129-L129","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toCompressionMethod","parameters":"8","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toCompressionMethod 8 = Just Deflate","function_tokens":["toCompressionMethod","8","=","Just","Deflate"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1110-L1110","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"findFilesR","parameters":"v path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findFilesR v path = do\n  doesFileExist path >>= \\case\n    True -> return [path]\n    _    -> doesDirectoryExist path >>= \\case\n      True  -> findFilesRecursive path >>=\n        return . filter (\\x -> takeExtension x == \".hs\")\n      False -> do\n        makeVerbose v (\"Input folder does not exists: \" <> path)\n        findFilesR v []\n  where\n    findFilesRecursive :: FilePath -> IO [FilePath]\n    findFilesRecursive = listDirectoryFiles findFilesRecursive\n\n    listDirectoryFiles :: (FilePath -> IO [FilePath])\n                       -> FilePath -> IO [FilePath]\n    listDirectoryFiles go topdir = do\n      ps <- listDirectory topdir >>=\n        mapM (\\x -> do\n                 let dir = topdir <\/> x\n                 doesDirectoryExist dir >>= \\case\n                   True  -> go dir\n                   False -> return [dir])\n      return $ concat ps","function_tokens":["findFilesR","v","path","=","do","doesFileExist","path",">>=","\\","case","True","->","return","[","path","]","_","->","doesDirectoryExist","path",">>=","\\","case","True","->","findFilesRecursive","path",">>=","return",".","filter","(","\\","x","->","takeExtension","x","==","\".hs\"",")","False","->","do","makeVerbose","v","(","\"Input folder does not exists: \"","<>","path",")","findFilesR","v","[","]","where","findFilesRecursive","::","FilePath","->","IO","[","FilePath","]","findFilesRecursive","=","listDirectoryFiles","findFilesRecursive","listDirectoryFiles","::","(","FilePath","->","IO","[","FilePath","]",")","->","FilePath","->","IO","[","FilePath","]","listDirectoryFiles","go","topdir","=","do","ps","<-","listDirectory","topdir",">>=","mapM","(","\\","x","->","do","let","dir","=","topdir","<\/>","x","doesDirectoryExist","dir",">>=","\\","case","True","->","go","dir","False","->","return","[","dir","]",")","return","$","concat","ps"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L128-L150","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"startLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"startLine = fromMaybe 1 $ moduleLine <|>\n            (fmap GHC.srcSpanStartLine . GHC.srcSpanToRealSrcSpan $\n                GHC.getLoc lmodul)","function_tokens":["startLine","=","fromMaybe","1","$","moduleLine","<|>","(","fmap","GHC","srcSpanStartLine",".","GHC","srcSpanToRealSrcSpan","$","GHC","getLoc","lmodul",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L74-L76","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"slice'","parameters":"t0 t1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"slice' t0 t1 = sliceDur . del (-t0) . filterEvents (within t0 t1)\n    where sliceDur (Track _ a) = Track (t1 - t0) a\n\n-- | @('takeT' t)@ is equivalent to @('slice' 0 t)@.","function_tokens":["slice'","t0","t1","=","sliceDur",".","del","(","-","t0",")",".","filterEvents","(","within","t0","t1",")","where","sliceDur","(","Track","_","a",")","=","Track","(","t1","-","t0",")","a","-- | @('takeT' t)@ is equivalent to @('slice' 0 t)@."],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L165-L169","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"maybePath","parameters":"\".\"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maybePath \".\" = Nothing","function_tokens":["maybePath","\".\"","=","Nothing"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L154-L154","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"liftByline","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftByline = BylineT . Free.fromF","function_tokens":["liftByline","=","BylineT",".","Free","fromF"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L85-L85","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a =:= b = a <> b","function_tokens":["a","=:=","b","=","a","<>","b"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L123-L123","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getInt8","parameters":"","argument_list":"","return_statement":"","docstring":"8-bit Int value","docstring_summary":"8-bit Int value","docstring_tokens":["8","-","bit","Int","value"],"function":"getInt8 = fromIntegral <$> getWord8","function_tokens":["getInt8","=","fromIntegral","<$>","getWord8"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L16-L16","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"color","parameters":"l c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"color l c = case c of\n                Color.ColorCode ai ac -> ANSI.SetColor l ai ac\n                rgb -> ANSI.SetColor l ANSI.Dull (Color.colorAsANSI rgb)","function_tokens":["color","l","c","=","case","c","of","Color","ColorCode","ai","ac","->","ANSI","SetColor","l","ai","ac","rgb","->","ANSI","SetColor","l","ANSI","Dull","(","Color","colorAsANSI","rgb",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L191-L194","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"nl","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nl = configNewline conf","function_tokens":["nl","=","configNewline","conf"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L170-L170","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"stride","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stride = prev - current","function_tokens":["stride","=","prev","-","current"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L99-L99","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"dataSink","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dataSink =\n        getZipSink $\n          ZipSink sizeSink <* ZipSink (CB.sinkHandle h)","function_tokens":["dataSink","=","getZipSink","$","ZipSink","sizeSink","<*","ZipSink","(","CB","sinkHandle","h",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L580-L582","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(FileUrl _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (FileUrl _)              = (True, True, False, False)","function_tokens":["go","(","FileUrl","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L370-L370","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getDouble","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getDouble = getFloat64le","function_tokens":["getDouble","=","getFloat64le"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L122-L122","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = take (length fs)","function_tokens":["s","=","take","(","length","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L519-L519","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pats","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pats      = take i pats1 ++ [wildP] ++ drop (i + 1) pats1","function_tokens":["pats","=","take","i","pats1","++","[","wildP","]","++","drop","(","i","+","1",")","pats1"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L547-L547","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_,c) = dim mat","function_tokens":["(","_",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L183-L183","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DPi v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DPi v t e)  = s `hashWithSalt` (2 :: Int) `hashWithSalt` v `hashWithSalt` t `hashWithSalt` e","function_tokens":["hashWithSalt","s","(","DPi","v","t","e",")","=","s","`","hashWithSalt","`","(","2","::","Int",")","`","hashWithSalt","`","v","`","hashWithSalt","`","t","`","hashWithSalt","`","e"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L68-L68","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"unstore","parameters":"a","argument_list":"","return_statement":"","docstring":"Replaces `store` with an instance of its axiomatization.","docstring_summary":"Replaces `store` with an instance of its axiomatization.","docstring_tokens":["Replaces","store","with","an","instance","of","its","axiomatization","."],"function":"unstore a = let a' = flatten a in evalState (imapM unstore' a') (freenames a') where\n    unstore' :: IFix f s -> State VariableNamePool (IFix f s)\n    unstore' a' = fromMaybe (return a') (match a' >>= \\(Equals _ l r) -> instantiate l (unIFix r) <|> instantiate r (unIFix l))","function_tokens":["unstore","a","=","let","a'","=","flatten","a","in","evalState","(","imapM","unstore'","a'",")","(","freenames","a'",")","where","unstore'","::","IFix","f","s","->","State","VariableNamePool","(","IFix","f","s",")","unstore'","a'","=","fromMaybe","(","return","a'",")","(","match","a'",">>=","\\","(","Equals","_","l","r",")","->","instantiate","l","(","unIFix","r",")","<|>","instantiate","r","(","unIFix","l",")",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L928-L930","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = lift empty","function_tokens":["empty","=","lift","empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L98-L98","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"nomatch","parameters":"i p m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nomatch i p m\n  = (mask i m) \/= p","function_tokens":["nomatch","i","p","m","=","(","mask","i","m",")","\/=","p"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L907-L908","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookCommitCommentEvent","function_tokens":["reflect","_","=","WebhookCommitCommentEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L412-L412","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"elems","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"elems s = toList s","function_tokens":["elems","s","=","toList","s"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L709-L709","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","language":"haskell","identifier":"zipPadded","parameters":"a b []     (d:ds)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipPadded a b []     (d:ds) = (a, d):zipPadded a b [] ds","function_tokens":["zipPadded","a","b","[","]","(","d",":","ds",")","=","(","a",",","d",")",":","zipPadded","a","b","[","]","ds"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs#L7-L7","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/List.hs","hash_val":30237,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"commentsInFile","parameters":"file code","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commentsInFile file code = map (makeComment file) cmnts\n  where joinBrokenLines = unlines . parseLines\n        (_,cmnts) = parseComments (joinBrokenLines code)\n\n-- | Extract comments from a C file.","function_tokens":["commentsInFile","file","code","=","map","(","makeComment","file",")","cmnts","where","joinBrokenLines","=","unlines",".","parseLines","(","_",",","cmnts",")","=","parseComments","(","joinBrokenLines","code",")","-- | Extract comments from a C file."],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L54-L59","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"sizeCheck","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sizeCheck = do\n      fsize <- hFileSize h\n      let limit = max 0 (fsize - 0xffff - 22)\n      if fsize < 22\n        then return Nothing\n        else hSeek h SeekFromEnd (-22) >> loop limit","function_tokens":["sizeCheck","=","do","fsize","<-","hFileSize","h","let","limit","=","max","0","(","fsize","-","0xffff","-","22",")","if","fsize","<","22","then","return","Nothing","else","hSeek","h","SeekFromEnd","(","-","22",")",">>","loop","limit"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L966-L972","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' a = bind (Proxy :: Proxy g) (inject a)","function_tokens":["bind'","a","=","bind","(","Proxy","::","Proxy","g",")","(","inject","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L816-L816","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toRecreatingActions","parameters":"path entries","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toRecreatingActions path entries = E.foldl' f S.empty (M.keysSet entries)\n  where\n    f s e = s |> CopyEntry path e e\n\n-- | Transform a collection of 'PendingAction's into 'ProducingActions' and\n-- 'EditingActions'\u2014data that describes how to create resulting archive.","function_tokens":["toRecreatingActions","path","entries","=","E","foldl'","f","S","empty","(","M","keysSet","entries",")","where","f","s","e","=","s","|>","CopyEntry","path","e","e","-- | Transform a collection of 'PendingAction's into 'ProducingActions' and","-- 'EditingActions'\u2014data that describes how to create resulting archive."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L338-L344","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"resBPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resBPtr   = F.castPtr (F.unsafeForeignPtrToPtr resBFptr )","function_tokens":["resBPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L56-L56","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"comment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"comment = maybe B.empty T.encodeUtf8 mcomment","function_tokens":["comment","=","maybe","B","empty","T","encodeUtf8","mcomment"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L957-L957","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"select''","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"select'' _ _ = fail \"selecting from non-array\"","function_tokens":["select''","_","_","=","fail","\"selecting from non-array\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L102-L102","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"columns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"columns = configColumns config","function_tokens":["columns","=","configColumns","config"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L293-L293","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"modify","parameters":"(Point _ m)","argument_list":"","return_statement":"","docstring":"Get the modifier category from a Point.","docstring_summary":"Get the modifier category from a Point.","docstring_tokens":["Get","the","modifier","category","from","a","Point","."],"function":"modify (Point _ m) = m","function_tokens":["modify","(","Point","_","m",")","=","m"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L67-L67","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"shareFp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shareFp = prefixFp <\/> \"share\" <\/> project","function_tokens":["shareFp","=","prefixFp","<\/>","\"share\"","<\/>","project"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L99-L99","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"estimate","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"estimate\n            | ax <= 1   = evalChebyshevSeries erfc_xlt1_cs (2 * ax - 1)\n            | ax <= 5   = \n                let t = 0.5 * (ax - 3)\n                in exp (negate x*x) * evalChebyshevSeries erfc_x15_cs t\n            | ax < 10   = \n                let t = (2 * ax - 15) \/ 5\n                in (exp (negate x*x) \/ ax) * evalChebyshevSeries erfc_x510_cs t\n            | otherwise = erfc8 ax","function_tokens":["estimate","|","ax","<=","1","=","evalChebyshevSeries","erfc_xlt1_cs","(","2","*","ax","-","1",")","|","ax","<=","5","=","let","t","=","0.5","*","(","ax","-","3",")","in","exp","(","negate","x","*","x",")","*","evalChebyshevSeries","erfc_x15_cs","t","|","ax","<","10","=","let","t","=","(","2","*","ax","-","15",")","\/","5","in","(","exp","(","negate","x","*","x",")","\/","ax",")","*","evalChebyshevSeries","erfc_x510_cs","t","|","otherwise","=","erfc8","ax"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L56-L64","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Doppler.hs","language":"haskell","identifier":"speedOfSound","parameters":"","argument_list":"","return_statement":"","docstring":"'speedOfSound' allows the application to change the reference (propagation) speed used in the Doppler calculation. The source and listener velocities should be expressed in the same units as the speed of sound. Setting 'speedOfSound' to a negative or zero value will result in an 'ALInvalidValue' error, the command is ignored then. The default value is 343.3 (appropriate for velocity units of meters and air as the propagation medium).","docstring_summary":"'speedOfSound' allows the application to change the reference (propagation) speed used in the Doppler calculation. The source and listener velocities should be expressed in the same units as the speed of sound. Setting 'speedOfSound' to a negative or zero value will result in an 'ALInvalidValue' error, the command is ignored then. The default value is 343.3 (appropriate for velocity units of meters and air as the propagation medium).","docstring_tokens":["speedOfSound","allows","the","application","to","change","the","reference","(","propagation",")","speed","used","in","the","Doppler","calculation",".","The","source","and","listener","velocities","should","be","expressed","in","the","same","units","as","the","speed","of","sound",".","Setting","speedOfSound","to","a","negative","or","zero","value","will","result","in","an","ALInvalidValue","error","the","command","is","ignored","then",".","The","default","value","is","343",".","3","(","appropriate","for","velocity","units","of","meters","and","air","as","the","propagation","medium",")","."],"function":"speedOfSound = makeDopplerVar GetSpeedOfSound \"alSpeedOfSound\"","function_tokens":["speedOfSound","=","makeDopplerVar","GetSpeedOfSound","\"alSpeedOfSound\""],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Doppler.hs#L61-L61","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Doppler.hs","hash_val":10218,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"dropEnd","parameters":"count xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dropEnd count xs = take (length xs - count) xs","function_tokens":["dropEnd","count","xs","=","take","(","length","xs","-","count",")","xs"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L48-L48","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"VarT f <+> VarT g = VarT $ \\a -> f a `mplus` g a","function_tokens":["VarT","f","<+>","VarT","g","=","VarT","$","\\","a","->","f","a","`","mplus","`","g","a"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L161-L161","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for binary conjunction","docstring_summary":"A smart constructor for binary conjunction","docstring_tokens":["A","smart","constructor","for","binary","conjunction"],"function":"a .&. b = merge (flatten'' a ++ flatten'' b) where\n    merge []  = true\n    merge [f] = f\n    merge as  = inject $ And as\n\n    flatten'' e = case match e of\n        Just (And as) -> as\n        _ -> [e]\n\n-- | A smart constructor for binary disjunction","function_tokens":["a",".&.","b","=","merge","(","flatten''","a","++","flatten''","b",")","where","merge","[","]","=","true","merge","[","f","]","=","f","merge","as","=","inject","$","And","as","flatten''","e","=","case","match","e","of","Just","(","And","as",")","->","as","_","->","[","e","]","-- | A smart constructor for binary disjunction"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L455-L465","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"stepArea","parameters":"point (sum, base)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stepArea point (sum, base) = (sum + (areaTriangle base1 base point), point)","function_tokens":["stepArea","point","(","sum",",","base",")","=","(","sum","+","(","areaTriangle","base1","base","point",")",",","point",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L47-L47","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withInit","parameters":"f (x : xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withInit f (x : xs) = f x : withInit f xs","function_tokens":["withInit","f","(","x",":","xs",")","=","f","x",":","withInit","f","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L190-L190","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"mrqbody","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mrqbody =\n              handleCTypeH (Proxy :: Proxy list) (cs contentTypeH) $\n              fromStrict msg","function_tokens":["mrqbody","=","handleCTypeH","(","Proxy","::","Proxy","list",")","(","cs","contentTypeH",")","$","fromStrict","msg"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L298-L300","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_SPEED_OF_SOUND","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_SPEED_OF_SOUND                   = 0xC003","function_tokens":["al_SPEED_OF_SOUND","=","0xC003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L43-L43","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"direction","parameters":"","argument_list":"","return_statement":"","docstring":"If 'direction' does not contain the zero vector ('Vector3' 0 0 0), the source is directional. The sound emission is presumed to be symmetric around the direction vector (cylinder symmetry). Sources are not oriented in full 3 degrees of freedom, only two angles are effectively needed.  The zero vector is the initial value, indicating that a source is not directional. Specifying a non-zero vector will make the source directional. Specifying a zero vector for a directional source will effectively mark it as nondirectional.","docstring_summary":"If 'direction' does not contain the zero vector ('Vector3' 0 0 0), the source is directional. The sound emission is presumed to be symmetric around the direction vector (cylinder symmetry). Sources are not oriented in full 3 degrees of freedom, only two angles are effectively needed.  The zero vector is the initial value, indicating that a source is not directional. Specifying a non-zero vector will make the source directional. Specifying a zero vector for a directional source will effectively mark it as nondirectional.","docstring_tokens":["If","direction","does","not","contain","the","zero","vector","(","Vector3","0","0","0",")","the","source","is","directional",".","The","sound","emission","is","presumed","to","be","symmetric","around","the","direction","vector","(","cylinder","symmetry",")",".","Sources","are","not","oriented","in","full","3","degrees","of","freedom","only","two","angles","are","effectively","needed",".","The","zero","vector","is","the","initial","value","indicating","that","a","source","is","not","directional",".","Specifying","a","non","-","zero","vector","will","make","the","source","directional",".","Specifying","a","zero","vector","for","a","directional","source","will","effectively","mark","it","as","nondirectional","."],"function":"direction = makeSourceStateVar dictVector3ALfloat GetDirection","function_tokens":["direction","=","makeSourceStateVar","dictVector3ALfloat","GetDirection"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L410-L410","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"os","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge os  = inject $ Or os","function_tokens":["merge","os","=","inject","$","Or","os"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L469-L469","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"dst","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))","function_tokens":["dst","=","run",".","runNonDet","(","liftA2","(","liftA2","(","<|>",")",")",")","(","pure",".","runNonDetA",")","(","pure","(","pure","empty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L133-L133","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"liftIO","parameters":"io","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO io = StateC (\\ s -> (,) s <$> liftIO io)","function_tokens":["liftIO","io","=","StateC","(","\\","s","->","(",",",")","s","<$>","liftIO","io",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L115-L115","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = pickProjection projection","function_tokens":["p","=","pickProjection","projection"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L20-L20","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"index","parameters":"Exists {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Exists {} = SBooleanSort","function_tokens":["index","Exists","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L544-L544","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"DoubleSharp","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go DoubleSharp  = \"^^\"","function_tokens":["go","DoubleSharp","=","\"^^\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L462-L462","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putType","parameters":"ltp","argument_list":"","return_statement":"","docstring":"Print type","docstring_summary":"Print type","docstring_tokens":["Print","type"],"function":"putType ltp = case GHC.unLoc ltp of\n  GHC.HsFunTy _ arrowTp argTp funTp -> do\n    putOutputable argTp\n    space\n    case arrowTp of\n        GHC.HsUnrestrictedArrow {} -> putText \"->\"\n        GHC.HsLinearArrow {}       -> putText \"%1 ->\"\n        GHC.HsExplicitMult {}      -> putOutputable arrowTp\n    space\n    putType funTp\n  GHC.HsAppTy _ t1 t2 ->\n    putType t1 >> space >> putType t2\n  GHC.HsExplicitListTy _ _ xs -> do\n    putText \"'[\"\n    sep\n      (comma >> space)\n      (fmap putType xs)\n    putText \"]\"\n  GHC.HsExplicitTupleTy _ xs -> do\n    putText \"'(\"\n    sep\n      (comma >> space)\n      (fmap putType xs)\n    putText \")\"\n  GHC.HsOpTy _ lhs op rhs -> do\n    putType lhs\n    space\n    putRdrName op\n    space\n    putType rhs\n  GHC.HsTyVar _ flag rdrName -> do\n    case flag of\n      GHC.IsPromoted  -> putText \"'\"\n      GHC.NotPromoted -> pure ()\n    putRdrName rdrName\n  GHC.HsTyLit _ tp ->\n    putOutputable tp\n  GHC.HsParTy _ tp -> do\n    putText \"(\"\n    putType tp\n    putText \")\"\n  GHC.HsTupleTy _ _ xs -> do\n    putText \"(\"\n    sep\n      (comma >> space)\n      (fmap putType xs)\n    putText \")\"\n  GHC.HsForAllTy {} ->\n    putOutputable ltp\n  GHC.HsQualTy {} ->\n    putOutputable ltp\n  GHC.HsAppKindTy _ _ _ ->\n    putOutputable ltp\n  GHC.HsListTy _ _ ->\n    putOutputable ltp\n  GHC.HsSumTy _ _ ->\n    putOutputable ltp\n  GHC.HsIParamTy _ _ _ ->\n    putOutputable ltp\n  GHC.HsKindSig _ _ _ ->\n    putOutputable ltp\n  GHC.HsStarTy _ _ ->\n    putOutputable ltp\n  GHC.HsSpliceTy _ _ ->\n    putOutputable ltp\n  GHC.HsDocTy _ _ _ ->\n    putOutputable ltp\n  GHC.HsBangTy _ _ _ ->\n    putOutputable ltp\n  GHC.HsRecTy _ _ ->\n    putOutputable ltp\n  GHC.HsWildCardTy _ ->\n    putOutputable ltp\n  GHC.XHsType _ ->\n    putOutputable ltp\n\n-- | Print a newline","function_tokens":["putType","ltp","=","case","GHC","unLoc","ltp","of","GHC","HsFunTy","_","arrowTp","argTp","funTp","->","do","putOutputable","argTp","space","case","arrowTp","of","GHC","HsUnrestrictedArrow","{","}","->","putText","\"->\"","GHC","HsLinearArrow","{","}","->","putText","\"%1 ->\"","GHC","HsExplicitMult","{","}","->","putOutputable","arrowTp","space","putType","funTp","GHC","HsAppTy","_","t1","t2","->","putType","t1",">>","space",">>","putType","t2","GHC","HsExplicitListTy","_","_","xs","->","do","putText","\"'[\"","sep","(","comma",">>","space",")","(","fmap","putType","xs",")","putText","\"]\"","GHC","HsExplicitTupleTy","_","xs","->","do","putText","\"'(\"","sep","(","comma",">>","space",")","(","fmap","putType","xs",")","putText","\")\"","GHC","HsOpTy","_","lhs","op","rhs","->","do","putType","lhs","space","putRdrName","op","space","putType","rhs","GHC","HsTyVar","_","flag","rdrName","->","do","case","flag","of","GHC","IsPromoted","->","putText","\"'\"","GHC","NotPromoted","->","pure","(",")","putRdrName","rdrName","GHC","HsTyLit","_","tp","->","putOutputable","tp","GHC","HsParTy","_","tp","->","do","putText","\"(\"","putType","tp","putText","\")\"","GHC","HsTupleTy","_","_","xs","->","do","putText","\"(\"","sep","(","comma",">>","space",")","(","fmap","putType","xs",")","putText","\")\"","GHC","HsForAllTy","{","}","->","putOutputable","ltp","GHC","HsQualTy","{","}","->","putOutputable","ltp","GHC","HsAppKindTy","_","_","_","->","putOutputable","ltp","GHC","HsListTy","_","_","->","putOutputable","ltp","GHC","HsSumTy","_","_","->","putOutputable","ltp","GHC","HsIParamTy","_","_","_","->","putOutputable","ltp","GHC","HsKindSig","_","_","_","->","putOutputable","ltp","GHC","HsStarTy","_","_","->","putOutputable","ltp","GHC","HsSpliceTy","_","_","->","putOutputable","ltp","GHC","HsDocTy","_","_","_","->","putOutputable","ltp","GHC","HsBangTy","_","_","_","->","putOutputable","ltp","GHC","HsRecTy","_","_","->","putOutputable","ltp","GHC","HsWildCardTy","_","->","putOutputable","ltp","GHC","XHsType","_","->","putOutputable","ltp","-- | Print a newline"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L195-L272","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mergeConstAdd","parameters":"e (acc, r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeConstAdd e (acc, r) = case match e of\n    Just (Const c) -> (acc + c, r)\n    _              -> (acc, e : r)\n\n-- | A smart constructor for binary addition","function_tokens":["mergeConstAdd","e","(","acc",",","r",")","=","case","match","e","of","Just","(","Const","c",")","->","(","acc","+","c",",","r",")","_","->","(","acc",",","e",":","r",")","-- | A smart constructor for binary addition"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L163-L168","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"io","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"io = Iso (arr Tuple.swap) (arr Tuple.swap)","function_tokens":["io","=","Iso","(","arr","Tuple","swap",")","(","arr","Tuple","swap",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L94-L94","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/shell.hs","language":"haskell","identifier":"promptP","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"promptP =\n      SetPrompt\n        <$> O.strArgument\n          ( mconcat\n              [ O.metavar \"STR\",\n                O.help \"Set the prompt to STR\"\n              ]\n          )","function_tokens":["promptP","=","SetPrompt","<$>","O","strArgument","(","mconcat","[","O","metavar","\"STR\"",",","O","help","\"Set the prompt to STR\"","]",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/shell.hs#L48-L55","hash_key":"pjones\/byline:examples\/shell.hs","hash_val":26698,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"setNewlineMode","parameters":"h","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setNewlineMode h = do\n      let nl = configNewline conf\n      let mode = IO.NewlineMode IO.nativeNewline nl\n      IO.hSetNewlineMode h mode","function_tokens":["setNewlineMode","h","=","do","let","nl","=","configNewline","conf","let","mode","=","IO","NewlineMode","IO","nativeNewline","nl","IO","hSetNewlineMode","h","mode"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L169-L173","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_EXTENSIONS","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_EXTENSIONS                       = 0xB004","function_tokens":["al_EXTENSIONS","=","0xB004"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L49-L49","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"getSubitems","parameters":"path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getSubitems path = getSubitems' \"\"\n  where\n    getChildren path' =  (\\\\ [\".\", \"..\"]) <$> getDirectoryContents path'\n\n    getSubitems' relPath = do\n      let absPath = path <\/> relPath\n      isDir <- doesDirectoryExist absPath\n      children <- if isDir then getChildren absPath else return []\n      let relChildren = [relPath <\/> p | p <- children]\n      ((isDir, relPath) :) . concat <$> mapM getSubitems' relChildren","function_tokens":["getSubitems","path","=","getSubitems'","\"\"","where","getChildren","path'","=","(","\\\\","[","\".\"",",","\"..\"","]",")","<$>","getDirectoryContents","path'","getSubitems'","relPath","=","do","let","absPath","=","path","<\/>","relPath","isDir","<-","doesDirectoryExist","absPath","children","<-","if","isDir","then","getChildren","absPath","else","return","[","]","let","relChildren","=","[","relPath","<\/>","p","|","p","<-","children","]","(","(","isDir",",","relPath",")",":",")",".","concat","<$>","mapM","getSubitems'","relChildren"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L37-L49","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"rename","parameters":"f (Field n a b c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rename f (Field n a b c) =\n          Field (mkName . f . nameBase <$> n) a b c","function_tokens":["rename","f","(","Field","n","a","b","c",")","=","Field","(","mkName",".","f",".","nameBase","<$>","n",")","a","b","c"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L326-L327","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"prettyPragmas","parameters":"lp _    _       _     VerticalCompact","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prettyPragmas lp _    _       _     VerticalCompact = verticalCompactPragmas lp","function_tokens":["prettyPragmas","lp","_","_","_","VerticalCompact","=","verticalCompactPragmas","lp"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L96-L96","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"takeColumn","parameters":"mat j","argument_list":"","return_statement":"","docstring":"Extract a row.","docstring_summary":"Extract a row.","docstring_tokens":["Extract","a","row","."],"function":"takeColumn mat j | j < 0 || j >= c =\n                   error $ printf \"index out of bounds: (%d,%d)\" j c\n                 | otherwise = unsafeTakeColumn mat j\n  where\n    (_,c) = dim mat","function_tokens":["takeColumn","mat","j","|","j","<","0","||","j",">=","c","=","error","$","printf","\"index out of bounds: (%d,%d)\"","j","c","|","otherwise","=","unsafeTakeColumn","mat","j","where","(","_",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L179-L184","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mapTypeVariables","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapTypeVariables f = go\n  where\n  go ty =\n    case ty of\n      ForallT ts a b -> ForallT (mapTyVarBndr f <$> ts)\n                                (mapPred f <$> a) (go b)\n      AppT a b       -> AppT (go a) (go b)\n      SigT t a       -> SigT (go t) a\n      VarT n         -> VarT (f n)\n      t              -> t","function_tokens":["mapTypeVariables","f","=","go","where","go","ty","=","case","ty","of","ForallT","ts","a","b","->","ForallT","(","mapTyVarBndr","f","<$>","ts",")","(","mapPred","f","<$>","a",")","(","go","b",")","AppT","a","b","->","AppT","(","go","a",")","(","go","b",")","SigT","t","a","->","SigT","(","go","t",")","a","VarT","n","->","VarT","(","f","n",")","t","->","t"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L643-L654","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/StringQueries.hs","language":"haskell","identifier":"alVendor","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains the name of the vendor.","docstring_summary":"------------------------------------------------------------------------------ Contains the name of the vendor.","docstring_tokens":["------------------------------------------------------------------------------","Contains","the","name","of","the","vendor","."],"function":"alVendor = makeGettableStateVar (getString Vendor)","function_tokens":["alVendor","=","makeGettableStateVar","(","getString","Vendor",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/StringQueries.hs#L29-L29","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/StringQueries.hs","hash_val":22866,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a .=. b = inject (Equals (sing :: Sing s) a b)","function_tokens":["a",".=.","b","=","inject","(","Equals","(","sing","::","Sing","s",")","a","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L76-L76","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(a, (_, q)) = runState (imapM (pushQuantifier . unIFix) (nnf f)) (freenames f, id)","function_tokens":["(","a",",","(","_",",","q",")",")","=","runState","(","imapM","(","pushQuantifier",".","unIFix",")","(","nnf","f",")",")","(","freenames","f",",","id",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L752-L752","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"getIntensity","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getIntensity = case modBold mod of\n      Off -> Nothing\n      On -> Just ANSI.BoldIntensity","function_tokens":["getIntensity","=","case","modBold","mod","of","Off","->","Nothing","On","->","Just","ANSI","BoldIntensity"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L238-L241","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"joinBrokenLines","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"joinBrokenLines [] = []","function_tokens":["joinBrokenLines","[","]","=","[","]"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L28-L28","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"delete","parameters":"c q","argument_list":"","return_statement":"","docstring":"Delete the given 'Quad'.","docstring_summary":"Delete the given 'Quad'.","docstring_tokens":["Delete","the","given","Quad","."],"function":"delete c q = deleteQuads c [q]","function_tokens":["delete","c","q","=","deleteQuads","c","[","q","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L137-L137","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = withRequest $ \\req -> do\n        case lookupGHEvent (requestHeaders req) of\n          Nothing -> delayedFail err401\n          Just h -> do\n            case catMaybes $ map (`matchEvent` h) events of\n              [] -> delayedFail err404\n                { errBody = cs $ \"supported events: \" <> eventNames }\n              (event:_) -> pure event\n\n-- | Type function that reflects a kind to a type.","function_tokens":["go","=","withRequest","$","\\","req","->","do","case","lookupGHEvent","(","requestHeaders","req",")","of","Nothing","->","delayedFail","err401","Just","h","->","do","case","catMaybes","$","map","(","`","matchEvent","`","h",")","events","of","[","]","->","delayedFail","err404","{","errBody","=","cs","$","\"supported events: \"","<>","eventNames","}","(","event",":","_",")","->","pure","event","-- | Type function that reflects a kind to a type."],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L363-L373","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind''","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind'' a = fromMaybe (return a) . fmap snd . bind' . unIFix $ a","function_tokens":["bind''","a","=","fromMaybe","(","return","a",")",".","fmap","snd",".","bind'",".","unIFix","$","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L826-L826","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"defaultRenderMode","parameters":"hOut","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultRenderMode hOut = do\n  isTerm <- ANSI.hSupportsANSI hOut\n  if isTerm\n    then runMaybeT getMaxColors >>= \\case\n      Nothing -> pure Simple\n      Just n\n        | n < 256 -> pure Simple\n        | n > 256 -> pure TermRGB\n        | otherwise -> pure Term256\n    else pure Plain\n  where\n    getMaxColors :: MaybeT IO Int\n    getMaxColors = do\n      term <- MaybeT (System.lookupEnv \"TERM\")\n      lift (Terminfo.acquireDatabase term) >>= \\case\n        Left _ -> empty\n        Right db ->\n          hoistMaybe $\n            Terminfo.queryNumTermCap db Terminfo.MaxColors","function_tokens":["defaultRenderMode","hOut","=","do","isTerm","<-","ANSI","hSupportsANSI","hOut","if","isTerm","then","runMaybeT","getMaxColors",">>=","\\","case","Nothing","->","pure","Simple","Just","n","|","n","<","256","->","pure","Simple","|","n",">","256","->","pure","TermRGB","|","otherwise","->","pure","Term256","else","pure","Plain","where","getMaxColors","::","MaybeT","IO","Int","getMaxColors","=","do","term","<-","MaybeT","(","System","lookupEnv","\"TERM\"",")","lift","(","Terminfo","acquireDatabase","term",")",">>=","\\","case","Left","_","->","empty","Right","db","->","hoistMaybe","$","Terminfo","queryNumTermCap","db","Terminfo","MaxColors"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L236-L254","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"ifold","parameters":"(Equals _ a b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Equals _ a b) = coerce a <> coerce b","function_tokens":["ifold","(","Equals","_","a","b",")","=","coerce","a","<>","coerce","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L51-L51","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"takeRow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeRow = MG.takeRow","function_tokens":["takeRow","=","MG","takeRow"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L30-L30","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"step","parameters":"cfg","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"step cfg = makeStep \"Data\" \\ls m -> Editor.apply (changes m) ls\n  where\n    changes :: Module -> Editor.Edits\n    changes = foldMap (formatDataDecl cfg) . dataDecls\n\n    dataDecls :: Module -> [DataDecl]\n    dataDecls m = do\n        ldecl <- GHC.hsmodDecls $ GHC.unLoc m\n        GHC.TyClD _ tycld <- pure $ GHC.unLoc ldecl\n        loc <- maybeToList $ GHC.srcSpanToRealSrcSpan $ GHC.getLocA ldecl\n        case tycld of\n            GHC.DataDecl {..} -> pure $ MkDataDecl\n                { dataComments = epAnnComments tcdDExt\n                , dataLoc      = loc\n                , dataDeclName = tcdLName\n                , dataTypeVars = tcdTyVars\n                , dataDefn     = tcdDataDefn\n                , dataFixity   = tcdFixity\n                }\n            _ -> []","function_tokens":["step","cfg","=","makeStep","\"Data\"","\\","ls","m","->","Editor","apply","(","changes","m",")","ls","where","changes","::","Module","->","Editor","Edits","changes","=","foldMap","(","formatDataDecl","cfg",")",".","dataDecls","dataDecls","::","Module","->","[","DataDecl","]","dataDecls","m","=","do","ldecl","<-","GHC","hsmodDecls","$","GHC","unLoc","m","GHC","TyClD","_","tycld","<-","pure","$","GHC","unLoc","ldecl","loc","<-","maybeToList","$","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","ldecl","case","tycld","of","GHC","DataDecl","{","..","}","->","pure","$","MkDataDecl","{","dataComments","=","epAnnComments","tcdDExt",",","dataLoc","=","loc",",","dataDeclName","=","tcdLName",",","dataTypeVars","=","tcdTyVars",",","dataDefn","=","tcdDataDefn",",","dataFixity","=","tcdFixity","}","_","->","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L90-L111","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Traversable.hs","language":"haskell","identifier":"imapM","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imapM f = f . IFix <=< itraverse (imapM f) . unIFix","function_tokens":["imapM","f","=","f",".","IFix","<=<","itraverse","(","imapM","f",")",".","unIFix"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Traversable.hs#L26-L26","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Traversable.hs","hash_val":6464,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"bench\/bench.hs","language":"haskell","identifier":"testActions","parameters":"tellaction","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"testActions tellaction = do\n    v <- get\n    unless (v == 0) $ do\n        put $! v - 1\n        when (v `mod` 11 == 0) $ tellaction v\n        testActions tellaction","function_tokens":["testActions","tellaction","=","do","v","<-","get","unless","(","v","==","0",")","$","do","put","$!","v","-","1","when","(","v","`","mod","`","11","==","0",")","$","tellaction","v","testActions","tellaction"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/bench\/bench.hs#L21-L28","hash_key":"bartavelle\/stateWriter:bench\/bench.hs","hash_val":16621,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"mfix","parameters":"ma","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix ma = AccumC $ \\w -> mfix $ flip runAccumC w . ma . snd","function_tokens":["mfix","ma","=","AccumC","$","\\","w","->","mfix","$","flip","runAccumC","w",".","ma",".","snd"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L123-L123","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"computePrefixDir","parameters":"(Prefix prefixFp) _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"computePrefixDir (Prefix prefixFp) _ = PrefixDir prefixFp","function_tokens":["computePrefixDir","(","Prefix","prefixFp",")","_","=","PrefixDir","prefixFp"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L106-L106","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"index","parameters":"Const    {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Const    {} = SIntegralSort","function_tokens":["index","Const","{","}","=","SIntegralSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L75-L75","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"outputBpFile","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"outputBpFile  = opts ^. L.outputBpFile & fromMaybe (filePath <> \".bp.idx\")","function_tokens":["outputBpFile","=","opts","^.","L","outputBpFile","&","fromMaybe","(","filePath","<>","\".bp.idx\"",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L30-L30","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"vtrace","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vtrace = vstrace \"\"","function_tokens":["vtrace","=","vstrace","\"\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L416-L416","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"forkWithUnmask","parameters":"doForkWithUnmask","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forkWithUnmask doForkWithUnmask = \\(ThreadGroup numThreadsTV) f -> do\n  res <- newEmptyMVar\n  tid <- mask $ \\restore -> do\n    atomically $ modifyTVar numThreadsTV (+ 1)\n    doForkWithUnmask $ \\unmask -> do\n      try (restore $ f unmask) >>= putMVar res\n      atomically $ modifyTVar numThreadsTV (subtract 1)\n  return (tid, readMVar res)\n\n-- | Strictly modify the contents of a 'TVar'.","function_tokens":["forkWithUnmask","doForkWithUnmask","=","\\","(","ThreadGroup","numThreadsTV",")","f","->","do","res","<-","newEmptyMVar","tid","<-","mask","$","\\","restore","->","do","atomically","$","modifyTVar","numThreadsTV","(","+","1",")","doForkWithUnmask","$","\\","unmask","->","do","try","(","restore","$","f","unmask",")",">>=","putMVar","res","atomically","$","modifyTVar","numThreadsTV","(","subtract","1",")","return","(","tid",",","readMVar","res",")","-- | Strictly modify the contents of a 'TVar'."],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L196-L206","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_TRUE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_TRUE                             = 0x0001","function_tokens":["al_TRUE","=","0x0001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L27-L27","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/State.hs","language":"haskell","identifier":"from","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"from = 0 :: Int","function_tokens":["from","=","0","::","Int"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/State.hs#L31-L31","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/State.hs","hash_val":42170,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toCompressionMethod","parameters":"93","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toCompressionMethod 93 = Just Zstd","function_tokens":["toCompressionMethod","93","=","Just","Zstd"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1112-L1112","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Tip i _ `compare` Tip j _ = compare i j","function_tokens":["Tip","i","_","`","compare","`","Tip","j","_","=","compare","i","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L851-L851","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putNewtypeConstructor","parameters":"cfg lcons","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putNewtypeConstructor cfg lcons = case GHC.unLoc lcons of\n  GHC.ConDeclH98{..} ->\n    putRdrName con_name >> case con_args of\n      GHC.PrefixCon _ args -> do\n        unless (null args) space\n        sep space (fmap putOutputable args)\n      GHC.RecCon largs | [firstArg] <- GHC.unLoc largs -> do\n        space\n        putText \"{\"\n        space\n        putConDeclField cfg $ GHC.unLoc firstArg\n        space\n        putText \"}\"\n      GHC.RecCon {} ->\n        error . mconcat $\n          [ \"Language.Haskell.Stylish.Step.Data.putNewtypeConstructor: \"\n          , \"encountered newtype with several arguments\"\n          ]\n      GHC.InfixCon {} ->\n        error . mconcat $\n          [ \"Language.Haskell.Stylish.Step.Data.putNewtypeConstructor: \"\n          , \"infix newtype constructor\"\n          ]\n  GHC.ConDeclGADT{} ->\n    error . mconcat $\n      [ \"Language.Haskell.Stylish.Step.Data.putNewtypeConstructor: \"\n      , \"GADT encountered in newtype\"\n      ]","function_tokens":["putNewtypeConstructor","cfg","lcons","=","case","GHC","unLoc","lcons","of","GHC","ConDeclH98","{","..","}","->","putRdrName","con_name",">>","case","con_args","of","GHC","PrefixCon","_","args","->","do","unless","(","null","args",")","space","sep","space","(","fmap","putOutputable","args",")","GHC","RecCon","largs","|","[","firstArg","]","<-","GHC","unLoc","largs","->","do","space","putText","\"{\"","space","putConDeclField","cfg","$","GHC","unLoc","firstArg","space","putText","\"}\"","GHC","RecCon","{","}","->","error",".","mconcat","$","[","\"Language.Haskell.Stylish.Step.Data.putNewtypeConstructor: \"",",","\"encountered newtype with several arguments\"","]","GHC","InfixCon","{","}","->","error",".","mconcat","$","[","\"Language.Haskell.Stylish.Step.Data.putNewtypeConstructor: \"",",","\"infix newtype constructor\"","]","GHC","ConDeclGADT","{","}","->","error",".","mconcat","$","[","\"Language.Haskell.Stylish.Step.Data.putNewtypeConstructor: \"",",","\"GADT encountered in newtype\"","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L439-L468","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookDeleteEvent","function_tokens":["reflect","_","=","WebhookDeleteEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L418-L418","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrap'","parameters":"ss []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrap' ss [] = [ss]","function_tokens":["wrap'","ss","[","]","=","[","ss","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L101-L101","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (Cull m)       -> CullC (local (const True) (runCullC (hdl (m <$ ctx))))\n    R (L (L Empty))  -> empty\n    R (L (R Choose)) -> pure (True <$ ctx) <|> pure (False <$ ctx)\n    R (R other)      -> CullC (alg (runCullC . hdl) (R (R other)) ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","Cull","m",")","->","CullC","(","local","(","const","True",")","(","runCullC","(","hdl","(","m","<$","ctx",")",")",")",")","R","(","L","(","L","Empty",")",")","->","empty","R","(","L","(","R","Choose",")",")","->","pure","(","True","<$","ctx",")","<|>","pure","(","False","<$","ctx",")","R","(","R","other",")","->","CullC","(","alg","(","runCullC",".","hdl",")","(","R","(","R","other",")",")","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L89-L94","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"unsafeWrite","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeWrite = MG.unsafeWrite","function_tokens":["unsafeWrite","=","MG","unsafeWrite"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L36-L36","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ifold","parameters":"(Const _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Const _) = mempty","function_tokens":["ifold","(","Const","_",")","=","mempty"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L82-L82","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"alignEvent","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alignEvent e = e{ eventStart = eventStart e - minT }","function_tokens":["alignEvent","e","=","e","{","eventStart","=","eventStart","e","-","minT","}"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L271-L271","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Empty.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"Abort the computation.  'empty' annihilates '>>=':  @ 'empty' '>>=' k = 'empty' @  @since 1.0.0.0","docstring_summary":"Abort the computation.  'empty' annihilates '>>=':","docstring_tokens":["Abort","the","computation",".","empty","annihilates",">>","=",":"],"function":"empty = send Empty","function_tokens":["empty","=","send","Empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Empty.hs#L39-L39","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Empty.hs","hash_val":17478,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freenames","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freenames a = fmap (\\n -> freename a ++ show n) $ unfold (succ . runIdentity) (Identity (0 :: Int))","function_tokens":["freenames","a","=","fmap","(","\\","n","->","freename","a","++","show","n",")","$","unfold","(","succ",".","runIdentity",")","(","Identity","(","0","::","Int",")",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L717-L717","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"startsWith","parameters":"x (y:_)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"startsWith x (y:_) = x == y","function_tokens":["startsWith","x","(","y",":","_",")","=","x","==","y"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L24-L24","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"b","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b = runPut (mapM_ putField es)","function_tokens":["b","=","runPut","(","mapM_","putField","es",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L158-L158","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(cb, NextComment c, (ib, i) : items, comments)\n\n\n--------------------------------------------------------------------------------\ndata NextThing a\n    = NextComment GHC.LEpaComment\n    | NextItem a\n    | NextItemWithComment a GHC.LEpaComment\n\n\n--------------------------------------------------------------------------------\ninstance GHC.Outputable a => Show (NextThing a) where\n    show (NextComment c) = \"NextComment \" ++ showOutputable c","function_tokens":["(","cb",",","NextComment","c",",","(","ib",",","i",")",":","items",",","comments",")","--------------------------------------------------------------------------------","data","NextThing","=","NextComment","GHC","LEpaComment","|","NextItem","a","|","NextItemWithComment","a","GHC","LEpaComment","--------------------------------------------------------------------------------","instance","GHC","Outputable","a","=>","Show","(","NextThing","a",")","where","show","(","NextComment","c",")","=","\"NextComment \"","++","showOutputable","c"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L110-L122","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"sinkEntry","parameters":"h s o src EditingActions {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sinkEntry h s o src EditingActions {..} = do\n  currentTime <- getCurrentTime\n  offset <- hTell h\n  let compressed = case o of\n        GenericOrigin -> Store\n        Borrowed ed -> edCompression ed\n      compression = M.findWithDefault compressed s eaCompression\n      recompression = compression \/= compressed\n      modTime = case o of\n        GenericOrigin -> currentTime\n        Borrowed ed -> edModTime ed\n      extFileAttr = case o of\n        GenericOrigin -> M.findWithDefault defaultFileMode s eaExtFileAttr\n        Borrowed _ -> M.findWithDefault defaultFileMode s eaExtFileAttr\n      oldExtraFields = case o of\n        GenericOrigin -> M.empty\n        Borrowed ed -> edExtraField ed\n      extraField =\n        (M.findWithDefault M.empty s eaExtraField `M.union` oldExtraFields)\n          `M.difference` M.findWithDefault M.empty s eaDeleteField\n      oldComment = case (o, M.lookup s eaDeleteComment) of\n        (GenericOrigin, _) -> Nothing\n        (Borrowed ed, Nothing) -> edComment ed\n        (Borrowed _, Just ()) -> Nothing\n      desc0 =\n        EntryDescription -- to write in local header\n          { edVersionMadeBy = zipVersion,\n            edVersionNeeded = zipVersion,\n            edCompression = compression,\n            edModTime = M.findWithDefault modTime s eaModTime,\n            edCRC32 = 0, -- to be overwritten after streaming\n            edCompressedSize = 0, -- \u2191\n            edUncompressedSize = 0, -- \u2191\n            edOffset = fromIntegral offset,\n            edComment = M.lookup s eaEntryComment <|> oldComment,\n            edExtraField = extraField,\n            edExternalFileAttrs = extFileAttr\n          }\n  B.hPut h (runPut (putHeader LocalHeader s desc0))\n  DataDescriptor {..} <-\n    C.runConduitRes $\n      if recompression\n        then\n          if compressed == Store\n            then src .| sinkData h compression\n            else src .| decompressingPipe compressed .| sinkData h compression\n        else src .| sinkData h Store\n  afterStreaming <- hTell h\n  let desc1 = case o of\n        GenericOrigin ->\n          desc0\n            { edCRC32 = ddCRC32,\n              edCompressedSize = ddCompressedSize,\n              edUncompressedSize = ddUncompressedSize\n            }\n        Borrowed ed ->\n          desc0\n            { edCRC32 =\n                bool (edCRC32 ed) ddCRC32 recompression,\n              edCompressedSize =\n                bool (edCompressedSize ed) ddCompressedSize recompression,\n              edUncompressedSize =\n                bool (edUncompressedSize ed) ddUncompressedSize recompression\n            }\n      desc2 =\n        desc1\n          { edVersionNeeded =\n              getZipVersion (needsZip64 desc1) (Just compression)\n          }\n  hSeek h AbsoluteSeek offset\n  B.hPut h (runPut (putHeader LocalHeader s desc2))\n  hSeek h AbsoluteSeek afterStreaming\n  return (s, desc2)\n\n{- ORMOLU_DISABLE -}\n\n-- | Create a 'Sink' to stream data there. Once streaming is finished,\n-- return 'DataDescriptor' for the streamed data. The action \/does not\/\n-- close the given 'Handle'.","function_tokens":["sinkEntry","h","s","o","src","EditingActions","{","..","}","=","do","currentTime","<-","getCurrentTime","offset","<-","hTell","h","let","compressed","=","case","o","of","GenericOrigin","->","Store","Borrowed","ed","->","edCompression","ed","compression","=","M","findWithDefault","compressed","s","eaCompression","recompression","=","compression","\/=","compressed","modTime","=","case","o","of","GenericOrigin","->","currentTime","Borrowed","ed","->","edModTime","ed","extFileAttr","=","case","o","of","GenericOrigin","->","M","findWithDefault","defaultFileMode","s","eaExtFileAttr","Borrowed","_","->","M","findWithDefault","defaultFileMode","s","eaExtFileAttr","oldExtraFields","=","case","o","of","GenericOrigin","->","M","empty","Borrowed","ed","->","edExtraField","ed","extraField","=","(","M","findWithDefault","M","empty","s","eaExtraField","`","M","union","`","oldExtraFields",")","`","M","difference","`","M","findWithDefault","M","empty","s","eaDeleteField","oldComment","=","case","(","o",",","M","lookup","s","eaDeleteComment",")","of","(","GenericOrigin",",","_",")","->","Nothing","(","Borrowed","ed",",","Nothing",")","->","edComment","ed","(","Borrowed","_",",","Just","(",")",")","->","Nothing","desc0","=","EntryDescription","-- to write in local header","{","edVersionMadeBy","=","zipVersion",",","edVersionNeeded","=","zipVersion",",","edCompression","=","compression",",","edModTime","=","M","findWithDefault","modTime","s","eaModTime",",","edCRC32","=","0",",","-- to be overwritten after streaming","edCompressedSize","=","0",",","-- \u2191","edUncompressedSize","=","0",",","-- \u2191","edOffset","=","fromIntegral","offset",",","edComment","=","M","lookup","s","eaEntryComment","<|>","oldComment",",","edExtraField","=","extraField",",","edExternalFileAttrs","=","extFileAttr","}","B","hPut","h","(","runPut","(","putHeader","LocalHeader","s","desc0",")",")","DataDescriptor","{","..","}","<-","C","runConduitRes","$","if","recompression","then","if","compressed","==","Store","then","src",".|","sinkData","h","compression","else","src",".|","decompressingPipe","compressed",".|","sinkData","h","compression","else","src",".|","sinkData","h","Store","afterStreaming","<-","hTell","h","let","desc1","=","case","o","of","GenericOrigin","->","desc0","{","edCRC32","=","ddCRC32",",","edCompressedSize","=","ddCompressedSize",",","edUncompressedSize","=","ddUncompressedSize","}","Borrowed","ed","->","desc0","{","edCRC32","=","bool","(","edCRC32","ed",")","ddCRC32","recompression",",","edCompressedSize","=","bool","(","edCompressedSize","ed",")","ddCompressedSize","recompression",",","edUncompressedSize","=","bool","(","edUncompressedSize","ed",")","ddUncompressedSize","recompression","}","desc2","=","desc1","{","edVersionNeeded","=","getZipVersion","(","needsZip64","desc1",")","(","Just","compression",")","}","hSeek","h","AbsoluteSeek","offset","B","hPut","h","(","runPut","(","putHeader","LocalHeader","s","desc2",")",")","hSeek","h","AbsoluteSeek","afterStreaming","return","(","s",",","desc2",")","{- ORMOLU_DISABLE -}","-- | Create a 'Sink' to stream data there. Once streaming is finished,","-- return 'DataDescriptor' for the streamed data. The action \/does not\/","-- close the given 'Handle'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L492-L571","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Fresh\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = FreshC $ case sig of\n    L Fresh -> state $ \\ i -> (i + 1, i <$ ctx)\n    R other -> alg (runFreshC . hdl) (R other) ctx","function_tokens":["alg","hdl","sig","ctx","=","FreshC","$","case","sig","of","L","Fresh","->","state","$","\\","i","->","(","i","+","1",",","i","<$","ctx",")","R","other","->","alg","(","runFreshC",".","hdl",")","(","R","other",")","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Fresh\/Church.hs#L63-L66","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Fresh\/Church.hs","hash_val":22500,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"cons","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cons  = fst <$> vals","function_tokens":["cons","=","fst","<$>","vals"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L317-L317","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandArgs","parameters":"(FIND_VALUE k)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandArgs (FIND_VALUE k)       = toBS k","function_tokens":["commandArgs","(","FIND_VALUE","k",")","=","toBS","k"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L40-L40","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"toList","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a list by concatenating rows","docstring_summary":"O(m*n) Create a list by concatenating rows","docstring_tokens":["O","(","m","*","n",")","Create","a","list","by","concatenating","rows"],"function":"toList = G.toList . flatten","function_tokens":["toList","=","G","toList",".","flatten"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L110-L110","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"index","parameters":"Forall {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Forall {} = SBooleanSort","function_tokens":["index","Forall","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L540-L540","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(Recompress _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (Recompress _ s) = Just s","function_tokens":["targetEntry","(","Recompress","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1057-L1057","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"getSwapForegroundBackground","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getSwapForegroundBackground = case modSwapFgBg mod of\n      Off -> Nothing\n      On -> Just True","function_tokens":["getSwapForegroundBackground","=","case","modSwapFgBg","mod","of","Off","->","Nothing","On","->","Just","True"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L246-L248","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"findFilesR","parameters":"_ []","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"findFilesR _ []   = return []","function_tokens":["findFilesR","_","[","]","=","return","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L127-L127","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"takeRow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeRow = MG.takeRow","function_tokens":["takeRow","=","MG","takeRow"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L30-L30","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"read","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"read = MG.read","function_tokens":["read","=","MG","read"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L39-L39","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkSubst","parameters":"vars t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkSubst vars t = go (reverse vars) t\n  where\n    go [] _ = []\n    go (v:vs) (AppT t1 t2) = (typeFromBinder v, t2) : go vs t1\n    go _  _ = fclError \"Non-AppT with type variables in mkSubst. Please report this as a bug for fclabels.\"\n#endif","function_tokens":["mkSubst","vars","t","=","go","(","reverse","vars",")","t","where","go","[","]","_","=","[","]","go","(","v",":","vs",")","(","AppT","t1","t2",")","=","(","typeFromBinder","v",",","t2",")",":","go","vs","t1","go","_","_","=","fclError","\"Non-AppT with type variables in mkSubst. Please report this as a bug for fclabels.\"","#endif"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L368-L375","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"getGitRootDir","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getGitRootDir =\n  do  cwd <- getCurrentDirectory\n      relativePath cwd . stripNewline <$>\n          readProcess \"git\" [\"rev-parse\", \"--show-toplevel\"] \"\"","function_tokens":["getGitRootDir","=","do","cwd","<-","getCurrentDirectory","relativePath","cwd",".","stripNewline","<$>","readProcess","\"git\"","[","\"rev-parse\"",",","\"--show-toplevel\"","]","\"\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L209-L214","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"binarySearchByBounds","parameters":"vec x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"binarySearchByBounds vec x = loop\n  where\n    loop !l !u\n        | l > u = Nothing\n        | x == x' = Just k\n        | x < x' = loop l (k-1)\n        | otherwise = loop (k+1) u\n      where\n        k = (u+l) `shiftR` 1\n        x' = vec `U.unsafeIndex` k","function_tokens":["binarySearchByBounds","vec","x","=","loop","where","loop","l","u","|","l",">","u","=","Nothing","|","x","==","x'","=","Just","k","|","x","<","x'","=","loop","l","(","k","-","1",")","|","otherwise","=","loop","(","k","+","1",")","u","where","k","=","(","u","+","l",")","`","shiftR","`","1","x'","=","vec","`","U","unsafeIndex","`","k"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L157-L167","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_,c) = dim mat","function_tokens":["(","_",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L190-L190","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"verbose'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"verbose' = makeVerbose (saVerbose sa)","function_tokens":["verbose'","=","makeVerbose","(","saVerbose","sa",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L124-L124","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"steps","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"steps = configSteps conf","function_tokens":["steps","=","configSteps","conf"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L115-L115","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified'","parameters":"(InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified' (InR gb) = isQuantified' gb","function_tokens":["isQuantified'","(","InR","gb",")","=","isQuantified'","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L630-L630","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fields","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fields = groupFields mk vars cons","function_tokens":["fields","=","groupFields","mk","vars","cons"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L308-L308","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"index","parameters":"(Select _  es _ _  )","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index (Select _  es _ _  ) = es","function_tokens":["index","(","Select","_","es","_","_",")","=","es"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L63-L63","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"removeCr","parameters":"x@(_:_)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"removeCr x@(_:_) | last x == '\\r' = init x","function_tokens":["removeCr","x","@","(","_",":","_",")","|","last","x","==","'\\r'","=","init","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L127-L127","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"time","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"time = (fromIntegral (end - begin) \/ 1e9) \/ fromIntegral weight","function_tokens":["time","=","(","fromIntegral","(","end","-","begin",")","\/","1e9",")","\/","fromIntegral","weight"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L384-L384","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"imap","parameters":"f (Add as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Add as)         = Add $ map f as","function_tokens":["imap","f","(","Add","as",")","=","Add","$","map","f","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L70-L70","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWith4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith4 = MG.zipWith4","function_tokens":["zipWith4","=","MG","zipWith4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L268-L268","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"finishCheck","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"finishCheck _ = finish","function_tokens":["finishCheck","_","=","finish"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L86-L86","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"go","parameters":"wb ws (bs:bss)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go wb ws (bs:bss) = do\n          let resLen = BS.length bs `div` 8\n          resIbFptr  <- F.mallocForeignPtrBytes resLen\n          resAFptr   <- F.mallocForeignPtrBytes resLen\n          resBFptr   <- F.mallocForeignPtrBytes resLen\n          let resIbPtr  = F.castPtr (F.unsafeForeignPtrToPtr resIbFptr)\n          let resAPtr   = F.castPtr (F.unsafeForeignPtrToPtr resAFptr )\n          let resBPtr   = F.castPtr (F.unsafeForeignPtrToPtr resBFptr )\n          let (bsFptr, bsOff, bsLen) = BSI.toForeignPtr bs\n          let bsPtr = F.castPtr (F.unsafeForeignPtrToPtr bsFptr)\n          _ <- F.processChunk\n            (F.plusPtr bsPtr bsOff) -- in_buffer:           Ptr UInt8\n            (fromIntegral bsLen)    -- in_length:           Size\n            (workBuffersD wb)       -- work_bits_of_d:      Ptr UInt8\n            (workBuffersA wb)       -- work_bits_of_a:      Ptr UInt8\n            (workBuffersZ wb)       -- work_bits_of_z:      Ptr UInt8\n            (workBuffersQ wb)       -- work_bits_of_q:      Ptr UInt8\n            (workBuffersB wb)       -- work_bits_of_b:      Ptr UInt8\n            (workBuffersE wb)       -- work_bits_of_e:      Ptr UInt8\n            (workStateZ ws)         -- last_trailing_ones:  Ptr Size\n            (workStateO ws)         -- quote_odds_carry:    Ptr Size\n            (workStateE ws)         -- quote_evens_carry:   Ptr Size\n            (workStateM ws)         -- quote_mask_carry:    Ptr UInt64\n            resIbPtr                -- result_ibs:          Ptr UInt8\n            resAPtr                 -- result_a:            Ptr UInt8\n            resBPtr                 -- result_z:            Ptr UInt8\n          let r =\n                ( BSI.fromForeignPtr resIbFptr 0 resLen\n                , BSI.fromForeignPtr resAFptr  0 resLen\n                , BSI.fromForeignPtr resBFptr  0 resLen\n                )\n          rs <- IO.unsafeInterleaveIO $ go wb ws bss\n          return (r:rs)","function_tokens":["go","wb","ws","(","bs",":","bss",")","=","do","let","resLen","=","BS","length","bs","`","div","`","8","resIbFptr","<-","F","mallocForeignPtrBytes","resLen","resAFptr","<-","F","mallocForeignPtrBytes","resLen","resBFptr","<-","F","mallocForeignPtrBytes","resLen","let","resIbPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resIbFptr",")","let","resAPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resAFptr",")","let","resBPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBFptr",")","let","(","bsFptr",",","bsOff",",","bsLen",")","=","BSI","toForeignPtr","bs","let","bsPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","bsFptr",")","_","<-","F","processChunk","(","F","plusPtr","bsPtr","bsOff",")","-- in_buffer:           Ptr UInt8","(","fromIntegral","bsLen",")","-- in_length:           Size","(","workBuffersD","wb",")","-- work_bits_of_d:      Ptr UInt8","(","workBuffersA","wb",")","-- work_bits_of_a:      Ptr UInt8","(","workBuffersZ","wb",")","-- work_bits_of_z:      Ptr UInt8","(","workBuffersQ","wb",")","-- work_bits_of_q:      Ptr UInt8","(","workBuffersB","wb",")","-- work_bits_of_b:      Ptr UInt8","(","workBuffersE","wb",")","-- work_bits_of_e:      Ptr UInt8","(","workStateZ","ws",")","-- last_trailing_ones:  Ptr Size","(","workStateO","ws",")","-- quote_odds_carry:    Ptr Size","(","workStateE","ws",")","-- quote_evens_carry:   Ptr Size","(","workStateM","ws",")","-- quote_mask_carry:    Ptr UInt64","resIbPtr","-- result_ibs:          Ptr UInt8","resAPtr","-- result_a:            Ptr UInt8","resBPtr","-- result_z:            Ptr UInt8","let","r","=","(","BSI","fromForeignPtr","resIbFptr","0","resLen",",","BSI","fromForeignPtr","resAFptr","0","resLen",",","BSI","fromForeignPtr","resBFptr","0","resLen",")","rs","<-","IO","unsafeInterleaveIO","$","go","wb","ws","bss","return","(","r",":","rs",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L49-L83","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Result\n            { _resolvedSuccessfully = successes\n            , _reducedConflicts = reductions\n            , _failedToResolve = failures\n            } = result","function_tokens":["Result","{","_resolvedSuccessfully","=","successes",",","_reducedConflicts","=","reductions",",","_failedToResolve","=","failures","}","=","result"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L112-L116","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,found,gt) = splitMember x r","function_tokens":["(","lt",",","found",",","gt",")","=","splitMember","x","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L575-L575","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"guards","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"guards     = getGuards m","function_tokens":["guards","=","getGuards","m"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L120-L120","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bottom = false","function_tokens":["bottom","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L215-L215","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"noWrap","parameters":"leading _ind","argument_list":"","return_statement":"","docstring":"^ Resulting lines","docstring_summary":"^ Resulting lines","docstring_tokens":["^","Resulting","lines"],"function":"noWrap leading _ind = noWrap' leading\n  where\n    noWrap' ss []         = [ss]\n    noWrap' ss (str:strs) = noWrap' (ss ++ \" \" ++ str) strs\n\n\n--------------------------------------------------------------------------------","function_tokens":["noWrap","leading","_ind","=","noWrap'","leading","where","noWrap'","ss","[","]","=","[","ss","]","noWrap'","ss","(","str",":","strs",")","=","noWrap'","(","ss","++","\" \"","++","str",")","strs","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L126-L133","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,found,gt) = splitMember' x l","function_tokens":["(","lt",",","found",",","gt",")","=","splitMember'","x","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L560-L560","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"trailingWhitespace","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"trailingWhitespace = TrailingWhitespace.step","function_tokens":["trailingWhitespace","=","TrailingWhitespace","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L82-L82","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"both","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"both _ = False","function_tokens":["both","_","=","False"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L48-L48","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"checkSignal","parameters":"(Signal _ (RETURN_NODES _ nodes))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkSignal (Signal _ (RETURN_NODES _ nodes)) =\n                continueLookup nodes sendS continue cancel","function_tokens":["checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","continueLookup","nodes","sendS","continue","cancel"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L67-L68","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"con","parameters":"c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"con c            = c","function_tokens":["con","c","=","c"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L232-L232","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Discography _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Discography _)          = \"D\"","function_tokens":["go","(","Discography","_",")","=","\"D\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L338-L338","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand 1 = return PONG","function_tokens":["parseCommand","1","=","return","PONG"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L125-L125","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"usedVars","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"usedVars  = filter (`elem` fieldVars) varNames","function_tokens":["usedVars","=","filter","(","`","elem","`","fieldVars",")","varNames"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L600-L600","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Source _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Source _)               = (True, True, False, False)","function_tokens":["go","(","Source","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L387-L387","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"go","parameters":"(left, _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (left, _) =\n      if Text.null left\n        then pure (\"\", completions ts)\n        else pure (\"\", completions (filter (Text.isPrefixOf left) ts))","function_tokens":["go","(","left",",","_",")","=","if","Text","null","left","then","pure","(","\"\"",",","completions","ts",")","else","pure","(","\"\"",",","completions","(","filter","(","Text","isPrefixOf","left",")","ts",")",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L89-L92","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label.hs","language":"haskell","identifier":"modify","parameters":"","argument_list":"","return_statement":"","docstring":"Get the modifier function from a lens.","docstring_summary":"Get the modifier function from a lens.","docstring_tokens":["Get","the","modifier","function","from","a","lens","."],"function":"modify = curry . Mono.modify","function_tokens":["modify","=","curry",".","Mono","modify"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label.hs#L205-L205","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label.hs","hash_val":23450,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"pure","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure = done","function_tokens":["pure","=","done"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L125-L125","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = forall' <?> \"Universal\" where\n        var' :: Parser (DynamicallySorted Var)\n        var' = parser (Proxy :: Proxy VarF) var'\n\n        forall' = do\n            _   <- char '(' *> string \"forall\" *> space *> char '('\n            vs  <- var' `sepBy1` space\n            _   <- char ')' *> space\n            phi <- local (union (fromList $ map context vs)) r\n            _   <- char ')'\n            forall'' vs phi\n\n        forall'' [] _   = fail \"quantifying zero variables\"\n        forall'' vs phi = case (mapM toStaticallySorted vs :: Maybe [Var v]) of\n            Just vs' -> case toStaticallySorted phi of\n                Just phi' -> return . toDynamicallySorted . forall vs' $ phi'\n                Nothing   -> fail \"quantifying non-boolean expression\"\n            Nothing  -> fail \"ill-sorted quantifier\"\n\n        context (DynamicallySorted s v) = case match v of\n            Just (Var n _) -> (n, DynamicSort s)\n            _              -> error \"impossible error\"","function_tokens":["parser","_","r","=","forall'","<?>","\"Universal\"","where","var'","::","Parser","(","DynamicallySorted","Var",")","var'","=","parser","(","Proxy","::","Proxy","VarF",")","var'","forall'","=","do","_","<-","char","'('","*>","string","\"forall\"","*>","space","*>","char","'('","vs","<-","var'","`","sepBy1","`","space","_","<-","char","')'","*>","space","phi","<-","local","(","union","(","fromList","$","map","context","vs",")",")","r","_","<-","char","')'","forall''","vs","phi","forall''","[","]","_","=","fail","\"quantifying zero variables\"","forall''","vs","phi","=","case","(","mapM","toStaticallySorted","vs","::","Maybe","[","Var","v","]",")","of","Just","vs'","->","case","toStaticallySorted","phi","of","Just","phi'","->","return",".","toDynamicallySorted",".","forall","vs'","$","phi'","Nothing","->","fail","\"quantifying non-boolean expression\"","Nothing","->","fail","\"ill-sorted quantifier\"","context","(","DynamicallySorted","s","v",")","=","case","match","v","of","Just","(","Var","n","_",")","->","(","n",",","DynamicSort","s",")","_","->","error","\"impossible error\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L565-L588","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"quoted","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"quoted = do\n      prefix <- many bareChar\n      quote <- Atto.satisfy (\\c -> c == '\\'' || c == '\"') Atto.<?> \"quote\"\n      (_, ScanState {..}) <-\n        Atto.runScanner (ScanState [] False) (quoteScanner quote)\n      when scanEscape (fail \"expecting a character after a backslash\")\n      _ <- Atto.char quote Atto.<?> \"closing quotation character\"\n      let str = toText prefix <> toText (reverse scanResult)\n      end <-\n        (Atto.many1 Atto.space $> True)\n          <|> (Atto.endOfInput $> True)\n          <|> pure False\n      if end then pure str else (str <>) <$> quoted\n\n    -- Parse a single character that might be escaped.","function_tokens":["quoted","=","do","prefix","<-","many","bareChar","quote","<-","Atto","satisfy","(","\\","c","->","c","==","'\\''","||","c","==","'\"'",")","Atto","<?>","\"quote\"","(","_",",","ScanState","{","..","}",")","<-","Atto","runScanner","(","ScanState","[","]","False",")","(","quoteScanner","quote",")","when","scanEscape","(","fail","\"expecting a character after a backslash\"",")","_","<-","Atto","char","quote","Atto","<?>","\"closing quotation character\"","let","str","=","toText","prefix","<>","toText","(","reverse","scanResult",")","end","<-","(","Atto","many1","Atto","space","$>","True",")","<|>","(","Atto","endOfInput","$>","True",")","<|>","pure","False","if","end","then","pure","str","else","(","str","<>",")","<$>","quoted","-- Parse a single character that might be escaped."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L172-L187","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"subMatrix","parameters":"","argument_list":"","return_statement":"","docstring":"O(1) Extract sub matrix","docstring_summary":"O(1) Extract sub matrix","docstring_tokens":["O","(","1",")","Extract","sub","matrix"],"function":"subMatrix = MG.subMatrix","function_tokens":["subMatrix","=","MG","subMatrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L193-L193","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"getAmount","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getAmount = do\n      _ <- APT.string \"Successfully \"\n      _ <- APT.string \"deleted \" <|> APT.string \"wrote \"\n      a <- APT.decimal\n      _ <- APT.string \" quads.\"\n      return a","function_tokens":["getAmount","=","do","_","<-","APT","string","\"Successfully \"","_","<-","APT","string","\"deleted \"","<|>","APT","string","\"wrote \"","a","<-","APT","decimal","_","<-","APT","string","\" quads.\"","return","a"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L226-L231","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"grhsToAlignable","parameters":"(GHC.L grhsloc (Hs.GRHS _ guards@(_ : _) body))","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"grhsToAlignable (GHC.L grhsloc (Hs.GRHS _ guards@(_ : _) body)) = do\n    let guardsLocs = map GHC.getLocA guards\n        bodyLoc    = GHC.getLocA $ body\n        left       = foldl1' GHC.combineSrcSpans guardsLocs\n    matchPos <- GHC.srcSpanToRealSrcSpan grhsloc\n    leftPos  <- GHC.srcSpanToRealSrcSpan left\n    bodyPos  <- GHC.srcSpanToRealSrcSpan bodyLoc\n    Just $ Alignable\n        { aContainer = matchPos\n        , aLeft      = leftPos\n        , aRight     = bodyPos\n        , aRightLead = length \"-> \"\n        }","function_tokens":["grhsToAlignable","(","GHC","L","grhsloc","(","Hs","GRHS","_","guards","@","(","_",":","_",")","body",")",")","=","do","let","guardsLocs","=","map","GHC","getLocA","guards","bodyLoc","=","GHC","getLocA","$","body","left","=","foldl1'","GHC","combineSrcSpans","guardsLocs","matchPos","<-","GHC","srcSpanToRealSrcSpan","grhsloc","leftPos","<-","GHC","srcSpanToRealSrcSpan","left","bodyPos","<-","GHC","srcSpanToRealSrcSpan","bodyLoc","Just","$","Alignable","{","aContainer","=","matchPos",",","aLeft","=","leftPos",",","aRight","=","bodyPos",",","aRightLead","=","length","\"-> \"","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L167-L180","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"merge","parameters":"xs ys","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge xs ys\n      = L.nubBy ((==) `on` showOutputable) (xs ++ ys)","function_tokens":["merge","xs","ys","=","L","nubBy","(","(","==",")","`","on","`","showOutputable",")","(","xs","++","ys",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L128-L129","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"runChoose","parameters":"fork leaf (ChooseC runChooseC)","argument_list":"","return_statement":"","docstring":"Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.  @ runChoose fork leaf ('pure' a '<|>' b) = leaf a \\`fork\\` 'runChoose' fork leaf b @  @since 1.0.0.0","docstring_summary":"Run a 'Choose' effect with continuations respectively interpreting '<|>' and 'pure'.","docstring_tokens":["Run","a","Choose","effect","with","continuations","respectively","interpreting","<|",">","and","pure","."],"function":"runChoose fork leaf (ChooseC runChooseC) = runChooseC fork leaf","function_tokens":["runChoose","fork","leaf","(","ChooseC","runChooseC",")","=","runChooseC","fork","leaf"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L47-L47","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed\/Mutable.hs","language":"haskell","identifier":"write","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"write = MG.write","function_tokens":["write","=","MG","write"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed\/Mutable.hs#L33-L33","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed\/Mutable.hs","hash_val":25864,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putSymbol","parameters":"(Symbol x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putSymbol (Symbol x) = putString x","function_tokens":["putSymbol","(","Symbol","x",")","=","putString","x"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L215-L215","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty  = Substitution (const Nothing)","function_tokens":["mempty","=","Substitution","(","const","Nothing",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L327-L327","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"bold","parameters":"(StylizedList l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bold (StylizedList l) = StylizedList (map bold l)","function_tokens":["bold","(","StylizedList","l",")","=","StylizedList","(","map","bold","l",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L111-L111","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"labels","parameters":"dec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"labels dec =\n    case dec of\n      DataD    {} -> [dec]\n      NewtypeD {} -> [dec]\n      _           -> []","function_tokens":["labels","dec","=","case","dec","of","DataD","{","}","->","[","dec","]","NewtypeD","{","}","->","[","dec","]","_","->","[","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L211-L217","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"toPeer","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toPeer _ = return Nothing","function_tokens":["toPeer","_","=","return","Nothing"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L88-L88","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"izipWith4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith4 = MG.izipWith4","function_tokens":["izipWith4","=","MG","izipWith4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L293-L293","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"matchSeparator","parameters":"GHC.EpAnn {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchSeparator GHC.EpAnn {..}\n    | GHC.AddEpAnn _ (GHC.EpaSpan s) <- GHC.ga_sep anns = Just s","function_tokens":["matchSeparator","GHC","EpAnn","{","..","}","|","GHC","AddEpAnn","_","(","GHC","EpaSpan","s",")","<-","GHC","ga_sep","anns","=","Just","s"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L78-L79","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"markerLine","parameters":"c str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"markerLine c str = markerPrefix c ++ \" \" ++ str ++ \"\\n\"","function_tokens":["markerLine","c","str","=","markerPrefix","c","++","\" \"","++","str","++","\"\\n\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L36-L36","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"doSort","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doSort = if sort conf then fmap (commentGroupSort compareLIE) else id","function_tokens":["doSort","=","if","sort","conf","then","fmap","(","commentGroupSort","compareLIE",")","else","id"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L119-L119","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"literals","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"literals e = fromMaybe [e]  $  (concatMap literals <$> conjuncts' e)\n                           <|> (concatMap literals <$> disjuncts' e)","function_tokens":["literals","e","=","fromMaybe","[","e","]","$","(","concatMap","literals","<$>","conjuncts'","e",")","<|>","(","concatMap","literals","<$>","disjuncts'","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L436-L437","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","language":"haskell","identifier":"fieldsRemain","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldsRemain = (< firstRecPos - 1) . fromIntegral <$> bytesRead","function_tokens":["fieldsRemain","=","(","<","firstRecPos","-","1",")",".","fromIntegral","<$>","bytesRead"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs#L34-L34","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","hash_val":38792,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Empty\/Maybe.hs","language":"haskell","identifier":"fail","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail = lift . Fail.fail","function_tokens":["fail","=","lift",".","Fail","fail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Empty\/Maybe.hs#L86-L86","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Empty\/Maybe.hs","hash_val":35180,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"foldMap","parameters":"f (Buffer (Just a))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldMap f (Buffer (Just a)) = foldMap f a","function_tokens":["foldMap","f","(","Buffer","(","Just","a",")",")","=","foldMap","f","a"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L149-L149","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getIntBE","parameters":"","argument_list":"","return_statement":"","docstring":"32-bit big-endian Int","docstring_summary":"32-bit big-endian Int","docstring_tokens":["32","-","bit","big","-","endian","Int"],"function":"getIntBE = fromIntegral <$> getWord32be","function_tokens":["getIntBE","=","fromIntegral","<$>","getWord32be"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L20-L20","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"longestRight","parameters":"","argument_list":"","return_statement":"","docstring":"The longest thing in the right column","docstring_summary":"The longest thing in the right column","docstring_tokens":["The","longest","thing","in","the","right","column"],"function":"longestRight = maximum\n      [ GHC.srcSpanEndCol (aRight a) - GHC.srcSpanStartCol (aRight a)\n          + aRightLead a\n      | a <- alignment\n      ]","function_tokens":["longestRight","=","maximum","[","GHC","srcSpanEndCol","(","aRight","a",")","-","GHC","srcSpanStartCol","(","aRight","a",")","+","aRightLead","a","|","a","<-","alignment","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L76-L80","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Reader.hs","language":"haskell","identifier":"ask","parameters":"","argument_list":"","return_statement":"","docstring":"Retrieve the environment value.  @ runReader a ('ask' '>>=' k) = runReader a (k a) @  @since 0.1.0.0","docstring_summary":"Retrieve the environment value.","docstring_tokens":["Retrieve","the","environment","value","."],"function":"ask = send Ask","function_tokens":["ask","=","send","Ask"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Reader.hs#L39-L39","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Reader.hs","hash_val":1897,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"rolloffFactor","parameters":"","argument_list":"","return_statement":"","docstring":"'rolloffFactor' is used for distance attenuation calculations based on inverse distance with rolloff. For distances smaller than 'maxDistance' (and, depending on the distance model, larger than 'referenceDistance'), this will scale the distance attenuation over the applicable range. See \"Sound.OpenAL.AL.Attenuation\" for details how the attenuation is computed as a function of the distance. The initial value is 1.  In particular, 'rolloffFactor' can be set to zero for those sources that are supposed to be exempt from distance attenuation. The implementation is encouraged to optimize this case, bypassing distance attenuation calculation entirely on a persource basis.","docstring_summary":"'rolloffFactor' is used for distance attenuation calculations based on inverse distance with rolloff. For distances smaller than 'maxDistance' (and, depending on the distance model, larger than 'referenceDistance'), this will scale the distance attenuation over the applicable range. See \"Sound.OpenAL.AL.Attenuation\" for details how the attenuation is computed as a function of the distance. The initial value is 1.  In particular, 'rolloffFactor' can be set to zero for those sources that are supposed to be exempt from distance attenuation. The implementation is encouraged to optimize this case, bypassing distance attenuation calculation entirely on a persource basis.","docstring_tokens":["rolloffFactor","is","used","for","distance","attenuation","calculations","based","on","inverse","distance","with","rolloff",".","For","distances","smaller","than","maxDistance","(","and","depending","on","the","distance","model","larger","than","referenceDistance",")","this","will","scale","the","distance","attenuation","over","the","applicable","range",".","See","Sound",".","OpenAL",".","AL",".","Attenuation","for","details","how","the","attenuation","is","computed","as","a","function","of","the","distance",".","The","initial","value","is","1",".","In","particular","rolloffFactor","can","be","set","to","zero","for","those","sources","that","are","supposed","to","be","exempt","from","distance","attenuation",".","The","implementation","is","encouraged","to","optimize","this","case","bypassing","distance","attenuation","calculation","entirely","on","a","persource","basis","."],"function":"rolloffFactor = makeSourceStateVar dictALfloat GetRolloffFactor","function_tokens":["rolloffFactor","=","makeSourceStateVar","dictALfloat","GetRolloffFactor"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L359-L359","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_ATTRIBUTES_SIZE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_ATTRIBUTES_SIZE                 = 0x1002","function_tokens":["alc_ATTRIBUTES_SIZE","=","0x1002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L158-L158","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putConstructor","parameters":"cfg consIndent lcons","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putConstructor cfg consIndent lcons = case GHC.unLoc lcons of\n  GHC.ConDeclGADT {..} -> do\n    -- Put argument to constructor first:\n    case con_g_args of\n      GHC.PrefixConGADT _ -> sep (comma >> space) $ fmap putRdrName con_names\n      GHC.RecConGADT _ -> error . mconcat $\n          [ \"Language.Haskell.Stylish.Step.Data.putConstructor: \"\n          , \"encountered a GADT with record constructors, not supported yet\"\n          ]\n\n    -- Put type of constructor:\n    space\n    putText \"::\"\n    space\n\n    putForAll\n        (case GHC.unLoc con_bndrs of\n            GHC.HsOuterImplicit {} -> False\n            GHC.HsOuterExplicit {} -> True)\n        (case GHC.unLoc con_bndrs of\n            GHC.HsOuterImplicit {}   -> []\n            GHC.HsOuterExplicit {..} -> hso_bndrs)\n    forM_ con_mb_cxt $ putContext cfg\n    case con_g_args of\n        GHC.PrefixConGADT scaledTys -> forM_ scaledTys $ \\scaledTy -> do\n            putType $ GHC.hsScaledThing scaledTy\n            space >> putText \"->\" >> space\n        GHC.RecConGADT _ -> error . mconcat $\n            [ \"Language.Haskell.Stylish.Step.Data.putConstructor: \"\n            , \"encountered a GADT with record constructors, not supported yet\"\n            ]\n    putType con_res_ty\n\n  GHC.ConDeclH98 {..} -> do\n    putForAll con_forall con_ex_tvs\n    forM_ con_mb_cxt $ putContext cfg\n    case con_args of\n      GHC.InfixCon arg1 arg2 -> do\n        putType $ GHC.hsScaledThing arg1\n        space\n        putRdrName con_name\n        space\n        putType $ GHC.hsScaledThing arg2\n      GHC.PrefixCon _tyargs args -> do\n        putRdrName con_name\n        unless (null args) space\n        sep space (fmap putOutputable args)\n      GHC.RecCon largs | _ : _ <- GHC.unLoc largs -> do\n        putRdrName con_name\n        skipToBrace\n        bracePos <- getCurrentLineLength\n        putText \"{\"\n        let fieldPos = bracePos + 2\n        space\n\n        let commented = commentGroups\n                (GHC.srcSpanToRealSrcSpan . GHC.getLocA)\n                (GHC.unLoc largs)\n                (epAnnComments . GHC.ann $ GHC.getLoc largs)\n\n        forM_ (flagEnds commented) $ \\(CommentGroup {..}, firstCommentGroup, _) -> do\n\n        -- Unless everything's configured to be on the same line, put pending\n        -- comments\n          forM_ cgPrior $ \\lc -> do\n            pad fieldPos\n            putComment $ GHC.unLoc lc\n            sepDecl bracePos\n\n          forM_ (flagEnds cgItems) $ \\((item, mbInlineComment), firstItem, _) -> do\n            if firstCommentGroup && firstItem\n                then pad fieldPos\n                else do\n                    comma\n                    space\n            putConDeclField cfg $ GHC.unLoc item\n            case mbInlineComment of\n                Just c -> do\n                    sepDecl bracePos >> spaces (cFieldComment cfg)\n                    putComment $ GHC.unLoc c\n                _ -> pure ()\n            sepDecl bracePos\n\n          forM_ cgFollowing $ \\lc -> do\n            spaces $ cFieldComment cfg\n            putComment $ GHC.unLoc lc\n            sepDecl bracePos\n\n        -- Print whitespace to closing brace\n        putText \"}\"\n      GHC.RecCon _ -> do\n        skipToBrace >> putText \"{\"\n        skipToBrace >> putText \"}\"\n\n    where\n      -- Jump to the first brace of the first record of the first constructor.\n      skipToBrace = case (cEquals cfg, cFirstField cfg) of\n        (_, Indent y) | not (cBreakSingleConstructors cfg) -> newline >> spaces y\n        (SameLine, SameLine) -> space\n        (Indent x, Indent y) -> newline >> spaces (x + y + 2)\n        (SameLine, Indent y) -> newline >> spaces (consIndent + y)\n        (Indent _, SameLine) -> space\n\n      -- Jump to the next declaration.\n      sepDecl bracePos = newline >> spaces case (cEquals cfg, cFirstField cfg) of\n        (_, Indent y) | not (cBreakSingleConstructors cfg) -> y\n        (SameLine, SameLine)                               -> bracePos\n        (Indent x, Indent y)                               -> x + y + 2\n        (SameLine, Indent y)                               -> bracePos + y - 2\n        (Indent x, SameLine)                               -> bracePos + x - 2","function_tokens":["putConstructor","cfg","consIndent","lcons","=","case","GHC","unLoc","lcons","of","GHC","ConDeclGADT","{","..","}","->","do","-- Put argument to constructor first:","case","con_g_args","of","GHC","PrefixConGADT","_","->","sep","(","comma",">>","space",")","$","fmap","putRdrName","con_names","GHC","RecConGADT","_","->","error",".","mconcat","$","[","\"Language.Haskell.Stylish.Step.Data.putConstructor: \"",",","\"encountered a GADT with record constructors, not supported yet\"","]","-- Put type of constructor:","space","putText","\"::\"","space","putForAll","(","case","GHC","unLoc","con_bndrs","of","GHC","HsOuterImplicit","{","}","->","False","GHC","HsOuterExplicit","{","}","->","True",")","(","case","GHC","unLoc","con_bndrs","of","GHC","HsOuterImplicit","{","}","->","[","]","GHC","HsOuterExplicit","{","..","}","->","hso_bndrs",")","forM_","con_mb_cxt","$","putContext","cfg","case","con_g_args","of","GHC","PrefixConGADT","scaledTys","->","forM_","scaledTys","$","\\","scaledTy","->","do","putType","$","GHC","hsScaledThing","scaledTy","space",">>","putText","\"->\"",">>","space","GHC","RecConGADT","_","->","error",".","mconcat","$","[","\"Language.Haskell.Stylish.Step.Data.putConstructor: \"",",","\"encountered a GADT with record constructors, not supported yet\"","]","putType","con_res_ty","GHC","ConDeclH98","{","..","}","->","do","putForAll","con_forall","con_ex_tvs","forM_","con_mb_cxt","$","putContext","cfg","case","con_args","of","GHC","InfixCon","arg1","arg2","->","do","putType","$","GHC","hsScaledThing","arg1","space","putRdrName","con_name","space","putType","$","GHC","hsScaledThing","arg2","GHC","PrefixCon","_tyargs","args","->","do","putRdrName","con_name","unless","(","null","args",")","space","sep","space","(","fmap","putOutputable","args",")","GHC","RecCon","largs","|","_",":","_","<-","GHC","unLoc","largs","->","do","putRdrName","con_name","skipToBrace","bracePos","<-","getCurrentLineLength","putText","\"{\"","let","fieldPos","=","bracePos","+","2","space","let","commented","=","commentGroups","(","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")","(","GHC","unLoc","largs",")","(","epAnnComments",".","GHC","ann","$","GHC","getLoc","largs",")","forM_","(","flagEnds","commented",")","$","\\","(","CommentGroup","{","..","}",",","firstCommentGroup",",","_",")","->","do","-- Unless everything's configured to be on the same line, put pending","-- comments","forM_","cgPrior","$","\\","lc","->","do","pad","fieldPos","putComment","$","GHC","unLoc","lc","sepDecl","bracePos","forM_","(","flagEnds","cgItems",")","$","\\","(","(","item",",","mbInlineComment",")",",","firstItem",",","_",")","->","do","if","firstCommentGroup","&&","firstItem","then","pad","fieldPos","else","do","comma","space","putConDeclField","cfg","$","GHC","unLoc","item","case","mbInlineComment","of","Just","c","->","do","sepDecl","bracePos",">>","spaces","(","cFieldComment","cfg",")","putComment","$","GHC","unLoc","c","_","->","pure","(",")","sepDecl","bracePos","forM_","cgFollowing","$","\\","lc","->","do","spaces","$","cFieldComment","cfg","putComment","$","GHC","unLoc","lc","sepDecl","bracePos","-- Print whitespace to closing brace","putText","\"}\"","GHC","RecCon","_","->","do","skipToBrace",">>","putText","\"{\"","skipToBrace",">>","putText","\"}\"","where","-- Jump to the first brace of the first record of the first constructor.","skipToBrace","=","case","(","cEquals","cfg",",","cFirstField","cfg",")","of","(","_",",","Indent","y",")","|","not","(","cBreakSingleConstructors","cfg",")","->","newline",">>","spaces","y","(","SameLine",",","SameLine",")","->","space","(","Indent","x",",","Indent","y",")","->","newline",">>","spaces","(","x","+","y","+","2",")","(","SameLine",",","Indent","y",")","->","newline",">>","spaces","(","consIndent","+","y",")","(","Indent","_",",","SameLine",")","->","space","-- Jump to the next declaration.","sepDecl","bracePos","=","newline",">>","spaces","case","(","cEquals","cfg",",","cFirstField","cfg",")","of","(","_",",","Indent","y",")","|","not","(","cBreakSingleConstructors","cfg",")","->","y","(","SameLine",",","SameLine",")","->","bracePos","(","Indent","x",",","Indent","y",")","->","x","+","y","+","2","(","SameLine",",","Indent","y",")","->","bracePos","+","y","-","2","(","Indent","x",",","SameLine",")","->","bracePos","+","x","-","2"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L327-L438","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"mzero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mzero = lift mzero","function_tokens":["mzero","=","lift","mzero"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L109-L109","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"modifyActions","parameters":"f","argument_list":"","return_statement":"","docstring":"Modify the collection of pending actions.","docstring_summary":"Modify the collection of pending actions.","docstring_tokens":["Modify","the","collection","of","pending","actions","."],"function":"modifyActions f = ZipArchive (modify g)\n  where\n    g st = st {zsActions = f (zsActions st)}\n\n-- | Add a new action to the list of pending actions.","function_tokens":["modifyActions","f","=","ZipArchive","(","modify","g",")","where","g","st","=","st","{","zsActions","=","f","(","zsActions","st",")","}","-- | Add a new action to the list of pending actions."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L680-L685","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"compareBench","parameters":"cfg d x1 x2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compareBench cfg d x1 x2 = warmup *> fix go x1 x2\n  where go h b1 b2 | oneOf ((<3) . samples) || oneOf ((<1) . informationOf) = next\n                   | otherwise = case compareMeans cfg (analysis b1) (analysis b2) of\n                       EQ | oneOf (relativeErrorAbove cfg (d\/2)) -> next\n                       r -> pure r\n           where next | ((<=) `on` informationOf . analysis) b1 b2 = (`h` b2) =<< step b1\n                      | otherwise = h b1 =<< step b2\n                 oneOf f = f (analysis b1) || f (analysis b2)","function_tokens":["compareBench","cfg","d","x1","x2","=","warmup","*>","fix","go","x1","x2","where","go","h","b1","b2","|","oneOf","(","(","<","3",")",".","samples",")","||","oneOf","(","(","<","1",")",".","informationOf",")","=","next","|","otherwise","=","case","compareMeans","cfg","(","analysis","b1",")","(","analysis","b2",")","of","EQ","|","oneOf","(","relativeErrorAbove","cfg","(","d","\/","2",")",")","->","next","r","->","pure","r","where","next","|","(","(","<=",")","`","on","`","informationOf",".","analysis",")","b1","b2","=","(","`","h","`","b2",")","=<<","step","b1","|","otherwise","=","h","b1","=<<","step","b2","oneOf","f","=","f","(","analysis","b1",")","||","f","(","analysis","b2",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L320-L329","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bottom = false","function_tokens":["bottom","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L218-L218","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = fromIntegral numALCints","function_tokens":["n","=","fromIntegral","numALCints"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L97-L97","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"writeNQuadFile","parameters":"CayleyConnection{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"writeNQuadFile CayleyConnection{..} =\n  doWrite manager cayleyConfig\n  where\n    doWrite m CayleyConfig{..} fp = do\n      r <- parseRequest (urlBase serverName apiVersion ++ \"\/write\/file\/nquad\")\n             >>= \\r -> return r { port = serverPort }\n      t <- liftIO $\n             try $\n               flip httpLbs m\n                 =<< formDataBody [partFileSource \"NQuadFile\" fp] r\n      return $\n        case t of\n          Right b -> A.decode (responseBody b)\n          Left e  -> Just $\n            A.object [\"error\" A..= T.pack (show (e :: SomeException))]\n\n-- | A valid 'Quad' has its subject, predicate and object not empty.","function_tokens":["writeNQuadFile","CayleyConnection","{","..","}","=","doWrite","manager","cayleyConfig","where","doWrite","m","CayleyConfig","{","..","}","fp","=","do","r","<-","parseRequest","(","urlBase","serverName","apiVersion","++","\"\/write\/file\/nquad\"",")",">>=","\\","r","->","return","r","{","port","=","serverPort","}","t","<-","liftIO","$","try","$","flip","httpLbs","m","=<<","formDataBody","[","partFileSource","\"NQuadFile\"","fp","]","r","return","$","case","t","of","Right","b","->","A","decode","(","responseBody","b",")","Left","e","->","Just","$","A","object","[","\"error\"","A",".=","T","pack","(","show","(","e","::","SomeException",")",")","]","-- | A valid 'Quad' has its subject, predicate and object not empty."],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L172-L189","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DT h)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DT h) = hashWithSalt s h","function_tokens":["hashWithSalt","s","(","DT","h",")","=","hashWithSalt","s","h"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L43-L43","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"divides'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"divides' = do\n            _ <- char '('\n            c <- decimal\n            _ <- char '|' *> space\n            a <- r\n            _ <- char ')'\n            divides'' c a","function_tokens":["divides'","=","do","_","<-","char","'('","c","<-","decimal","_","<-","char","'|'","*>","space","a","<-","r","_","<-","char","')'","divides''","c","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L118-L126","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"nodeDown","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nodeDown = return NodeDown","function_tokens":["nodeDown","=","return","NodeDown"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L136-L136","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(n', ns') = runCoiter ns","function_tokens":["(","n'",",","ns'",")","=","runCoiter","ns"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L714-L714","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Opts.hs","language":"haskell","identifier":"getOpts","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getOpts =\n    O.execParser opts\n    >>= \\case\n    CmdVersion ->\n        do\n            putStrLn $ \"git-mediate version \" ++ versionString\n            exitSuccess\n    CmdOptions o -> pure o","function_tokens":["getOpts","=","O","execParser","opts",">>=","\\","case","CmdVersion","->","do","putStrLn","$","\"git-mediate version \"","++","versionString","exitSuccess","CmdOptions","o","->","pure","o"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Opts.hs#L81-L88","hash_key":"Peaker\/git-mediate:src\/Opts.hs","hash_val":22726,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"p2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p2 = Proxy :: Proxy context","function_tokens":["p2","=","Proxy","::","Proxy","context"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L271-L271","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/StringQueries.hs","language":"haskell","identifier":"alRenderer","parameters":"","argument_list":"","return_statement":"","docstring":"Contains information about the specific renderer.","docstring_summary":"Contains information about the specific renderer.","docstring_tokens":["Contains","information","about","the","specific","renderer","."],"function":"alRenderer = makeGettableStateVar (getString Renderer)","function_tokens":["alRenderer","=","makeGettableStateVar","(","getString","Renderer",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/StringQueries.hs#L34-L34","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/StringQueries.hs","hash_val":22866,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"unsafeThaw","parameters":"(SymMatrix n v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeThaw (SymMatrix n v) = SymMMatrix n `liftM` G.thaw v","function_tokens":["unsafeThaw","(","SymMatrix","n","v",")","=","SymMMatrix","n","`","liftM","`","G","thaw","v"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L67-L67","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \/\\ b = a .&. b","function_tokens":["a","\/\\","b","=","a",".&.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L210-L210","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","language":"haskell","identifier":"readDbfData","parameters":"","argument_list":"","return_statement":"","docstring":"Parse a ByteString containing DBF data","docstring_summary":"Parse a ByteString containing DBF data","docstring_tokens":["Parse","a","ByteString","containing","DBF","data"],"function":"readDbfData = runGet $ do\n  _           <- getByteString 4   -- DBF File type\n  numRecs     <- getIntLE          -- Number of records\n  firstRecPos <- getInt16LE        -- Position of first record\n  _           <- getByteString 22  -- Rec len, table flags, code page mark\n  -- Field descriptors\n  let fieldsRemain = (< firstRecPos - 1) . fromIntegral <$> bytesRead\n  fields      <- whileM fieldsRemain getDbfFieldDesc\n  _           <- getWord8          -- Skip spacer\n  -- Records\n  recs        <- replicateM numRecs (getWord8 >> mapM getDbfRecord fields)\n  -- Everything together\n  return DbfData { dbfNumRecs = numRecs,\n              dbfFields  = fields,\n              dbfRecords = recs }\n\n-- | Read header field descriptor","function_tokens":["readDbfData","=","runGet","$","do","_","<-","getByteString","4","-- DBF File type","numRecs","<-","getIntLE","-- Number of records","firstRecPos","<-","getInt16LE","-- Position of first record","_","<-","getByteString","22","-- Rec len, table flags, code page mark","-- Field descriptors","let","fieldsRemain","=","(","<","firstRecPos","-","1",")",".","fromIntegral","<$>","bytesRead","fields","<-","whileM","fieldsRemain","getDbfFieldDesc","_","<-","getWord8","-- Skip spacer","-- Records","recs","<-","replicateM","numRecs","(","getWord8",">>","mapM","getDbfRecord","fields",")","-- Everything together","return","DbfData","{","dbfNumRecs","=","numRecs",",","dbfFields","=","fields",",","dbfRecords","=","recs","}","-- | Read header field descriptor"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs#L28-L45","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","hash_val":38792,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unsafeIndex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeIndex = MG.unsafeIndex","function_tokens":["unsafeIndex","=","MG","unsafeIndex"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L123-L123","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"runTweenT","parameters":"(TweenT s) dt leftover","argument_list":"","return_statement":"","docstring":"^ Returns @ a tuple of either the result or a tuple of this step's output value and the tween for the next step and the leftover time delta for the next step @","docstring_summary":"^ Returns","docstring_tokens":["^","Returns"],"function":"runTweenT (TweenT s) dt leftover =\n  first (second $ second TweenT)\n  <$> runStateT\n        (runSplineT s dt)\n        leftover","function_tokens":["runTweenT","(","TweenT","s",")","dt","leftover","=","first","(","second","$","second","TweenT",")","<$>","runStateT","(","runSplineT","s","dt",")","leftover"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L210-L214","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"forM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM = MG.forM","function_tokens":["forM","=","MG","forM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L251-L251","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unzip6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip6 = MG.unzip6","function_tokens":["unzip6","=","MG","unzip6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L366-L366","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(Forall vs phi)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Forall vs phi) = coerce $ \"(forall (\" ++ intercalate \" \" (map show vs) ++ \") \" ++ coerce phi ++ \")\"","function_tokens":["ishow","(","Forall","vs","phi",")","=","coerce","$","\"(forall (\"","++","intercalate","\" \"","(","map","show","vs",")","++","\") \"","++","coerce","phi","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L559-L559","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"scanVar","parameters":"v","argument_list":"","return_statement":"","docstring":"Run the var over the input values, gathering the output values in a list.  >>> let Identity (outputs, _) = scanVar (accumulate (+) 0) [1,1,1,1] >>> print outputs [1,2,3,4]","docstring_summary":"Run the var over the input values, gathering the output values in a list.  >>> let Identity (outputs, _) = scanVar (accumulate (+) 0) [1,1,1,1] >>> print outputs [1,2,3,4]","docstring_tokens":["Run","the","var","over","the","input","values","gathering","the","output","values","in","a","list",".",">>>","let","Identity","(","outputs","_",")","=","scanVar","(","accumulate","(","+",")","0",")","[","1","1","1","1","]",">>>","print","outputs","[","1","2","3","4","]"],"function":"scanVar v = foldM f ([], v)\n    where f (outs, v') a = do (b, v'') <- runVarT v' a\n                              return (outs ++ [b], v'')\n--------------------------------------------------------------------------------\n-- Testing and debugging\n--------------------------------------------------------------------------------\n-- | Trace the sample value of a var and pass it along as output. This is\n-- very useful for debugging graphs of vars. The (v|vs|vf)trace family of\n-- vars use 'Debug.Trace.trace' under the hood, so the value is only traced\n-- when evaluated.\n--\n-- >>> let v = id >>> vtrace\n-- >>> testVarOver v [1,2,3]\n-- 1\n-- 1\n-- 2\n-- 2\n-- 3\n-- 3","function_tokens":["scanVar","v","=","foldM","f","(","[","]",",","v",")","where","f","(","outs",",","v'",")","a","=","do","(","b",",","v''",")","<-","runVarT","v'","a","return","(","outs","++","[","b","]",",","v''",")","--------------------------------------------------------------------------------","-- Testing and debugging","--------------------------------------------------------------------------------","-- | Trace the sample value of a var and pass it along as output. This is","-- very useful for debugging graphs of vars. The (v|vs|vf)trace family of","-- vars use 'Debug.Trace.trace' under the hood, so the value is only traced","-- when evaluated.","--","-- >>> let v = id >>> vtrace","-- >>> testVarOver v [1,2,3]","-- 1","-- 1","-- 2","-- 2","-- 3","-- 3"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L396-L415","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"mantissa","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mantissa [] = mempty","function_tokens":["mantissa","[","]","=","mempty"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L359-L359","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"closestKnown","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"closestKnown = T.findClosest tree originId 1","function_tokens":["closestKnown","=","T","findClosest","tree","originId","1"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L151-L151","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"describe","parameters":"(BPi v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe (BPi v t e)  = DPi v (identity t) (identity e)","function_tokens":["describe","(","BPi","v","t","e",")","=","DPi","v","(","identity","t",")","(","identity","e",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L33-L33","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_CONE_INNER_ANGLE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_CONE_INNER_ANGLE                 = 0x1001","function_tokens":["al_CONE_INNER_ANGLE","=","0x1001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L90-L90","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotSVG.hs","language":"haskell","identifier":"mkMapSVG","parameters":"path map","argument_list":"","return_statement":"","docstring":"Given a `Map`, write it to file as an SVG.","docstring_summary":"Given a `Map`, write it to file as an SVG.","docstring_tokens":["Given","a","Map","write","it","to","file","as","an","SVG","."],"function":"mkMapSVG path map = do\n    renderableToFile fileOptions path $ mkMapR map\n    putStrLn (\"...output written to \" <> path)","function_tokens":["mkMapSVG","path","map","=","do","renderableToFile","fileOptions","path","$","mkMapR","map","putStrLn","(","\"...output written to \"","<>","path",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotSVG.hs#L23-L27","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotSVG.hs","hash_val":9853,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"changes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changes =\n            foldMap squashFieldDecl (everything module') <>\n            foldMap squashMatch (everything module')","function_tokens":["changes","=","foldMap","squashFieldDecl","(","everything","module'",")","<>","foldMap","squashMatch","(","everything","module'",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L86-L88","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"g","parameters":"((a, _), xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g ((a, _), xs) | a == 0 = 0 : xs\n                       | otherwise = replicate (a+1) 0 ++ xs","function_tokens":["g","(","(","a",",","_",")",",","xs",")","|","a","==","0","=","0",":","xs","|","otherwise","=","replicate","(","a","+","1",")","0","++","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L101-L102","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"foldr","parameters":"f z t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldr f z t\n  = case t of\n      Bin _ _ _ _ l r -> foldr f (foldr f z r) l\n      Tip _ x         -> f x z\n      Nil             -> z\n\n{--------------------------------------------------------------------\n  List variations\n--------------------------------------------------------------------}\n-- | \/O(n)\/. The elements of a set. (For sets, this is equivalent to toList)","function_tokens":["foldr","f","z","t","=","case","t","of","Bin","_","_","_","_","l","r","->","foldr","f","(","foldr","f","z","r",")","l","Tip","_","x","->","f","x","z","Nil","->","z","{--------------------------------------------------------------------\n  List variations\n--------------------------------------------------------------------}","-- | \/O(n)\/. The elements of a set. (For sets, this is equivalent to toList)"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L698-L708","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"inputLines","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"inputLines =\n        lines contents","function_tokens":["inputLines","=","lines","contents"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L149-L150","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapRest'","parameters":"ls ss []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapRest' ls ss []\n        | null ss = ls\n        | otherwise = ss:ls","function_tokens":["wrapRest'","ls","ss","[","]","|","null","ss","=","ls","|","otherwise","=","ss",":","ls"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L139-L141","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"withArchive","parameters":"path m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withArchive path m = liftIO $ do\n  apath <- canonicalizePath path\n  (desc, entries) <- liftIO (I.scanArchive apath)\n  let st =\n        ZipState\n          { zsFilePath = apath,\n            zsEntries = entries,\n            zsArchive = desc,\n            zsActions = S.empty\n          }\n      action = unZipArchive (m <* commit)\n  liftIO (evalStateT action st)\n\n----------------------------------------------------------------------------\n-- Retrieving information\n\n-- | Retrieve a description of all archive entries. This is an efficient\n-- operation that can be used for example to list all entries in the\n-- archive. Do not hesitate to use the function frequently: scanning of the\n-- archive happens only once.\n--\n-- Please note that the returned value only reflects the current contents of\n-- the archive in file system, non-committed actions are not reflected, see\n-- 'commit' for more information.","function_tokens":["withArchive","path","m","=","liftIO","$","do","apath","<-","canonicalizePath","path","(","desc",",","entries",")","<-","liftIO","(","I","scanArchive","apath",")","let","st","=","ZipState","{","zsFilePath","=","apath",",","zsEntries","=","entries",",","zsArchive","=","desc",",","zsActions","=","S","empty","}","action","=","unZipArchive","(","m","<*","commit",")","liftIO","(","evalStateT","action","st",")","----------------------------------------------------------------------------","-- Retrieving information","-- | Retrieve a description of all archive entries. This is an efficient","-- operation that can be used for example to list all entries in the","-- archive. Do not hesitate to use the function frequently: scanning of the","-- archive happens only once.","--","-- Please note that the returned value only reflects the current contents of","-- the archive in file system, non-committed actions are not reflected, see","-- 'commit' for more information."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L286-L310","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"grhs","parameters":"","argument_list":"","return_statement":"","docstring":"[]","docstring_summary":"[]","docstring_tokens":["[]"],"function":"grhs  = map GHC.unLoc lgrhs","function_tokens":["grhs","=","map","GHC","unLoc","lgrhs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L246-L246","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unsafeFreeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFreeze = MG.unsafeFreeze","function_tokens":["unsafeFreeze","=","MG","unsafeFreeze"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L381-L381","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/Capabilities.hs","language":"haskell","identifier":"cmdCapabilities","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cmdCapabilities = command \"capabilities\" $ flip info idm $ runCapabilities <$> optsCapabilities","function_tokens":["cmdCapabilities","=","command","\"capabilities\"","$","flip","info","idm","$","runCapabilities","<$>","optsCapabilities"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/Capabilities.hs#L26-L26","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/Capabilities.hs","hash_val":30166,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/menu.hs","language":"haskell","identifier":"prompt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prompt = \"Which snack? \" & bold & fg yellow","function_tokens":["prompt","=","\"Which snack? \"","&","bold","&","fg","yellow"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/menu.hs#L51-L51","hash_key":"pjones\/byline:examples\/menu.hs","hash_val":10089,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_VENDOR","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_VENDOR                           = 0xB001","function_tokens":["al_VENDOR","=","0xB001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L48-L48","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"crc32Sink","parameters":"","argument_list":"","return_statement":"","docstring":"A sink that calculates the CRC32 check sum for an incoming stream.","docstring_summary":"A sink that calculates the CRC32 check sum for an incoming stream.","docstring_tokens":["A","sink","that","calculates","the","CRC32","check","sum","for","an","incoming","stream","."],"function":"crc32Sink = CL.fold crc32Update 0","function_tokens":["crc32Sink","=","CL","fold","crc32Update","0"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1166-L1166","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs","language":"haskell","identifier":"avx_2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"avx_2 = U.unsafePerformIO F.enabled_avx_2 \/= 0","function_tokens":["avx_2","=","U","unsafePerformIO","F","enabled_avx_2","\/=","0"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs#L7-L7","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs","hash_val":30181,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"outputIbFile","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"outputIbFile  = opts ^. L.outputIbFile & fromMaybe (filePath <> \".ib.idx\")","function_tokens":["outputIbFile","=","opts","^.","L","outputIbFile","&","fromMaybe","(","filePath","<>","\".ib.idx\"",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L29-L29","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ma1 <|> ma2 = AccumC $ \\w -> runAccumC ma1 w <|> runAccumC ma2 w","function_tokens":["ma1","<|>","ma2","=","AccumC","$","\\","w","->","runAccumC","ma1","w","<|>","runAccumC","ma2","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L101-L101","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Iso a b . Iso c d = Iso (a . c) (d . b)","function_tokens":["Iso","a","b",".","Iso","c","d","=","Iso","(","a",".","c",")","(","d",".","b",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L119-L119","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"trd","parameters":"(_, _, x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"trd (_, _, x) = x","function_tokens":["trd","(","_",",","_",",","x",")","=","x"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L729-L729","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"runRSS","parameters":"m r s","argument_list":"","return_statement":"","docstring":"Unwrap an RSS computation as a function. (The inverse of 'rss'.)","docstring_summary":"Unwrap an RSS computation as a function. (The inverse of 'rss'.)","docstring_tokens":["Unwrap","an","RSS","computation","as","a","function",".","(","The","inverse","of","rss",".",")"],"function":"runRSS m r s = runIdentity (runRSST m r s)","function_tokens":["runRSS","m","r","s","=","runIdentity","(","runRSST","m","r","s",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L50-L50","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/CP437.hs","language":"haskell","identifier":"decodeByteCP437","parameters":"byte","argument_list":"","return_statement":"","docstring":"Decode a single byte of CP437 encoded text.","docstring_summary":"Decode a single byte of CP437 encoded text.","docstring_tokens":["Decode","a","single","byte","of","CP437","encoded","text","."],"function":"decodeByteCP437 byte = chr $ case byte of\n  128 -> 199\n  129 -> 252\n  130 -> 233\n  131 -> 226\n  132 -> 228\n  133 -> 224\n  134 -> 229\n  135 -> 231\n  136 -> 234\n  137 -> 235\n  138 -> 232\n  139 -> 239\n  140 -> 238\n  141 -> 236\n  142 -> 196\n  143 -> 197\n  144 -> 201\n  145 -> 230\n  146 -> 198\n  147 -> 244\n  148 -> 246\n  149 -> 242\n  150 -> 251\n  151 -> 249\n  152 -> 255\n  153 -> 214\n  154 -> 220\n  155 -> 162\n  156 -> 163\n  157 -> 165\n  158 -> 8359\n  159 -> 402\n  160 -> 225\n  161 -> 237\n  162 -> 243\n  163 -> 250\n  164 -> 241\n  165 -> 209\n  166 -> 170\n  167 -> 186\n  168 -> 191\n  169 -> 8976\n  170 -> 172\n  171 -> 189\n  172 -> 188\n  173 -> 161\n  174 -> 171\n  175 -> 187\n  176 -> 9617\n  177 -> 9618\n  178 -> 9619\n  179 -> 9474\n  180 -> 9508\n  181 -> 9569\n  182 -> 9570\n  183 -> 9558\n  184 -> 9557\n  185 -> 9571\n  186 -> 9553\n  187 -> 9559\n  188 -> 9565\n  189 -> 9564\n  190 -> 9563\n  191 -> 9488\n  192 -> 9492\n  193 -> 9524\n  194 -> 9516\n  195 -> 9500\n  196 -> 9472\n  197 -> 9532\n  198 -> 9566\n  199 -> 9567\n  200 -> 9562\n  201 -> 9556\n  202 -> 9577\n  203 -> 9574\n  204 -> 9568\n  205 -> 9552\n  206 -> 9580\n  207 -> 9575\n  208 -> 9576\n  209 -> 9572\n  210 -> 9573\n  211 -> 9561\n  212 -> 9560\n  213 -> 9554\n  214 -> 9555\n  215 -> 9579\n  216 -> 9578\n  217 -> 9496\n  218 -> 9484\n  219 -> 9608\n  220 -> 9604\n  221 -> 9612\n  222 -> 9616\n  223 -> 9600\n  224 -> 945\n  225 -> 223\n  226 -> 915\n  227 -> 960\n  228 -> 931\n  229 -> 963\n  230 -> 181\n  231 -> 964\n  232 -> 934\n  233 -> 920\n  234 -> 937\n  235 -> 948\n  236 -> 8734\n  237 -> 966\n  238 -> 949\n  239 -> 8745\n  240 -> 8801\n  241 -> 177\n  242 -> 8805\n  243 -> 8804\n  244 -> 8992\n  245 -> 8993\n  246 -> 247\n  247 -> 8776\n  248 -> 176\n  249 -> 8729\n  250 -> 183\n  251 -> 8730\n  252 -> 8319\n  253 -> 178\n  254 -> 9632\n  255 -> 160\n  x -> fromIntegral x -- the rest of characters translate directly","function_tokens":["decodeByteCP437","byte","=","chr","$","case","byte","of","128","->","199","129","->","252","130","->","233","131","->","226","132","->","228","133","->","224","134","->","229","135","->","231","136","->","234","137","->","235","138","->","232","139","->","239","140","->","238","141","->","236","142","->","196","143","->","197","144","->","201","145","->","230","146","->","198","147","->","244","148","->","246","149","->","242","150","->","251","151","->","249","152","->","255","153","->","214","154","->","220","155","->","162","156","->","163","157","->","165","158","->","8359","159","->","402","160","->","225","161","->","237","162","->","243","163","->","250","164","->","241","165","->","209","166","->","170","167","->","186","168","->","191","169","->","8976","170","->","172","171","->","189","172","->","188","173","->","161","174","->","171","175","->","187","176","->","9617","177","->","9618","178","->","9619","179","->","9474","180","->","9508","181","->","9569","182","->","9570","183","->","9558","184","->","9557","185","->","9571","186","->","9553","187","->","9559","188","->","9565","189","->","9564","190","->","9563","191","->","9488","192","->","9492","193","->","9524","194","->","9516","195","->","9500","196","->","9472","197","->","9532","198","->","9566","199","->","9567","200","->","9562","201","->","9556","202","->","9577","203","->","9574","204","->","9568","205","->","9552","206","->","9580","207","->","9575","208","->","9576","209","->","9572","210","->","9573","211","->","9561","212","->","9560","213","->","9554","214","->","9555","215","->","9579","216","->","9578","217","->","9496","218","->","9484","219","->","9608","220","->","9604","221","->","9612","222","->","9616","223","->","9600","224","->","945","225","->","223","226","->","915","227","->","960","228","->","931","229","->","963","230","->","181","231","->","964","232","->","934","233","->","920","234","->","937","235","->","948","236","->","8734","237","->","966","238","->","949","239","->","8745","240","->","8801","241","->","177","242","->","8805","243","->","8804","244","->","8992","245","->","8993","246","->","247","247","->","8776","248","->","176","249","->","8729","250","->","183","251","->","8730","252","->","8319","253","->","178","254","->","9632","255","->","160","x","->","fromIntegral","x","-- the rest of characters translate directly"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/CP437.hs#L34-L163","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/CP437.hs","hash_val":21977,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"tween","parameters":"f start end dur","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tween f start end dur =\n  TweenT\n    $ SplineT g\n  where\n    c = end - start\n    b = start\n    g dt = do\n      leftover <- get\n      let\n        t = dt + leftover\n      if t == dur\n        then\n          put 0 >> return (Right (end, return end))\n        else\n          if t > dur\n          then\n            put (t - dur - dt) >> return (Left end)\n          else\n            put t >> return (Right (f c (t\/dur) b, SplineT g))\n\n\n-- | A version of 'tween' that discards the result. It is simply\n--\n-- @\n-- tween f a b c >> return ()\n-- @\n--","function_tokens":["tween","f","start","end","dur","=","TweenT","$","SplineT","g","where","c","=","end","-","start","b","=","start","g","dt","=","do","leftover","<-","get","let","t","=","dt","+","leftover","if","t","==","dur","then","put","0",">>","return","(","Right","(","end",",","return","end",")",")","else","if","t",">","dur","then","put","(","t","-","dur","-","dt",")",">>","return","(","Left","end",")","else","put","t",">>","return","(","Right","(","f","c","(","t","\/","dur",")","b",",","SplineT","g",")",")","-- | A version of 'tween' that discards the result. It is simply","--","-- @","-- tween f a b c >> return ()","-- @","--"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L292-L319","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = pickProjection projection","function_tokens":["p","=","pickProjection","projection"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L22-L22","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intersection","parameters":"_ Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intersection _ Nil = Nil","function_tokens":["intersection","_","Nil","=","Nil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L438-L438","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"liftIx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIx = coerce","function_tokens":["liftIx","=","coerce"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L74-L74","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","language":"haskell","identifier":"ptr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptr = F.unsafeForeignPtrToPtr fptr","function_tokens":["ptr","=","F","unsafeForeignPtrToPtr","fptr"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs#L70-L70","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","hash_val":30325,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"findMax","parameters":"(Bin _ _ _ m l r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findMax (Bin _ _ _ m l r)\n  |   m < 0   = find l\n  | otherwise = find r\n    where find (Tip _ x)          = x\n          find (Bin _ _ _ _ _ r') = find r'\n          find Nil                = error \"findMax Nil\"\n\n\n-- | \/O(min(n,W))\/. Delete the minimal element.","function_tokens":["findMax","(","Bin","_","_","_","m","l","r",")","|","m","<","0","=","find","l","|","otherwise","=","find","r","where","find","(","Tip","_","x",")","=","x","find","(","Bin","_","_","_","_","_","r'",")","=","find","r'","find","Nil","=","error","\"findMax Nil\"","-- | \/O(min(n,W))\/. Delete the minimal element."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L652-L661","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"divides''","parameters":"c a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"divides'' c a = case toStaticallySorted a of\n            Just a' -> return . toDynamicallySorted $ c .\\. a'\n            _       -> fail \"divisibility of non-integral argument\"","function_tokens":["divides''","c","a","=","case","toStaticallySorted","a","of","Just","a'","->","return",".","toDynamicallySorted","$","c",".\\.","a'","_","->","fail","\"divisibility of non-integral argument\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L142-L146","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"sequenceA","parameters":"(Choosing m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sequenceA (Choosing m) = fmap Choosing (sequenceA m)","function_tokens":["sequenceA","(","Choosing","m",")","=","fmap","Choosing","(","sequenceA","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L146-L146","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/menu.hs","language":"haskell","identifier":"toStylizedText","parameters":"item","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toStylizedText item = case item of\n    Fruit name -> text name <> (\" (fruit)\" & fg red)\n    Vegetable name -> text name <> (\" (vegetable)\" & fg green)\n\n-- | The list of menu items.","function_tokens":["toStylizedText","item","=","case","item","of","Fruit","name","->","text","name","<>","(","\" (fruit)\"","&","fg","red",")","Vegetable","name","->","text","name","<>","(","\" (vegetable)\"","&","fg","green",")","-- | The list of menu items."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/menu.hs#L31-L36","hash_key":"pjones\/byline:examples\/menu.hs","hash_val":10089,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"","parameters":"a@(Stylized _ _) b@(Stylized _ _)","argument_list":"","return_statement":"","docstring":"StylizedText on LHS.","docstring_summary":"StylizedText on LHS.","docstring_tokens":["StylizedText","on","LHS","."],"function":"(<>) a@(Stylized _ _) b@(Stylized _ _) = StylizedList [a, b]","function_tokens":["(","<>",")","a","@","(","Stylized","_","_",")","b","@","(","Stylized","_","_",")","=","StylizedList","[","a",",","b","]"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L53-L53","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"stepMany","parameters":"v [] e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stepMany v [] e     = runVarT v e","function_tokens":["stepMany","v","[","]","e","=","runVarT","v","e"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L386-L386","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"configFilePath","parameters":"verbose Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"configFilePath verbose Nothing              = do\n    current    <- getCurrentDirectory\n    configPath <- getXdgDirectory XdgConfig \"stylish-haskell\"\n    home       <- getHomeDirectory\n    search verbose $\n        [d <\/> configFileName | d <- ancestors current] ++\n        [configPath <\/> \"config.yaml\", home <\/> configFileName]","function_tokens":["configFilePath","verbose","Nothing","=","do","current","<-","getCurrentDirectory","configPath","<-","getXdgDirectory","XdgConfig","\"stylish-haskell\"","home","<-","getHomeDirectory","search","verbose","$","[","d","<\/>","configFileName","|","d","<-","ancestors","current","]","++","[","configPath","<\/>","\"config.yaml\"",",","home","<\/>","configFileName","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L100-L108","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty = go\n        where\n            go DoubleFlat   = \"__\"\n            go Flat         = \"_\"\n            go Natural      = \"=\"\n            go Sharp        = \"^\"\n            go DoubleSharp  = \"^^\"\n\n-- | Octaves (4.1).","function_tokens":["pretty","=","go","where","go","DoubleFlat","=","\"__\"","go","Flat","=","\"_\"","go","Natural","=","\"=\"","go","Sharp","=","\"^\"","go","DoubleSharp","=","\"^^\"","-- | Octaves (4.1)."],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L456-L465","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"sub","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sub v = case lookup v env of\n                  Nothing -> v\n                  Just w  -> w","function_tokens":["sub","v","=","case","lookup","v","env","of","Nothing","->","v","Just","w","->","w"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L666-L670","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = pure mempty","function_tokens":["mempty","=","pure","mempty"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L220-L220","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"deleteObjectNames","parameters":"buffers","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteObjectNames buffers =\n      liftIO $ withArrayLen buffers $ alDeleteBuffers . fromIntegral","function_tokens":["deleteObjectNames","buffers","=","liftIO","$","withArrayLen","buffers","$","alDeleteBuffers",".","fromIntegral"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L66-L67","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"month","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"month = fromIntegral $ shiftR msDosDate 5 .&. 0x0f","function_tokens":["month","=","fromIntegral","$","shiftR","msDosDate","5",".&.","0x0f"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1194-L1194","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/Capabilities.hs","language":"haskell","identifier":"optsCapabilities","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"optsCapabilities = pure ()","function_tokens":["optsCapabilities","=","pure","(",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/Capabilities.hs#L23-L23","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/Capabilities.hs","hash_val":30166,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeOutQuad","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease out quadratic.","docstring_summary":"Ease out quadratic.","docstring_tokens":["Ease","out","quadratic","."],"function":"easeOutQuad c t b =  (-c) * realToFrac (t * (t - 2)) + b","function_tokens":["easeOutQuad","c","t","b","=","(","-","c",")","*","realToFrac","(","t","*","(","t","-","2",")",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L100-L100","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"wrapLanguage","parameters":"ps","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapLanguage ps = \"{-# \" ++ lg ++ ps ++  \" #-}\"","function_tokens":["wrapLanguage","ps","=","\"{-# \"","++","lg","++","ps","++","\" #-}\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L63-L63","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Types.hs","language":"haskell","identifier":"show","parameters":"ShpNull","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show ShpNull = show $ red (text \"Error: \") <> (text \"\")","function_tokens":["show","ShpNull","=","show","$","red","(","text","\"Error: \"",")","<>","(","text","\"\"",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Types.hs#L31-L31","hash_key":"vmchale\/hgis:src\/GIS\/Types.hs","hash_val":29930,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"u      . Id     = u","function_tokens":["u",".","Id","=","u"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L92-L92","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f0 . g0 = VarT $ \\a -> do\n      (b, g) <- runVarT g0 a\n      (c, f) <- runVarT f0 b\n      return (c, f . g)\n\n-- | Vars are applicative.\n--\n-- >>> let v = (,) <$> pure True <*> pure \"Applicative\"\n-- >>> testVarOver v [()]\n-- (True,\"Applicative\")\n--\n-- Note - checkout the <$proofs proofs>","function_tokens":["f0",".","g0","=","VarT","$","\\","a","->","do","(","b",",","g",")","<-","runVarT","g0","a","(","c",",","f",")","<-","runVarT","f0","b","return","(","c",",","f",".","g",")","-- | Vars are applicative.","--","-- >>> let v = (,) <$> pure True <*> pure \"Applicative\"","-- >>> testVarOver v [()]","-- (True,\"Applicative\")","--","-- Note - checkout the <$proofs proofs>"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L112-L124","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"mul","parameters":"[m]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mul [m] = m","function_tokens":["mul","[","m","]","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L205-L205","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"implus","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"implus = coerce $ mplus @m @a","function_tokens":["implus","=","coerce","$","mplus","@","m","@","a"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L68-L68","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten'","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten' (InL fa) = flatten' fa","function_tokens":["flatten'","(","InL","fa",")","=","flatten'","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L863-L863","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"pat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pat        = last patsLocs","function_tokens":["pat","=","last","patsLocs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L119-L119","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sizeOf","parameters":"~(Source b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sizeOf    ~(Source b) = sizeOf b","function_tokens":["sizeOf","~","(","Source","b",")","=","sizeOf","b"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L117-L117","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"const","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"const a = arr (\\_ -> a)","function_tokens":["const","a","=","arr","(","\\","_","->","a",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L160-L160","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"not'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"not' = do\n            _ <- char '(' *> string \"not\" *> space\n            n <- r\n            _ <- char ')'\n            not'' n","function_tokens":["not'","=","do","_","<-","char","'('","*>","string","\"not\"","*>","space","n","<-","r","_","<-","char","')'","not''","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L424-L430","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"generateLabels","parameters":"mk concrete failing dec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"generateLabels mk concrete failing dec =\n\n do -- Only process data and newtype declarations, filter out all\n    -- constructors and the type variables.\n    let (name, cons, vars) =\n          case dec of\n#if MIN_VERSION_template_haskell(2,11,0)\n            DataD    _ n vs _ cs _ -> (n, cs,  vs)\n            NewtypeD _ n vs _ c  _ -> (n, [c], vs)\n#else\n            DataD    _ n vs cs _ -> (n, cs,  vs)\n            NewtypeD _ n vs c  _ -> (n, [c], vs)\n#endif\n            _ -> fclError \"Can only derive labels for datatypes and newtypes.\"\n\n        -- We are only interested in lenses of record constructors.\n        fields = groupFields mk vars cons\n\n    forM fields $ generateLabel failing concrete name vars cons","function_tokens":["generateLabels","mk","concrete","failing","dec","=","do","-- Only process data and newtype declarations, filter out all","-- constructors and the type variables.","let","(","name",",","cons",",","vars",")","=","case","dec","of","#if MIN_VERSION_template_haskell(2,11,0)","DataD","_","n","vs","_","cs","_","->","(","n",",","cs",",","vs",")","NewtypeD","_","n","vs","_","c","_","->","(","n",",","[","c","]",",","vs",")","#else\n            DataD    _ n vs cs _ -> (n, cs,  vs)\n            NewtypeD _ n vs c  _ -> (n, [c], vs)\n","#endif","_","->","fclError","\"Can only derive labels for datatypes and newtypes.\"","-- We are only interested in lenses of record constructors.","fields","=","groupFields","mk","vars","cons","forM","fields","$","generateLabel","failing","concrete","name","vars","cons"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L292-L312","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"go","parameters":"s (step:steps)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go s (step:steps) = do\n          let bp = stepToByteString s step\n          bps <- IO.unsafeInterleaveIO $ go s steps\n          return $ bp:bps","function_tokens":["go","s","(","step",":","steps",")","=","do","let","bp","=","stepToByteString","s","step","bps","<-","IO","unsafeInterleaveIO","$","go","s","steps","return","$","bp",":","bps"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L93-L97","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"resLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resLen = BS.length bs `div` 8","function_tokens":["resLen","=","BS","length","bs","`","div","`","8"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L50-L50","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(d, i) = partition (\\(vs', _) -> any (`elem` mapMaybe toStaticallySorted vs') vs) qs","function_tokens":["(","d",",","i",")","=","partition","(","\\","(","vs'",",","_",")","->","any","(","`","elem","`","mapMaybe","toStaticallySorted","vs'",")","vs",")","qs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L856-L856","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"askChar","parameters":"","argument_list":"","return_statement":"","docstring":"Read a single character of input.  @since 1.0.0.0","docstring_summary":"Read a single character of input.","docstring_tokens":["Read","a","single","character","of","input","."],"function":"askChar =\n  toStylizedText\n    >>> Prim.askChar\n    >>> liftByline","function_tokens":["askChar","=","toStylizedText",">>>","Prim","askChar",">>>","liftByline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L114-L117","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"isObjectName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isObjectName = liftIO . fmap unmarshalALboolean . alIsBuffer","function_tokens":["isObjectName","=","liftIO",".","fmap","unmarshalALboolean",".","alIsBuffer"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L69-L69","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"removeFileIfEmpty","parameters":"path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"removeFileIfEmpty path =\n    do  isEmpty <- null <$> readFile path\n        when isEmpty $\n            do  removeFile path\n                callProcess \"git\" [\"add\", \"-u\", \"--\", path]","function_tokens":["removeFileIfEmpty","path","=","do","isEmpty","<-","null","<$>","readFile","path","when","isEmpty","$","do","removeFile","path","callProcess","\"git\"","[","\"add\"",",","\"-u\"",",","\"--\"",",","path","]"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L191-L197","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"exitCodes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exitCodes =\n        [ (\"normal\", NormalExitBehavior)\n        , (\"error_on_format\", ErrorOnFormatExitBehavior)\n        ]","function_tokens":["exitCodes","=","[","(","\"normal\"",",","NormalExitBehavior",")",",","(","\"error_on_format\"",",","ErrorOnFormatExitBehavior",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L157-L160","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"injLabelled","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"injLabelled = L","function_tokens":["injLabelled","=","L"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L98-L98","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(result,t') = minViewUnsigned r","function_tokens":["(","result",",","t'",")","=","minViewUnsigned","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L612-L612","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getPending","parameters":"","argument_list":"","return_statement":"","docstring":"Get the collection of pending actions.","docstring_summary":"Get the collection of pending actions.","docstring_tokens":["Get","the","collection","of","pending","actions","."],"function":"getPending = ZipArchive (gets zsActions)","function_tokens":["getPending","=","ZipArchive","(","gets","zsActions",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L676-L676","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"getIntegerv","parameters":"maybeDevice query numALCints","argument_list":"","return_statement":"","docstring":"We are extremely careful below to avoid segfaults in case that there is no current context, an invalid device, etc.","docstring_summary":"We are extremely careful below to avoid segfaults in case that there is no current context, an invalid device, etc.","docstring_tokens":["We","are","extremely","careful","below","to","avoid","segfaults","in","case","that","there","is","no","current","context","an","invalid","device","etc","."],"function":"getIntegerv maybeDevice query numALCints =\n   let n = fromIntegral numALCints\n   in withArray (replicate n 0) $ \\buf -> do\n         when (numALCints > 0) $\n            alcGetIntegerv (marshalMaybeDevice maybeDevice)\n                           (marshalIntQuery query) numALCints buf\n         peekArray n buf","function_tokens":["getIntegerv","maybeDevice","query","numALCints","=","let","n","=","fromIntegral","numALCints","in","withArray","(","replicate","n","0",")","$","\\","buf","->","do","when","(","numALCints",">","0",")","$","alcGetIntegerv","(","marshalMaybeDevice","maybeDevice",")","(","marshalIntQuery","query",")","numALCints","buf","peekArray","n","buf"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L96-L104","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"setter","parameters":"failing total (Field mn _ _ (cons, _))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"setter failing total (Field mn _ _ (cons, _)) =\n  do let pt = mkName \"f\"\n         md = mkName \"v\"\n         nm = maybe (tupE []) (litE . StringL . nameBase) (guard failing >> mn)\n         wild = if total then [] else [match wildP (normalB [| Left $(nm) |]) []]\n         rght = if total then id else appE [| Right |]\n         mkCase (Context i _ c) = map (\\(pat, var) -> match pat (normalB (rght var)) []) (case1 i c)\n     lamE [tupP [varP md, varP pt]]\n          (caseE (varE pt) (concatMap mkCase cons ++ wild))\n  where\n  case1 i con =\n    case con of\n      NormalC  c  fs   -> [one fs c]\n      RecC     c  fs   -> [one fs c]\n      InfixC   _  c  _ -> [( infixP (pats !! 0) c (pats !! 1)\n                          , infixE (Just (vars !! 0)) (conE c) (Just (vars !! 1))\n                          )\n                         ]\n      ForallC  _  _  c -> case1 i c\n#if MIN_VERSION_template_haskell(2,11,0)\n      GadtC    cs fs _ -> map (one fs) cs\n      RecGadtC cs fs _ -> map (one fs) cs\n#endif\n    where fresh     = mkName <$> delete \"f\" (delete \"v\" freshNames)\n          pats1     = varP <$> fresh\n          pats      = take i pats1 ++ [wildP] ++ drop (i + 1) pats1\n          vars1     = varE <$> fresh\n          v         = varE (mkName \"v\")\n          vars      = take i vars1 ++ [v] ++ drop (i + 1) vars1\n          apps f as = foldl appE f as\n          one fs c  = let s = take (length fs) in (conP c (s pats), apps (conE c) (s vars))","function_tokens":["setter","failing","total","(","Field","mn","_","_","(","cons",",","_",")",")","=","do","let","pt","=","mkName","\"f\"","md","=","mkName","\"v\"","nm","=","maybe","(","tupE","[","]",")","(","litE",".","StringL",".","nameBase",")","(","guard","failing",">>","mn",")","wild","=","if","total","then","[","]","else","[","match","wildP","(","normalB","[","|"," Left $(nm) ","|]",")","[","]","]","rght","=","if","total","then","id","else","appE","[","|"," Right ","|]","mkCase","(","Context","i","_","c",")","=","map","(","\\","(","pat",",","var",")","->","match","pat","(","normalB","(","rght","var",")",")","[","]",")","(","case1","i","c",")","lamE","[","tupP","[","varP","md",",","varP","pt","]","]","(","caseE","(","varE","pt",")","(","concatMap","mkCase","cons","++","wild",")",")","where","case1","i","con","=","case","con","of","NormalC","c","fs","->","[","one","fs","c","]","RecC","c","fs","->","[","one","fs","c","]","InfixC","_","c","_","->","[","(","infixP","(","pats","!!","0",")","c","(","pats","!!","1",")",",","infixE","(","Just","(","vars","!!","0",")",")","(","conE","c",")","(","Just","(","vars","!!","1",")",")",")","]","ForallC","_","_","c","->","case1","i","c","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","cs","fs","_","->","map","(","one","fs",")","cs","RecGadtC","cs","fs","_","->","map","(","one","fs",")","cs","#endif","where","fresh","=","mkName","<$>","delete","\"f\"","(","delete","\"v\"","freshNames",")","pats1","=","varP","<$>","fresh","pats","=","take","i","pats1","++","[","wildP","]","++","drop","(","i","+","1",")","pats1","vars1","=","varE","<$>","fresh","v","=","varE","(","mkName","\"v\"",")","vars","=","take","i","vars1","++","[","v","]","++","drop","(","i","+","1",")","vars1","apps","f","as","=","foldl","appE","f","as","one","fs","c","=","let","s","=","take","(","length","fs",")","in","(","conP","c","(","s","pats",")",",","apps","(","conE","c",")","(","s","vars",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L522-L554","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureStop","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"captureStop = captureStartStop \"alcCaptureStop\"","function_tokens":["captureStop","=","captureStartStop","\"alcCaptureStop\""],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L104-L104","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"evalPrimF","parameters":"renderMode outputHandle compRef","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"evalPrimF renderMode outputHandle compRef = Free.iterTM go\n  where\n    go ::\n      PrimF (EvalT m a) ->\n      EvalT m a\n    go = \\case\n      Say s k ->\n        liftIO (render renderMode outputHandle s) >> k\n      AskLn s d k -> do\n        let prompt =\n              renderText renderMode $\n                maybe s (\\d' -> s <> text \"[\" <> text d' <> text \"] \") d\n        liftHaskeline (Haskeline.getInputLine (toString prompt)) >>= \\case\n          Nothing -> EvalT empty\n          Just answer\n            | null answer -> k (fromMaybe mempty d)\n            | otherwise -> k (toText answer)\n      AskChar s k -> do\n        let prompt = toString (renderText renderMode s)\n        liftHaskeline (Haskeline.getInputChar prompt) >>= \\case\n          Nothing -> EvalT empty\n          Just c -> k c\n      AskPassword s m k -> do\n        let prompt = toString (renderText renderMode s)\n        liftHaskeline (Haskeline.getPassword m prompt) >>= \\case\n          Nothing -> EvalT empty\n          Just str -> k (toText str)\n      PushCompFunc f k ->\n        modifyIORef' compRef (f :) >> k\n      PopCompFunc k ->\n        modifyIORef'\n          compRef\n          ( \\case\n              [] -> []\n              (_ : fs) -> fs\n          )\n          >> k\n    liftHaskeline :: Haskeline.InputT m b -> EvalT m b\n    liftHaskeline = Haskeline.withInterrupt >>> lift >>> EvalT\n\n-- | Calculate the default rendering mode based on the terminal type.","function_tokens":["evalPrimF","renderMode","outputHandle","compRef","=","Free","iterTM","go","where","go","::","PrimF","(","EvalT","m","a",")","->","EvalT","m","a","go","=","\\","case","Say","s","k","->","liftIO","(","render","renderMode","outputHandle","s",")",">>","k","AskLn","s","d","k","->","do","let","prompt","=","renderText","renderMode","$","maybe","s","(","\\","d'","->","s","<>","text","\"[\"","<>","text","d'","<>","text","\"] \"",")","d","liftHaskeline","(","Haskeline","getInputLine","(","toString","prompt",")",")",">>=","\\","case","Nothing","->","EvalT","empty","Just","answer","|","null","answer","->","k","(","fromMaybe","mempty","d",")","|","otherwise","->","k","(","toText","answer",")","AskChar","s","k","->","do","let","prompt","=","toString","(","renderText","renderMode","s",")","liftHaskeline","(","Haskeline","getInputChar","prompt",")",">>=","\\","case","Nothing","->","EvalT","empty","Just","c","->","k","c","AskPassword","s","m","k","->","do","let","prompt","=","toString","(","renderText","renderMode","s",")","liftHaskeline","(","Haskeline","getPassword","m","prompt",")",">>=","\\","case","Nothing","->","EvalT","empty","Just","str","->","k","(","toText","str",")","PushCompFunc","f","k","->","modifyIORef'","compRef","(","f",":",")",">>","k","PopCompFunc","k","->","modifyIORef'","compRef","(","\\","case","[","]","->","[","]","(","_",":","fs",")","->","fs",")",">>","k","liftHaskeline","::","Haskeline","InputT","m","b","->","EvalT","m","b","liftHaskeline","=","Haskeline","withInterrupt",">>>","lift",">>>","EvalT","-- | Calculate the default rendering mode based on the terminal type."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L194-L235","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"valueLength","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"valueLength = round len - errorLength","function_tokens":["valueLength","=","round","len","-","errorLength"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L414-L414","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"index","parameters":"Add      {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index Add      {} = SIntegralSort","function_tokens":["index","Add","{","}","=","SIntegralSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L76-L76","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"new","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"new = BenchmarkMeta (informationOf ana) (snd newMax) position benchmark{analysis = ana}","function_tokens":["new","=","BenchmarkMeta","(","informationOf","ana",")","(","snd","newMax",")","position","benchmark","{","analysis","=","ana","}"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L261-L261","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"compare","parameters":"(InternedText i _) (InternedText j _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compare (InternedText i _) (InternedText j _) = compare i j","function_tokens":["compare","(","InternedText","i","_",")","(","InternedText","j","_",")","=","compare","i","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L24-L24","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"sinkData","parameters":"h compression","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sinkData h compression = do\n  let sizeSink = CL.fold (\\acc input -> fromIntegral (B.length input) + acc) 0\n      dataSink =\n        getZipSink $\n          ZipSink sizeSink <* ZipSink (CB.sinkHandle h)\n      withCompression sink =\n        getZipSink $\n          (,,) <$> ZipSink sizeSink\n            <*> ZipSink crc32Sink\n            <*> ZipSink sink\n  (uncompressedSize, crc32, compressedSize) <-\n    case compression of\n      Store ->\n        withCompression\n          dataSink\n      Deflate ->\n        withCompression $\n          Z.compress 9 (Z.WindowBits (-15)) .| dataSink\n#ifdef ENABLE_BZIP2\n      BZip2 ->\n        withCompression $\n          BZ.bzip2 .| dataSink\n#else\n      BZip2 -> throwM BZip2Unsupported\n#endif\n#ifdef ENABLE_ZSTD\n      Zstd ->\n        withCompression $\n          Zstandard.compress 1 .| dataSink\n#else\n      Zstd -> throwM ZstdUnsupported\n#endif\n  return\n    DataDescriptor\n      { ddCRC32 = fromIntegral crc32,\n        ddCompressedSize = compressedSize,\n        ddUncompressedSize = uncompressedSize\n      }\n\n{- ORMOLU_ENABLE -}\n\n-- | Append central directory entries and the end of central directory\n-- record to the file that given 'Handle' is associated with. Note that this\n-- automatically writes Zip64 end of central directory record and Zip64 end\n-- of central directory locator when necessary.","function_tokens":["sinkData","h","compression","=","do","let","sizeSink","=","CL","fold","(","\\","acc","input","->","fromIntegral","(","B","length","input",")","+","acc",")","0","dataSink","=","getZipSink","$","ZipSink","sizeSink","<*","ZipSink","(","CB","sinkHandle","h",")","withCompression","sink","=","getZipSink","$","(",",",",",")","<$>","ZipSink","sizeSink","<*>","ZipSink","crc32Sink","<*>","ZipSink","sink","(","uncompressedSize",",","crc32",",","compressedSize",")","<-","case","compression","of","Store","->","withCompression","dataSink","Deflate","->","withCompression","$","Z","compress","9","(","Z","WindowBits","(","-","15",")",")",".|","dataSink","#ifdef ENABLE_BZIP2","BZip2","->","withCompression","$","BZ","bzip2",".|","dataSink","#else\n      BZip2 -> throwM BZip2Unsupported\n","#endif","#ifdef ENABLE_ZSTD","Zstd","->","withCompression","$","Zstandard","compress","1",".|","dataSink","#else\n      Zstd -> throwM ZstdUnsupported\n","#endif","return","DataDescriptor","{","ddCRC32","=","fromIntegral","crc32",",","ddCompressedSize","=","compressedSize",",","ddUncompressedSize","=","uncompressedSize","}","{- ORMOLU_ENABLE -}","-- | Append central directory entries and the end of central directory","-- record to the file that given 'Handle' is associated with. Note that this","-- automatically writes Zip64 end of central directory record and Zip64 end","-- of central directory locator when necessary."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L578-L623","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"prependBuffer","parameters":"(Buffer a) (Buffer b)","argument_list":"","return_statement":"","docstring":"Warning: this function is asymetric","docstring_summary":"Warning: this function is asymetric","docstring_tokens":["Warning",":","this","function","is","asymetric"],"function":"prependBuffer (Buffer a) (Buffer b) = case a of\n  Just a' -> Buffer $ Just (fromMaybe mempty b `append` a')\n  _       -> Buffer a","function_tokens":["prependBuffer","(","Buffer","a",")","(","Buffer","b",")","=","case","a","of","Just","a'","->","Buffer","$","Just","(","fromMaybe","mempty","b","`","append","`","a'",")","_","->","Buffer","a"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L161-L165","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"startLookup","parameters":"sendSignal cancel onSignal","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"startLookup sendSignal cancel onSignal = do\n    inst <- gets inst\n    tree <- liftIO . atomically . readTVar . sTree . state $ inst\n    chan <- gets replyChan\n    id <- gets targetId\n\n    -- Find the three nodes closest to the supplied id\n    case T.findClosest tree id 3 of\n            [] -> cancel\n            closest -> do\n                -- Send a signal to each of the Nodes\n                forM_ closest sendSignal\n\n                -- Add them to the list of known nodes. At this point, it will\n                -- be empty, therfore just overwrite it.\n                modify $ \\s -> s { known = closest }\n\n                -- Start the recursive lookup\n                waitForReply cancel onSignal\n\n-- Wait for the next reply and handle it appropriately","function_tokens":["startLookup","sendSignal","cancel","onSignal","=","do","inst","<-","gets","inst","tree","<-","liftIO",".","atomically",".","readTVar",".","sTree",".","state","$","inst","chan","<-","gets","replyChan","id","<-","gets","targetId","-- Find the three nodes closest to the supplied id","case","T","findClosest","tree","id","3","of","[","]","->","cancel","closest","->","do","-- Send a signal to each of the Nodes","forM_","closest","sendSignal","-- Add them to the list of known nodes. At this point, it will","-- be empty, therfore just overwrite it.","modify","$","\\","s","->","s","{","known","=","closest","}","-- Start the recursive lookup","waitForReply","cancel","onSignal","-- Wait for the next reply and handle it appropriately"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L206-L227","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind","parameters":"_ a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind _ a = let ls = bind (Proxy :: Proxy f) a\n                   rs = bind (Proxy :: Proxy g) a in merge ls rs where\n\n        merge Nothing m = m\n        merge m Nothing = m\n\n        merge m@(Just (True, _)) _ = m\n        merge _ m@(Just (True, _)) = m\n\n        merge m _ = m","function_tokens":["bind","_","a","=","let","ls","=","bind","(","Proxy","::","Proxy","f",")","a","rs","=","bind","(","Proxy","::","Proxy","g",")","a","in","merge","ls","rs","where","merge","Nothing","m","=","m","merge","m","Nothing","=","m","merge","m","@","(","Just","(","True",",","_",")",")","_","=","m","merge","_","m","@","(","Just","(","True",",","_",")",")","=","m","merge","m","_","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L786-L797","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"m Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge m Nothing = m","function_tokens":["merge","m","Nothing","=","m"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L790-L790","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"dataDecls","parameters":"m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dataDecls m = do\n        ldecl <- GHC.hsmodDecls $ GHC.unLoc m\n        GHC.TyClD _ tycld <- pure $ GHC.unLoc ldecl\n        loc <- maybeToList $ GHC.srcSpanToRealSrcSpan $ GHC.getLocA ldecl\n        case tycld of\n            GHC.DataDecl {..} -> pure $ MkDataDecl\n                { dataComments = epAnnComments tcdDExt\n                , dataLoc      = loc\n                , dataDeclName = tcdLName\n                , dataTypeVars = tcdTyVars\n                , dataDefn     = tcdDataDefn\n                , dataFixity   = tcdFixity\n                }\n            _ -> []","function_tokens":["dataDecls","m","=","do","ldecl","<-","GHC","hsmodDecls","$","GHC","unLoc","m","GHC","TyClD","_","tycld","<-","pure","$","GHC","unLoc","ldecl","loc","<-","maybeToList","$","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","ldecl","case","tycld","of","GHC","DataDecl","{","..","}","->","pure","$","MkDataDecl","{","dataComments","=","epAnnComments","tcdDExt",",","dataLoc","=","loc",",","dataDeclName","=","tcdLName",",","dataTypeVars","=","tcdTyVars",",","dataDefn","=","tcdDataDefn",",","dataFixity","=","tcdFixity","}","_","->","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L96-L111","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ishow","parameters":"(Const c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Const c)        = coerce $ show c","function_tokens":["ishow","(","Const","c",")","=","coerce","$","show","c"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L96-L96","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"perimeterPolygon","parameters":"[x1, x2]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"perimeterPolygon [x1, x2]       = distance x1 x2","function_tokens":["perimeterPolygon","[","x1",",","x2","]","=","distance","x1","x2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L59-L59","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"create","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"create = MG.create","function_tokens":["create","=","MG","create"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L384-L384","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"fileOptions","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fileOptions = fmap GHC.unLoc $ GHC.getOptions dynFlags0\n            (GHC.stringToStringBuffer string)\n            (fromMaybe \"-\" fp)","function_tokens":["fileOptions","=","fmap","GHC","unLoc","$","GHC","getOptions","dynFlags0","(","GHC","stringToStringBuffer","string",")","(","fromMaybe","\"-\"","fp",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L71-L73","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"total","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"total = length contexts == length (prune contexts allCons)","function_tokens":["total","=","length","contexts","==","length","(","prune","contexts","allCons",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L427-L427","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"sayLn","parameters":"","argument_list":"","return_statement":"","docstring":"Like 'say', but append a newline character.  @since 1.0.0.0","docstring_summary":"Like 'say', but append a newline character.","docstring_tokens":["Like","say","but","append","a","newline","character","."],"function":"sayLn =\n  toStylizedText\n    >>> Prim.sayLn\n    >>> liftByline","function_tokens":["sayLn","=","toStylizedText",">>>","Prim","sayLn",">>>","liftByline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L87-L90","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2\n            | zero p1 m2        = bin_ p2 m2 (union t1 l2) r2\n            | otherwise         = bin_ p2 m2 l2 (union t1 r2)","function_tokens":["union2","|","nomatch","p1","p2","m2","=","join","p1","t1","p2","t2","|","zero","p1","m2","=","bin_","p2","m2","(","union","t1","l2",")","r2","|","otherwise","=","bin_","p2","m2","l2","(","union","t1","r2",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L372-L374","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"isRedundantViewPatterns","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Check if the ViewPatterns language pragma is redundant.","docstring_summary":"------------------------------------------------------------------------------ Check if the ViewPatterns language pragma is redundant.","docstring_tokens":["------------------------------------------------------------------------------","Check","if","the","ViewPatterns","language","pragma","is","redundant","."],"function":"isRedundantViewPatterns = null . queryModule getViewPat\n  where\n    getViewPat :: GHC.Pat GHC.GhcPs -> [()]\n    getViewPat = \\case\n      GHC.ViewPat{} -> [()]\n      _             -> []\n\n\n--------------------------------------------------------------------------------\n-- | Check if the BangPatterns language pragma is redundant.","function_tokens":["isRedundantViewPatterns","=","null",".","queryModule","getViewPat","where","getViewPat","::","GHC","Pat","GHC","GhcPs","->","[","(",")","]","getViewPat","=","\\","case","GHC","ViewPat","{","}","->","[","(",")","]","_","->","[","]","--------------------------------------------------------------------------------","-- | Check if the BangPatterns language pragma is redundant."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L179-L189","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(CopyEntry _ _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (CopyEntry _ _ s) = Just s","function_tokens":["targetEntry","(","CopyEntry","_","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1054-L1054","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"forM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forM = MG.forM","function_tokens":["forM","=","MG","forM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L251-L251","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"c@Const {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' c@Const {} = Just (True, return . inject $ c)","function_tokens":["bind'","c","@","Const","{","}","=","Just","(","True",",","return",".","inject","$","c",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L807-L807","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"eitherMaybe","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eitherMaybe e = case e of\n    Left _ -> Nothing\n    Right x -> Just x\n\n-- | Determines whether a given webhook event matches a given raw\n-- representation of one. The result is 'Nothing' if there is no match. This\n-- function accounts for the 'WebhookWildcardEvent' matching everything, so it\n-- returns the result of parsing the raw representation when trying to match\n-- against the wildcard.","function_tokens":["eitherMaybe","e","=","case","e","of","Left","_","->","Nothing","Right","x","->","Just","x","-- | Determines whether a given webhook event matches a given raw","-- representation of one. The result is 'Nothing' if there is no match. This","-- function accounts for the 'WebhookWildcardEvent' matching everything, so it","-- returns the result of parsing the raw representation when trying to match","-- against the wildcard."],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L485-L494","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"insert","parameters":"x t","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nInsert\n------------------------------------------------------------------} \/O(min(n,W))\/. Add a value to the set. When the value is already an element of the set, it is replaced by the new one, ie. 'insert' is left-biased.","docstring_summary":"{--------------------------------------------------------------------\nInsert\n------------------------------------------------------------------} \/O(min(n,W))\/. Add a value to the set. When the value is already an element of the set, it is replaced by the new one, ie. 'insert' is left-biased.","docstring_tokens":["{","--------------------------------------------------------------------","Insert","------------------------------------------------------------------","}","\/","O","(","min","(","n","W","))","\/",".","Add","a","value","to","the","set",".","When","the","value","is","already","an","element","of","the","set","it","is","replaced","by","the","new","one","ie",".","insert","is","left","-","biased","."],"function":"insert x t\n  = case t of\n      Bin _ _ p m l r\n        | nomatch x p m -> join x (tip x) p t\n        | zero x m      -> bin_ p m (insert x l) r\n        | otherwise     -> bin_ p m l (insert x r)\n      Tip _ y\n        | x==y          -> tip x\n        | otherwise     -> join x (tip x) y t\n      Nil -> tip x\n\n-- right-biased insertion, used by 'union'","function_tokens":["insert","x","t","=","case","t","of","Bin","_","_","p","m","l","r","|","nomatch","x","p","m","->","join","x","(","tip","x",")","p","t","|","zero","x","m","->","bin_","p","m","(","insert","x","l",")","r","|","otherwise","->","bin_","p","m","l","(","insert","x","r",")","Tip","_","y","|","x","==","y","->","tip","x","|","otherwise","->","join","x","(","tip","x",")","y","t","Nil","->","tip","x","-- right-biased insertion, used by 'union'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L313-L325","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"getBufferData","parameters":"buffer","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getBufferData buffer = do\n   channels <- getBufferi buffer Channels\n   bits <- getBufferi buffer Bits\n   raw <- return nullPtr -- ToDo: AL_DATA query missing!!!\n   size <- getBufferi buffer Size\n   frequency <- getBufferi buffer Frequency\n   return $ BufferData (MemoryRegion  raw size) (makeFormat channels bits) frequency","function_tokens":["getBufferData","buffer","=","do","channels","<-","getBufferi","buffer","Channels","bits","<-","getBufferi","buffer","Bits","raw","<-","return","nullPtr","-- ToDo: AL_DATA query missing!!!","size","<-","getBufferi","buffer","Size","frequency","<-","getBufferi","buffer","Frequency","return","$","BufferData","(","MemoryRegion","raw","size",")","(","makeFormat","channels","bits",")","frequency"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L125-L133","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"find","parameters":"Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"find Nil                = error \"findMax Nil\"","function_tokens":["find","Nil","=","error","\"findMax Nil\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L657-L657","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"f","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f = S.filter ((\/= Nothing) . I.targetEntry)","function_tokens":["f","=","S","filter","(","(","\/=","Nothing",")",".","I","targetEntry",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L632-L632","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (InL fa) = dual fa","function_tokens":["dual","(","InL","fa",")","=","dual","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L683-L683","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"doWrite","parameters":"m CayleyConfig{..} fp","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doWrite m CayleyConfig{..} fp = do\n      r <- parseRequest (urlBase serverName apiVersion ++ \"\/write\/file\/nquad\")\n             >>= \\r -> return r { port = serverPort }\n      t <- liftIO $\n             try $\n               flip httpLbs m\n                 =<< formDataBody [partFileSource \"NQuadFile\" fp] r\n      return $\n        case t of\n          Right b -> A.decode (responseBody b)\n          Left e  -> Just $\n            A.object [\"error\" A..= T.pack (show (e :: SomeException))]\n\n-- | A valid 'Quad' has its subject, predicate and object not empty.","function_tokens":["doWrite","m","CayleyConfig","{","..","}","fp","=","do","r","<-","parseRequest","(","urlBase","serverName","apiVersion","++","\"\/write\/file\/nquad\"",")",">>=","\\","r","->","return","r","{","port","=","serverPort","}","t","<-","liftIO","$","try","$","flip","httpLbs","m","=<<","formDataBody","[","partFileSource","\"NQuadFile\"","fp","]","r","return","$","case","t","of","Right","b","->","A","decode","(","responseBody","b",")","Left","e","->","Just","$","A","object","[","\"error\"","A",".=","T","pack","(","show","(","e","::","SomeException",")",")","]","-- | A valid 'Quad' has its subject, predicate and object not empty."],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L175-L189","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"isObjectName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isObjectName = liftIO . fmap unmarshalALboolean . alIsSource","function_tokens":["isObjectName","=","liftIO",".","fmap","unmarshalALboolean",".","alIsSource"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L125-L125","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"go","parameters":"!col (x:rest)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go !col (x:rest) = x : go (cyclicInc col) rest","function_tokens":["go","col","(","x",":","rest",")","=","x",":","go","(","cyclicInc","col",")","rest"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L89-L89","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = StateC $ \\ s -> pure (s, a)","function_tokens":["pure","a","=","StateC","$","\\","s","->","pure","(","s",",","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L81-L81","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client\/Internal.hs","language":"haskell","identifier":"apiRequest","parameters":"m u p b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"apiRequest m u p b = do\n  r <- parseRequest u >>= \\c ->\n         return c { method = \"POST\", port = p, requestBody = b }\n  t <- liftIO (try $ httpLbs r m)\n  case t of\n    Right r' -> return (A.decode $ responseBody r')\n    Left  e ->\n      return $\n        Just $ A.object [\"error\" A..= T.pack (show (e :: SomeException))]","function_tokens":["apiRequest","m","u","p","b","=","do","r","<-","parseRequest","u",">>=","\\","c","->","return","c","{","method","=","\"POST\"",",","port","=","p",",","requestBody","=","b","}","t","<-","liftIO","(","try","$","httpLbs","r","m",")","case","t","of","Right","r'","->","return","(","A","decode","$","responseBody","r'",")","Left","e","->","return","$","Just","$","A","object","[","\"error\"","A",".=","T","pack","(","show","(","e","::","SomeException",")",")","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client\/Internal.hs#L19-L29","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client\/Internal.hs","hash_val":6396,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(FileHeader info directives)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (FileHeader info directives) = mempty\n        <> sepBy \"\\n\" (fmap pretty info) <> \"\\n\"\n        <> sepBy \"\\n\" (fmap pretty directives)","function_tokens":["pretty","(","FileHeader","info","directives",")","=","mempty","<>","sepBy","\"\\n\"","(","fmap","pretty","info",")","<>","\"\\n\"","<>","sepBy","\"\\n\"","(","fmap","pretty","directives",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L114-L116","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"imap","parameters":"f mat","argument_list":"","return_statement":"","docstring":"Upper triangular imap, i.e., i <= j","docstring_summary":"Upper triangular imap, i.e., i <= j","docstring_tokens":["Upper","triangular","imap","i",".","e",".","i","<","=","j"],"function":"imap f mat = create $ do\n    mat' <- new (n,n)\n    let loop m !i !j\n            | i >= n = return ()\n            | j >= n = loop m (i+1) (i+1)\n            | otherwise = unsafeWrite m (i,j) (f (i,j) x) >>\n                          loop m i (j+1)\n          where\n            x = unsafeIndex mat (i,j)\n    loop mat' 0 0\n    return mat'\n  where\n    n = rows mat","function_tokens":["imap","f","mat","=","create","$","do","mat'","<-","new","(","n",",","n",")","let","loop","m","i","j","|","i",">=","n","=","return","(",")","|","j",">=","n","=","loop","m","(","i","+","1",")","(","i","+","1",")","|","otherwise","=","unsafeWrite","m","(","i",",","j",")","(","f","(","i",",","j",")","x",")",">>","loop","m","i","(","j","+","1",")","where","x","=","unsafeIndex","mat","(","i",",","j",")","loop","mat'","0","0","return","mat'","where","n","=","rows","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L84-L97","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"fromList","parameters":"xs","argument_list":"","return_statement":"","docstring":"\/O(n*min(n,W))\/. Create a set from a list of integers.","docstring_summary":"\/O(n*min(n,W))\/. Create a set from a list of integers.","docstring_tokens":["\/","O","(","n","*","min","(","n","W","))","\/",".","Create","a","set","from","a","list","of","integers","."],"function":"fromList xs = foldlStrict ins empty xs\n  where\n    ins t x  = insert x t\n\n-- | \/O(n)\/. Build a set from an ascending list of elements.\n-- \/The precondition (input list is ascending) is not checked.\/","function_tokens":["fromList","xs","=","foldlStrict","ins","empty","xs","where","ins","t","x","=","insert","x","t","-- | \/O(n)\/. Build a set from an ascending list of elements.","-- \/The precondition (input list is ascending) is not checked.\/"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L724-L730","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"cols","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cols = MG.cols","function_tokens":["cols","=","MG","cols"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L120-L120","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"ctx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ctx     = if total\n                   then cxt [ classP ''ArrowApply  [cat] ]\n                   else cxt [ classP ''ArrowChoice [cat]\n                            , classP ''ArrowApply  [cat]\n                            , failP\n                            ]","function_tokens":["ctx","=","if","total","then","cxt","[","classP","''","ArrowApply","[","cat","]","]","else","cxt","[","classP","''","ArrowChoice","[","cat","]",",","classP","''","ArrowApply","[","cat","]",",","failP","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L443-L448","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"foldl","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldl = MG.foldl","function_tokens":["foldl","=","MG","foldl"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L226-L226","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"index","parameters":"(IfThenElse s _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index (IfThenElse s _ _ _) = s","function_tokens":["index","(","IfThenElse","s","_","_","_",")","=","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L49-L49","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mel","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mel = foldr (+:+) nil","function_tokens":["mel","=","foldr","(","+:+",")","nil"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L118-L118","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(outFptr, _, _) = DVSM.unsafeToForeignPtr bpvm","function_tokens":["(","outFptr",",","_",",","_",")","=","DVSM","unsafeToForeignPtr","bpvm"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L111-L111","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"computationP","parameters":"","argument_list":"","return_statement":"","docstring":"Parses the `Command` datatype into a Computation","docstring_summary":"Parses the `Command` datatype into a Computation","docstring_tokens":["Parses","the","Command","datatype","into","a","Computation"],"function":"computationP = Computation\n    <$> argument str\n        ( metavar \"COMPUTATION\"\n        <> help \"which computation to perform, e.g. area, perimeter, etc.\" )\n    <*> ( optional $ strOption  -- because it's a maybe filepath\n        ( long \"output\"\n        <> short 'o'\n        <> metavar \"OUTPUT\"\n        <> help \"Where to write output\" ) )","function_tokens":["computationP","=","Computation","<$>","argument","str","(","metavar","\"COMPUTATION\"","<>","help","\"which computation to perform, e.g. area, perimeter, etc.\"",")","<*>","(","optional","$","strOption","-- because it's a maybe filepath","(","long","\"output\"","<>","short","'o'","<>","metavar","\"OUTPUT\"","<>","help","\"Where to write output\"",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L35-L43","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"union","parameters":"(Tip _ x) t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"union (Tip _ x) t = insert x t","function_tokens":["union","(","Tip","_","x",")","t","=","insert","x","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L376-L376","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withLast","parameters":"f [x]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withLast f [x]      = [f x]","function_tokens":["withLast","f","[","x","]","=","[","f","x","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L182-L182","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"v","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"v         = varE (mkName \"v\")","function_tokens":["v","=","varE","(","mkName","\"v\"",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L549-L549","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Setup.hs#L2-L2","hash_key":"bartavelle\/stateWriter:Setup.hs","hash_val":1912,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"hasMergableQualified","parameters":"q0 q1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hasMergableQualified q0 q1                      = q0 == q1","function_tokens":["hasMergableQualified","q0","q1","=","q0","==","q1"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L75-L75","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Writer.hs","language":"haskell","identifier":"tell","parameters":"w","argument_list":"","return_statement":"","docstring":"Write a value to the log.  @ runWriter ('tell' w '>>' m) = 'Data.Bifunctor.first' ('mappend' w) '<$>' runWriter m @  @since 0.1.0.0","docstring_summary":"Write a value to the log.","docstring_tokens":["Write","a","value","to","the","log","."],"function":"tell w = send (Tell w)","function_tokens":["tell","w","=","send","(","Tell","w",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Writer.hs#L46-L46","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Writer.hs","hash_val":30433,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"checkSignal","parameters":"(Signal _ (RETURN_NODES _ nodes))","argument_list":"","return_statement":"","docstring":"Check wether the own id was encountered. If so, return a IDClash error, otherwise, continue the lookup.","docstring_summary":"Check wether the own id was encountered. If so, return a IDClash error, otherwise, continue the lookup.","docstring_tokens":["Check","wether","the","own","id","was","encountered",".","If","so","return","a","IDClash","error","otherwise","continue","the","lookup","."],"function":"checkSignal (Signal _ (RETURN_NODES _ nodes)) = do\n                tId <- gets targetId\n                case find (\\node -> nodeId node == tId) nodes of\n                    Just _ -> return IDClash\n                    _ -> continueLookup nodes sendS continue finish\n\n          -- Continuing always means waiting for the next signal","function_tokens":["checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","do","tId","<-","gets","targetId","case","find","(","\\","node","->","nodeId","node","==","tId",")","nodes","of","Just","_","->","return","IDClash","_","->","continueLookup","nodes","sendS","continue","finish","-- Continuing always means waiting for the next signal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L144-L151","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"den","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"den = poly q x","function_tokens":["den","=","poly","q","x"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L90-L90","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"ffffffff","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ffffffff = 5000","function_tokens":["ffffffff","=","5000"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1208-L1208","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"del","parameters":"k (Track d es)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"del k (Track d es) = Track (k+d) $ delayTList k es","function_tokens":["del","k","(","Track","d","es",")","=","Track","(","k","+","d",")","$","delayTList","k","es"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L109-L109","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"(Modifier a b c d e) (Modifier a' b' c' d' e')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) (Modifier a b c d e) (Modifier a' b' c' d' e') =\n    Modifier (a <> a') (b <> b') (c <> c') (d <> d') (e <> e')","function_tokens":["(","<>",")","(","Modifier","a","b","c","d","e",")","(","Modifier","a'","b'","c'","d'","e'",")","=","Modifier","(","a","<>","a'",")","(","b","<>","b'",")","(","c","<>","c'",")","(","d","<>","d'",")","(","e","<>","e'",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L86-L87","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(a, PrinterState parsedLines _ startedLine) = runReaderT printer cfg `runState` PrinterState [] 0 \"\"","function_tokens":["(","a",",","PrinterState","parsedLines","_","startedLine",")","=","runReaderT","printer","cfg","`","runState","`","PrinterState","[","]","0","\"\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L95-L95","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"parseWith","parameters":"c","argument_list":"","return_statement":"","docstring":"Like `parse` but allows adding initial assumption about sorts of some variables.","docstring_summary":"Like `parse` but allows adding initial assumption about sorts of some variables.","docstring_tokens":["Like","parse","but","allows","adding","initial","assumption","about","sorts","of","some","variables","."],"function":"parseWith c = let a = parser (Proxy :: Proxy f) a in toStaticallySorted <=< A.maybeResult . flip A.feed \"\" . A.parse (evalStateT (runReaderT a c) empty <* A.endOfInput)","function_tokens":["parseWith","c","=","let","a","=","parser","(","Proxy","::","Proxy","f",")","a","in","toStaticallySorted","<=<","A","maybeResult",".","flip","A","feed","\"\"",".","A","parse","(","evalStateT","(","runReaderT","a","c",")","empty","<*","A","endOfInput",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L74-L74","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"store''","parameters":"_ _ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"store'' _ _ _ = fail \"storing to non-array\"","function_tokens":["store''","_","_","_","=","fail","\"storing to non-array\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L110-L110","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"difference1 | nomatch p2 p1 m1  = t1\n                | zero p2 m1        = bin p1 m1 (difference l1 t2) r1\n                | otherwise         = bin p1 m1 l1 (difference r1 t2)","function_tokens":["difference1","|","nomatch","p2","p1","m1","=","t1","|","zero","p2","m1","=","bin","p1","m1","(","difference","l1","t2",")","r1","|","otherwise","=","bin","p1","m1","l1","(","difference","r1","t2",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L393-L395","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"node","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"node = Node peer id","function_tokens":["node","=","Node","peer","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L39-L39","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"conIndices","parameters":"(AppT (ConT _) ty)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"conIndices (AppT (ConT _) ty) = [ty]","function_tokens":["conIndices","(","AppT","(","ConT","_",")","ty",")","=","[","ty","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L400-L400","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtCompactness","parameters":"districts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"districtCompactness districts = concat . intercalate (pure \"\\n\") $ map (pure . show . distC) districts\n    where distC (District _ label _ _ compacticity) = (label, compacticity)\n\n-- | Given a projection and lists of districts, draw a map.","function_tokens":["districtCompactness","districts","=","concat",".","intercalate","(","pure","\"\\n\"",")","$","map","(","pure",".","show",".","distC",")","districts","where","distC","(","District","_","label","_","_","compacticity",")","=","(","label",",","compacticity",")","-- | Given a projection and lists of districts, draw a map."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L36-L40","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseJSON","parameters":"(A.Object v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseJSON (A.Object v) = do\n    vnds <- v A..: \"nodes\"\n    nds  <- mapM parseNode $ V.toList vnds\n    vlks <- v A..: \"links\"\n    lks  <- mapM parseLink $ V.toList vlks\n    return Shape { nodes = nds, links = lks }","function_tokens":["parseJSON","(","A","Object","v",")","=","do","vnds","<-","v","A",".:","\"nodes\"","nds","<-","mapM","parseNode","$","V","toList","vnds","vlks","<-","v","A",".:","\"links\"","lks","<-","mapM","parseLink","$","V","toList","vlks","return","Shape","{","nodes","=","nds",",","links","=","lks","}"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L98-L104","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"prompt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prompt =\n              renderText renderMode $\n                maybe s (\\d' -> s <> text \"[\" <> text d' <> text \"] \") d","function_tokens":["prompt","=","renderText","renderMode","$","maybe","s","(","\\","d'","->","s","<>","text","\"[\"","<>","text","d'","<>","text","\"] \"",")","d"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L203-L205","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"bench\/bench.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain $ mkBench \"Seq\" Seq.singleton\n                  ++ mkBench \"List\" (:[])\n                  ++ mkBench \"Vector Primitive\" VP.singleton\n                  ++ mkBench \"IntSet\" IS.singleton\n                  ++ mkBench \"Set\" S.singleton\n                  ++ mkBench \"DList\" D.singleton\n    where\n        mkBench n = map toBench . actions\n            where\n                toBench (n', a) = bench (n' ++ \" [\" ++ n ++ \"]\") $ nf a benchlen","function_tokens":["main","=","defaultMain","$","mkBench","\"Seq\"","Seq","singleton","++","mkBench","\"List\"","(",":","[","]",")","++","mkBench","\"Vector Primitive\"","VP","singleton","++","mkBench","\"IntSet\"","IS","singleton","++","mkBench","\"Set\"","S","singleton","++","mkBench","\"DList\"","D","singleton","where","mkBench","n","=","map","toBench",".","actions","where","toBench","(","n'",",","a",")","=","bench","(","n'","++","\" [\"","++","n","++","\"]\"",")","$","nf","a","benchlen"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/bench\/bench.hs#L39-L48","hash_key":"bartavelle\/stateWriter:bench\/bench.hs","hash_val":16621,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"printHeight","parameters":"cfg","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"printHeight cfg = 3 - fromEnum (hideBar cfg) - fromEnum (sameLine cfg)","function_tokens":["printHeight","cfg","=","3","-","fromEnum","(","hideBar","cfg",")","-","fromEnum","(","sameLine","cfg",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L250-L250","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"dumpDiff","parameters":"(side, (lineNo, marker), diff)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dumpDiff (side, (lineNo, marker), diff) =\n            do  putStrLn $ concat\n                    [filePath, \":\", show lineNo, \":Diff\", show side, \": \", marker]\n                putStr $ unlines $ map (ppDiff colorEnable) (trimDiff (diffsContext opts) diff)","function_tokens":["dumpDiff","(","side",",","(","lineNo",",","marker",")",",","diff",")","=","do","putStrLn","$","concat","[","filePath",",","\":\"",",","show","lineNo",",","\":Diff\"",",","show","side",",","\": \"",",","marker","]","putStr","$","unlines","$","map","(","ppDiff","colorEnable",")","(","trimDiff","(","diffsContext","opts",")","diff",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L57-L61","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"relChildren","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"relChildren = [relPath <\/> p | p <- children]","function_tokens":["relChildren","=","[","relPath","<\/>","p","|","p","<-","children","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L45-L45","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"compare","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compare = compare `on` information &&& negate . position &&& analysis . benchmark","function_tokens":["compare","=","compare","`","on","`","information","&&&","negate",".","position","&&&","analysis",".","benchmark"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L68-L68","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"revRel","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"revRel = makeRelative path base","function_tokens":["revRel","=","makeRelative","path","base"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L135-L135","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"show","parameters":"(Quad s p o (Just l))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (Quad s p o (Just l)) = T.unpack s\n                               ++ \" -- \"\n                               ++ T.unpack p\n                               ++ \" -> \"\n                               ++ T.unpack o\n                               ++ \" (\"\n                               ++ T.unpack l\n                               ++ \")\"","function_tokens":["show","(","Quad","s","p","o","(","Just","l",")",")","=","T","unpack","s","++","\" -- \"","++","T","unpack","p","++","\" -> \"","++","T","unpack","o","++","\" (\"","++","T","unpack","l","++","\")\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L57-L64","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"named","parameters":"name","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"named name = flip (<?>) (unpack name)","function_tokens":["named","name","=","flip","(","<?>",")","(","unpack","name",")"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L99-L99","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"findMax","parameters":"Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findMax Nil = error \"findMax: empty set has no maximal element\"","function_tokens":["findMax","Nil","=","error","\"findMax: empty set has no maximal element\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L650-L650","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"slice","parameters":"t0 t1","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"slice t0 t1 = (slice' t0 t1)","function_tokens":["slice","t0","t1","=","(","slice'","t0","t1",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L162-L162","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Macro","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Macro                    = (True, True, True, True)","function_tokens":["go","Macro","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L378-L378","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_,r,_,_) = fieldAllowed a","function_tokens":["(","_",",","r",",","_",",","_",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L398-L398","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmp","parameters":"Nil Nil","argument_list":"","return_statement":"","docstring":"disjoint","docstring_summary":"disjoint","docstring_tokens":["disjoint"],"function":"subsetCmp Nil Nil = EQ","function_tokens":["subsetCmp","Nil","Nil","=","EQ"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L476-L476","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"binFp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"binFp = prefixFp <\/> \"bin\"","function_tokens":["binFp","=","prefixFp","<\/>","\"bin\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L97-L97","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"identity","parameters":"(Set i _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identity (Set i _) = i","function_tokens":["identity","(","Set","i","_",")","=","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L46-L46","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(UnitNoteLength _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (UnitNoteLength _)       = \"L\"","function_tokens":["go","(","UnitNoteLength","_",")","=","\"L\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L344-L344","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"lineEndings","parameters":"xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lineEndings xs =\n    foldl1 f (map lineEnding xs)\n    where\n        f Mixed _ = Mixed\n        f x c\n            | x == c = x\n            | otherwise = Mixed","function_tokens":["lineEndings","xs","=","foldl1","f","(","map","lineEnding","xs",")","where","f","Mixed","_","=","Mixed","f","x","c","|","x","==","c","=","x","|","otherwise","=","Mixed"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L104-L112","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"f","parameters":"i ((!prev,!acc), xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f i ((!prev,!acc), xs) | stride == 0 = ((prev, acc-1), xs)\n                               | otherwise = ((current, acc-1), replicate stride (acc+1) ++ xs)\n          where\n            stride = prev - current\n            current = i `div` c","function_tokens":["f","i","(","(","prev",",","acc",")",",","xs",")","|","stride","==","0","=","(","(","prev",",","acc","-","1",")",",","xs",")","|","otherwise","=","(","(","current",",","acc","-","1",")",",","replicate","stride","(","acc","+","1",")","++","xs",")","where","stride","=","prev","-","current","current","=","i","`","div","`","c"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L96-L101","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"parseHeaderMaybe","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseHeaderMaybe = eitherMaybe . parseHeader where\n  eitherMaybe :: Either e a -> Maybe a\n  eitherMaybe e = case e of\n    Left _ -> Nothing\n    Right x -> Just x\n\n-- | Determines whether a given webhook event matches a given raw\n-- representation of one. The result is 'Nothing' if there is no match. This\n-- function accounts for the 'WebhookWildcardEvent' matching everything, so it\n-- returns the result of parsing the raw representation when trying to match\n-- against the wildcard.","function_tokens":["parseHeaderMaybe","=","eitherMaybe",".","parseHeader","where","eitherMaybe","::","Either","e","a","->","Maybe","a","eitherMaybe","e","=","case","e","of","Left","_","->","Nothing","Right","x","->","Just","x","-- | Determines whether a given webhook event matches a given raw","-- representation of one. The result is 'Nothing' if there is no match. This","-- function accounts for the 'WebhookWildcardEvent' matching everything, so it","-- returns the result of parsing the raw representation when trying to match","-- against the wildcard."],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L483-L494","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"markerPrefix","parameters":"","argument_list":"","return_statement":"","docstring":"'>' -> \">>>>>>>\"","docstring_summary":"'>' -> \">>>>>>>\"","docstring_tokens":[">","-",">",">>>>>>>"],"function":"markerPrefix = replicate 7","function_tokens":["markerPrefix","=","replicate","7"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L33-L33","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"forall''","parameters":"[] _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forall'' [] _   = fail \"quantifying zero variables\"","function_tokens":["forall''","[","]","_","=","fail","\"quantifying zero variables\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L577-L577","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sampleOffset","parameters":"","argument_list":"","return_statement":"","docstring":"'sampleOffset' contains the playback position, expressed in samples (the value will loop back to zero for looping sources). For a compressed format, this value will represent an exact offset within the uncompressed data.  When setting 'sampleOffset' on a source which is already playing, the playback will jump to the new offset unless the new offset is out of range, in which case an 'ALInvalidValue' error is set. If the source is not playing, then the offset will be applied on the next 'play' call. A 'stop', 'rewind', or a second 'play' call will reset the offset to the beginning of the buffer.  The position is relative to the beginning of all the queued buffers for the source, and any queued buffers traversed by a set call will be marked as processed.","docstring_summary":"'sampleOffset' contains the playback position, expressed in samples (the value will loop back to zero for looping sources). For a compressed format, this value will represent an exact offset within the uncompressed data.  When setting 'sampleOffset' on a source which is already playing, the playback will jump to the new offset unless the new offset is out of range, in which case an 'ALInvalidValue' error is set. If the source is not playing, then the offset will be applied on the next 'play' call. A 'stop', 'rewind', or a second 'play' call will reset the offset to the beginning of the buffer.  The position is relative to the beginning of all the queued buffers for the source, and any queued buffers traversed by a set call will be marked as processed.","docstring_tokens":["sampleOffset","contains","the","playback","position","expressed","in","samples","(","the","value","will","loop","back","to","zero","for","looping","sources",")",".","For","a","compressed","format","this","value","will","represent","an","exact","offset","within","the","uncompressed","data",".","When","setting","sampleOffset","on","a","source","which","is","already","playing","the","playback","will","jump","to","the","new","offset","unless","the","new","offset","is","out","of","range","in","which","case","an","ALInvalidValue","error","is","set",".","If","the","source","is","not","playing","then","the","offset","will","be","applied","on","the","next","play","call",".","A","stop","rewind","or","a","second","play","call","will","reset","the","offset","to","the","beginning","of","the","buffer",".","The","position","is","relative","to","the","beginning","of","all","the","queued","buffers","for","the","source","and","any","queued","buffers","traversed","by","a","set","call","will","be","marked","as","processed","."],"function":"sampleOffset = makeSourceStateVar dictALint GetSampleOffset","function_tokens":["sampleOffset","=","makeSourceStateVar","dictALint","GetSampleOffset"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L472-L472","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"cos'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cos' = cos (pi * realToFrac t)","function_tokens":["cos'","=","cos","(","pi","*","realToFrac","t",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L133-L133","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"describe","parameters":"(BApp f a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe (BApp f a)   = DApp (identity f) (identity a)","function_tokens":["describe","(","BApp","f","a",")","=","DApp","(","identity","f",")","(","identity","a",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L31-L31","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"show","parameters":"(InvalidEntrySelector path)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show (InvalidEntrySelector path) = \"Cannot build selector from \" ++ show path","function_tokens":["show","(","InvalidEntrySelector","path",")","=","\"Cannot build selector from \"","++","show","path"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L136-L136","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"imap","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap = MG.imap","function_tokens":["imap","=","MG","imap"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L232-L232","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Types.hs","language":"haskell","identifier":"show","parameters":"NotAPolygon","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show NotAPolygon = show $ red (text \"Error: \") <> (text \"Shape not a polygon! Are you sure you're opening a district?\")","function_tokens":["show","NotAPolygon","=","show","$","red","(","text","\"Error: \"",")","<>","(","text","\"Shape not a polygon! Are you sure you're opening a district?\"",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Types.hs#L30-L30","hash_key":"vmchale\/hgis:src\/GIS\/Types.hs","hash_val":29930,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"ageByOneYear'","parameters":"person","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ageByOneYear' person = person{_age = (+1) $ _age person}","function_tokens":["ageByOneYear'","person","=","person","{","_age","=","(","+","1",")","$","_age","person","}"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L39-L39","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ns = sort $ map (\\(DynamicallySorted _ (IFix (Var n _))) -> takeWhile (`elem` ['a'..'z']) n) fs","function_tokens":["ns","=","sort","$","map","(","\\","(","DynamicallySorted","_","(","IFix","(","Var","n","_",")",")",")","->","takeWhile","(","`","elem","`","[","'a'","..","'z'","]",")","n",")","fs"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L707-L707","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"makeSourceStateVar","parameters":"dict name source","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeSourceStateVar dict name source =\n   makeStateVar\n      (makeGetter dict name source)\n      (makeSetter dict name source)","function_tokens":["makeSourceStateVar","dict","name","source","=","makeStateVar","(","makeGetter","dict","name","source",")","(","makeSetter","dict","name","source",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L592-L595","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"exists''","parameters":"vs phi","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exists'' vs phi = case (mapM toStaticallySorted vs :: Maybe [Var v]) of\n            Just vs' -> case toStaticallySorted phi of\n                Just phi' -> return . toDynamicallySorted . exists vs' $ phi'\n                Nothing   -> fail \"quantifying non-boolean expression\"\n            Nothing  -> fail \"ill-sorted quantifier\"","function_tokens":["exists''","vs","phi","=","case","(","mapM","toStaticallySorted","vs","::","Maybe","[","Var","v","]",")","of","Just","vs'","->","case","toStaticallySorted","phi","of","Just","phi'","->","return",".","toDynamicallySorted",".","exists","vs'","$","phi'","Nothing","->","fail","\"quantifying non-boolean expression\"","Nothing","->","fail","\"ill-sorted quantifier\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L602-L608","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = StateC (\\ s -> mfix (runState s . f . snd))","function_tokens":["mfix","f","=","StateC","(","\\","s","->","mfix","(","runState","s",".","f",".","snd",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L109-L109","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"conjuncts'","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"conjuncts' e = (\\(And as) -> as) <$> match e","function_tokens":["conjuncts'","e","=","(","\\","(","And","as",")","->","as",")","<$>","match","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L440-L440","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"fullx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fullx = cdir <\/> x","function_tokens":["fullx","=","cdir","<\/>","x"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L700-L700","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"checkSignal","parameters":"(Signal _ (RETURN_NODES _ nodes))","argument_list":"","return_statement":"","docstring":"Always add the nodes into the loop and continue the lookup","docstring_summary":"Always add the nodes into the loop and continue the lookup","docstring_tokens":["Always","add","the","nodes","into","the","loop","and","continue","the","lookup"],"function":"checkSignal (Signal _ (RETURN_NODES _ nodes)) =\n                continueLookup nodes sendS continue end","function_tokens":["checkSignal","(","Signal","_","(","RETURN_NODES","_","nodes",")",")","=","continueLookup","nodes","sendS","continue","end"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L95-L96","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"nextThingItem","parameters":"(NextItem _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nextThingItem (NextItem _)              = True","function_tokens":["nextThingItem","(","NextItem","_",")","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L131-L131","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Ask              -> RWS.Lazy.asks (<$ ctx)\n    L (Local f m)      -> RWS.Lazy.local f (hdl (m <$ ctx))\n    R (L (Tell w))     -> ctx <$ RWS.Lazy.tell w\n    R (L (Listen m))   -> swapAndLift <$> RWS.Lazy.listen (hdl (m <$ ctx))\n    R (L (Censor f m)) -> RWS.Lazy.censor f (hdl (m <$ ctx))\n    R (R (L Get))      -> RWS.Lazy.gets (<$ ctx)\n    R (R (L (Put s)))  -> ctx <$ RWS.Lazy.put s\n    R (R (R other))    -> RWS.Lazy.RWST $ \\ r s -> unRWSTF <$> thread ((\\ (RWSTF (x, s, w)) -> toRWSTF w <$> RWS.Lazy.runRWST x r s) ~<~ hdl) other (RWSTF (ctx, s, mempty))","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Ask","->","RWS","Lazy","asks","(","<$","ctx",")","L","(","Local","f","m",")","->","RWS","Lazy","local","f","(","hdl","(","m","<$","ctx",")",")","R","(","L","(","Tell","w",")",")","->","ctx","<$","RWS","Lazy","tell","w","R","(","L","(","Listen","m",")",")","->","swapAndLift","<$>","RWS","Lazy","listen","(","hdl","(","m","<$","ctx",")",")","R","(","L","(","Censor","f","m",")",")","->","RWS","Lazy","censor","f","(","hdl","(","m","<$","ctx",")",")","R","(","R","(","L","Get",")",")","->","RWS","Lazy","gets","(","<$","ctx",")","R","(","R","(","L","(","Put","s",")",")",")","->","ctx","<$","RWS","Lazy","put","s","R","(","R","(","R","other",")",")","->","RWS","Lazy","RWST","$","\\","r","s","->","unRWSTF","<$>","thread","(","(","\\","(","RWSTF","(","x",",","s",",","w",")",")","->","toRWSTF","w","<$>","RWS","Lazy","runRWST","x","r","s",")","~<~","hdl",")","other","(","RWSTF","(","ctx",",","s",",","mempty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L271-L280","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"Setup.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain","function_tokens":["main","=","defaultMain"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/Setup.hs#L2-L2","hash_key":"tsani\/servant-github-webhook:Setup.hs","hash_val":37324,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"go","parameters":"(CacheState i m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (CacheState i m) = case HashMap.lookup dt m of\n    Nothing -> let t = identify (wid * i + r) bt in (CacheState (i + 1) (HashMap.insert dt t m), t)\n    Just t -> (CacheState i m, t)\n\n-- given a description, go hunting for an entry in the cache","function_tokens":["go","(","CacheState","i","m",")","=","case","HashMap","lookup","dt","m","of","Nothing","->","let","t","=","identify","(","wid","*","i","+","r",")","bt","in","(","CacheState","(","i","+","1",")","(","HashMap","insert","dt","t","m",")",",","t",")","Just","t","->","(","CacheState","i","m",",","t",")","-- given a description, go hunting for an entry in the cache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L88-L93","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withInit","parameters":"_ [x]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withInit _ [x]      = [x]","function_tokens":["withInit","_","[","x","]","=","[","x","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L189-L189","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"turnSndBackToNel","parameters":"(a, bss)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"turnSndBackToNel (a, bss) = (a, fromList . concat $ bss)","function_tokens":["turnSndBackToNel","(","a",",","bss",")","=","(","a",",","fromList",".","concat","$","bss",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L139-L139","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"indentPrefix","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"indentPrefix = (`replicate` ' ')","function_tokens":["indentPrefix","=","(","`","replicate","`","' '",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L56-L56","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"b","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"b = start","function_tokens":["b","=","start"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L297-L297","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"mkRenderableLabelled","parameters":"title points","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkRenderableLabelled title points = mkRenderablePlots title [ plotDataPoints (concat . (fmap fst) $ points), plotLabels points ]","function_tokens":["mkRenderableLabelled","title","points","=","mkRenderablePlots","title","[","plotDataPoints","(","concat",".","(","fmap","fst",")","$","points",")",",","plotLabels","points","]"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L30-L30","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(major, minor) = quotRem (fromIntegral $ x .&. 0x00ff) 10","function_tokens":["(","major",",","minor",")","=","quotRem","(","fromIntegral","$","x",".&.","0x00ff",")","10"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1094-L1094","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"ifsat","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifsat v =\n          if v >= ffffffff\n            then fromIntegral <$> getWord64le\n            else return v","function_tokens":["ifsat","v","=","if","v",">=","ffffffff","then","fromIntegral","<$>","getWord64le","else","return","v"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L764-L767","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"seedIdentity","parameters":"_","argument_list":"","return_statement":"","docstring":"identity :: t -> Id","docstring_summary":"identity :: t -> Id","docstring_tokens":["identity","::","t","-",">","Id"],"function":"seedIdentity _ = 0","function_tokens":["seedIdentity","_","=","0"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L70-L70","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"overflows","parameters":"ss str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"overflows ss str = (length ss + length str + 1) >= maxWidth","function_tokens":["overflows","ss","str","=","(","length","ss","+","length","str","+","1",")",">=","maxWidth"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L147-L147","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"showsPrec","parameters":"d (InternedText _ b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsPrec d (InternedText _ b) = showsPrec d b","function_tokens":["showsPrec","d","(","InternedText","_","b",")","=","showsPrec","d","b"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L27-L27","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"uniquePrefix","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"uniquePrefix =\n      let matches = matchOnPrefix config cleanInput\n       in if length matches == 1\n            then listToMaybe matches\n            else Nothing","function_tokens":["uniquePrefix","=","let","matches","=","matchOnPrefix","config","cleanInput","in","if","length","matches","==","1","then","listToMaybe","matches","else","Nothing"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L127-L131","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","language":"haskell","identifier":"ptr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptr = F.unsafeForeignPtrToPtr fptr","function_tokens":["ptr","=","F","unsafeForeignPtrToPtr","fptr"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs#L56-L56","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","hash_val":30325,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"say","parameters":"","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"say = Free.liftF . (`Say` ())","function_tokens":["say","=","Free","liftF",".","(","`","Say","`","(",")",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L50-L50","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"num","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"num = poly p x","function_tokens":["num","=","poly","p","x"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L89-L89","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"doesEntryExist","parameters":"s","argument_list":"","return_statement":"","docstring":"Check whether the specified entry exists in the archive. This is a simple shortcut defined as:  > doesEntryExist s = M.member s <$> getEntries","docstring_summary":"Check whether the specified entry exists in the archive. This is a simple shortcut defined as:  > doesEntryExist s = M.member s <$> getEntries","docstring_tokens":["Check","whether","the","specified","entry","exists","in","the","archive",".","This","is","a","simple","shortcut","defined","as",":",">","doesEntryExist","s","=","M",".","member","s","<$",">","getEntries"],"function":"doesEntryExist s = M.member s <$> getEntries","function_tokens":["doesEntryExist","s","=","M","member","s","<$>","getEntries"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L318-L318","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = fromVector (0,0) G.empty","function_tokens":["empty","=","fromVector","(","0",",","0",")","G","empty"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L114-L114","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"bsSize","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bsSize = size * 8","function_tokens":["bsSize","=","size","*","8"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L141-L141","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_ORIENTATION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_ORIENTATION                      = 0x100F","function_tokens":["al_ORIENTATION","=","0x100F"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L70-L70","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"var''","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var'' = do\n            n <- many1 letter\n\n            s <- assumeSort n\n\n            var''' n s","function_tokens":["var''","=","do","n","<-","many1","letter","s","<-","assumeSort","n","var'''","n","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L278-L285","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"zsLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zsLen = BS.length zs","function_tokens":["zsLen","=","BS","length","zs"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L103-L103","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/StrUtils.hs","language":"haskell","identifier":"ensureNewline","parameters":"str","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ensureNewline str = str ++ suffix\n    where\n        suffix\n            | \"\\n\" `isSuffixOf` str = \"\"\n            | otherwise = \"\\n\"","function_tokens":["ensureNewline","str","=","str","++","suffix","where","suffix","|","\"\\n\"","`","isSuffixOf","`","str","=","\"\"","|","otherwise","=","\"\\n\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/StrUtils.hs#L18-L24","hash_key":"Peaker\/git-mediate:src\/StrUtils.hs","hash_val":9940,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"getCaptureFunc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getCaptureFunc = get . alcProcAddress Nothing","function_tokens":["getCaptureFunc","=","get",".","alcProcAddress","Nothing"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L53-L53","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"sourceType","parameters":"","argument_list":"","return_statement":"","docstring":"'sourceType' indicates whether a source is ready to queue buffers, ready to use a static buffer, or is in an undetermined state where it can be used for either streaming or static playback.","docstring_summary":"'sourceType' indicates whether a source is ready to queue buffers, ready to use a static buffer, or is in an undetermined state where it can be used for either streaming or static playback.","docstring_tokens":["sourceType","indicates","whether","a","source","is","ready","to","queue","buffers","ready","to","use","a","static","buffer","or","is","in","an","undetermined","state","where","it","can","be","used","for","either","streaming","or","static","playback","."],"function":"sourceType = makeSourceGettableStateVar dictSourceType GetSourceType","function_tokens":["sourceType","=","makeSourceGettableStateVar","dictSourceType","GetSourceType"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L238-L238","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = mask p1 m","function_tokens":["p","=","mask","p1","m"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L895-L895","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"copyEntries","parameters":"h path m e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"copyEntries h path m e = do\n  entries <- snd <$> scanArchive path\n  done <- forM (M.keys m) $ \\s ->\n    case s `M.lookup` entries of\n      Nothing -> throwM (EntryDoesNotExist path s)\n      Just desc ->\n        sinkEntry\n          h\n          (m ! s)\n          (Borrowed desc)\n          (sourceEntry path desc False)\n          e\n  return (M.fromList done)\n\n-- | Sink an entry from the given stream into the file associated with the\n-- given 'Handle'.","function_tokens":["copyEntries","h","path","m","e","=","do","entries","<-","snd","<$>","scanArchive","path","done","<-","forM","(","M","keys","m",")","$","\\","s","->","case","s","`","M","lookup","`","entries","of","Nothing","->","throwM","(","EntryDoesNotExist","path","s",")","Just","desc","->","sinkEntry","h","(","m","!","s",")","(","Borrowed","desc",")","(","sourceEntry","path","desc","False",")","e","return","(","M","fromList","done",")","-- | Sink an entry from the given stream into the file associated with the","-- given 'Handle'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L463-L479","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Nil `compare` Tip _ _ = LT","function_tokens":["Nil","`","compare","`","Tip","_","_","=","LT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L848-L848","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"delay","parameters":"b v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delay b v = VarT $ \\a -> return (b, go a v)\n    where go a v' = VarT $ \\a' -> do (b', v'') <- runVarT v' a\n                                     return (b', go a' v'')\n--------------------------------------------------------------------------------\n-- $running\n-- To sample a var simply run it in the desired monad with\n-- 'runVarT'. This will produce a sample value and a new var.\n--\n-- >>> :{\n-- do let v0 = accumulate (+) 0\n--    (b, v1) <- runVarT v0 1\n--    print b\n--    (c, v2) <- runVarT v1 b\n--    print c\n--    (d,  _) <- runVarT v2 c\n--    print d\n-- >>> :}\n-- 1\n-- 2\n-- 4\n--------------------------------------------------------------------------------\n-- | Iterate a var over a list of input until all input is consumed,\n-- then iterate the var using one single input. Returns the resulting\n-- output value and the new var.\n--\n-- >>> let Identity (outputs, _) = stepMany (accumulate (+) 0) [1,1,1] 1\n-- >>> print outputs\n-- 4","function_tokens":["delay","b","v","=","VarT","$","\\","a","->","return","(","b",",","go","a","v",")","where","go","a","v'","=","VarT","$","\\","a'","->","do","(","b'",",","v''",")","<-","runVarT","v'","a","return","(","b'",",","go","a'","v''",")","--------------------------------------------------------------------------------","-- $running","-- To sample a var simply run it in the desired monad with","-- 'runVarT'. This will produce a sample value and a new var.","--","-- >>> :{","-- do let v0 = accumulate (+) 0","--    (b, v1) <- runVarT v0 1","--    print b","--    (c, v2) <- runVarT v1 b","--    print c","--    (d,  _) <- runVarT v2 c","--    print d","-- >>> :}","-- 1","-- 2","-- 4","--------------------------------------------------------------------------------","-- | Iterate a var over a list of input until all input is consumed,","-- then iterate the var using one single input. Returns the resulting","-- output value and the new var.","--","-- >>> let Identity (outputs, _) = stepMany (accumulate (+) 0) [1,1,1] 1","-- >>> print outputs","-- 4"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L357-L385","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","language":"haskell","identifier":"newWorkState","parameters":"initialValue","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newWorkState initialValue = do\n  fptr <- F.mallocForeignPtrBytes 256\n  let ptr = F.unsafeForeignPtrToPtr fptr\n  let ws = WorkState\n        { workStateState      = ptr `F.plusPtr`  0\n        , workStateRemBits    = ptr `F.plusPtr`  8\n        , workStateRemBitsLen = ptr `F.plusPtr`  16\n        , workStateFptr       = fptr\n        }\n  F.poke (workStateState      ws) (fromIntegral initialValue)\n  F.poke (workStateRemBits    ws) 0\n  F.poke (workStateRemBitsLen ws) 0\n  return ws","function_tokens":["newWorkState","initialValue","=","do","fptr","<-","F","mallocForeignPtrBytes","256","let","ptr","=","F","unsafeForeignPtrToPtr","fptr","let","ws","=","WorkState","{","workStateState","=","ptr","`","F","plusPtr","`","0",",","workStateRemBits","=","ptr","`","F","plusPtr","`","8",",","workStateRemBitsLen","=","ptr","`","F","plusPtr","`","16",",","workStateFptr","=","fptr","}","F","poke","(","workStateState","ws",")","(","fromIntegral","initialValue",")","F","poke","(","workStateRemBits","ws",")","0","F","poke","(","workStateRemBitsLen","ws",")","0","return","ws"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs#L42-L54","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Standard.hs","hash_val":16990,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Mono.hs","language":"haskell","identifier":"point","parameters":"","argument_list":"","return_statement":"","docstring":"Create lens from a `Point`.","docstring_summary":"Create lens from a `Point`.","docstring_tokens":["Create","lens","from","a","Point","."],"function":"point = Poly.point","function_tokens":["point","=","Poly","point"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Mono.hs#L73-L73","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Mono.hs","hash_val":24943,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"erfc8","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"erfc8 x = erfc8_sum x * exp (negate x * x)","function_tokens":["erfc8","x","=","erfc8_sum","x","*","exp","(","negate","x","*","x",")"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L67-L67","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"imap","parameters":"f (Not n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Not n)  = Not $ f n","function_tokens":["imap","f","(","Not","n",")","=","Not","$","f","n"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L360-L360","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_OUT_OF_MEMORY","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_OUT_OF_MEMORY                   = 0xA005","function_tokens":["alc_OUT_OF_MEMORY","=","0xA005"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L146-L146","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Mono.hs","language":"haskell","identifier":"iso","parameters":"(Iso f b)","argument_list":"","return_statement":"","docstring":"Lift an isomorphism into a `Lens`.","docstring_summary":"Lift an isomorphism into a `Lens`.","docstring_tokens":["Lift","an","isomorphism","into","a","Lens","."],"function":"iso (Iso f b) = lens f (app . arr (\\(m, v) -> (b . m . f, v)))","function_tokens":["iso","(","Iso","f","b",")","=","lens","f","(","app",".","arr","(","\\","(","m",",","v",")","->","(","b",".","m",".","f",",","v",")",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Mono.hs#L78-L78","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Mono.hs","hash_val":24943,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"dim","parameters":"(SymMatrix n _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim (SymMatrix n _) = (n,n)","function_tokens":["dim","(","SymMatrix","n","_",")","=","(","n",",","n",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L51-L51","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"squashFieldDecl","parameters":"(GHC.ConDeclField ext names@(_ : _) type' _)","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"squashFieldDecl (GHC.ConDeclField ext names@(_ : _) type' _)\n    | Just left <- GHC.srcSpanToRealSrcSpan . GHC.getLoc $ last names\n    , Just sep <- fieldDeclSeparator ext\n    , Just right <- GHC.srcSpanToRealSrcSpan $ GHC.getLocA type' =\n        squash left sep <> squash sep right","function_tokens":["squashFieldDecl","(","GHC","ConDeclField","ext","names","@","(","_",":","_",")","type'","_",")","|","Just","left","<-","GHC","srcSpanToRealSrcSpan",".","GHC","getLoc","$","last","names",",","Just","sep","<-","fieldDeclSeparator","ext",",","Just","right","<-","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","type'","=","squash","left","sep","<>","squash","sep","right"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L39-L43","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DSet n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DSet n)     = s `hashWithSalt` (3 :: Int) `hashWithSalt` n","function_tokens":["hashWithSalt","s","(","DSet","n",")","=","s","`","hashWithSalt","`","(","3","::","Int",")","`","hashWithSalt","`","n"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L69-L69","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"hasMergableQualified","parameters":"QualifiedPost QualifiedPre","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hasMergableQualified QualifiedPost QualifiedPre = True","function_tokens":["hasMergableQualified","QualifiedPost","QualifiedPre","=","True"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L74-L74","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"unzip4","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip4 = MG.unzip4","function_tokens":["unzip4","=","MG","unzip4"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L354-L354","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"fromVector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromVector = MG.fromVector","function_tokens":["fromVector","=","MG","fromVector"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L141-L141","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWith3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith3 = MG.zipWith3","function_tokens":["zipWith3","=","MG","zipWith3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L263-L263","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_FORMAT_MONO8","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_FORMAT_MONO8                     = 0x1100","function_tokens":["al_FORMAT_MONO8","=","0x1100"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L119-L119","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"alg","parameters":"hdl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl = \\case\n    L eff -> Labelled . alg (runLabelled . hdl) (L (runLabelled eff))\n    R sig -> Labelled . alg (runLabelled . hdl) (R sig)","function_tokens":["alg","hdl","=","\\","case","L","eff","->","Labelled",".","alg","(","runLabelled",".","hdl",")","(","L","(","runLabelled","eff",")",")","R","sig","->","Labelled",".","alg","(","runLabelled",".","hdl",")","(","R","sig",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L68-L71","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"stride","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stride = i - i'","function_tokens":["stride","=","i","-","i'"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L149-L149","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"year","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"year = fromIntegral year' - 1980","function_tokens":["year","=","fromIntegral","year'","-","1980"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1180-L1180","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"next","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"next = head . sortByDistanceTo newKnown $ id","function_tokens":["next","=","head",".","sortByDistanceTo","newKnown","$","id"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L296-L296","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"onelineEnum","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"onelineEnum =\n            isEnum decl && not cBreakEnums &&\n            all (not . commentGroupHasComments) constructorComments","function_tokens":["onelineEnum","=","isEnum","decl","&&","not","cBreakEnums","&&","all","(","not",".","commentGroupHasComments",")","constructorComments"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L145-L147","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = StateC (const empty)","function_tokens":["empty","=","StateC","(","const","empty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L100-L100","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_FREQUENCY","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"al_FREQUENCY                        = 0x2001","function_tokens":["al_FREQUENCY","=","0x2001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L112-L112","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"areas","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"areas = map (fmap areaPolygon . getPolygon . fromJust . shpRecContents) . shpRecs $ file","function_tokens":["areas","=","map","(","fmap","areaPolygon",".","getPolygon",".","fromJust",".","shpRecContents",")",".","shpRecs","$","file"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L72-L72","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"sendRequests","parameters":"tree key val","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sendRequests tree key val = do\n            let closest = T.findClosest tree key 7\n            forM_ closest $ \\node -> send h (peer node) (STORE key val)","function_tokens":["sendRequests","tree","key","val","=","do","let","closest","=","T","findClosest","tree","key","7","forM_","closest","$","\\","node","->","send","h","(","peer","node",")","(","STORE","key","val",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L237-L241","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Extensions.hs","language":"haskell","identifier":"alEnumValue","parameters":"enumName","argument_list":"","return_statement":"","docstring":"To obtain enumeration values for extensions, the application has to use 'alEnumValue' of an extension token. Enumeration values are defined within the OpenAL name space and allocated according to specification of the core API and the extensions, thus they are context-independent.  'alEnumValue' contains 0 if the enumeration can not be found. The presence of an enum value does not guarantee the applicability of an extension to the current context. A non-zero value indicates merely that the implementation is aware of the existence of this extension. Implementations should not attempt to use 0 to indicate that the extensions is not supported for the current context.","docstring_summary":"To obtain enumeration values for extensions, the application has to use 'alEnumValue' of an extension token. Enumeration values are defined within the OpenAL name space and allocated according to specification of the core API and the extensions, thus they are context-independent.  'alEnumValue' contains 0 if the enumeration can not be found. The presence of an enum value does not guarantee the applicability of an extension to the current context. A non-zero value indicates merely that the implementation is aware of the existence of this extension. Implementations should not attempt to use 0 to indicate that the extensions is not supported for the current context.","docstring_tokens":["To","obtain","enumeration","values","for","extensions","the","application","has","to","use","alEnumValue","of","an","extension","token",".","Enumeration","values","are","defined","within","the","OpenAL","name","space","and","allocated","according","to","specification","of","the","core","API","and","the","extensions","thus","they","are","context","-","independent",".","alEnumValue","contains","0","if","the","enumeration","can","not","be","found",".","The","presence","of","an","enum","value","does","not","guarantee","the","applicability","of","an","extension","to","the","current","context",".","A","non","-","zero","value","indicates","merely","that","the","implementation","is","aware","of","the","existence","of","this","extension",".","Implementations","should","not","attempt","to","use","0","to","indicate","that","the","extensions","is","not","supported","for","the","current","context","."],"function":"alEnumValue enumName = makeGettableStateVar $\n   withALString enumName alGetEnumValue","function_tokens":["alEnumValue","enumName","=","makeGettableStateVar","$","withALString","enumName","alGetEnumValue"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Extensions.hs#L106-L107","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Extensions.hs","hash_val":40318,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"tod","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tod = timeToTimeOfDay utctDayTime","function_tokens":["tod","=","timeToTimeOfDay","utctDayTime"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1179-L1179","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"ident","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create an identity matrix","docstring_summary":"O(m*n) Create an identity matrix","docstring_tokens":["O","(","m","*","n",")","Create","an","identity","matrix"],"function":"ident = MG.ident","function_tokens":["ident","=","MG","ident"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L197-L197","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/SideDiff.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Sides markerA _ markerB = cMarkers","function_tokens":["Sides","markerA","_","markerB","=","cMarkers"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/SideDiff.hs#L32-L32","hash_key":"Peaker\/git-mediate:src\/SideDiff.hs","hash_val":4146,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putInt32","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putInt32 = putWord32le . fromIntegral","function_tokens":["putInt32","=","putWord32le",".","fromIntegral"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L125-L125","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"show","parameters":"NormalExitBehavior","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show NormalExitBehavior        = \"normal\"","function_tokens":["show","NormalExitBehavior","=","\"normal\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L79-L79","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"t","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t = (2 * ax - 15) \/ 5","function_tokens":["t","=","(","2","*","ax","-","15",")","\/","5"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L62-L62","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"foldl","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldl = MG.foldl","function_tokens":["foldl","=","MG","foldl"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L226-L226","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_STOPPED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_STOPPED                          = 0x1014","function_tokens":["al_STOPPED","=","0x1014"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L107-L107","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"showError","parameters":"err","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showError err = B.char7 '(' <> foldMap B.intDec (take 2 $ err ++ repeat 0) <> B.char7 ')'","function_tokens":["showError","err","=","B","char7","'('","<>","foldMap","B","intDec","(","take","2","$","err","++","repeat","0",")","<>","B","char7","')'"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L354-L354","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkLabelsWithForDec","parameters":"mk sigs concrete failing inl dec","argument_list":"","return_statement":"","docstring":"All used type variables. -----------------------------------------------------------------------------","docstring_summary":"All used type variables. -----------------------------------------------------------------------------","docstring_tokens":["All","used","type","variables",".","-----------------------------------------------------------------------------"],"function":"mkLabelsWithForDec mk sigs concrete failing inl dec =\n  do labels <- generateLabels mk concrete failing dec\n     decls  <- forM labels $ \\l ->\n       case l of\n         LabelExpr {} -> return []\n         LabelDecl n i v c t b ->\n           do bdy <- pure <$> funD n [clause [] (normalB b) []]\n              prg <- if inl then pure <$> i else return []\n              typ <- if sigs\n                       then pure <$> sigD n (forallT v c t)\n                       else return []\n              return (concat [prg, typ, bdy])\n     return (concat decls)\n\n-- Generate the labels for all the record fields in the data type.","function_tokens":["mkLabelsWithForDec","mk","sigs","concrete","failing","inl","dec","=","do","labels","<-","generateLabels","mk","concrete","failing","dec","decls","<-","forM","labels","$","\\","l","->","case","l","of","LabelExpr","{","}","->","return","[","]","LabelDecl","n","i","v","c","t","b","->","do","bdy","<-","pure","<$>","funD","n","[","clause","[","]","(","normalB","b",")","[","]","]","prg","<-","if","inl","then","pure","<$>","i","else","return","[","]","typ","<-","if","sigs","then","pure","<$>","sigD","n","(","forallT","v","c","t",")","else","return","[","]","return","(","concat","[","prg",",","typ",",","bdy","]",")","return","(","concat","decls",")","-- Generate the labels for all the record fields in the data type."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L275-L291","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"var'''","parameters":"n (DynamicSort (s :: Sing s))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var''' n (DynamicSort (s :: Sing s)) = return $ dynvar n s","function_tokens":["var'''","n","(","DynamicSort","(","s","::","Sing","s",")",")","=","return","$","dynvar","n","s"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L286-L286","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"replicate","parameters":"(r,c) x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"replicate (r,c) x = MMatrix r c c 0 `liftM` GM.replicate (r*c) x","function_tokens":["replicate","(","r",",","c",")","x","=","MMatrix","r","c","c","0","`","liftM","`","GM","replicate","(","r","*","c",")","x"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L45-L45","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"aligns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"aligns =\n        [ (\"always\",   SimpleAlign.Always)\n        , (\"adjacent\", SimpleAlign.Adjacent)\n        , (\"never\",    SimpleAlign.Never)\n        ]","function_tokens":["aligns","=","[","(","\"always\"",",","SimpleAlign","Always",")",",","(","\"adjacent\"",",","SimpleAlign","Adjacent",")",",","(","\"never\"",",","SimpleAlign","Never",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L235-L239","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withTail","parameters":"f (x : xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withTail f (x : xs) = x : map f xs","function_tokens":["withTail","f","(","x",":","xs",")","=","x",":","map","f","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L196-L196","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"mediateAll","parameters":"colorEnable opts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mediateAll colorEnable opts =\n  do  filesMatchingPrefixes <- makeFilesMatchingPrefixes\n\n-- from git-diff manpage:\n-- Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R),\n-- have their type (i.e. regular file, symlink, submodule, ...) changed (T),\n-- are Unmerged (U), are Unknown (X), or have had their pairing Broken (B)\n\n      deleteModifyConflicts <- filesMatchingPrefixes [\"DU \", \"UD \"]\n\n      traverse_ deleteModifyConflictHandle deleteModifyConflicts\n\n      result <- filesMatchingPrefixes [\"UU \", \"AA \", \"DA \", \"AD \", \"DU \", \"UD \"]\n          >>= foldMap (resolve colorEnable opts)\n\n      -- Heuristically delete files that were remove\/modify conflict\n      -- and ended up with empty content\n      traverse_ removeFileIfEmpty deleteModifyConflicts\n      pure result","function_tokens":["mediateAll","colorEnable","opts","=","do","filesMatchingPrefixes","<-","makeFilesMatchingPrefixes","-- from git-diff manpage:","-- Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R),","-- have their type (i.e. regular file, symlink, submodule, ...) changed (T),","-- are Unmerged (U), are Unknown (X), or have had their pairing Broken (B)","deleteModifyConflicts","<-","filesMatchingPrefixes","[","\"DU \"",",","\"UD \"","]","traverse_","deleteModifyConflictHandle","deleteModifyConflicts","result","<-","filesMatchingPrefixes","[","\"UU \"",",","\"AA \"",",","\"DA \"",",","\"AD \"",",","\"DU \"",",","\"UD \"","]",">>=","foldMap","(","resolve","colorEnable","opts",")","-- Heuristically delete files that were remove\/modify conflict","-- and ended up with empty content","traverse_","removeFileIfEmpty","deleteModifyConflicts","pure","result"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L234-L254","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"step","parameters":"(Benchmark n a f)","argument_list":"","return_statement":"","docstring":"Run the benchmark once and update its analysis.  For functions with very low runtimes multiple runs will be executed.","docstring_summary":"Run the benchmark once and update its analysis.  For functions with very low runtimes multiple runs will be executed.","docstring_tokens":["Run","the","benchmark","once","and","update","its","analysis",".","For","functions","with","very","low","runtimes","multiple","runs","will","be","executed","."],"function":"step (Benchmark n a f) = flip (Benchmark n) f <$> f a","function_tokens":["step","(","Benchmark","n","a","f",")","=","flip","(","Benchmark","n",")","f","<$>","f","a"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L203-L203","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Lens pointing to the right value in an Either. (Partial and polymorphic)","docstring_summary":"Lens pointing to the right value in an Either. (Partial and polymorphic)","docstring_tokens":["Lens","pointing","to","the","right","value","in","an","Either",".","(","Partial","and","polymorphic",")"],"function":"(left, right) = $(getLabel ''Either)","function_tokens":["(","left",",","right",")","=","(","getLabel","''","Either",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L72-L72","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"node","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"node = fromJust . find (\\n -> nodeId n == id) $ polled","function_tokens":["node","=","fromJust",".","find","(","\\","n","->","nodeId","n","==","id",")","$","polled"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L258-L258","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookCreateEvent","function_tokens":["reflect","_","=","WebhookCreateEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L415-L415","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"takeNext","parameters":"((ib, i) : items) ((cb, c) : comments)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeNext ((ib, i) : items) ((cb, c) : comments)\n    | blockStart ib == blockStart cb =\n        Just","function_tokens":["takeNext","(","(","ib",",","i",")",":","items",")","(","(","cb",",","c",")",":","comments",")","|","blockStart","ib","==","blockStart","cb","=","Just"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L104-L106","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getRecContents","parameters":"t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getRecContents t = case t of\n\n        ShpPoint -> do\n          p <- getPoint\n          return $ RecPoint p\n\n        ShpPointM -> do\n          p <- getPoint\n          m <- getFloat64le\n          return $ RecPointM { pmPoint = p, pmM = m }\n\n        ShpPointZ -> do\n          p <- getPoint\n          z <- getFloat64le\n          m <- getFloat64le\n          return $ RecPointZ { pzPoint = p, pzZ = z, pzM = m }\n\n        ShpMultiPoint -> do\n          (bb, nPoints, points) <- getPointsData\n          return RecMultiPoint { recMPBBox      = bb,\n                            recMPNumPoints = nPoints,\n                            recMPPoints    = points }\n\n        ShpMultiPointM -> do\n          (bb, nPoints, points) <- getPointsData\n          (mMin, mMax, ms)      <- getMData nPoints\n          return RecMultiPointM { recMPMBBox      = bb,\n                             recMPMNumPoints = nPoints,\n                             recMPMPoints    = points,\n                             recMPMMRange    = (mMin, mMax),\n                             recMPMMs        = ms}\n\n        ShpMultiPointZ -> do\n          (bb, nPoints, points) <- getPointsData\n          (zMin, zMax, zs)      <- getZData nPoints\n          (mMin, mMax, ms)      <- getMData nPoints\n          return RecMultiPointZ { recMPZBBox      = bb,\n                             recMPZNumPoints = nPoints,\n                             recMPZPoints    = points,\n                             recMPZZRange    = (zMin, zMax),\n                             recMPZZs        = zs,\n                             recMPZMRange    = (mMin, mMax),\n                             recMPZMs        = ms }\n\n        ShpPolyLine -> do\n          (bb, nParts, nPoints, partLengths, pntLists) <- getPolyData\n          return RecPolyLine { recPolLBBox        = bb,\n                          recPolLNumParts    = nParts,\n                          recPolLNumPoints   = nPoints,\n                          recPolLPartLengths = partLengths,\n                          recPolLPoints      = pntLists }\n\n        ShpPolyLineM -> do\n          (bb, nParts, nPoints, partLengths, pntLists) <- getPolyData\n          (mMin, mMax, ms)                             <- getMData nPoints\n          return RecPolyLineM { recPolLMBBox        = bb,\n                           recPolLMNumParts    = nParts,\n                           recPolLMNumPoints   = nPoints,\n                           recPolLMPartLengths = partLengths,\n                           recPolLMPoints      = pntLists,\n                           recPolLMMRange      = (mMin, mMax),\n                           recPolLMMs          = ms }\n\n        ShpPolyLineZ -> do\n          (bb, nParts, nPoints, partLengths, pntLists) <- getPolyData\n          (zMin, zMax, zs)                             <- getZData nPoints\n          (mMin, mMax, ms)                             <- getMData nPoints\n          return RecPolyLineZ { recPolLZBBox        = bb,\n                           recPolLZNumParts    = nParts,\n                           recPolLZNumPoints   = nPoints,\n                           recPolLZPartLengths = partLengths,\n                           recPolLZPoints      = pntLists,\n                           recPolLZZRange      = (zMin, zMax),\n                           recPolLZZs          = zs,\n                           recPolLZMRange      = (mMin, mMax),\n                           recPolLZMs          = ms }\n\n        ShpPolygon -> do\n          (bb, nParts, nPoints, partLengths, pntLists) <- getPolyData\n          return RecPolygon { recPolBBox        = bb,\n                         recPolNumParts    = nParts,\n                         recPolNumPoints   = nPoints,\n                         recPolPartLengths = partLengths,\n                         recPolPoints      = pntLists }\n\n        ShpPolygonM -> do\n          (bb, nParts, nPoints, partLengths, pntLists) <- getPolyData\n          (mMin, mMax, ms)                             <- getMData nPoints\n          return RecPolygonM { recPolMBBox        = bb,\n                          recPolMNumParts    = nParts,\n                          recPolMNumPoints   = nPoints,\n                          recPolMPartLengths = partLengths,\n                          recPolMPoints      = pntLists,\n                          recPolMMRange      = (mMin, mMax),\n                          recPolMMs          = ms }\n\n        ShpPolygonZ -> do\n          (bb, nParts, nPoints, partLengths, pntLists) <- getPolyData\n          (zMin, zMax, zs)                             <- getZData nPoints\n          (mMin, mMax, ms)                             <- getMData nPoints\n          return RecPolygonZ { recPolZBBox        = bb,\n                          recPolZNumParts    = nParts,\n                          recPolZNumPoints   = nPoints,\n                          recPolZPartLengths = partLengths,\n                          recPolZPoints      = pntLists,\n                          recPolZZRange      = (zMin, zMax),\n                          recPolZZs          = zs,\n                          recPolZMRange      = (mMin, mMax),\n                          recPolZMs          = ms }\n\n        ShpNull ->\n          return RecNull\n\n        ShpMultiPatch ->\n          error \"getShpRec: MultiPatch type is not supported, sorry!\"\n\n-- | Recurring pattern of bounding box with a number of points","function_tokens":["getRecContents","t","=","case","t","of","ShpPoint","->","do","p","<-","getPoint","return","$","RecPoint","p","ShpPointM","->","do","p","<-","getPoint","m","<-","getFloat64le","return","$","RecPointM","{","pmPoint","=","p",",","pmM","=","m","}","ShpPointZ","->","do","p","<-","getPoint","z","<-","getFloat64le","m","<-","getFloat64le","return","$","RecPointZ","{","pzPoint","=","p",",","pzZ","=","z",",","pzM","=","m","}","ShpMultiPoint","->","do","(","bb",",","nPoints",",","points",")","<-","getPointsData","return","RecMultiPoint","{","recMPBBox","=","bb",",","recMPNumPoints","=","nPoints",",","recMPPoints","=","points","}","ShpMultiPointM","->","do","(","bb",",","nPoints",",","points",")","<-","getPointsData","(","mMin",",","mMax",",","ms",")","<-","getMData","nPoints","return","RecMultiPointM","{","recMPMBBox","=","bb",",","recMPMNumPoints","=","nPoints",",","recMPMPoints","=","points",",","recMPMMRange","=","(","mMin",",","mMax",")",",","recMPMMs","=","ms","}","ShpMultiPointZ","->","do","(","bb",",","nPoints",",","points",")","<-","getPointsData","(","zMin",",","zMax",",","zs",")","<-","getZData","nPoints","(","mMin",",","mMax",",","ms",")","<-","getMData","nPoints","return","RecMultiPointZ","{","recMPZBBox","=","bb",",","recMPZNumPoints","=","nPoints",",","recMPZPoints","=","points",",","recMPZZRange","=","(","zMin",",","zMax",")",",","recMPZZs","=","zs",",","recMPZMRange","=","(","mMin",",","mMax",")",",","recMPZMs","=","ms","}","ShpPolyLine","->","do","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","<-","getPolyData","return","RecPolyLine","{","recPolLBBox","=","bb",",","recPolLNumParts","=","nParts",",","recPolLNumPoints","=","nPoints",",","recPolLPartLengths","=","partLengths",",","recPolLPoints","=","pntLists","}","ShpPolyLineM","->","do","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","<-","getPolyData","(","mMin",",","mMax",",","ms",")","<-","getMData","nPoints","return","RecPolyLineM","{","recPolLMBBox","=","bb",",","recPolLMNumParts","=","nParts",",","recPolLMNumPoints","=","nPoints",",","recPolLMPartLengths","=","partLengths",",","recPolLMPoints","=","pntLists",",","recPolLMMRange","=","(","mMin",",","mMax",")",",","recPolLMMs","=","ms","}","ShpPolyLineZ","->","do","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","<-","getPolyData","(","zMin",",","zMax",",","zs",")","<-","getZData","nPoints","(","mMin",",","mMax",",","ms",")","<-","getMData","nPoints","return","RecPolyLineZ","{","recPolLZBBox","=","bb",",","recPolLZNumParts","=","nParts",",","recPolLZNumPoints","=","nPoints",",","recPolLZPartLengths","=","partLengths",",","recPolLZPoints","=","pntLists",",","recPolLZZRange","=","(","zMin",",","zMax",")",",","recPolLZZs","=","zs",",","recPolLZMRange","=","(","mMin",",","mMax",")",",","recPolLZMs","=","ms","}","ShpPolygon","->","do","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","<-","getPolyData","return","RecPolygon","{","recPolBBox","=","bb",",","recPolNumParts","=","nParts",",","recPolNumPoints","=","nPoints",",","recPolPartLengths","=","partLengths",",","recPolPoints","=","pntLists","}","ShpPolygonM","->","do","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","<-","getPolyData","(","mMin",",","mMax",",","ms",")","<-","getMData","nPoints","return","RecPolygonM","{","recPolMBBox","=","bb",",","recPolMNumParts","=","nParts",",","recPolMNumPoints","=","nPoints",",","recPolMPartLengths","=","partLengths",",","recPolMPoints","=","pntLists",",","recPolMMRange","=","(","mMin",",","mMax",")",",","recPolMMs","=","ms","}","ShpPolygonZ","->","do","(","bb",",","nParts",",","nPoints",",","partLengths",",","pntLists",")","<-","getPolyData","(","zMin",",","zMax",",","zs",")","<-","getZData","nPoints","(","mMin",",","mMax",",","ms",")","<-","getMData","nPoints","return","RecPolygonZ","{","recPolZBBox","=","bb",",","recPolZNumParts","=","nParts",",","recPolZNumPoints","=","nPoints",",","recPolZPartLengths","=","partLengths",",","recPolZPoints","=","pntLists",",","recPolZZRange","=","(","zMin",",","zMax",")",",","recPolZZs","=","zs",",","recPolZMRange","=","(","mMin",",","mMax",")",",","recPolZMs","=","ms","}","ShpNull","->","return","RecNull","ShpMultiPatch","->","error","\"getShpRec: MultiPatch type is not supported, sorry!\"","-- | Recurring pattern of bounding box with a number of points"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L93-L210","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"fromVersion","parameters":"v","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromVersion v = fromIntegral ((ZIP_OS `shiftL` 8) .|. (major * 10 + minor))\n  where\n    (major, minor) =\n      case versionBranch v of\n        v0 : v1 : _ -> (v0, v1)\n        v0 : _ -> (v0, 0)\n        [] -> (0, 0)\n\n-- | Get the compression method form its numeric representation.","function_tokens":["fromVersion","v","=","fromIntegral","(","(","ZIP_OS","`","shiftL","`","8",")",".|.","(","major","*","10","+","minor",")",")","where","(","major",",","minor",")","=","case","versionBranch","v","of","v0",":","v1",":","_","->","(","v0",",","v1",")","v0",":","_","->","(","v0",",","0",")","[","]","->","(","0",",","0",")","-- | Get the compression method form its numeric representation."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1099-L1108","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = choice [ cnst', add', mul', divides', lessThan' ] <?> \"Arithmetic\" where\n        cnst' = toDynamicallySorted . cnst <$> signed decimal\n\n        add' = do\n            _  <- char '(' *> char '+' *> space\n            as <- r `sepBy1` space\n            _  <- char ')'\n            add'' as\n\n        mul' = do\n            _  <- char '(' *> char '*' *> space\n            ms <- r `sepBy1` space\n            _  <- char ')'\n            mul'' ms\n\n        divides' = do\n            _ <- char '('\n            c <- decimal\n            _ <- char '|' *> space\n            a <- r\n            _ <- char ')'\n            divides'' c a\n\n        lessThan' = do\n            _ <- char '(' *> char '<' *> space\n            a <- r\n            _ <- space\n            b <- r\n            _ <- char ')'\n            lessThan'' a b\n\n        add'' as = case mapM toStaticallySorted as of\n            Just as' -> return . toDynamicallySorted . add $ as'\n            Nothing  -> fail \"add of non-integral arguments\"\n\n        mul'' ms = case mapM toStaticallySorted ms of\n            Just ms' -> return . toDynamicallySorted . mul $ ms'\n            Nothing  -> fail \"mul of non-integral arguments\"\n\n        divides'' c a = case toStaticallySorted a of\n            Just a' -> return . toDynamicallySorted $ c .\\. a'\n            _       -> fail \"divisibility of non-integral argument\"\n\n        lessThan'' a b = case mapM toStaticallySorted [a, b] of\n            Just [a', b'] -> return . toDynamicallySorted $ a' .<. b'\n            _             -> fail \"less-than of non-integral arguments\"\n\n-- | A smart constructor for integer constants","function_tokens":["parser","_","r","=","choice","[","cnst'",",","add'",",","mul'",",","divides'",",","lessThan'","]","<?>","\"Arithmetic\"","where","cnst'","=","toDynamicallySorted",".","cnst","<$>","signed","decimal","add'","=","do","_","<-","char","'('","*>","char","'+'","*>","space","as","<-","r","`","sepBy1","`","space","_","<-","char","')'","add''","as","mul'","=","do","_","<-","char","'('","*>","char","'*'","*>","space","ms","<-","r","`","sepBy1","`","space","_","<-","char","')'","mul''","ms","divides'","=","do","_","<-","char","'('","c","<-","decimal","_","<-","char","'|'","*>","space","a","<-","r","_","<-","char","')'","divides''","c","a","lessThan'","=","do","_","<-","char","'('","*>","char","'<'","*>","space","a","<-","r","_","<-","space","b","<-","r","_","<-","char","')'","lessThan''","a","b","add''","as","=","case","mapM","toStaticallySorted","as","of","Just","as'","->","return",".","toDynamicallySorted",".","add","$","as'","Nothing","->","fail","\"add of non-integral arguments\"","mul''","ms","=","case","mapM","toStaticallySorted","ms","of","Just","ms'","->","return",".","toDynamicallySorted",".","mul","$","ms'","Nothing","->","fail","\"mul of non-integral arguments\"","divides''","c","a","=","case","toStaticallySorted","a","of","Just","a'","->","return",".","toDynamicallySorted","$","c",".\\.","a'","_","->","fail","\"divisibility of non-integral argument\"","lessThan''","a","b","=","case","mapM","toStaticallySorted","[","a",",","b","]","of","Just","[","a'",",","b'","]","->","return",".","toDynamicallySorted","$","a'",".<.","b'","_","->","fail","\"less-than of non-integral arguments\"","-- | A smart constructor for integer constants"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L103-L151","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getObjectId","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getObjectId = Oid <$> getWord32be <*> getWord64be","function_tokens":["getObjectId","=","Oid","<$>","getWord32be","<*>","getWord64be"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L222-L222","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/ALboolean.hs","language":"haskell","identifier":"unmarshalALboolean","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalALboolean = (\/= al_FALSE)","function_tokens":["unmarshalALboolean","=","(","\/=","al_FALSE",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/ALboolean.hs#L30-L30","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/ALboolean.hs","hash_val":20506,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified'","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified' _ = coerce False","function_tokens":["isQuantified'","_","=","coerce","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L617-L617","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"continue","parameters":"","argument_list":"","return_statement":"","docstring":"Continuing always means waiting for the next signal","docstring_summary":"Continuing always means waiting for the next signal","docstring_tokens":["Continuing","always","means","waiting","for","the","next","signal"],"function":"continue = waitForReply cancel checkSignal","function_tokens":["continue","=","waitForReply","cancel","checkSignal"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L71-L71","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"xor","parameters":"a b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"xor a b = not (a && b) && (a || b)","function_tokens":["xor","a","b","=","not","(","a","&&","b",")","&&","(","a","||","b",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L81-L81","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"adir'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"adir' = adir <\/> x","function_tokens":["adir'","=","adir","<\/>","x"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L701-L701","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getInt16LE","parameters":"","argument_list":"","return_statement":"","docstring":"16-bit little-endian Int","docstring_summary":"16-bit little-endian Int","docstring_tokens":["16","-","bit","little","-","endian","Int"],"function":"getInt16LE = fromIntegral <$> getWord16le","function_tokens":["getInt16LE","=","fromIntegral","<$>","getWord16le"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L32-L32","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"loop","parameters":"vmbdcd","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop vmbdcd = VarT $ \\b -> fmap fst $ mfix $ \\(~(_, d)) -> do\n    ((c1, d1), vmbdcd1) <- runVarT vmbdcd (b, d)\n    return ((c1, loop vmbdcd1), d1)\n\n-- | VarT with its input and output parameters flipped.","function_tokens":["loop","vmbdcd","=","VarT","$","\\","b","->","fmap","fst","$","mfix","$","\\","(","~","(","_",",","d",")",")","->","do","(","(","c1",",","d1",")",",","vmbdcd1",")","<-","runVarT","vmbdcd","(","b",",","d",")","return","(","(","c1",",","loop","vmbdcd1",")",",","d1",")","-- | VarT with its input and output parameters flipped."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L191-L196","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"difference","parameters":"t1@(Tip _ x) t2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"difference t1@(Tip _ x) t2\n  | member x t2  = Nil\n  | otherwise    = t1","function_tokens":["difference","t1","@","(","Tip","_","x",")","t2","|","member","x","t2","=","Nil","|","otherwise","=","t1"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L401-L403","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"one","parameters":"(i, f@(n, _, ty))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"one (i, f@(n, _, ty)) = Field (Just n) mono ty (Context i c con, [])\n              where fsTys = map (typeVariables . trd) (delete f fs)\n                    mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["one","(","i",",","f","@","(","n",",","_",",","ty",")",")","=","Field","(","Just","n",")","mono","ty","(","Context","i","c","con",",","[","]",")","where","fsTys","=","map","(","typeVariables",".","trd",")","(","delete","f","fs",")","mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L340-L344","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"go","parameters":"compRef hOut","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go compRef hOut = do\n      mode <- maybe (liftIO (defaultRenderMode hOut)) pure bylineMode\n      unBylineT m\n        & evalPrimF mode hOut compRef\n        & unEvalT\n        & runMaybeT\n\n-- | Internal transformer for evaluating primitive operations in the\n-- 'Haskeline.InputT' transformer with EOF handling.\n--\n-- @since 1.0.0.0","function_tokens":["go","compRef","hOut","=","do","mode","<-","maybe","(","liftIO","(","defaultRenderMode","hOut",")",")","pure","bylineMode","unBylineT","m","&","evalPrimF","mode","hOut","compRef","&","unEvalT","&","runMaybeT","-- | Internal transformer for evaluating primitive operations in the","-- 'Haskeline.InputT' transformer with EOF handling.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L165-L176","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"DSet n       == DSet n'       = n == n'","function_tokens":["DSet","n","==","DSet","n'","=","n","==","n'"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L62-L62","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"toList","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a list by concatenating rows","docstring_summary":"O(m*n) Create a list by concatenating rows","docstring_tokens":["O","(","m","*","n",")","Create","a","list","by","concatenating","rows"],"function":"toList = MG.toList","function_tokens":["toList","=","MG","toList"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L178-L178","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s (DApp f a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s (DApp f a)   = s `hashWithSalt` (0 :: Int) `hashWithSalt` f `hashWithSalt` a","function_tokens":["hashWithSalt","s","(","DApp","f","a",")","=","s","`","hashWithSalt","`","(","0","::","Int",")","`","hashWithSalt","`","f","`","hashWithSalt","`","a"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L66-L66","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Opts.hs","language":"haskell","identifier":"parser","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser = Options\n  <$> ( CleanSwitch <$> switch\n        (  long \"clean\"\n        <> short 'c'\n        <> help \"Do stack or cabal 'clean' first\"\n        )\n      )\n  <*> ( DumpIconSwitch <$> switch\n        (  long \"dump-stock-icon\"\n        <> help \"Save a default icon, unix-terminal.svg, to the current working directory\"\n        )\n      )\n  <*> ( maybe Project (AppImageExe . ExeFile) <$> optional\n        ( strOption\n          (  long \"mk-appimage\"\n          <> short 'i'\n          <> metavar \"EXE\"\n          <> help \"Prepare the AppDir structure and build an AppImage for EXE. Changes PREFIX to EXE.AppDir\/usr.\"\n          )\n        )\n      )\n  <*> ( maybe NoPrefixSpecified Prefix <$> optional\n        ( strOption\n          (  long \"prefix\"\n          <> short 'p'\n          <> metavar \"DIR\"\n          <> help \"Install prefix directory (Default: AppDir\/usr)\"\n          )\n        )\n      )","function_tokens":["parser","=","Options","<$>","(","CleanSwitch","<$>","switch","(","long","\"clean\"","<>","short","'c'","<>","help","\"Do stack or cabal 'clean' first\"",")",")","<*>","(","DumpIconSwitch","<$>","switch","(","long","\"dump-stock-icon\"","<>","help","\"Save a default icon, unix-terminal.svg, to the current working directory\"",")",")","<*>","(","maybe","Project","(","AppImageExe",".","ExeFile",")","<$>","optional","(","strOption","(","long","\"mk-appimage\"","<>","short","'i'","<>","metavar","\"EXE\"","<>","help","\"Prepare the AppDir structure and build an AppImage for EXE. Changes PREFIX to EXE.AppDir\/usr.\"",")",")",")","<*>","(","maybe","NoPrefixSpecified","Prefix","<$>","optional","(","strOption","(","long","\"prefix\"","<>","short","'p'","<>","metavar","\"DIR\"","<>","help","\"Install prefix directory (Default: AppDir\/usr)\"",")",")",")"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Opts.hs#L51-L80","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Opts.hs","hash_val":22933,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"mbLeft","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mbLeft = case match of\n        GHC.Match _ (GHC.FunRhs name _ _) [] _ ->\n            GHC.srcSpanToRealSrcSpan $ GHC.getLocA name\n        GHC.Match _ _ pats@(_ : _) _ ->\n            GHC.srcSpanToRealSrcSpan . GHC.getLocA $ last pats\n        _ -> Nothing\n\n\n--------------------------------------------------------------------------------","function_tokens":["mbLeft","=","case","match","of","GHC","Match","_","(","GHC","FunRhs","name","_","_",")","[","]","_","->","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","name","GHC","Match","_","_","pats","@","(","_",":","_",")","_","->","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA","$","last","pats","_","->","Nothing","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L68-L77","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"stripCommentMarks","parameters":"SingleLine","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stripCommentMarks SingleLine = drop 2","function_tokens":["stripCommentMarks","SingleLine","=","drop","2"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L46-L46","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"unmarshalSourceRelative","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalSourceRelative x = if x then Listener else World","function_tokens":["unmarshalSourceRelative","x","=","if","x","then","Listener","else","World"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L198-L198","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"verticalPragmas","parameters":"lg longest align pragmas'","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"verticalPragmas lg longest align pragmas' =\n    [ \"{-# \" ++ lg ++ \" \" ++ pad pragma ++ \" #-}\"\n    | pragma <- pragmas'\n    ]\n  where\n    pad\n      | align = padRight longest\n      | otherwise = id\n\n\n--------------------------------------------------------------------------------","function_tokens":["verticalPragmas","lg","longest","align","pragmas'","=","[","\"{-# \"","++","lg","++","\" \"","++","pad","pragma","++","\" #-}\"","|","pragma","<-","pragmas'","]","where","pad","|","align","=","padRight","longest","|","otherwise","=","id","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L42-L53","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!w'' = mappend w w'","function_tokens":["w''","=","mappend","w","w'"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Strict.hs#L71-L71","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Strict.hs","hash_val":32183,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"unsafeThaw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeThaw = undefined","function_tokens":["unsafeThaw","=","undefined"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L119-L119","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"desc","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desc =\n            EntryDescription\n              { edVersionMadeBy = versionMadeBy,\n                edVersionNeeded = versionNeeded,\n                edCompression = compression,\n                edModTime = fromMsDosTime (MsDosTime modDate modTime),\n                edCRC32 = crc32,\n                edCompressedSize = z64efCompressedSize z64ef,\n                edUncompressedSize = z64efUncompressedSize z64ef,\n                edOffset = z64efOffset z64ef,\n                edComment = if commentSize == 0 then Nothing else comment,\n                edExtraField = extraField,\n                edExternalFileAttrs = externalFileAttrs\n              }","function_tokens":["desc","=","EntryDescription","{","edVersionMadeBy","=","versionMadeBy",",","edVersionNeeded","=","versionNeeded",",","edCompression","=","compression",",","edModTime","=","fromMsDosTime","(","MsDosTime","modDate","modTime",")",",","edCRC32","=","crc32",",","edCompressedSize","=","z64efCompressedSize","z64ef",",","edUncompressedSize","=","z64efUncompressedSize","z64ef",",","edOffset","=","z64efOffset","z64ef",",","edComment","=","if","commentSize","==","0","then","Nothing","else","comment",",","edExtraField","=","extraField",",","edExternalFileAttrs","=","externalFileAttrs","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L722-L735","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"filesMatchingPrefixes","parameters":"prefixes","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"filesMatchingPrefixes prefixes =\n              rootRelativeFiles . mapMaybe (firstMatchingPrefix prefixes)\n              $ lines statusPorcelain","function_tokens":["filesMatchingPrefixes","prefixes","=","rootRelativeFiles",".","mapMaybe","(","firstMatchingPrefix","prefixes",")","$","lines","statusPorcelain"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L228-L230","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showWide","parameters":"wide bars","argument_list":"","return_statement":"","docstring":"++ show (p,m)","docstring_summary":"++ show (p,m)","docstring_tokens":["++","show","(","p","m",")"],"function":"showWide wide bars\n  | wide      = showString (concat (reverse bars)) . showString \"|\\n\"\n  | otherwise = id","function_tokens":["showWide","wide","bars","|","wide","=","showString","(","concat","(","reverse","bars",")",")",".","showString","\"|\\n\"","|","otherwise","=","id"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L813-L815","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Catch.hs","language":"haskell","identifier":"catchError","parameters":"m h","argument_list":"","return_statement":"","docstring":"Run a computation which can throw errors with a handler to run on error.  Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does \/not\/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if @fused-effects-exceptions@ fits your use case; if not, use 'Control.Monad.IO.Class.liftIO' with 'Control.Exception.try' or use 'Control.Exception.catch' from outside the effect invocation.  @ runError ('Control.Effect.Throw.throwError' e `catchError` f) = runError (f e) @  @since 0.1.0.0","docstring_summary":"Run a computation which can throw errors with a handler to run on error.  Errors thrown by the handler will escape up to the nearest enclosing 'catchError' (if any). Note that this effect does \/not\/ handle errors thrown from impure contexts such as IO, nor will it handle exceptions thrown from pure code. If you need to handle IO-based errors, consider if","docstring_tokens":["Run","a","computation","which","can","throw","errors","with","a","handler","to","run","on","error",".","Errors","thrown","by","the","handler","will","escape","up","to","the","nearest","enclosing","catchError","(","if","any",")",".","Note","that","this","effect","does","\/","not","\/","handle","errors","thrown","from","impure","contexts","such","as","IO","nor","will","it","handle","exceptions","thrown","from","pure","code",".","If","you","need","to","handle","IO","-","based","errors","consider","if"],"function":"catchError m h = send (Catch m h)","function_tokens":["catchError","m","h","=","send","(","Catch","m","h",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Catch.hs#L32-L32","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Catch.hs","hash_val":8430,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (InR gb) = dual gb","function_tokens":["dual","(","InR","gb",")","=","dual","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L684-L684","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"informationOf","parameters":"Analysis{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"informationOf Analysis{..} = fromRational mean ** 0.7 * fromIntegral samples","function_tokens":["informationOf","Analysis","{","..","}","=","fromRational","mean","**","0.7","*","fromIntegral","samples"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L371-L371","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Ask         -> Reader.asks (<$ ctx)\n    L (Local f m) -> Reader.local f (hdl (m <$ ctx))\n    R other       -> Reader.ReaderT $ \\ r -> alg ((`Reader.runReaderT` r) . hdl) other ctx","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Ask","->","Reader","asks","(","<$","ctx",")","L","(","Local","f","m",")","->","Reader","local","f","(","hdl","(","m","<$","ctx",")",")","R","other","->","Reader","ReaderT","$","\\","r","->","alg","(","(","`","Reader","runReaderT","`","r",")",".","hdl",")","other","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L235-L239","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrRemBits","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrRemBits    = F.unsafeForeignPtrToPtr fptrRemBits","function_tokens":["ptrRemBits","=","F","unsafeForeignPtrToPtr","fptrRemBits"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L44-L44","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic.hs","language":"haskell","identifier":"unsafeFromVector","parameters":"(r,c) vec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeFromVector (r,c) vec | r \/= c = error \"columns \/= rows\"\n                               | otherwise = SymMatrix r . G.concat . Prelude.map f $ [0..r-1]\n      where\n        f i = G.slice (i*(c+1)) (c-i) vec\n--        n = ((r+1)*r) `shiftR` 1","function_tokens":["unsafeFromVector","(","r",",","c",")","vec","|","r","\/=","c","=","error","\"columns \/= rows\"","|","otherwise","=","SymMatrix","r",".","G","concat",".","Prelude","map","f","$","[","0","..","r","-","1","]","where","f","i","=","G","slice","(","i","*","(","c","+","1",")",")","(","c","-","i",")","vec","--        n = ((r+1)*r) `shiftR` 1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic.hs#L57-L62","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic.hs","hash_val":12847,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"weight","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"weight = weightOf ana","function_tokens":["weight","=","weightOf","ana"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L385-L385","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"go","parameters":"f n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go f n | n < 0 = B.charUtf8 '\u207b' <> f (abs n)\n               | n < 10 = B.charUtf8 $ \"\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\" !! fromIntegral n\n               | otherwise = uncurry ((<>) `on` f) $ divMod n 10","function_tokens":["go","f","n","|","n","<","0","=","B","charUtf8","'\u207b' <"," f","(","b","s n","","","|","n","<","10","=","B","charUtf8","$","\"\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\" !! fromIntegral ","","","","|","otherwise","=","uncurry","(","(","<>",")","`","on","`","f",")","$","divMod","n","10"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L366-L368","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"ptrRemBitsLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ptrRemBitsLen = F.unsafeForeignPtrToPtr fptrRemBitsLen","function_tokens":["ptrRemBitsLen","=","F","unsafeForeignPtrToPtr","fptrRemBitsLen"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L62-L62","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"unintern","parameters":"(InternedText _ b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (InternedText _ b) = b","function_tokens":["unintern","(","InternedText","_","b",")","=","b"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L40-L40","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"runStep","parameters":"exts mfp ls","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"runStep exts mfp ls = \\case\n  Step _name step ->\n    step ls <$> parseModule exts mfp (unlines ls)\n\n--------------------------------------------------------------------------------","function_tokens":["runStep","exts","mfp","ls","=","\\","case","Step","_name","step","->","step","ls","<$>","parseModule","exts","mfp","(","unlines","ls",")","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L94-L99","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"composeTfm","parameters":"(Tfm s2 d2) (Tfm s1 d1)","argument_list":"","return_statement":"","docstring":"composition on transformations: s2 `composeTfm` s1","docstring_summary":"composition on transformations: s2 `composeTfm` s1","docstring_tokens":["composition","on","transformations",":","s2","composeTfm","s1"],"function":"composeTfm (Tfm s2 d2) (Tfm s1 d1) = Tfm (s1*s2) (d1*s2 + d2)","function_tokens":["composeTfm","(","Tfm","s2","d2",")","(","Tfm","s1","d1",")","=","Tfm","(","s1","*","s2",")","(","d1","*","s2","+","d2",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L370-L370","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(!bsFptr, !bsOff, !bsLen) = BSI.toForeignPtr bs","function_tokens":["(","bsFptr",",","bsOff",",","bsLen",")","=","BSI","toForeignPtr","bs"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L74-L74","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"allCaptureDeviceSpecifiers","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains a list of specifiers for all available capture devices.","docstring_summary":"------------------------------------------------------------------------------ Contains a list of specifiers for all available capture devices.","docstring_tokens":["------------------------------------------------------------------------------","Contains","a","list","of","specifiers","for","all","available","capture","devices","."],"function":"allCaptureDeviceSpecifiers = makeGettableStateVar $ do\n   enumExtPresent <- get (alcIsExtensionPresent Nothing \"ALC_ENUMERATION_EXT\")\n   if enumExtPresent\n      then peekALCStrings =<< getStringRaw Nothing CaptureDeviceSpecifier\n      else fmap (\\s -> [s]) $ get captureDefaultDeviceSpecifier","function_tokens":["allCaptureDeviceSpecifiers","=","makeGettableStateVar","$","do","enumExtPresent","<-","get","(","alcIsExtensionPresent","Nothing","\"ALC_ENUMERATION_EXT\"",")","if","enumExtPresent","then","peekALCStrings","=<<","getStringRaw","Nothing","CaptureDeviceSpecifier","else","fmap","(","\\","s","->","[","s","]",")","$","get","captureDefaultDeviceSpecifier"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L138-L142","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"go","parameters":"h b1 b2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go h b1 b2 | oneOf ((<3) . samples) || oneOf ((<1) . informationOf) = next\n                   | otherwise = case compareMeans cfg (analysis b1) (analysis b2) of\n                       EQ | oneOf (relativeErrorAbove cfg (d\/2)) -> next\n                       r -> pure r\n           where next | ((<=) `on` informationOf . analysis) b1 b2 = (`h` b2) =<< step b1\n                      | otherwise = h b1 =<< step b2\n                 oneOf f = f (analysis b1) || f (analysis b2)","function_tokens":["go","h","b1","b2","|","oneOf","(","(","<","3",")",".","samples",")","||","oneOf","(","(","<","1",")",".","informationOf",")","=","next","|","otherwise","=","case","compareMeans","cfg","(","analysis","b1",")","(","analysis","b2",")","of","EQ","|","oneOf","(","relativeErrorAbove","cfg","(","d","\/","2",")",")","->","next","r","->","pure","r","where","next","|","(","(","<=",")","`","on","`","informationOf",".","analysis",")","b1","b2","=","(","`","h","`","b2",")","=<<","step","b1","|","otherwise","=","h","b1","=<<","step","b2","oneOf","f","=","f","(","analysis","b1",")","||","f","(","analysis","b2",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L321-L329","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"space","parameters":"","argument_list":"","return_statement":"","docstring":"Matches space.","docstring_summary":"Matches space.","docstring_tokens":["Matches","space","."],"function":"space = lift . lift $ A.space","function_tokens":["space","=","lift",".","lift","$","A","space"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L113-L113","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"xs'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"xs'    = S.fromList fxs `S.difference` known","function_tokens":["xs'","=","S","fromList","fxs","`","S","difference","`","known"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L112-L112","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"unintern","parameters":"Nil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern Nil = UNil","function_tokens":["unintern","Nil","=","UNil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L224-L224","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"used","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"used  = show . pretty <$> varNames","function_tokens":["used","=","show",".","pretty","<$>","varNames"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L580-L580","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"withEmpty","parameters":"bars","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withEmpty bars = \"   \":bars","function_tokens":["withEmpty","bars","=","\"   \"",":","bars"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L828-L828","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"r","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r = length xs","function_tokens":["r","=","length","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L148-L148","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"findMin","parameters":"(Bin _ _ _ m l r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findMin (Bin _ _ _ m l r)\n  |   m < 0   = find r\n  | otherwise = find l\n    where find (Tip _ x)          = x\n          find (Bin _ _ _ _ l' _) = find l'\n          find Nil                = error \"findMin Nil\"\n\n-- | \/O(min(n,W))\/. The maximal element of a set.","function_tokens":["findMin","(","Bin","_","_","_","m","l","r",")","|","m","<","0","=","find","r","|","otherwise","=","find","l","where","find","(","Tip","_","x",")","=","x","find","(","Bin","_","_","_","_","l'","_",")","=","find","l'","find","Nil","=","error","\"findMin Nil\"","-- | \/O(min(n,W))\/. The maximal element of a set."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L641-L649","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"putZip64ECDLocator","parameters":"ecdOffset","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putZip64ECDLocator ecdOffset = do\n  putWord32le 0x07064b50 -- zip64 end of central dir locator signature\n  putWord32le 0 -- number of the disk with the start of the zip64 end of\n  -- central directory\n  putWord64le (fromIntegral ecdOffset) -- relative offset of the zip64 end\n  -- of central directory record\n  putWord32le 1 -- total number of disks\n\n-- | Parse end of the central directory record or Zip64 end of the central\n-- directory record depending on signature binary data begins with.","function_tokens":["putZip64ECDLocator","ecdOffset","=","do","putWord32le","0x07064b50","-- zip64 end of central dir locator signature","putWord32le","0","-- number of the disk with the start of the zip64 end of","-- central directory","putWord64le","(","fromIntegral","ecdOffset",")","-- relative offset of the zip64 end","-- of central directory record","putWord32le","1","-- total number of disks","-- | Parse end of the central directory record or Zip64 end of the central","-- directory record depending on signature binary data begins with."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L887-L897","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"ifold","parameters":"(Store  _ _ a i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Store  _ _ a i e) = coerce a <> coerce i <> coerce e","function_tokens":["ifold","(","Store","_","_","a","i","e",")","=","coerce","a","<>","coerce","i","<>","coerce","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L68-L68","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"mergeModuleImport","parameters":"(L p0 i0) (L _p1 i1)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mergeModuleImport (L p0 i0) (L _p1 i1) =\n  L p0 $ i0 { ideclHiding = newImportNames }\n  where\n    newImportNames =\n      case (ideclHiding i0, ideclHiding i1) of\n        (Just (b, L p imps0), Just (_, L _ imps1)) -> Just (b, L p (imps0 `merge` imps1))\n        (Nothing, Nothing) -> Nothing\n        (Just x, Nothing) -> Just x\n        (Nothing, Just x) -> Just x\n    merge xs ys\n      = L.nubBy ((==) `on` showOutputable) (xs ++ ys)\n\n-- | Query the module AST using @f@","function_tokens":["mergeModuleImport","(","L","p0","i0",")","(","L","_p1","i1",")","=","L","p0","$","i0","{","ideclHiding","=","newImportNames","}","where","newImportNames","=","case","(","ideclHiding","i0",",","ideclHiding","i1",")","of","(","Just","(","b",",","L","p","imps0",")",",","Just","(","_",",","L","_","imps1",")",")","->","Just","(","b",",","L","p","(","imps0","`","merge","`","imps1",")",")","(","Nothing",",","Nothing",")","->","Nothing","(","Just","x",",","Nothing",")","->","Just","x","(","Nothing",",","Just","x",")","->","Just","x","merge","xs","ys","=","L","nubBy","(","(","==",")","`","on","`","showOutputable",")","(","xs","++","ys",")","-- | Query the module AST using @f@"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L119-L132","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"getParserNames","parameters":"","argument_list":"","return_statement":"","docstring":"Return the ordered list of names (assigned through ('<?>')) for the current parser stack. First element is the most nested parser.","docstring_summary":"Return the ordered list of names (assigned through ('<?>')) for the current parser stack. First element is the most nested parser.","docstring_tokens":["Return","the","ordered","list","of","names","(","assigned","through","(","<?",">","))","for","the","current","parser","stack",".","First","element","is","the","most","nested","parser","."],"function":"getParserNames = ConduitParser $ lift $ gets fst","function_tokens":["getParserNames","=","ConduitParser","$","lift","$","gets","fst"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L109-L109","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"notFollowedBy","parameters":"parser","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"notFollowedBy parser = do\n    result <- optional parser\n    name <- getParserName\n    forM_ result $ \\_ -> throwError $ UnexpectedFollowedBy name\n\n-- | Flipped version of ('<?>').","function_tokens":["notFollowedBy","parser","=","do","result","<-","optional","parser","name","<-","getParserName","forM_","result","$","\\","_","->","throwError","$","UnexpectedFollowedBy","name","-- | Flipped version of ('<?>')."],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L92-L98","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"clear","parameters":"cfg","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"clear cfg | printOnce cfg = mempty\n          | otherwise = csi' [0] 'K'","function_tokens":["clear","cfg","|","printOnce","cfg","=","mempty","|","otherwise","=","csi'","[","0","]","'K'"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L223-L224","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictSourceState","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictSourceState = Dictionary {\n   alGetter  = alGetSourceiv,\n   alSetter  = undefined,\n   size      = 1,\n   peekSize  = peek1 unmarshalSourceState,\n   marshal   = undefined }","function_tokens":["dictSourceState","=","Dictionary","{","alGetter","=","alGetSourceiv",",","alSetter","=","undefined",",","size","=","1",",","peekSize","=","peek1","unmarshalSourceState",",","marshal","=","undefined","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L547-L552","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"select","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"select e = if isDoesNotExistError e then Just e else Nothing","function_tokens":["select","e","=","if","isDoesNotExistError","e","then","Just","e","else","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L715-L715","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/State.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = 100000","function_tokens":["n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/State.hs#L32-L32","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/State.hs","hash_val":42170,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"go","parameters":"(BSet n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (BSet n) = Set i n","function_tokens":["go","(","BSet","n",")","=","Set","i","n"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L39-L39","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictLoopingMode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictLoopingMode = Dictionary {\n   alGetter  = alGetSourceiv,\n   alSetter  = alSourceiv,\n   size      = 1,\n   peekSize  = peek1 (unmarshalLoopingMode . unmarshalALboolean . fromIntegral),\n   marshal   = fromIntegral . marshalALboolean . marshalLoopingMode }","function_tokens":["dictLoopingMode","=","Dictionary","{","alGetter","=","alGetSourceiv",",","alSetter","=","alSourceiv",",","size","=","1",",","peekSize","=","peek1","(","unmarshalLoopingMode",".","unmarshalALboolean",".","fromIntegral",")",",","marshal","=","fromIntegral",".","marshalALboolean",".","marshalLoopingMode","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L539-L544","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"member","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"member x t\n  = case t of\n      Bin _ _ p m l r\n        | nomatch x p m -> False\n        | zero x m      -> member x l\n        | otherwise     -> member x r\n      Tip _ y -> (x==y)\n      Nil     -> False\n\n-- | \/O(min(n,W))\/. Is the element not in the set?","function_tokens":["member","x","t","=","case","t","of","Bin","_","_","p","m","l","r","|","nomatch","x","p","m","->","False","|","zero","x","m","->","member","x","l","|","otherwise","->","member","x","r","Tip","_","y","->","(","x","==","y",")","Nil","->","False","-- | \/O(min(n,W))\/. Is the element not in the set?"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L263-L273","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"centralAngle","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"centralAngle = acos $ (sin lat1) * (sin lat2) + (cos lat1) * (cos lat2) * (cos (long1 - long2))","function_tokens":["centralAngle","=","acos","$","(","sin","lat1",")","*","(","sin","lat2",")","+","(","cos","lat1",")","*","(","cos","lat2",")","*","(","cos","(","long1","-","long2",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L75-L75","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"nodeToArg","parameters":"node","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nodeToArg node = id `B.append` C.pack (host ++ \" \") `B.append` port\n    where id = toBS . nodeId $ node\n          host = peerHost . peer $ node\n          port = toBinary . fromIntegral . peerPort . peer $ node\n          -- Converts a Word16 into a two character ByteString\n          toBinary = B.concat . L.toChunks . toLazyByteString . word16BE\n\n-- | Turn a command into a sendable ByteString","function_tokens":["nodeToArg","node","=","id","`","B","append","`","C","pack","(","host","++","\" \"",")","`","B","append","`","port","where","id","=","toBS",".","nodeId","$","node","host","=","peerHost",".","peer","$","node","port","=","toBinary",".","fromIntegral",".","peerPort",".","peer","$","node","-- Converts a Word16 into a two character ByteString","toBinary","=","B","concat",".","L","toChunks",".","toLazyByteString",".","word16BE","-- | Turn a command into a sendable ByteString"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L46-L54","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"dictALfloat","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dictALfloat = Dictionary {\n   alGetter  = alGetSourcefv,\n   alSetter  = alSourcefv,\n   size      = 1,\n   peekSize  = peek1 id,\n   marshal   = id }","function_tokens":["dictALfloat","=","Dictionary","{","alGetter","=","alGetSourcefv",",","alSetter","=","alSourcefv",",","size","=","1",",","peekSize","=","peek1","id",",","marshal","=","id","}"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L515-L520","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freevars'","parameters":"(Exists vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freevars' (Exists vs a) = coerce (P.filter (`notElem` map (\\v@(IFix (Var _ s)) -> DynamicallySorted s v) vs)) a","function_tokens":["freevars'","(","Exists","vs","a",")","=","coerce","(","P","filter","(","`","notElem","`","map","(","\\","v","@","(","IFix","(","Var","_","s",")",")","->","DynamicallySorted","s","v",")","vs",")",")","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L626-L626","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"vars","parameters":"","argument_list":"","return_statement":"","docstring":"Collects a list of all variables occurring in an expression (bound or free).","docstring_summary":"Collects a list of all variables occurring in an expression (bound or free).","docstring_tokens":["Collects","a","list","of","all","variables","occurring","in","an","expression","(","bound","or","free",")","."],"function":"vars = nub . F.getConst . icata vars' where\n    vars' a = case prj a of\n        Just (Var n s) -> F.Const [dynvar n s]\n        Nothing -> ifold a\n\n-- | Substitution that given an expression produces replacement if the expression is to be replaced or nothing otherwise.","function_tokens":["vars","=","nub",".","F","getConst",".","icata","vars'","where","vars'","a","=","case","prj","a","of","Just","(","Var","n","s",")","->","F","Const","[","dynvar","n","s","]","Nothing","->","ifold","a","-- | Substitution that given an expression produces replacement if the expression is to be replaced or nothing otherwise."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L303-L309","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"index","parameters":"And {}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"index And {} = SBooleanSort","function_tokens":["index","And","{","}","=","SBooleanSort"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L353-L353","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/menu.hs","language":"haskell","identifier":"items","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"items =\n  NonEmpty.fromList\n    [ Fruit \"Watermelon\",\n      Vegetable \"Cucumber\",\n      Fruit \"Kiwi\",\n      Vegetable \"Asparagus\"\n    ]","function_tokens":["items","=","NonEmpty","fromList","[","Fruit","\"Watermelon\"",",","Vegetable","\"Cucumber\"",",","Fruit","\"Kiwi\"",",","Vegetable","\"Asparagus\"","]"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/menu.hs#L37-L43","hash_key":"pjones\/byline:examples\/menu.hs","hash_val":10089,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Attenuation.hs","language":"haskell","identifier":"distanceModel","parameters":"","argument_list":"","return_statement":"","docstring":"Contains the current per-context distance model.","docstring_summary":"Contains the current per-context distance model.","docstring_tokens":["Contains","the","current","per","-","context","distance","model","."],"function":"distanceModel =\n   makeStateVar\n      (alloca $ \\buf -> do\n          alGetIntegerv (marshalGetPName GetDistanceModel) buf\n          peek1 (unmarshalDistanceModel . fromIntegral) buf)\n      (alDistanceModel . marshalDistanceModel)","function_tokens":["distanceModel","=","makeStateVar","(","alloca","$","\\","buf","->","do","alGetIntegerv","(","marshalGetPName","GetDistanceModel",")","buf","peek1","(","unmarshalDistanceModel",".","fromIntegral",")","buf",")","(","alDistanceModel",".","marshalDistanceModel",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Attenuation.hs#L201-L206","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Attenuation.hs","hash_val":13566,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"parseZip64ExtraField","parameters":"dflt@Zip64ExtraField {..} b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseZip64ExtraField dflt@Zip64ExtraField {..} b =\n  either (const dflt) id . flip runGet b $ do\n    let ifsat v =\n          if v >= ffffffff\n            then fromIntegral <$> getWord64le\n            else return v\n    uncompressed <- ifsat z64efUncompressedSize -- uncompressed size\n    compressed <- ifsat z64efCompressedSize -- compressed size\n    offset <- ifsat z64efOffset -- offset of local file header\n    return (Zip64ExtraField uncompressed compressed offset)\n\n-- | Produce binary representation of 'Zip64ExtraField'.","function_tokens":["parseZip64ExtraField","dflt","@","Zip64ExtraField","{","..","}","b","=","either","(","const","dflt",")","id",".","flip","runGet","b","$","do","let","ifsat","v","=","if","v",">=","ffffffff","then","fromIntegral","<$>","getWord64le","else","return","v","uncompressed","<-","ifsat","z64efUncompressedSize","-- uncompressed size","compressed","<-","ifsat","z64efCompressedSize","-- compressed size","offset","<-","ifsat","z64efOffset","-- offset of local file header","return","(","Zip64ExtraField","uncompressed","compressed","offset",")","-- | Produce binary representation of 'Zip64ExtraField'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L762-L774","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"firstLocation","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"firstLocation = minimum . fmap (GHC.srcLocLine . GHC.realSrcSpanStart . fst)","function_tokens":["firstLocation","=","minimum",".","fmap","(","GHC","srcLocLine",".","GHC","realSrcSpanStart",".","fst",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L164-L164","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = NewContent mempty mempty","function_tokens":["mempty","=","NewContent","mempty","mempty"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L77-L77","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"ibind","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ibind = coerce $ (=<<) @m @a @b","function_tokens":["ibind","=","coerce","$","(","=<<",")","@","m","@","a","@","b"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L54-L54","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"fieldAllowed","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldAllowed = go\n    where\n        go (Area _)                 = (True, True, False, False)\n        go (Book _)                 = (True, True, False, False)\n        go (Composer _)             = (True, True, False, False)\n        go (Discography _)          = (True, True, False, False)\n        go (FileUrl _)              = (True, True, False, False)\n        go (Group _)                = (True, True, False, False)\n        go (History _)              = (True, True, False, False)\n        \n        go (Instruction _)          = (True, True, True, True)\n        go (Key _)                  = (False, True{-last-}, True, True)\n        go (UnitNoteLength _)       = (True, True, True, True)\n        go (Meter _)                = (True, True, True, True)\n        go Macro                    = (True, True, True, True)\n        go (Notes _)                = (True, True, True, True)\n        \n        go (Origin _)               = (True, True, False, False)\n        go Parts                    = (False, True, True, True)\n        go (Tempo _)                = (False, True, True, True)\n        go (Rhythm _)               = (True, True, True, True)\n        go Remark                   = (True, True, True, True)\n        \n        go (Source _)               = (True, True, False, False)\n        go SymbolLine               = (False, False, True, False)\n        go (Title _)                = (False, True{-second-}, True, False)\n        \n        go UserDefined              = (True, True, True, True)\n        go (Voice _)                = (False, True, True, True)\n        go (Words _)                = (False, True, True, False)\n        go (ReferenceNumber _)      = (False, True{-first-}, True, False)\n        go (Transcription _)        = (True, True, False, False)","function_tokens":["fieldAllowed","=","go","where","go","(","Area","_",")","=","(","True",",","True",",","False",",","False",")","go","(","Book","_",")","=","(","True",",","True",",","False",",","False",")","go","(","Composer","_",")","=","(","True",",","True",",","False",",","False",")","go","(","Discography","_",")","=","(","True",",","True",",","False",",","False",")","go","(","FileUrl","_",")","=","(","True",",","True",",","False",",","False",")","go","(","Group","_",")","=","(","True",",","True",",","False",",","False",")","go","(","History","_",")","=","(","True",",","True",",","False",",","False",")","go","(","Instruction","_",")","=","(","True",",","True",",","True",",","True",")","go","(","Key","_",")","=","(","False",",","True","{-last-}",",","True",",","True",")","go","(","UnitNoteLength","_",")","=","(","True",",","True",",","True",",","True",")","go","(","Meter","_",")","=","(","True",",","True",",","True",",","True",")","go","Macro","=","(","True",",","True",",","True",",","True",")","go","(","Notes","_",")","=","(","True",",","True",",","True",",","True",")","go","(","Origin","_",")","=","(","True",",","True",",","False",",","False",")","go","Parts","=","(","False",",","True",",","True",",","True",")","go","(","Tempo","_",")","=","(","False",",","True",",","True",",","True",")","go","(","Rhythm","_",")","=","(","True",",","True",",","True",",","True",")","go","Remark","=","(","True",",","True",",","True",",","True",")","go","(","Source","_",")","=","(","True",",","True",",","False",",","False",")","go","SymbolLine","=","(","False",",","False",",","True",",","False",")","go","(","Title","_",")","=","(","False",",","True","{-second-}",",","True",",","False",")","go","UserDefined","=","(","True",",","True",",","True",",","True",")","go","(","Voice","_",")","=","(","False",",","True",",","True",",","True",")","go","(","Words","_",")","=","(","False",",","True",",","True",",","False",")","go","(","ReferenceNumber","_",")","=","(","False",",","True","{-first-}",",","True",",","False",")","go","(","Transcription","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L364-L397","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseSteps","parameters":"config val","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"parseSteps config val = do\n    map' <- parseJSON val :: A.Parser (Map String A.Value)\n    forM (M.toList map') $ \\(k, v) -> case (M.lookup k catalog, v) of\n        (Just parser, A.Object o) -> parser config o\n        _                         -> fail $ \"Invalid declaration for \" ++ k\n\n\n--------------------------------------------------------------------------------\n-- | Utility for enum-like options","function_tokens":["parseSteps","config","val","=","do","map'","<-","parseJSON","val","::","A","Parser","(","Map","String","A","Value",")","forM","(","M","toList","map'",")","$","\\","(","k",",","v",")","->","case","(","M","lookup","k","catalog",",","v",")","of","(","Just","parser",",","A","Object","o",")","->","parser","config","o","_","->","fail","$","\"Invalid declaration for \"","++","k","--------------------------------------------------------------------------------","-- | Utility for enum-like options"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L181-L190","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_INVALID_ENUM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_INVALID_ENUM                    = 0xA003","function_tokens":["alc_INVALID_ENUM","=","0xA003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L143-L143","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"benchmark","parameters":"title runQueens","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark title runQueens = bgroup title\n  [ bench \"4\"  $ whnf (runQueens . queens) 4\n  , bench \"8\"  $ whnf (runQueens . queens) 8\n  , bench \"16\" $ whnf (runQueens . queens) 16\n  ]","function_tokens":["benchmark","title","runQueens","=","bgroup","title","[","bench","\"4\"","$","whnf","(","runQueens",".","queens",")","4",",","bench","\"8\"","$","whnf","(","runQueens",".","queens",")","8",",","bench","\"16\"","$","whnf","(","runQueens",".","queens",")","16","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L52-L56","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"forkOS","parameters":"","argument_list":"","return_statement":"","docstring":"Same as @Control.Concurrent.Thread.'Thread.forkOS'@ but additionaly adds the thread to the group.","docstring_summary":"Same as","docstring_tokens":["Same","as"],"function":"forkOS = fork Control.Concurrent.forkOS","function_tokens":["forkOS","=","fork","Control","Concurrent","forkOS"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L149-L149","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(sig,expo) = floatToDigits 10 x","function_tokens":["(","sig",",","expo",")","=","floatToDigits","10","x"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L355-L355","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"barBuilder","parameters":"cfg width m stdErr sd","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"barBuilder cfg width m stdErr sd | simple cfg =\n  B.char7 ' ' <> B.char7 ' ' <> B.string7 (replicate (pred valueLength) '=')\n  <> B.string7 (replicate errorLength '<')\n  <> mWhen (len * stdErr >= 0.20) (B.char7 '+')\n  <> B.string7 (replicate errorLength '>')\n  <> B.string7 (replicate sigmaLength '-')\n                                 | otherwise =\n  B.char7 ' ' <> B.char7 ' ' <> B.stringUtf8 (replicate (pred valueLength) '\u2580')\n  <> sgrBuilder (SetColor Foreground Dull Magenta)\n  <> B.stringUtf8 (replicate errorLength '\u2580')\n  <> mWhen (len * stdErr >= 0.20)\n           (sgrBuilder (SetColor Foreground Vivid Magenta) <> B.charUtf8 '\u2580')\n  <> sgrBuilder (SetColor Foreground Dull Magenta)\n  <> B.stringUtf8 (replicate errorLength '\u2580')\n  <> sgrBuilder (SetColor Foreground Vivid Black)\n  <> B.stringUtf8 (replicate sigmaLength '\u2594')\n  <> sgrBuilder Reset\n  where\n    len = fromRational m * fromIntegral (width - 6) \/ 2\n    valueLength = round len - errorLength\n    errorLength = round $ len * stdErr\n    sigmaLength = round (len * sd) - errorLength","function_tokens":["barBuilder","cfg","width","m","stdErr","sd","|","simple","cfg","=","B","char7","' '","<>","B","char7","' '","<>","B","string7","(","replicate","(","pred","valueLength",")","'='",")","<>","B","string7","(","replicate","errorLength","'<'",")","<>","mWhen","(","len","*","stdErr",">=","0.20",")","(","B","char7","'+'",")","<>","B","string7","(","replicate","errorLength","'>'",")","<>","B","string7","(","replicate","sigmaLength","'-'",")","|","otherwise","=","B","char7","' '","<>","B","char7","' '","<>","B","stringUtf8","(","replicate","(","pred","valueLength",")","'\u2580')","","<>","sgrBuilder","(","SetColor","Foreground","Dull","Magenta",")","<>","B","stringUtf8","(","replicate","errorLength","'\u2580')","","<>","mWhen","(","len","*","stdErr",">=","0.20",")","(","sgrBuilder","(","SetColor","Foreground","Vivid","Magenta",")","<>","B","charUtf8","'\u2580')","","<>","sgrBuilder","(","SetColor","Foreground","Dull","Magenta",")","<>","B","stringUtf8","(","replicate","errorLength","'\u2580')","","<>","sgrBuilder","(","SetColor","Foreground","Vivid","Black",")","<>","B","stringUtf8","(","replicate","sigmaLength","'\u2594')","","<>","sgrBuilder","Reset","where","len","=","fromRational","m","*","fromIntegral","(","width","-","6",")","\/","2","valueLength","=","round","len","-","errorLength","errorLength","=","round","$","len","*","stdErr","sigmaLength","=","round","(","len","*","sd",")","-","errorLength"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L395-L416","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"fromAdornment","parameters":"GHC.NameParensHash","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromAdornment GHC.NameParensHash = (\"#(\", \"#)\")","function_tokens":["fromAdornment","GHC","NameParensHash","=","(","\"#(\"",",","\"#)\"",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L186-L186","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"isGADTCons","parameters":"c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isGADTCons c = case GHC.unLoc c of\n      GHC.ConDeclGADT {} -> True\n      _                  -> False","function_tokens":["isGADTCons","c","=","case","GHC","unLoc","c","of","GHC","ConDeclGADT","{","}","->","True","_","->","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L527-L531","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"cur","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cur = ci `U.unsafeIndex` n","function_tokens":["cur","=","ci","`","U","unsafeIndex","`","n"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L112-L112","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"withAllStageFiles","parameters":"path action","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withAllStageFiles path action =\n    do  let stdin = \"\"\n        [baseTmpRaw, localTmpRaw, remoteTmpRaw] <-\n            take 3 . words <$>\n            readProcess \"git\" [\"checkout-index\", \"--stage=all\", \"--\", path] stdin\n        cdup <-\n            takeWhile (\/= '\\0') . stripNewline <$>\n            readProcess \"git\" [\"rev-parse\", \"--show-cdup\"] stdin\n        let maybePath \".\" = Nothing\n            maybePath p = Just (cdup <\/> p)\n        let mLocalTmp = maybePath localTmpRaw\n            mRemoteTmp = maybePath remoteTmpRaw\n            baseTmp = cdup <\/> baseTmpRaw\n        action baseTmp mLocalTmp mRemoteTmp\n            `E.finally`\n            do  removeFile baseTmp\n                traverse_ removeFile mLocalTmp\n                traverse_ removeFile mRemoteTmp","function_tokens":["withAllStageFiles","path","action","=","do","let","stdin","=","\"\"","[","baseTmpRaw",",","localTmpRaw",",","remoteTmpRaw","]","<-","take","3",".","words","<$>","readProcess","\"git\"","[","\"checkout-index\"",",","\"--stage=all\"",",","\"--\"",",","path","]","stdin","cdup","<-","takeWhile","(","\/=","'\\0'",")",".","stripNewline","<$>","readProcess","\"git\"","[","\"rev-parse\"",",","\"--show-cdup\"","]","stdin","let","maybePath","\".\"","=","Nothing","maybePath","p","=","Just","(","cdup","<\/>","p",")","let","mLocalTmp","=","maybePath","localTmpRaw","mRemoteTmp","=","maybePath","remoteTmpRaw","baseTmp","=","cdup","<\/>","baseTmpRaw","action","baseTmp","mLocalTmp","mRemoteTmp","`","E","finally","`","do","removeFile","baseTmp","traverse_","removeFile","mLocalTmp","traverse_","removeFile","mRemoteTmp"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L146-L165","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withHead","parameters":"f (x : xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withHead f (x : xs) = f x : xs","function_tokens":["withHead","f","(","x",":","xs",")","=","f","x",":","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L176-L176","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"vars","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vars      = take i vars1 ++ [v] ++ drop (i + 1) vars1","function_tokens":["vars","=","take","i","vars1","++","[","v","]","++","drop","(","i","+","1",")","vars1"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L550-L550","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"context","parameters":"(DynamicallySorted s v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"context (DynamicallySorted s v) = case match v of\n            Just (Var n _) -> (n, DynamicSort s)\n            _              -> error \"impossible error\"","function_tokens":["context","(","DynamicallySorted","s","v",")","=","case","match","v","of","Just","(","Var","n","_",")","->","(","n",",","DynamicSort","s",")","_","->","error","\"impossible error\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L584-L588","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"itraverse","parameters":"f (InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (InR gb) = InR <$> itraverse f gb","function_tokens":["itraverse","f","(","InR","gb",")","=","InR","<$>","itraverse","f","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L96-L96","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ifold","parameters":"(Add as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Add as)  = mconcat as","function_tokens":["ifold","(","Add","as",")","=","mconcat","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L83-L83","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"defaultConfig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultConfig = Config\n    { indent        = 4\n    , sort          = True\n    , separateLists = True\n    , breakWhere    = Exports\n    , openBracket   = NextLine\n    }","function_tokens":["defaultConfig","=","Config","{","indent","=","4",",","sort","=","True",",","separateLists","=","True",",","breakWhere","=","Exports",",","openBracket","=","NextLine","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L57-L63","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"binLength","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"binLength = B.length . T.encodeUtf8 . getEntryName","function_tokens":["binLength","=","B","length",".","T","encodeUtf8",".","getEntryName"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L107-L107","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getMData","parameters":"nPoints","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getMData nPoints = do\n  [mMin, mMax] <- replicateM 2 getFloat64le\n  ms           <- replicateM nPoints getFloat64le\n  return (mMin, mMax, ms)\n\n-- | Recurring pattern of Z-valued data (same structure as M-valued data)","function_tokens":["getMData","nPoints","=","do","[","mMin",",","mMax","]","<-","replicateM","2","getFloat64le","ms","<-","replicateM","nPoints","getFloat64le","return","(","mMin",",","mMax",",","ms",")","-- | Recurring pattern of Z-valued data (same structure as M-valued data)"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L230-L236","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"forall'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forall' = do\n            _   <- char '(' *> string \"forall\" *> space *> char '('\n            vs  <- var' `sepBy1` space\n            _   <- char ')' *> space\n            phi <- local (union (fromList $ map context vs)) r\n            _   <- char ')'\n            forall'' vs phi","function_tokens":["forall'","=","do","_","<-","char","'('","*>","string","\"forall\"","*>","space","*>","char","'('","vs","<-","var'","`","sepBy1","`","space","_","<-","char","')'","*>","space","phi","<-","local","(","union","(","fromList","$","map","context","vs",")",")","r","_","<-","char","')'","forall''","vs","phi"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L569-L577","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = defaultMain\n  [ Error.benchmark\n  , Interpret.benchmark\n  , NonDet.benchmark\n  , Reader.benchmark\n  , State.benchmark\n  , Writer.benchmark\n  ]","function_tokens":["main","=","defaultMain","[","Error","benchmark",",","Interpret","benchmark",",","NonDet","benchmark",",","Reader","benchmark",",","State","benchmark",",","Writer","benchmark","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench.hs#L14-L21","hash_key":"fused-effects\/fused-effects:benchmark\/Bench.hs","hash_val":22055,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Common.hs","language":"haskell","identifier":"destPath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"destPath = fromMaybe iconFilename mbDestPath","function_tokens":["destPath","=","fromMaybe","iconFilename","mbDestPath"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Common.hs#L40-L40","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Common.hs","hash_val":33449,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Environment.hs","language":"haskell","identifier":"getConflictStyle","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getConflictStyle =\n    do  (exitCode, output, _) <- readProcessWithExitCode \"git\" [\"config\", \"merge.conflictstyle\"] stdin\n        case exitCode of\n            ExitSuccess -> pure $ stripNewline output\n            ExitFailure 1 -> pure \"unset\"\n            ExitFailure _ -> E.throwIO exitCode\n    where\n        stdin = \"\"","function_tokens":["getConflictStyle","=","do","(","exitCode",",","output",",","_",")","<-","readProcessWithExitCode","\"git\"","[","\"config\"",",","\"merge.conflictstyle\"","]","stdin","case","exitCode","of","ExitSuccess","->","pure","$","stripNewline","output","ExitFailure","1","->","pure","\"unset\"","ExitFailure","_","->","E","throwIO","exitCode","where","stdin","=","\"\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Environment.hs#L27-L36","hash_key":"Peaker\/git-mediate:src\/Environment.hs","hash_val":17949,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"many1","parameters":"","argument_list":"","return_statement":"","docstring":"Matches one or more times.","docstring_summary":"Matches one or more times.","docstring_tokens":["Matches","one","or","more","times","."],"function":"many1 = A.many1","function_tokens":["many1","=","A","many1"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L101-L101","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"removeCpp","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"removeCpp s = if GHC.xopt LangExt.Cpp dynFlags1 then unCpp s else s","function_tokens":["removeCpp","s","=","if","GHC","xopt","LangExt","Cpp","dynFlags1","then","unCpp","s","else","s"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L83-L83","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"rootRelativeFiles","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rootRelativeFiles =\n              filterM (fmap not . isDirectory) . map (rootDir <\/>)","function_tokens":["rootRelativeFiles","=","filterM","(","fmap","not",".","isDirectory",")",".","map","(","rootDir","<\/>",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L218-L219","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"route","parameters":"_ context subserver","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"route _ context subserver\n    = route (Proxy :: Proxy sublayout) context (addBodyCheck subserver ct go)\n    where\n      lookupSig = lookup \"X-Hub-Signature\"\n\n      keyIndex :: Demote key\n      keyIndex = reflect (Proxy :: Proxy key)\n\n      ct :: DelayedIO (BS.ByteString, Maybe BS.ByteString, result)\n      ct = withRequest $ \\req -> do\n        let hdrs = requestHeaders req\n        let contentTypeH =\n              fromMaybe \"application\/octet-stream\" $ lookup hContentType hdrs\n\n        msg <- liftIO (toStrict <$> strictRequestBody req)\n\n        let mrqbody =\n              handleCTypeH (Proxy :: Proxy list) (cs contentTypeH) $\n              fromStrict msg\n\n        case mrqbody of\n          Nothing -> delayedFailFatal err415\n          Just (Left e) -> delayedFailFatal err400 { errBody = cs e }\n          Just (Right v) -> pure (msg, lookupSig hdrs, v)\n\n      go\n        :: (BS.ByteString, Maybe BS.ByteString, result)\n        -> DelayedIO (Demote key, result)\n      go tup@(_msg, _hdr, v) = do\n        keyM <- liftIO (unGitHubKey (getContextEntry context) keyIndex v)\n        case keyM of\n            Nothing -> delayedFailFatal err401\n            Just key -> verifySigWithKey tup key\n\n      verifySigWithKey\n            :: (BS.ByteString, Maybe BS.ByteString, result)\n            -> BS.ByteString\n            -> DelayedIO (Demote key, result)\n      verifySigWithKey (msg, hdr, v) key = do\n        let sig =\n              B16.encode $ convert $ hmacGetDigest (hmac key msg :: HMAC SHA1)\n\n        case parseHeaderMaybe =<< hdr of\n          Nothing -> delayedFailFatal err401\n          Just h -> do\n            let h' = BS.drop 5 $ E.encodeUtf8 h -- remove \"sha1=\" prefix\n            if constEq h' sig\n            then pure (keyIndex, v)\n            else delayedFailFatal err401","function_tokens":["route","_","context","subserver","=","route","(","Proxy","::","Proxy","sublayout",")","context","(","addBodyCheck","subserver","ct","go",")","where","lookupSig","=","lookup","\"X-Hub-Signature\"","keyIndex","::","Demote","key","keyIndex","=","reflect","(","Proxy","::","Proxy","key",")","ct","::","DelayedIO","(","BS","ByteString",",","Maybe","BS","ByteString",",","result",")","ct","=","withRequest","$","\\","req","->","do","let","hdrs","=","requestHeaders","req","let","contentTypeH","=","fromMaybe","\"application\/octet-stream\"","$","lookup","hContentType","hdrs","msg","<-","liftIO","(","toStrict","<$>","strictRequestBody","req",")","let","mrqbody","=","handleCTypeH","(","Proxy","::","Proxy","list",")","(","cs","contentTypeH",")","$","fromStrict","msg","case","mrqbody","of","Nothing","->","delayedFailFatal","err415","Just","(","Left","e",")","->","delayedFailFatal","err400","{","errBody","=","cs","e","}","Just","(","Right","v",")","->","pure","(","msg",",","lookupSig","hdrs",",","v",")","go","::","(","BS","ByteString",",","Maybe","BS","ByteString",",","result",")","->","DelayedIO","(","Demote","key",",","result",")","go","tup","@","(","_msg",",","_hdr",",","v",")","=","do","keyM","<-","liftIO","(","unGitHubKey","(","getContextEntry","context",")","keyIndex","v",")","case","keyM","of","Nothing","->","delayedFailFatal","err401","Just","key","->","verifySigWithKey","tup","key","verifySigWithKey","::","(","BS","ByteString",",","Maybe","BS","ByteString",",","result",")","->","BS","ByteString","->","DelayedIO","(","Demote","key",",","result",")","verifySigWithKey","(","msg",",","hdr",",","v",")","key","=","do","let","sig","=","B16","encode","$","convert","$","hmacGetDigest","(","hmac","key","msg","::","HMAC","SHA1",")","case","parseHeaderMaybe","=<<","hdr","of","Nothing","->","delayedFailFatal","err401","Just","h","->","do","let","h'","=","BS","drop","5","$","E","encodeUtf8","h","-- remove \"sha1=\" prefix","if","constEq","h'","sig","then","pure","(","keyIndex",",","v",")","else","delayedFailFatal","err401"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L282-L332","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main =\n  do  opts <- Opts.getOpts\n      colorEnable <- maybe shouldUseColorByTerminal pure (shouldUseColor opts)\n      checkConflictStyle opts\n      case mergeSpecificFile opts of\n          Nothing -> mediateAll colorEnable opts\n          Just path -> resolve colorEnable opts path\n          >>= exitProcess","function_tokens":["main","=","do","opts","<-","Opts","getOpts","colorEnable","<-","maybe","shouldUseColorByTerminal","pure","(","shouldUseColor","opts",")","checkConflictStyle","opts","case","mergeSpecificFile","opts","of","Nothing","->","mediateAll","colorEnable","opts","Just","path","->","resolve","colorEnable","opts","path",">>=","exitProcess"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L263-L270","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"toRows","parameters":"mat","argument_list":"","return_statement":"","docstring":"O(m) Return the rows","docstring_summary":"O(m) Return the rows","docstring_tokens":["O","(","m",")","Return","the","rows"],"function":"toRows mat = map (unsafeTakeRow mat) [0..r-1]\n  where\n    (r,_) = dim mat","function_tokens":["toRows","mat","=","map","(","unsafeTakeRow","mat",")","[","0","..","r","-","1","]","where","(","r",",","_",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L172-L175","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"SymbolLine","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go SymbolLine               = \"\"","function_tokens":["go","SymbolLine","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L424-L424","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"ow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ow = w `mappend` nw","function_tokens":["ow","=","w","`","mappend","`","nw"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L196-L196","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"unifiable","parameters":"x y","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unifiable x y =\n  case (x, y) of\n    ( VarT _        ,      _        ) -> True\n    ( _             , VarT _        ) -> True\n    ( AppT a b      , AppT c d      ) -> unifiable a c && unifiable b d\n    ( SigT t k      , SigT s j      ) -> unifiable t s && k == j\n    ( ForallT _ _ t , ForallT _ _ s ) -> unifiable t s\n    ( a             , b             ) -> a == b","function_tokens":["unifiable","x","y","=","case","(","x",",","y",")","of","(","VarT","_",",","_",")","->","True","(","_",",","VarT","_",")","->","True","(","AppT","a","b",",","AppT","c","d",")","->","unifiable","a","c","&&","unifiable","b","d","(","SigT","t","k",",","SigT","s","j",")","->","unifiable","t","s","&&","k","==","j","(","ForallT","_","_","t",",","ForallT","_","_","s",")","->","unifiable","t","s","(","a",",","b",")","->","a","==","b"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L406-L415","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"f","parameters":"'x' 'y'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f 'x' 'y' = '|'","function_tokens":["f","'x'","'y'","=","'|'"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L71-L71","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"makeIbs","parameters":"lbs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeIbs lbs = F.unsafeLocalState $ do\n  wb <- allocWorkBuffers (32 * 1024 * 1204)\n  ws <- allocWorkState\n  IO.unsafeInterleaveIO $ go wb ws (LBS.toChunks lbs)\n  where go :: WorkBuffers -> WorkState -> [BS.ByteString] -> IO [(BS.ByteString, BS.ByteString, BS.ByteString)]\n        go _  _  []       = return []\n        go wb ws (bs:bss) = do\n          let resLen = BS.length bs `div` 8\n          resIbFptr  <- F.mallocForeignPtrBytes resLen\n          resAFptr   <- F.mallocForeignPtrBytes resLen\n          resBFptr   <- F.mallocForeignPtrBytes resLen\n          let resIbPtr  = F.castPtr (F.unsafeForeignPtrToPtr resIbFptr)\n          let resAPtr   = F.castPtr (F.unsafeForeignPtrToPtr resAFptr )\n          let resBPtr   = F.castPtr (F.unsafeForeignPtrToPtr resBFptr )\n          let (bsFptr, bsOff, bsLen) = BSI.toForeignPtr bs\n          let bsPtr = F.castPtr (F.unsafeForeignPtrToPtr bsFptr)\n          _ <- F.processChunk\n            (F.plusPtr bsPtr bsOff) -- in_buffer:           Ptr UInt8\n            (fromIntegral bsLen)    -- in_length:           Size\n            (workBuffersD wb)       -- work_bits_of_d:      Ptr UInt8\n            (workBuffersA wb)       -- work_bits_of_a:      Ptr UInt8\n            (workBuffersZ wb)       -- work_bits_of_z:      Ptr UInt8\n            (workBuffersQ wb)       -- work_bits_of_q:      Ptr UInt8\n            (workBuffersB wb)       -- work_bits_of_b:      Ptr UInt8\n            (workBuffersE wb)       -- work_bits_of_e:      Ptr UInt8\n            (workStateZ ws)         -- last_trailing_ones:  Ptr Size\n            (workStateO ws)         -- quote_odds_carry:    Ptr Size\n            (workStateE ws)         -- quote_evens_carry:   Ptr Size\n            (workStateM ws)         -- quote_mask_carry:    Ptr UInt64\n            resIbPtr                -- result_ibs:          Ptr UInt8\n            resAPtr                 -- result_a:            Ptr UInt8\n            resBPtr                 -- result_z:            Ptr UInt8\n          let r =\n                ( BSI.fromForeignPtr resIbFptr 0 resLen\n                , BSI.fromForeignPtr resAFptr  0 resLen\n                , BSI.fromForeignPtr resBFptr  0 resLen\n                )\n          rs <- IO.unsafeInterleaveIO $ go wb ws bss\n          return (r:rs)","function_tokens":["makeIbs","lbs","=","F","unsafeLocalState","$","do","wb","<-","allocWorkBuffers","(","32","*","1024","*","1204",")","ws","<-","allocWorkState","IO","unsafeInterleaveIO","$","go","wb","ws","(","LBS","toChunks","lbs",")","where","go","::","WorkBuffers","->","WorkState","->","[","BS","ByteString","]","->","IO","[","(","BS","ByteString",",","BS","ByteString",",","BS","ByteString",")","]","go","_","_","[","]","=","return","[","]","go","wb","ws","(","bs",":","bss",")","=","do","let","resLen","=","BS","length","bs","`","div","`","8","resIbFptr","<-","F","mallocForeignPtrBytes","resLen","resAFptr","<-","F","mallocForeignPtrBytes","resLen","resBFptr","<-","F","mallocForeignPtrBytes","resLen","let","resIbPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resIbFptr",")","let","resAPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resAFptr",")","let","resBPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBFptr",")","let","(","bsFptr",",","bsOff",",","bsLen",")","=","BSI","toForeignPtr","bs","let","bsPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","bsFptr",")","_","<-","F","processChunk","(","F","plusPtr","bsPtr","bsOff",")","-- in_buffer:           Ptr UInt8","(","fromIntegral","bsLen",")","-- in_length:           Size","(","workBuffersD","wb",")","-- work_bits_of_d:      Ptr UInt8","(","workBuffersA","wb",")","-- work_bits_of_a:      Ptr UInt8","(","workBuffersZ","wb",")","-- work_bits_of_z:      Ptr UInt8","(","workBuffersQ","wb",")","-- work_bits_of_q:      Ptr UInt8","(","workBuffersB","wb",")","-- work_bits_of_b:      Ptr UInt8","(","workBuffersE","wb",")","-- work_bits_of_e:      Ptr UInt8","(","workStateZ","ws",")","-- last_trailing_ones:  Ptr Size","(","workStateO","ws",")","-- quote_odds_carry:    Ptr Size","(","workStateE","ws",")","-- quote_evens_carry:   Ptr Size","(","workStateM","ws",")","-- quote_mask_carry:    Ptr UInt64","resIbPtr","-- result_ibs:          Ptr UInt8","resAPtr","-- result_a:            Ptr UInt8","resBPtr","-- result_z:            Ptr UInt8","let","r","=","(","BSI","fromForeignPtr","resIbFptr","0","resLen",",","BSI","fromForeignPtr","resAFptr","0","resLen",",","BSI","fromForeignPtr","resBFptr","0","resLen",")","rs","<-","IO","unsafeInterleaveIO","$","go","wb","ws","bss","return","(","r",":","rs",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L43-L83","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pushQuantifier'","parameters":"c vs a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushQuantifier' c vs a = do\n    (ns, q) <- get\n\n    let (vs', ns') = rename ns vs\n        q'         = c vs' . q\n        sub        = mconcat $ zipWith (\\(IFix (Var n s)) (IFix (Var n' _)) -> inject (Var n' s) `for` inject (Var n s)) vs vs'\n\n    put (ns', q')\n\n    return $ a `substitute` sub","function_tokens":["pushQuantifier'","c","vs","a","=","do","(","ns",",","q",")","<-","get","let","(","vs'",",","ns'",")","=","rename","ns","vs","q'","=","c","vs'",".","q","sub","=","mconcat","$","zipWith","(","\\","(","IFix","(","Var","n","s",")",")","(","IFix","(","Var","n'","_",")",")","->","inject","(","Var","n'","s",")","`","for","`","inject","(","Var","n","s",")",")","vs","vs'","put","(","ns'",",","q'",")","return","$","a","`","substitute","`","sub"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L720-L731","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"f","parameters":"l","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f l = drop (length (takeWhile both l) - contextLen) l","function_tokens":["f","l","=","drop","(","length","(","takeWhile","both","l",")","-","contextLen",")","l"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L46-L46","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"makeGetter","parameters":"dict name source","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeGetter dict name source =\n   allocaArray (size dict) $ \\buf -> do\n      alGetter dict source (marshalGetPName name) buf\n      peekSize dict buf","function_tokens":["makeGetter","dict","name","source","=","allocaArray","(","size","dict",")","$","\\","buf","->","do","alGetter","dict","source","(","marshalGetPName","name",")","buf","peekSize","dict","buf"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L579-L584","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"bufferData","parameters":"buffer","argument_list":"","return_statement":"","docstring":"A special case of buffer state is the actual sound sample data stored in association with the buffer. Applications can specify sample data using 'bufferData'.  The data specified is copied to an internal software, or if possible, hardware buffer. The implementation is free to apply decompression, conversion, resampling, and filtering as needed. The internal format of the buffer is not exposed to the application, and not accessible.  Buffers containing audio data with more than one channel will be played without 3D spatialization features, these formats are normally used for background music. Applications should always check for an error condition after attempting to specify buffer data in case an implementation has to generate an 'ALOutOfMemory' or a conversion related 'ALInvalidValue' error. The application is free to reuse the memory specified by the data pointer once 'bufferData' is set. The implementation has to dereference, e.g. copy, the data while accessing 'bufferData' execution.","docstring_summary":"A special case of buffer state is the actual sound sample data stored in association with the buffer. Applications can specify sample data using 'bufferData'.  The data specified is copied to an internal software, or if possible, hardware buffer. The implementation is free to apply decompression, conversion, resampling, and filtering as needed. The internal format of the buffer is not exposed to the application, and not accessible.  Buffers containing audio data with more than one channel will be played without 3D spatialization features, these formats are normally used for background music. Applications should always check for an error condition after attempting to specify buffer data in case an implementation has to generate an 'ALOutOfMemory' or a conversion related 'ALInvalidValue' error. The application is free to reuse the memory specified by the data pointer once 'bufferData' is set. The implementation has to dereference, e.g. copy, the data while accessing 'bufferData' execution.","docstring_tokens":["A","special","case","of","buffer","state","is","the","actual","sound","sample","data","stored","in","association","with","the","buffer",".","Applications","can","specify","sample","data","using","bufferData",".","The","data","specified","is","copied","to","an","internal","software","or","if","possible","hardware","buffer",".","The","implementation","is","free","to","apply","decompression","conversion","resampling","and","filtering","as","needed",".","The","internal","format","of","the","buffer","is","not","exposed","to","the","application","and","not","accessible",".","Buffers","containing","audio","data","with","more","than","one","channel","will","be","played","without","3D","spatialization","features","these","formats","are","normally","used","for","background","music",".","Applications","should","always","check","for","an","error","condition","after","attempting","to","specify","buffer","data","in","case","an","implementation","has","to","generate","an","ALOutOfMemory","or","a","conversion","related","ALInvalidValue","error",".","The","application","is","free","to","reuse","the","memory","specified","by","the","data","pointer","once","bufferData","is","set",".","The","implementation","has","to","dereference","e",".","g",".","copy","the","data","while","accessing","bufferData","execution","."],"function":"bufferData buffer = makeStateVar (getBufferData buffer) (setBufferData buffer)","function_tokens":["bufferData","buffer","=","makeStateVar","(","getBufferData","buffer",")","(","setBufferData","buffer",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L122-L122","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Writer.hs","language":"haskell","identifier":"listens","parameters":"f","argument_list":"","return_statement":"","docstring":"Run a computation, applying a function to its output and returning the pair of the modified output and its result.  @ 'listens' f m = 'fmap' ('first' f) ('listen' m) @  @since 0.2.0.0","docstring_summary":"Run a computation, applying a function to its output and returning the pair of the modified output and its result.","docstring_tokens":["Run","a","computation","applying","a","function","to","its","output","and","returning","the","pair","of","the","modified","output","and","its","result","."],"function":"listens f = fmap (first f) . listen","function_tokens":["listens","f","=","fmap","(","first","f",")",".","listen"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Writer.hs#L68-L68","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Writer.hs","hash_val":30433,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = []","function_tokens":["reflect","_","=","[","]"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L395-L395","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"lookup","parameters":"k t","argument_list":"","return_statement":"","docstring":"'lookup' is used by 'intersection' for left-biasing","docstring_summary":"'lookup' is used by 'intersection' for left-biasing","docstring_tokens":["lookup","is","used","by","intersection","for","left","-","biasing"],"function":"lookup k t\n  = let nk = natFromInt k  in seq nk (lookupN nk t)","function_tokens":["lookup","k","t","=","let","nk","=","natFromInt","k","in","seq","nk","(","lookupN","nk","t",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L278-L279","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"ne","parameters":"(x : xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ne (x : xs) = [x :| xs]","function_tokens":["ne","(","x",":","xs",")","=","[","x",":|","xs","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L103-L103","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"liftIO","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO = lift . liftIO","function_tokens":["liftIO","=","lift",".","liftIO"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L127-L127","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"mkAppImage","parameters":"exeFile di DesktopExists","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkAppImage exeFile di DesktopExists = do\n  let desktopArg = Arg (\"--desktop-file=\" <>\n        (desktopDir <\/> op ExeFile exeFile <.> \"desktop\"))\n  mkAppImage' exeFile di desktopArg","function_tokens":["mkAppImage","exeFile","di","DesktopExists","=","do","let","desktopArg","=","Arg","(","\"--desktop-file=\"","<>","(","desktopDir","<\/>","op","ExeFile","exeFile","<.>","\"desktop\"",")",")","mkAppImage'","exeFile","di","desktopArg"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L53-L58","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"reduce","parameters":"z zs _ px tx Nada","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reduce z zs _ px tx Nada = work z zs (Push px tx Nada)","function_tokens":["reduce","z","zs","_","px","tx","Nada","=","work","z","zs","(","Push","px","tx","Nada",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L748-L748","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"store'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"store' = do\n            _ <- char '(' *> string \"store\"  *> space\n            a <- r\n            _ <- space\n            i <- r\n            _ <- space\n            v <- r\n            _ <- char ')'\n            store'' a i v","function_tokens":["store'","=","do","_","<-","char","'('","*>","string","\"store\"","*>","space","a","<-","r","_","<-","space","i","<-","r","_","<-","space","v","<-","r","_","<-","char","')'","store''","a","i","v"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L87-L97","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"add'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"add' = do\n            _  <- char '(' *> char '+' *> space\n            as <- r `sepBy1` space\n            _  <- char ')'\n            add'' as","function_tokens":["add'","=","do","_","<-","char","'('","*>","char","'+'","*>","space","as","<-","r","`","sepBy1","`","space","_","<-","char","')'","add''","as"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L106-L112","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Locrian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Locrian      = \"locrian\"","function_tokens":["go","Locrian","=","\"locrian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L536-L536","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookPageBuildEvent","function_tokens":["reflect","_","=","WebhookPageBuildEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L451-L451","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unzip6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip6 = MG.unzip6","function_tokens":["unzip6","=","MG","unzip6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L366-L366","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand 2 = liftM2 STORE parseSerialize parseSerialize","function_tokens":["parseCommand","2","=","liftM2","STORE","parseSerialize","parseSerialize"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L126-L126","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"InternedText i _ == InternedText j _ = i == j","function_tokens":["InternedText","i","_","==","InternedText","j","_","=","i","==","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L21-L21","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Strict.hs","language":"haskell","identifier":"lift","parameters":"ma","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift ma = AccumC $ \\_ -> (mempty, ) <$> ma","function_tokens":["lift","ma","=","AccumC","$","\\","_","->","(","mempty",",",")","<$>","ma"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Strict.hs#L80-L80","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Strict.hs","hash_val":7030,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"makeFormat","parameters":"2 16","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeFormat 2 16 = Stereo16","function_tokens":["makeFormat","2","16","=","Stereo16"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L147-L147","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"patsLocs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"patsLocs   = map GHC.getLocA pats","function_tokens":["patsLocs","=","map","GHC","getLocA","pats"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L118-L118","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"dist","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dist = zip (fmap (_shape) districts) (map (show . view lens) districts)","function_tokens":["dist","=","zip","(","fmap","(","_shape",")","districts",")","(","map","(","show",".","view","lens",")","districts",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L50-L50","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty _ = \"{Directive}\"","function_tokens":["pretty","_","=","\"{Directive}\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L573-L573","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Environment.hs","language":"haskell","identifier":"shouldUseColorByTerminal","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"shouldUseColorByTerminal =\n    hSupportsANSI stdout\n    <&> \\istty -> if istty then EnableColor else DisableColor","function_tokens":["shouldUseColorByTerminal","=","hSupportsANSI","stdout","<&>","\\","istty","->","if","istty","then","EnableColor","else","DisableColor"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Environment.hs#L22-L24","hash_key":"Peaker\/git-mediate:src\/Environment.hs","hash_val":17949,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"nextMultiline","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nextMultiline = isCpp && not (null x) && last x == '\\\\'","function_tokens":["nextMultiline","=","isCpp","&&","not","(","null","x",")","&&","last","x","==","'\\\\'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L46-L46","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"file","parameters":"sa conf mfp","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"file sa conf mfp = do\n    contents <- maybe getContents readUTF8File mfp\n    let\n      inputLines =\n        lines contents\n      result =\n        runSteps (configLanguageExtensions conf) mfp (configSteps conf) inputLines\n    case result of\n        Right ok  -> do\n            write contents (unlines ok)\n            pure $ if ok \/= inputLines then DidFormat else NoChange\n        Left  err -> do\n            IO.hPutStrLn IO.stderr err\n            exitFailure\n  where\n    write old new = case mfp of\n                Nothing -> putStrNewline new\n                Just _    | not (saInPlace sa) -> putStrNewline new\n                Just path | not (null new) && old \/= new  ->\n                    IO.withFile path IO.WriteMode $ \\h -> do\n                        setNewlineMode h\n                        IO.hPutStr h new\n                _ -> return ()\n    setNewlineMode h = do\n      let nl = configNewline conf\n      let mode = IO.NewlineMode IO.nativeNewline nl\n      IO.hSetNewlineMode h mode\n    putStrNewline txt = setNewlineMode IO.stdout >> putStr txt","function_tokens":["file","sa","conf","mfp","=","do","contents","<-","maybe","getContents","readUTF8File","mfp","let","inputLines","=","lines","contents","result","=","runSteps","(","configLanguageExtensions","conf",")","mfp","(","configSteps","conf",")","inputLines","case","result","of","Right","ok","->","do","write","contents","(","unlines","ok",")","pure","$","if","ok","\/=","inputLines","then","DidFormat","else","NoChange","Left","err","->","do","IO","hPutStrLn","IO","stderr","err","exitFailure","where","write","old","new","=","case","mfp","of","Nothing","->","putStrNewline","new","Just","_","|","not","(","saInPlace","sa",")","->","putStrNewline","new","Just","path","|","not","(","null","new",")","&&","old","\/=","new","->","IO","withFile","path","IO","WriteMode","$","\\","h","->","do","setNewlineMode","h","IO","hPutStr","h","new","_","->","return","(",")","setNewlineMode","h","=","do","let","nl","=","configNewline","conf","let","mode","=","IO","NewlineMode","IO","nativeNewline","nl","IO","hSetNewlineMode","h","mode","putStrNewline","txt","=","setNewlineMode","IO","stdout",">>","putStr","txt"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L146-L175","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"imap","parameters":"f (Or os)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Or os) = Or  $ map f os","function_tokens":["imap","f","(","Or","os",")","=","Or","$","map","f","os"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L356-L356","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"conIndices","parameters":"(AppT rest     ty)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"conIndices (AppT rest     ty) = conIndices rest ++ [ty]","function_tokens":["conIndices","(","AppT","rest","ty",")","=","conIndices","rest","++","[","ty","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L401-L401","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"deleteMin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteMin = maybe (error \"deleteMin: empty set has no minimal element\") snd . minView","function_tokens":["deleteMin","=","maybe","(","error","\"deleteMin: empty set has no minimal element\"",")","snd",".","minView"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L662-L662","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Errors.hs","language":"haskell","identifier":"unmarshalALCErrorCategory","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalALCErrorCategory x\n   | x == alc_INVALID_ENUM = ALCInvalidEnum\n   | x == alc_INVALID_VALUE = ALCInvalidValue\n   | x == alc_INVALID_OPERATION = ALCInvalidOperation\n   | x == alc_INVALID_DEVICE = ALCInvalidDevice\n   | x == alc_INVALID_CONTEXT = ALCInvalidContext\n   | x == alc_OUT_OF_MEMORY = ALCOutOfMemory\n   | otherwise = error (\"unmarshalALCErrorCategory: illegal value \" ++ show x)","function_tokens":["unmarshalALCErrorCategory","x","|","x","==","alc_INVALID_ENUM","=","ALCInvalidEnum","|","x","==","alc_INVALID_VALUE","=","ALCInvalidValue","|","x","==","alc_INVALID_OPERATION","=","ALCInvalidOperation","|","x","==","alc_INVALID_DEVICE","=","ALCInvalidDevice","|","x","==","alc_INVALID_CONTEXT","=","ALCInvalidContext","|","x","==","alc_OUT_OF_MEMORY","=","ALCOutOfMemory","|","otherwise","=","error","(","\"unmarshalALCErrorCategory: illegal value \"","++","show","x",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Errors.hs#L56-L63","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Errors.hs","hash_val":42696,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"vars","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vars    = head $ map (\\(LabelExpr v _ _ _) -> v) labels","function_tokens":["vars","=","head","$","map","(","\\","(","LabelExpr","v","_","_","_",")","->","v",")","labels"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L143-L143","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"toLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) List of lists","docstring_summary":"O(m*n) List of lists","docstring_tokens":["O","(","m","*","n",")","List","of","lists"],"function":"toLists = MG.toLists","function_tokens":["toLists","=","MG","toLists"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L182-L182","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"execState","parameters":"s","argument_list":"","return_statement":"","docstring":"Run a lazy 'State' effect, yielding the final state and discarding the return value.  @ 'execState' s m = 'fmap' 'fst' ('runState' s m) @  @since 1.0.0.0","docstring_summary":"Run a lazy 'State' effect, yielding the final state and discarding the return value.","docstring_tokens":["Run","a","lazy","State","effect","yielding","the","final","state","and","discarding","the","return","value","."],"function":"execState s = fmap fst . runState s","function_tokens":["execState","s","=","fmap","fst",".","runState","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L70-L70","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"intFromNat","parameters":"w","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"intFromNat w = fromIntegral w","function_tokens":["intFromNat","w","=","fromIntegral","w"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L143-L143","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"app\/App\/Commands\/CreateIndex.hs","language":"haskell","identifier":"runCreateIndex","parameters":"opts","argument_list":"","return_statement":"","docstring":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_summary":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_tokens":["{","-","HLINT","ignore","Reduce","duplication","-","}","{","-","HLINT","ignore","Redundant","do","-","}"],"function":"runCreateIndex opts = do\n  let filePath      = opts ^. L.filePath\n  let outputIbFile  = opts ^. L.outputIbFile & fromMaybe (filePath <> \".ib.idx\")\n  let outputBpFile  = opts ^. L.outputBpFile & fromMaybe (filePath <> \".bp.idx\")\n  let method        = opts ^. L.method\n\n  case method of\n    \"simple\" -> do\n      IO.withFile filePath IO.ReadMode $ \\hIn -> do\n        contents <- LBS.resegmentPadded 512 <$> LBS.hGetContents hIn\n        let chunks = makeSimpleJsonIbBpsUnsafe contents\n        IO.withFile outputIbFile IO.WriteMode $ \\hIb -> do\n          IO.withFile outputBpFile IO.WriteMode $ \\hBp -> do\n            forM_ chunks $ \\(ibBs, bpBs) -> do\n              BS.hPut hIb ibBs\n              BS.hPut hBp bpBs\n    \"standard\" -> do\n      IO.withFile filePath IO.ReadMode $ \\hIn -> do\n        contents <- LBS.resegmentPadded 512 <$> LBS.hGetContents hIn\n        case makeStandardJsonIbBps contents of\n          Right chunks -> do\n            IO.withFile outputIbFile IO.WriteMode $ \\hIb -> do\n              IO.withFile outputBpFile IO.WriteMode $ \\hBp -> do\n                forM_ chunks $ \\(ibBs, bpBs) -> do\n                  BS.hPut hIb ibBs\n                  BS.hPut hBp bpBs\n          Left msg -> do\n            IO.hPutStrLn IO.stderr $ \"Unable to create index: \" <> show msg\n            IO.exitFailure\n    _ -> do\n      IO.hPutStrLn IO.stderr $ \"Unrecognised method: \" <> show method\n      IO.exitFailure","function_tokens":["runCreateIndex","opts","=","do","let","filePath","=","opts","^.","L","filePath","let","outputIbFile","=","opts","^.","L","outputIbFile","&","fromMaybe","(","filePath","<>","\".ib.idx\"",")","let","outputBpFile","=","opts","^.","L","outputBpFile","&","fromMaybe","(","filePath","<>","\".bp.idx\"",")","let","method","=","opts","^.","L","method","case","method","of","\"simple\"","->","do","IO","withFile","filePath","IO","ReadMode","$","\\","hIn","->","do","contents","<-","LBS","resegmentPadded","512","<$>","LBS","hGetContents","hIn","let","chunks","=","makeSimpleJsonIbBpsUnsafe","contents","IO","withFile","outputIbFile","IO","WriteMode","$","\\","hIb","->","do","IO","withFile","outputBpFile","IO","WriteMode","$","\\","hBp","->","do","forM_","chunks","$","\\","(","ibBs",",","bpBs",")","->","do","BS","hPut","hIb","ibBs","BS","hPut","hBp","bpBs","\"standard\"","->","do","IO","withFile","filePath","IO","ReadMode","$","\\","hIn","->","do","contents","<-","LBS","resegmentPadded","512","<$>","LBS","hGetContents","hIn","case","makeStandardJsonIbBps","contents","of","Right","chunks","->","do","IO","withFile","outputIbFile","IO","WriteMode","$","\\","hIb","->","do","IO","withFile","outputBpFile","IO","WriteMode","$","\\","hBp","->","do","forM_","chunks","$","\\","(","ibBs",",","bpBs",")","->","do","BS","hPut","hIb","ibBs","BS","hPut","hBp","bpBs","Left","msg","->","do","IO","hPutStrLn","IO","stderr","$","\"Unable to create index: \"","<>","show","msg","IO","exitFailure","_","->","do","IO","hPutStrLn","IO","stderr","$","\"Unrecognised method: \"","<>","show","method","IO","exitFailure"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/app\/App\/Commands\/CreateIndex.hs#L27-L60","hash_key":"haskell-works\/hw-json-simd:app\/App\/Commands\/CreateIndex.hs","hash_val":3932,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"joinBrokenLines","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"joinBrokenLines = unlines . parseLines","function_tokens":["joinBrokenLines","=","unlines",".","parseLines"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L55-L55","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(year', month, day) = toGregorian utctDay","function_tokens":["(","year'",",","month",",","day",")","=","toGregorian","utctDay"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1181-L1181","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"zero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zero = 0.0","function_tokens":["zero","=","0.0"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L61-L61","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"UserDefined","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go UserDefined              = (True, True, True, True)","function_tokens":["go","UserDefined","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L391-L391","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"imapM_","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_summary":"O(m*n) Apply the monadic action to every element and its index, ignoring the results.","docstring_tokens":["O","(","m","*","n",")","Apply","the","monadic","action","to","every","element","and","its","index","ignoring","the","results","."],"function":"imapM_ = MG.imapM_","function_tokens":["imapM_","=","MG","imapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L248-L248","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"varNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"varNames  = nameFromBinder <$> dtBinders","function_tokens":["varNames","=","nameFromBinder","<$>","dtBinders"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L566-L566","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Monadic.hs","language":"haskell","identifier":"asks","parameters":"","argument_list":"","return_statement":"","docstring":"Fetch a value pointed to by a lens out of a reader environment.","docstring_summary":"Fetch a value pointed to by a lens out of a reader environment.","docstring_tokens":["Fetch","a","value","pointed","to","by","a","lens","out","of","a","reader","environment","."],"function":"asks = Reader.asks . Total.get","function_tokens":["asks","=","Reader","asks",".","Total","get"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Monadic.hs#L59-L59","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Monadic.hs","hash_val":31581,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"_ Choose ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg _ Choose ctx = (True <$ ctx) :| [ False <$ ctx ]","function_tokens":["alg","_","Choose","ctx","=","(","True","<$","ctx",")",":|","[","False","<$","ctx","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L154-L154","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"fieldAllowedInline","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldAllowedInline       a = r where (_,_,_,r) = fieldAllowed a","function_tokens":["fieldAllowedInline","a","=","r","where","(","_",",","_",",","_",",","r",")","=","fieldAllowed","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L400-L402","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"evalRSST","parameters":"m r s","argument_list":"","return_statement":"","docstring":"^computation yielding final value and output","docstring_summary":"^computation yielding final value and output","docstring_tokens":["^computation","yielding","final","value","and","output"],"function":"evalRSST m r s = do\n    (a, _, w) <- runRSST m r s\n    return (a, w)\n\n-- | Evaluate a computation with the given initial state and environment,\n-- returning the final state and output, discarding the final value.","function_tokens":["evalRSST","m","r","s","=","do","(","a",",","_",",","w",")","<-","runRSST","m","r","s","return","(","a",",","w",")","-- | Evaluate a computation with the given initial state and environment,","-- returning the final state and output, discarding the final value."],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L98-L104","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"sinkingKeys","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sinkingKeys = M.keys $ sinking `M.difference` copiedCD","function_tokens":["sinkingKeys","=","M","keys","$","sinking","`","M","difference","`","copiedCD"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L285-L285","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapRest'","parameters":"ls ss (str:strs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapRest' ls ss (str:strs)\n        | null ss = wrapRest' ls (indent ind str) strs\n        | overflows ss str = wrapRest' (ss:ls) \"\" (str:strs)\n        | otherwise = wrapRest' ls (ss ++ \" \" ++ str) strs","function_tokens":["wrapRest'","ls","ss","(","str",":","strs",")","|","null","ss","=","wrapRest'","ls","(","indent","ind","str",")","strs","|","overflows","ss","str","=","wrapRest'","(","ss",":","ls",")","\"\"","(","str",":","strs",")","|","otherwise","=","wrapRest'","ls","(","ss","++","\" \"","++","str",")","strs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L142-L145","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"scale","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"scale = (1\/4*pi)","function_tokens":["scale","=","(","1","\/","4","*","pi",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L38-L38","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"toLists","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) List of lists","docstring_summary":"O(m*n) List of lists","docstring_tokens":["O","(","m","*","n",")","List","of","lists"],"function":"toLists = MG.toLists","function_tokens":["toLists","=","MG","toLists"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L182-L182","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pushQuantifier","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushQuantifier (InL fa) = pushQuantifier fa","function_tokens":["pushQuantifier","(","InL","fa",")","=","pushQuantifier","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L741-L741","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"sayLn","parameters":"message","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"sayLn message = say (message <> text \"\\n\")","function_tokens":["sayLn","message","=","say","(","message","<>","text","\"\\n\"",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L56-L56","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(*) = liftA2 (*)","function_tokens":["(","*",")","=","liftA2","(","*",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L233-L233","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"timeoutNode","parameters":"(KI _ (KS sTree _) _) id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"timeoutNode (KI _ (KS sTree _) _) id = atomically $ do\n    tree <- readTVar sTree\n    let (newTree, pingAgain) = T.handleTimeout tree id\n    writeTVar sTree newTree\n    return pingAgain\n\n-- | Lookup a Node in the NodeTree","function_tokens":["timeoutNode","(","KI","_","(","KS","sTree","_",")","_",")","id","=","atomically","$","do","tree","<-","readTVar","sTree","let","(","newTree",",","pingAgain",")","=","T","handleTimeout","tree","id","writeTVar","sTree","newTree","return","pingAgain","-- | Lookup a Node in the NodeTree"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L70-L77","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"compare","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compare = compare `on` identity","function_tokens":["compare","=","compare","`","on","`","identity"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L75-L75","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"imap","parameters":"f (Store  is es a i e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Store  is es a i e) = Store  is es (f a) (f i) (f e)","function_tokens":["imap","f","(","Store","is","es","a","i","e",")","=","Store","is","es","(","f","a",")","(","f","i",")","(","f","e",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L61-L61","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Cut.hs","language":"haskell","identifier":"call","parameters":"m","argument_list":"","return_statement":"","docstring":"Delimit the effect of 'cutfail's, allowing backtracking to resume.  @ 'call' 'cutfail' '<|>' m = m @  @since 0.1.2.0","docstring_summary":"Delimit the effect of 'cutfail's, allowing backtracking to resume.","docstring_tokens":["Delimit","the","effect","of","cutfail","s","allowing","backtracking","to","resume","."],"function":"call m = send (Call m)","function_tokens":["call","m","=","send","(","Call","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Cut.hs#L61-L61","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Cut.hs","hash_val":25056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"bench\/Benchmark.hs","language":"haskell","identifier":"getAge","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getAge = get age jan","function_tokens":["getAge","=","get","age","jan"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/bench\/Benchmark.hs#L27-L27","hash_key":"sebastiaanvisser\/fclabels:bench\/Benchmark.hs","hash_val":30845,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"queryModule","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"queryModule f = everything (++) (mkQ [] f)","function_tokens":["queryModule","f","=","everything","(","++",")","(","mkQ","[","]","f",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L133-L133","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = (:) <$> a <*> go <|> pure []","function_tokens":["go","=","(",":",")","<$>","a","<*>","go","<|>","pure","[","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L91-L91","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getField","parameters":"","argument_list":"","return_statement":"","docstring":"^ Read binary representation of Element","docstring_summary":"^ Read binary representation of Element","docstring_tokens":["^","Read","binary","representation","of","Element"],"function":"getField = do\n  t <- getTag\n  k <- getLabel\n  v <- case t of\n        0x01 -> Float <$> getDouble\n        0x02 -> String <$> getString\n        0x03 -> Doc <$> getDocument\n        0x04 -> Array <$> getArray\n        0x05 -> getBinary >>= \\(s, b) ->\n          case s of\n           0x00 -> return $ Bin (Binary b)\n           0x01 -> return $ Fun (Function b)\n           0x02 -> return $ Bin (Binary b)\n           0x03 -> return $ Uuid (UUID b)\n           0x04 -> return $ Uuid (UUID b)\n           0x05 -> return $ Md5 (MD5 b)\n           0x80 -> return $ UserDef (UserDefined b)\n           _ -> fail $ \"unknown Bson binary subtype \" ++ show s\n        0x06 -> return Null\n        0x07 -> ObjId <$> getObjectId\n        0x08 -> Bool <$> getBool\n        0x09 -> UTC <$> getUTC\n        0x0A -> return Null\n        0x0B -> RegEx <$> getRegex\n        0x0C -> ObjId <$> getObjectId <* getString\n        0x0D -> JavaScr . Javascript [] <$> getString\n        0x0E -> Sym <$> getSymbol\n        0x0F -> JavaScr . uncurry (flip Javascript) <$> getClosure\n        0x10 -> Int32 <$> getInt32\n        0x11 -> Stamp <$> getMongoStamp\n        0x12 -> Int64 <$> getInt64\n        0xFF -> return (MinMax MinKey)\n        0x7F -> return (MinMax MaxKey)\n        _ -> fail $ \"unknown Bson value type \" ++ show t\n  return (k := v)","function_tokens":["getField","=","do","t","<-","getTag","k","<-","getLabel","v","<-","case","t","of","0x01","->","Float","<$>","getDouble","0x02","->","String","<$>","getString","0x03","->","Doc","<$>","getDocument","0x04","->","Array","<$>","getArray","0x05","->","getBinary",">>=","\\","(","s",",","b",")","->","case","s","of","0x00","->","return","$","Bin","(","Binary","b",")","0x01","->","return","$","Fun","(","Function","b",")","0x02","->","return","$","Bin","(","Binary","b",")","0x03","->","return","$","Uuid","(","UUID","b",")","0x04","->","return","$","Uuid","(","UUID","b",")","0x05","->","return","$","Md5","(","MD5","b",")","0x80","->","return","$","UserDef","(","UserDefined","b",")","_","->","fail","$","\"unknown Bson binary subtype \"","++","show","s","0x06","->","return","Null","0x07","->","ObjId","<$>","getObjectId","0x08","->","Bool","<$>","getBool","0x09","->","UTC","<$>","getUTC","0x0A","->","return","Null","0x0B","->","RegEx","<$>","getRegex","0x0C","->","ObjId","<$>","getObjectId","<*","getString","0x0D","->","JavaScr",".","Javascript","[","]","<$>","getString","0x0E","->","Sym","<$>","getSymbol","0x0F","->","JavaScr",".","uncurry","(","flip","Javascript",")","<$>","getClosure","0x10","->","Int32","<$>","getInt32","0x11","->","Stamp","<$>","getMongoStamp","0x12","->","Int64","<$>","getInt64","0xFF","->","return","(","MinMax","MinKey",")","0x7F","->","return","(","MinMax","MaxKey",")","_","->","fail","$","\"unknown Bson value type \"","++","show","t","return","(","k",":=","v",")"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L79-L115","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"go","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go x = case divMod x 1000 of\n             (a,b) | a == 0 -> B.wordDec b\n                   | b > 99 -> go a <> B.char7 ',' <> B.wordDec b\n                   | b >  9 -> go a <> B.char7 ',' <> B.char7 '0' <> B.wordDec b\n                   | otherwise -> go a <> B.char7 ',' <> B.char7 '0' <> B.char7 '0' <> B.wordDec b","function_tokens":["go","x","=","case","divMod","x","1000","of","(","a",",","b",")","|","a","==","0","->","B","wordDec","b","|","b",">","99","->","go","a","<>","B","char7","','","<>","B","wordDec","b","|","b",">","9","->","go","a","<>","B","char7","','","<>","B","char7","'0'","<>","B","wordDec","b","|","otherwise","->","go","a","<>","B","char7","','","<>","B","char7","'0'","<>","B","char7","'0'","<>","B","wordDec","b"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L342-L348","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"ifold","parameters":"(Mul ms)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Mul ms)  = mconcat ms","function_tokens":["ifold","(","Mul","ms",")","=","mconcat","ms"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L84-L84","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"zipWith6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith6 = MG.zipWith6","function_tokens":["zipWith6","=","MG","zipWith6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L279-L279","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"noWrapRest","parameters":"ind","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"noWrapRest ind = reverse . noWrapRest' [] \"\"\n  where\n    noWrapRest' ls ss []\n        | null ss = ls\n        | otherwise = ss:ls\n    noWrapRest' ls ss (str:strs)\n        | null ss = noWrapRest' ls (indent ind str) strs\n        | otherwise = noWrapRest' ls (ss ++ \" \" ++ str) strs\n\n\n--------------------------------------------------------------------------------","function_tokens":["noWrapRest","ind","=","reverse",".","noWrapRest'","[","]","\"\"","where","noWrapRest'","ls","ss","[","]","|","null","ss","=","ls","|","otherwise","=","ss",":","ls","noWrapRest'","ls","ss","(","str",":","strs",")","|","null","ss","=","noWrapRest'","ls","(","indent","ind","str",")","strs","|","otherwise","=","noWrapRest'","ls","(","ss","++","\" \"","++","str",")","strs","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L163-L174","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"swapFgBg","parameters":"(StylizedList l)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"swapFgBg (StylizedList l) = StylizedList (map swapFgBg l)","function_tokens":["swapFgBg","(","StylizedList","l",")","=","StylizedList","(","map","swapFgBg","l",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L125-L125","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"truncateComma","parameters":"xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"truncateComma xs\n    | last xs == ',' = init xs\n    | otherwise      = xs","function_tokens":["truncateComma","xs","|","last","xs","==","','","=","init","xs","|","otherwise","=","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L86-L88","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"maybePutKindSig","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maybePutKindSig = forM_ maybeKindSig (\\k -> space >> putText \"::\" >> space >> putOutputable k)","function_tokens":["maybePutKindSig","=","forM_","maybeKindSig","(","\\","k","->","space",">>","putText","\"::\"",">>","space",">>","putOutputable","k",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L321-L321","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"resIbPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resIbPtr      = F.castPtr (F.unsafeForeignPtrToPtr resIbFptr  )","function_tokens":["resIbPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resIbFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L78-L78","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"completions","parameters":"","argument_list":"","return_statement":"","docstring":"Convert menu items into Completion values.","docstring_summary":"Convert menu items into Completion values.","docstring_tokens":["Convert","menu","items","into","Completion","values","."],"function":"completions = map (\\i -> Completion (asText i) (asText i) True)","function_tokens":["completions","=","map","(","\\","i","->","Completion","(","asText","i",")","(","asText","i",")","True",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L148-L148","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten''","parameters":"f'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten'' f' = do\n        (ns, q) <- get\n        put (ns, [])\n        r <- flatten' (unIFix f')\n        (ns', q') <- get\n        put (ns', q ++ q')\n        return r","function_tokens":["flatten''","f'","=","do","(","ns",",","q",")","<-","get","put","(","ns",",","[","]",")","r","<-","flatten'","(","unIFix","f'",")","(","ns'",",","q'",")","<-","get","put","(","ns'",",","q","++","q'",")","return","r"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L875-L883","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Empty\/Maybe.hs","language":"haskell","identifier":"execEmpty","parameters":"","argument_list":"","return_statement":"","docstring":"Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.  This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.  @ 'execEmpty' = 'fmap' 'isJust' '.' 'runEmpty' @ @ 'execEmpty' ('pure' a) = 'pure' 'True' @ @ 'execEmpty' 'empty' = 'pure' 'False' @  @since 1.1.0.0","docstring_summary":"Run an 'Empty' effect, replacing its result with a 'Bool' indicating whether control exited normally.  This is convenient for using 'empty' to signal early returns when all you need to know is whether control exited normally or not, and not what value it exited with.","docstring_tokens":["Run","an","Empty","effect","replacing","its","result","with","a","Bool","indicating","whether","control","exited","normally",".","This","is","convenient","for","using","empty","to","signal","early","returns","when","all","you","need","to","know","is","whether","control","exited","normally","or","not","and","not","what","value","it","exited","with","."],"function":"execEmpty = fmap isJust . runEmpty","function_tokens":["execEmpty","=","fmap","isJust",".","runEmpty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Empty\/Maybe.hs#L77-L77","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Empty\/Maybe.hs","hash_val":35180,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrapRest","parameters":"maxWidth ind","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrapRest maxWidth ind = reverse . wrapRest' [] \"\"\n  where\n    wrapRest' ls ss []\n        | null ss = ls\n        | otherwise = ss:ls\n    wrapRest' ls ss (str:strs)\n        | null ss = wrapRest' ls (indent ind str) strs\n        | overflows ss str = wrapRest' (ss:ls) \"\" (str:strs)\n        | otherwise = wrapRest' ls (ss ++ \" \" ++ str) strs\n\n    overflows ss str = (length ss + length str + 1) >= maxWidth\n\n\n--------------------------------------------------------------------------------","function_tokens":["wrapRest","maxWidth","ind","=","reverse",".","wrapRest'","[","]","\"\"","where","wrapRest'","ls","ss","[","]","|","null","ss","=","ls","|","otherwise","=","ss",":","ls","wrapRest'","ls","ss","(","str",":","strs",")","|","null","ss","=","wrapRest'","ls","(","indent","ind","str",")","strs","|","overflows","ss","str","=","wrapRest'","(","ss",":","ls",")","\"\"","(","str",":","strs",")","|","otherwise","=","wrapRest'","ls","(","ss","++","\" \"","++","str",")","strs","overflows","ss","str","=","(","length","ss","+","length","str","+","1",")",">=","maxWidth","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L137-L151","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"dynamicKey","parameters":"f lk","argument_list":"","return_statement":"","docstring":"@dynamicKey keyLookup keyIdLookup@ acquires the key identifier, such as repository or user name, from the result then uses @keyLookup@ to acquire the key (or @Nothing@).  Dynamic keys allow servers to specify per-user repository keys.  This limits the impact of compromized keys and allows the server to acquire the key from external sources, such as a live configuration or per-user rows in a database.","docstring_summary":"","docstring_tokens":[],"function":"dynamicKey f lk = GitHubKey (\\_ r -> maybe (pure Nothing) f (lk r))","function_tokens":["dynamicKey","f","lk","=","GitHubKey","(","\\","_","r","->","maybe","(","pure","Nothing",")","f","(","lk","r",")",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L207-L207","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(pre, post) = splitAt column str","function_tokens":["(","pre",",","post",")","=","splitAt","column","str"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L84-L84","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"backgroundProcess","parameters":"inst chan threadIds","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"backgroundProcess inst chan threadIds = do\n    reply <- liftIO . readChan $ chan\n\n    case reply of\n        Answer sig -> do\n            let node = source sig\n\n            -- Handle the signal\n            handleCommand (command sig) (peer node) inst\n\n            -- Insert the node into the tree, if it's allready known, it will\n            -- be refreshed\n            insertNode inst node\n\n            backgroundProcess inst chan threadIds\n\n        -- Kill all other processes and stop on Closed\n        Closed -> do\n            mapM_ killThread threadIds\n\n            eThreads <- atomically . readTVar . expirationThreads $ inst\n            mapM_ killThread $ map snd (M.toList eThreads)\n\n        _ -> return ()\n\n-- | Ping all known nodes every five minutes to make sure they are still present","function_tokens":["backgroundProcess","inst","chan","threadIds","=","do","reply","<-","liftIO",".","readChan","$","chan","case","reply","of","Answer","sig","->","do","let","node","=","source","sig","-- Handle the signal","handleCommand","(","command","sig",")","(","peer","node",")","inst","-- Insert the node into the tree, if it's allready known, it will","-- be refreshed","insertNode","inst","node","backgroundProcess","inst","chan","threadIds","-- Kill all other processes and stop on Closed","Closed","->","do","mapM_","killThread","threadIds","eThreads","<-","atomically",".","readTVar",".","expirationThreads","$","inst","mapM_","killThread","$","map","snd","(","M","toList","eThreads",")","_","->","return","(",")","-- | Ping all known nodes every five minutes to make sure they are still present"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L186-L212","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Types.hs","language":"haskell","identifier":"def","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"def = Map { _projection = id , _title = mempty , _labelEntities = False , _labelledDistricts = mempty }","function_tokens":["def","=","Map","{","_projection","=","id",",","_title","=","mempty",",","_labelEntities","=","False",",","_labelledDistricts","=","mempty","}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Types.hs#L20-L20","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Types.hs","hash_val":39816,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"","parameters":"(StylizedList l) (StylizedList l')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) (StylizedList l) (StylizedList l') = StylizedList (l <> l')","function_tokens":["(","<>",")","(","StylizedList","l",")","(","StylizedList","l'",")","=","StylizedList","(","l","<>","l'",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L57-L57","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INVERSE_DISTANCE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INVERSE_DISTANCE                 = 0xD001","function_tokens":["al_INVERSE_DISTANCE","=","0xD001"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L55-L55","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"dynFlags0","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dynFlags0 = foldl' turnOn baseDynFlags externalExts1","function_tokens":["dynFlags0","=","foldl'","turnOn","baseDynFlags","externalExts1"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L68-L68","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"concTy","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"concTy  = if total\n                   then if mono\n                        then [t| Mono.Lens Total $tyI $tyO |]\n                        else [t| Poly.Lens Total $tyI $tyO |]\n                   else if mono\n                        then [t| Mono.Lens $partial $tyI $tyO |]\n                        else [t| Poly.Lens $partial $tyI $tyO |]","function_tokens":["concTy","=","if","total","then","if","mono","then","[","t","|"," Mono.Lens Total $tyI $tyO ","|]","else","[","t","|"," Poly.Lens Total $tyI $tyO ","|]","else","if","mono","then","[","t","|"," Mono.Lens $partial $tyI $tyO ","|]","else","[","t","|"," Poly.Lens $partial $tyI $tyO ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L458-L464","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"atan","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"atan = fmap atan","function_tokens":["atan","=","fmap","atan"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L251-L251","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"getMaxColors","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getMaxColors = do\n      term <- MaybeT (System.lookupEnv \"TERM\")\n      lift (Terminfo.acquireDatabase term) >>= \\case\n        Left _ -> empty\n        Right db ->\n          hoistMaybe $\n            Terminfo.queryNumTermCap db Terminfo.MaxColors","function_tokens":["getMaxColors","=","do","term","<-","MaybeT","(","System","lookupEnv","\"TERM\"",")","lift","(","Terminfo","acquireDatabase","term",")",">>=","\\","case","Left","_","->","empty","Right","db","->","hoistMaybe","$","Terminfo","queryNumTermCap","db","Terminfo","MaxColors"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L248-L254","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"maybePath","parameters":"p","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"maybePath p = Just (cdup <\/> p)","function_tokens":["maybePath","p","=","Just","(","cdup","<\/>","p",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L155-L155","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"fromRows","parameters":"xs","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from rows","docstring_summary":"O(m*n) Create matrix from rows","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","rows"],"function":"fromRows xs | null xs = empty\n            | otherwise = fromVector (r,c) . G.concat $ xs\n  where\n    r = length xs\n    c = G.length . head $ xs","function_tokens":["fromRows","xs","|","null","xs","=","empty","|","otherwise","=","fromVector","(","r",",","c",")",".","G","concat","$","xs","where","r","=","length","xs","c","=","G","length",".","head","$","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L154-L159","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"matrix","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix construction","docstring_summary":"O(m*n) Matrix construction","docstring_tokens":["O","(","m","*","n",")","Matrix","construction"],"function":"matrix = MG.matrix","function_tokens":["matrix","=","MG","matrix"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L145-L145","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"stdin","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stdin = \"\"","function_tokens":["stdin","=","\"\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L147-L147","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"f","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f _ _     = ' '","function_tokens":["f","_","_","=","' '"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L75-L75","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = length . head $ xs","function_tokens":["c","=","length",".","head","$","xs"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L149-L149","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"emb","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"emb = InR","function_tokens":["emb","=","InR"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L60-L60","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"mapLabelMaker","parameters":"","argument_list":"","return_statement":"","docstring":"Parses the `Command` datatype into a map","docstring_summary":"Parses the `Command` datatype into a map","docstring_tokens":["Parses","the","Command","datatype","into","a","map"],"function":"mapLabelMaker = MapLabel\n    <$> strOption\n        (long \"output\"\n        <> short 'o'\n        <> metavar \"OUTPUT\"\n        <> help \"Where to write the image\/map\" )\n    <*> switch\n        (long \"generate-all\"\n        <> short 'a'\n        <> help \"Whether to generate a separate file for each object in the shapefile\" )\n    <*> ( optional $ strOption\n        (long \"projection\"\n        <> short 'p'\n        <> help \"Which projection to use, e.g. mercator etc.\") )\n    <*> ( strOption\n        (long \"label\"\n        <> short 'p'\n        <> help \"What aspect to label (area, perimeter, compactness)\") )","function_tokens":["mapLabelMaker","=","MapLabel","<$>","strOption","(","long","\"output\"","<>","short","'o'","<>","metavar","\"OUTPUT\"","<>","help","\"Where to write the image\/map\"",")","<*>","switch","(","long","\"generate-all\"","<>","short","'a'","<>","help","\"Whether to generate a separate file for each object in the shapefile\"",")","<*>","(","optional","$","strOption","(","long","\"projection\"","<>","short","'p'","<>","help","\"Which projection to use, e.g. mercator etc.\"",")",")","<*>","(","strOption","(","long","\"label\"","<>","short","'p'","<>","help","\"What aspect to label (area, perimeter, compactness)\"",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L47-L64","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"defn","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defn = dataDefn decl","function_tokens":["defn","=","dataDefn","decl"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L139-L139","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"tyI","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tyI       = return $ foldr (flip AppT) (ConT datatype) (reverse dtTypes)","function_tokens":["tyI","=","return","$","foldr","(","flip","AppT",")","(","ConT","datatype",")","(","reverse","dtTypes",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L568-L568","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookDeploymentStatusEvent","function_tokens":["reflect","_","=","WebhookDeploymentStatusEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L424-L424","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"write","parameters":"c q","argument_list":"","return_statement":"","docstring":"Write the given 'Quad'.","docstring_summary":"Write the given 'Quad'.","docstring_tokens":["Write","the","given","Quad","."],"function":"write c q = writeQuads c [q]","function_tokens":["write","c","q","=","writeQuads","c","[","q","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L122-L122","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"ibsToIndexByteStrings","parameters":"bits","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ibsToIndexByteStrings bits = F.unsafeLocalState $ do\n  bpState <- emptyBpState\n  IO.unsafeInterleaveIO $ go bpState (fmap (\\(a, b, c) -> mkIndexStep a b c) bits)\n  where go :: ()\n          => BpState\n          -> [Step]\n          -> IO [BS.ByteString]\n        go s (step:steps) = do\n          let bp = stepToByteString s step\n          bps <- IO.unsafeInterleaveIO $ go s steps\n          return $ bp:bps\n        go s [] = return [stepToByteString s indexStepFinal]","function_tokens":["ibsToIndexByteStrings","bits","=","F","unsafeLocalState","$","do","bpState","<-","emptyBpState","IO","unsafeInterleaveIO","$","go","bpState","(","fmap","(","\\","(","a",",","b",",","c",")","->","mkIndexStep","a","b","c",")","bits",")","where","go","::","(",")","=>","BpState","->","[","Step","]","->","IO","[","BS","ByteString","]","go","s","(","step",":","steps",")","=","do","let","bp","=","stepToByteString","s","step","bps","<-","IO","unsafeInterleaveIO","$","go","s","steps","return","$","bp",":","bps","go","s","[","]","=","return","[","stepToByteString","s","indexStepFinal","]"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L86-L99","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"easeInPow","parameters":"power c t b","argument_list":"","return_statement":"","docstring":"Ease in by some power.","docstring_summary":"Ease in by some power.","docstring_tokens":["Ease","in","by","some","power","."],"function":"easeInPow power c t b =  c * (realToFrac t^power) + b","function_tokens":["easeInPow","power","c","t","b","=","c","*","(","realToFrac","t","^","power",")","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L112-L112","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"unintern","parameters":"(Set _ n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (Set _ n) = BSet n","function_tokens":["unintern","(","Set","_","n",")","=","BSet","n"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L52-L52","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putField","parameters":"(k := v)","argument_list":"","return_statement":"","docstring":"^ Write binary representation of element","docstring_summary":"^ Write binary representation of element","docstring_tokens":["^","Write","binary","representation","of","element"],"function":"putField (k := v) = case v of\n  Float x                       -> putTL 0x01 >> putDouble x\n  String x                      -> putTL 0x02 >> putString x\n  Doc x                         -> putTL 0x03 >> putDocument x\n  Array x                       -> putTL 0x04 >> putArray x\n  Bin (Binary x)                -> putTL 0x05 >> putBinary 0x00 x\n  Fun (Function x)              -> putTL 0x05 >> putBinary 0x01 x\n  Uuid (UUID x)                 -> putTL 0x05 >> putBinary 0x04 x\n  Md5 (MD5 x)                   -> putTL 0x05 >> putBinary 0x05 x\n  UserDef (UserDefined x)       -> putTL 0x05 >> putBinary 0x80 x\n  ObjId x                       -> putTL 0x07 >> putObjectId x\n  Bool x                        -> putTL 0x08 >> putBool x\n  UTC x                         -> putTL 0x09 >> putUTC x\n  Null                          -> putTL 0x0A\n  RegEx x                       -> putTL 0x0B >> putRegex x\n  JavaScr (Javascript env code) ->\n    if null env\n    then putTL 0x0D >> putString code\n    else putTL 0x0F >> putClosure code env\n  Sym x                         -> putTL 0x0E >> putSymbol x\n  Int32 x                       -> putTL 0x10 >> putInt32 x\n  Int64 x                       -> putTL 0x12 >> putInt64 x\n  Stamp x                       -> putTL 0x11 >> putMongoStamp x\n  MinMax x                      ->\n    case x of\n     MinKey -> putTL 0xFF\n     MaxKey -> putTL 0x7F\n where\n  putTL t = putTag t >> putLabel k","function_tokens":["putField","(","k",":=","v",")","=","case","v","of","Float","x","->","putTL","0x01",">>","putDouble","x","String","x","->","putTL","0x02",">>","putString","x","Doc","x","->","putTL","0x03",">>","putDocument","x","Array","x","->","putTL","0x04",">>","putArray","x","Bin","(","Binary","x",")","->","putTL","0x05",">>","putBinary","0x00","x","Fun","(","Function","x",")","->","putTL","0x05",">>","putBinary","0x01","x","Uuid","(","UUID","x",")","->","putTL","0x05",">>","putBinary","0x04","x","Md5","(","MD5","x",")","->","putTL","0x05",">>","putBinary","0x05","x","UserDef","(","UserDefined","x",")","->","putTL","0x05",">>","putBinary","0x80","x","ObjId","x","->","putTL","0x07",">>","putObjectId","x","Bool","x","->","putTL","0x08",">>","putBool","x","UTC","x","->","putTL","0x09",">>","putUTC","x","Null","->","putTL","0x0A","RegEx","x","->","putTL","0x0B",">>","putRegex","x","JavaScr","(","Javascript","env","code",")","->","if","null","env","then","putTL","0x0D",">>","putString","code","else","putTL","0x0F",">>","putClosure","code","env","Sym","x","->","putTL","0x0E",">>","putSymbol","x","Int32","x","->","putTL","0x10",">>","putInt32","x","Int64","x","->","putTL","0x12",">>","putInt64","x","Stamp","x","->","putTL","0x11",">>","putMongoStamp","x","MinMax","x","->","case","x","of","MinKey","->","putTL","0xFF","MaxKey","->","putTL","0x7F","where","putTL","t","=","putTag","t",">>","putLabel","k"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L47-L77","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"skipToBrace","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"skipToBrace = case (cEquals cfg, cFirstField cfg) of\n        (_, Indent y) | not (cBreakSingleConstructors cfg) -> newline >> spaces y\n        (SameLine, SameLine) -> space\n        (Indent x, Indent y) -> newline >> spaces (x + y + 2)\n        (SameLine, Indent y) -> newline >> spaces (consIndent + y)\n        (Indent _, SameLine) -> space\n\n      -- Jump to the next declaration.","function_tokens":["skipToBrace","=","case","(","cEquals","cfg",",","cFirstField","cfg",")","of","(","_",",","Indent","y",")","|","not","(","cBreakSingleConstructors","cfg",")","->","newline",">>","spaces","y","(","SameLine",",","SameLine",")","->","space","(","Indent","x",",","Indent","y",")","->","newline",">>","spaces","(","x","+","y","+","2",")","(","SameLine",",","Indent","y",")","->","newline",">>","spaces","(","consIndent","+","y",")","(","Indent","_",",","SameLine",")","->","space","-- Jump to the next declaration."],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L423-L431","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Opts.hs","language":"haskell","identifier":"versionHelper","parameters":"progName","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"versionHelper progName =\n  infoOption (printf \"%s %s\" progName (showVersion version)) $ mconcat\n  [ long \"version\"\n  , help \"Show version information\"\n  , hidden\n  ]","function_tokens":["versionHelper","progName","=","infoOption","(","printf","\"%s %s\"","progName","(","showVersion","version",")",")","$","mconcat","[","long","\"version\"",",","help","\"Show version information\"",",","hidden","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Opts.hs#L84-L89","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Opts.hs","hash_val":22933,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"not","parameters":"n","argument_list":"","return_statement":"","docstring":"A smart constructor for negation","docstring_summary":"A smart constructor for negation","docstring_tokens":["A","smart","constructor","for","negation"],"function":"not n = case match n of\n    Just (Not n') -> n'\n    _ -> inject $ Not n\n\n-- | A functor representing a mono-sorted universal quantifier binding a number of variables within a formula","function_tokens":["not","n","=","case","match","n","of","Just","(","Not","n'",")","->","n'","_","->","inject","$","Not","n","-- | A functor representing a mono-sorted universal quantifier binding a number of variables within a formula"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L520-L525","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = ChooseC (\\ _ leaf -> leaf a)","function_tokens":["pure","a","=","ChooseC","(","\\","_","leaf","->","leaf","a",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L64-L64","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"factor","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"factor = 1717856\/4.219690791828533e-2","function_tokens":["factor","=","1717856","\/","4.219690791828533e-2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L53-L53","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"isovector\/do-notation","sha":"919d3326fd191411cc507b74bc3eaffe0cdec1ce","path":"src\/Control\/Monad\/Trans\/Ix.hs","language":"haskell","identifier":"ireturn","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ireturn = P.pure","function_tokens":["ireturn","=","P","pure"],"url":"https:\/\/github.com\/isovector\/do-notation\/blob\/919d3326fd191411cc507b74bc3eaffe0cdec1ce\/src\/Control\/Monad\/Trans\/Ix.hs#L38-L38","hash_key":"isovector\/do-notation:src\/Control\/Monad\/Trans\/Ix.hs","hash_val":339,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"compare","parameters":"x y","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compare x y = compare (commentPosition x) (commentPosition y)","function_tokens":["compare","x","y","=","compare","(","commentPosition","x",")","(","commentPosition","y",")"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L43-L43","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"unintern","parameters":"(Lam _ v t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (Lam _ v t e) = BLam v t e","function_tokens":["unintern","(","Lam","_","v","t","e",")","=","BLam","v","t","e"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L50-L50","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"instantiate","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"instantiate _ _ = Nothing","function_tokens":["instantiate","_","_","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L921-L921","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_PITCH","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_PITCH                            = 0x1003","function_tokens":["al_PITCH","=","0x1003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L88-L88","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"current","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"current = i `div` c","function_tokens":["current","=","i","`","div","`","c"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L100-L100","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"installBinaries","parameters":"Stack mode binDir","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"installBinaries Stack mode binDir =\n  callProcess \"stack\"\n    [ \"install\"\n    , modeToStackArg mode \n    , \"--local-bin-path=\" ++ binDir\n    ]","function_tokens":["installBinaries","Stack","mode","binDir","=","callProcess","\"stack\"","[","\"install\"",",","modeToStackArg","mode",",","\"--local-bin-path=\"","++","binDir","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L53-L58","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showsTree","parameters":"wide lbars rbars t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsTree wide lbars rbars t\n  = case t of\n      Bin _ _ p m l r\n          -> showsTree wide (withBar rbars) (withEmpty rbars) r .\n             showWide wide rbars .\n             showsBars lbars . showString (showBin p m) . showString \"\\n\" .\n             showWide wide lbars .\n             showsTree wide (withEmpty lbars) (withBar lbars) l\n      Tip _ x\n          -> showsBars lbars . showString \" \" . shows x . showString \"\\n\"\n      Nil -> showsBars lbars . showString \"|\\n\"","function_tokens":["showsTree","wide","lbars","rbars","t","=","case","t","of","Bin","_","_","p","m","l","r","->","showsTree","wide","(","withBar","rbars",")","(","withEmpty","rbars",")","r",".","showWide","wide","rbars",".","showsBars","lbars",".","showString","(","showBin","p","m",")",".","showString","\"\\n\"",".","showWide","wide","lbars",".","showsTree","wide","(","withEmpty","lbars",")","(","withBar","lbars",")","l","Tip","_","x","->","showsBars","lbars",".","showString","\" \"",".","shows","x",".","showString","\"\\n\"","Nil","->","showsBars","lbars",".","showString","\"|\\n\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L783-L795","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"clause@GHC.HsDerivingClause {..} = GHC.unLoc lclause","function_tokens":["clause","@","GHC","HsDerivingClause","{","..","}","=","GHC","unLoc","lclause"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L228-L228","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"hoistServerWithContext","parameters":"_ _ f s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hoistServerWithContext _ _ f s = \\p -> hoistServerWithContext p1 p2 f (s p) where\n    p1 = Proxy :: Proxy sublayout\n    p2 = Proxy :: Proxy context","function_tokens":["hoistServerWithContext","_","_","f","s","=","\\","p","->","hoistServerWithContext","p1","p2","f","(","s","p",")","where","p1","=","Proxy","::","Proxy","sublayout","p2","=","Proxy","::","Proxy","context"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L339-L343","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L (L (Throw e))   -> Except.throwE e\n    L (R (Catch m h)) -> Except.catchE (hdl (m <$ ctx)) (hdl . (<$ ctx) . h)\n    R other           -> Except.ExceptT $ thread (either (pure . Left) Except.runExceptT ~<~ hdl) other (Right ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","(","L","(","Throw","e",")",")","->","Except","throwE","e","L","(","R","(","Catch","m","h",")",")","->","Except","catchE","(","hdl","(","m","<$","ctx",")",")","(","hdl",".","(","<$","ctx",")",".","h",")","R","other","->","Except","ExceptT","$","thread","(","either","(","pure",".","Left",")","Except","runExceptT","~<~","hdl",")","other","(","Right","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L190-L194","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(SetModTime _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (SetModTime _ s) = Just s","function_tokens":["targetEntry","(","SetModTime","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1060-L1060","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"runNonDet","parameters":"fork leaf nil (NonDetC m)","argument_list":"","return_statement":"","docstring":"Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.  @ runNonDet fork leaf nil ('pure' a '<|>' 'empty') = leaf a \\`fork\\` nil @  @since 1.0.0.0","docstring_summary":"Run a 'NonDet' effect, using the provided functions to interpret choice, leaf results, and failure.","docstring_tokens":["Run","a","NonDet","effect","using","the","provided","functions","to","interpret","choice","leaf","results","and","failure","."],"function":"runNonDet fork leaf nil (NonDetC m) = m fork leaf nil","function_tokens":["runNonDet","fork","leaf","nil","(","NonDetC","m",")","=","m","fork","leaf","nil"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L49-L49","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"computePrefixDir","parameters":"NoPrefixSpecified Project","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"computePrefixDir NoPrefixSpecified Project = defaultPrefix","function_tokens":["computePrefixDir","NoPrefixSpecified","Project","=","defaultPrefix"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L109-L109","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"areaPolyRectangular","parameters":"(pt:pts)","argument_list":"","return_statement":"","docstring":"Find the area of a polygon with rectangular co\u00f6rdinates given.","docstring_summary":"Find the area of a polygon with rectangular co\u00f6rdinates given.","docstring_tokens":["Find","the","area","of","a","polygon","with","rectangular","co\u00f6rdinates","given","."],"function":"areaPolyRectangular (pt:pts) = abs . (*0.5) . fst $ (foldl' areaPolyCalc (0,pt) pts)\n    where areaPolyCalc (sum,(x1,y1)) (x2, y2) = (sum + (x1 * y2 - x2 * y1),(x2,y2))\n          ((x1, y1),(xn, yn)) = (pt, last pts)\n\n-- | Distance in kilometers between two points given in degrees.","function_tokens":["areaPolyRectangular","(","pt",":","pts",")","=","abs",".","(","*","0.5",")",".","fst","$","(","foldl'","areaPolyCalc","(","0",",","pt",")","pts",")","where","areaPolyCalc","(","sum",",","(","x1",",","y1",")",")","(","x2",",","y2",")","=","(","sum","+","(","x1","*","y2","-","x2","*","y1",")",",","(","x2",",","y2",")",")","(","(","x1",",","y1",")",",","(","xn",",","yn",")",")","=","(","pt",",","last","pts",")","-- | Distance in kilometers between two points given in degrees. "],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L64-L69","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INVALID_VALUE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INVALID_VALUE                    = 0xA003","function_tokens":["al_INVALID_VALUE","=","0xA003"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L34-L34","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"convertFstToBlock","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"convertFstToBlock = fmap \\(rspan, a) ->\n      (Block (GHC.srcSpanStartLine rspan) (GHC.srcSpanEndLine rspan), a)","function_tokens":["convertFstToBlock","=","fmap","\\","(","rspan",",","a",")","->","(","Block","(","GHC","srcSpanStartLine","rspan",")","(","GHC","srcSpanEndLine","rspan",")",",","a",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L133-L134","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"e'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"e'      =  e + coef' \/ (2 * k + 1)","function_tokens":["e'","=","e","+","coef'","\/","(","2","*","k","+","1",")"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L46-L46","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getRegex","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getRegex = Regex <$> getCString <*> getCString","function_tokens":["getRegex","=","Regex","<$>","getCString","<*>","getCString"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L213-L213","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"isEnum","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isEnum = all isUnary . GHC.dd_cons . dataDefn\n  where\n    isUnary c = case GHC.unLoc c of\n      GHC.ConDeclH98 {..} -> case con_args of\n        GHC.PrefixCon tyargs args -> null tyargs && null args\n        _                         -> False\n      _ -> False","function_tokens":["isEnum","=","all","isUnary",".","GHC","dd_cons",".","dataDefn","where","isUnary","c","=","case","GHC","unLoc","c","of","GHC","ConDeclH98","{","..","}","->","case","con_args","of","GHC","PrefixCon","tyargs","args","->","null","tyargs","&&","null","args","_","->","False","_","->","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L538-L546","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ma1 <|> ma2 = AccumC $ \\k w -> runAccumC ma1 k w <|> runAccumC ma2 k w","function_tokens":["ma1","<|>","ma2","=","AccumC","$","\\","k","w","->","runAccumC","ma1","k","w","<|>","runAccumC","ma2","k","w"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L101-L101","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/PlotSVG.hs","language":"haskell","identifier":"fileOptions","parameters":"","argument_list":"","return_statement":"","docstring":"Default file options: PNG output and 1920x1080. To change the file size, you can do e.g. > fo_size .~ (640,480) $ fileOptions","docstring_summary":"Default file options: PNG output and 1920x1080. To change the file size, you can do e.g. > fo_size .~ (640,480) $ fileOptions","docstring_tokens":["Default","file","options",":","PNG","output","and","1920x1080",".","To","change","the","file","size","you","can","do","e",".","g",".",">","fo_size",".","~","(","640","480",")","$","fileOptions"],"function":"fileOptions = def { _fo_size = (1920, 1080) , _fo_format = SVG }","function_tokens":["fileOptions","=","def","{","_fo_size","=","(","1920",",","1080",")",",","_fo_format","=","SVG","}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/PlotSVG.hs#L19-L19","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/PlotSVG.hs","hash_val":9853,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = OnlyOne Nothing","function_tokens":["mempty","=","OnlyOne","Nothing"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L70-L70","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = M.delete k m","function_tokens":["n","=","M","delete","k","m"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L445-L445","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"lEnd","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lEnd = GHC.srcSpanEndLine (f x)","function_tokens":["lEnd","=","GHC","srcSpanEndLine","(","f","x",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L96-L96","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"identity","parameters":"Nil","argument_list":"","return_statement":"","docstring":"A unique integer ID associated with each interned set.","docstring_summary":"A unique integer ID associated with each interned set.","docstring_tokens":["A","unique","integer","ID","associated","with","each","interned","set","."],"function":"identity Nil = 0","function_tokens":["identity","Nil","=","0"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L193-L193","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"isDirectory","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isDirectory x = PosixFiles.isDirectory <$> PosixFiles.getFileStatus x","function_tokens":["isDirectory","x","=","PosixFiles","isDirectory","<$>","PosixFiles","getFileStatus","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L142-L142","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"dumpPeers","parameters":"(KI _ (KS sTree _) _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dumpPeers (KI _ (KS sTree _) _) = atomically $ do\n    tree <- readTVar sTree\n    return . T.toList $ tree\n\n-- | Insert a value into the store","function_tokens":["dumpPeers","(","KI","_","(","KS","sTree","_",")","_",")","=","atomically","$","do","tree","<-","readTVar","sTree","return",".","T","toList","$","tree","-- | Insert a value into the store"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L84-L89","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"forkIO","parameters":"","argument_list":"","return_statement":"","docstring":"Same as @Control.Concurrent.Thread.'Thread.forkIO'@ but additionaly adds the thread to the group.","docstring_summary":"Same as","docstring_tokens":["Same","as"],"function":"forkIO = fork rawForkIO","function_tokens":["forkIO","=","fork","rawForkIO"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L144-L144","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureOpenDevice","parameters":"maybeDeviceSpec frequency format size","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"captureOpenDevice maybeDeviceSpec frequency format size = liftIO $ do\n   funPtr <- getCaptureFunc \"alcCaptureOpenDevice\"\n   let open deviceSpec =\n          invokeCaptureOpenDevice funPtr deviceSpec (round frequency)\n                                  (fromIntegral (marshalFormat format)) size\n   fmap unmarshalDevice $\n      (maybe (open nullPtr)   -- use preferred device\n             (flip withALCString open)\n             maybeDeviceSpec)","function_tokens":["captureOpenDevice","maybeDeviceSpec","frequency","format","size","=","liftIO","$","do","funPtr","<-","getCaptureFunc","\"alcCaptureOpenDevice\"","let","open","deviceSpec","=","invokeCaptureOpenDevice","funPtr","deviceSpec","(","round","frequency",")","(","fromIntegral","(","marshalFormat","format",")",")","size","fmap","unmarshalDevice","$","(","maybe","(","open","nullPtr",")","-- use preferred device","(","flip","withALCString","open",")","maybeDeviceSpec",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L59-L69","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Matrix m v a where\n    dim :: m v a -> (Int, Int)\n\n    unsafeIndex :: m v a -> (Int, Int) -> a\n\n    unsafeFromVector :: (Int, Int) -> v a -> m v a\n\n    -- | Default algorithm is O((m*n) * O(unsafeIndex)).\n    flatten :: m v a -> v a\n    flatten mat = G.generate (r*c) $ \\i -> unsafeIndex mat (i `divMod` c)\n      where\n        (r,c) = dim mat\n    {-# INLINE flatten #-}\n\n    -- | Extract a row. Default algorithm is O(n * O(unsafeIndex)).\n    unsafeTakeRow :: m v a -> Int -> v a\n    unsafeTakeRow mat i = G.generate c $ \\j -> unsafeIndex mat (i,j)\n      where\n        (_,c) = dim mat\n    {-# INLINE unsafeTakeRow #-}\n\n    -- | Extract a column. Default algorithm is O(m * O(unsafeIndex)).\n    unsafeTakeColumn :: m v a -> Int -> v a\n    unsafeTakeColumn mat j = G.generate r $ \\i -> unsafeIndex mat (i,j)\n      where\n        (r,_) = dim mat\n    {-# INLINE unsafeTakeColumn #-}\n\n    -- | Extract the diagonal. Default algorithm is O(min(m,n) * O(unsafeIndex)).\n    takeDiag :: m v a -> v a\n    takeDiag mat = G.generate n $ \\i -> unsafeIndex mat (i,i)\n      where\n        n = uncurry min . dim $ mat\n    {-# INLINE takeDiag #-}\n\n    thaw :: PrimMonad s => m v a -> s ((Mutable m) (G.Mutable v) (PrimState s) a)\n\n    unsafeThaw :: PrimMonad s\n               => m v a -> s ((Mutable m) (G.Mutable v) (PrimState s) a)\n\n    freeze :: PrimMonad s\n           => (Mutable m) (G.Mutable v) (PrimState s) a -> s (m v a)\n\n    unsafeFreeze :: PrimMonad s\n                 => (Mutable m) (G.Mutable v) (PrimState s) a -> s (m v a)\n\n    {-# MINIMAL dim, unsafeIndex, unsafeFromVector, thaw, unsafeThaw, freeze, unsafeFreeze #-}\n\n-- | Derived methods\n\n-- | Return the number of rows\nrows :: Matrix m v a => m v a -> Int\nrows = fst . dim","function_tokens":["Matrix","m","v","a","where","dim","::","m","v","a","->","(","Int",",","Int",")","unsafeIndex","::","m","v","a","->","(","Int",",","Int",")","->","a","unsafeFromVector","::","(","Int",",","Int",")","->","v","a","->","m","v","a","-- | Default algorithm is O((m*n) * O(unsafeIndex)).","flatten","::","m","v","a","->","v","a","flatten","mat","=","G","(","r","*","c",")","$","\\","i","->","unsafeIndex","mat","(","i","`","`",")","where","(","r",",","c",")","=","dim","mat","{-# INLINE flatten #-}","-- | Extract a row. Default algorithm is O(n * O(unsafeIndex)).","unsafeTakeRow","::","m","v","a","->","Int","->","v","a","unsafeTakeRow","mat","i","=","G","c","$","\\","j","->","unsafeIndex","mat","(","i",",","j",")","where","(","_",",","c",")","=","dim","mat","{-# INLINE unsafeTakeRow #-}","-- | Extract a column. Default algorithm is O(m * O(unsafeIndex)).","unsafeTakeColumn","::","m","v","a","->","Int","->","v","a","unsafeTakeColumn","mat","j","=","G","r","$","\\","i","->","unsafeIndex","mat","(","i",",","j",")","where","(","r",",","_",")","=","dim","mat","{-# INLINE unsafeTakeColumn #-}","-- | Extract the diagonal. Default algorithm is O(min(m,n) * O(unsafeIndex)).","takeDiag","::","m","v","a","->","v","a","takeDiag","mat","=","G","n","$","\\","i","->","unsafeIndex","mat","(","i",",","i",")","where","n","=","uncurry","min",".","dim","$","mat","{-# INLINE takeDiag #-}","thaw","::","PrimMonad","s","=>","m","v","a","->","s","(","(","Mutable","m",")","(","G","Mutable","v",")","(","PrimState","s",")","a",")","unsafeThaw","::","PrimMonad","s","=>","m","v","a","->","s","(","(","Mutable","m",")","(","G","Mutable","v",")","(","PrimState","s",")","a",")","freeze","::","PrimMonad","s","=>","(","Mutable","m",")","(","G","Mutable","v",")","(","PrimState","s",")","a","->","s","(","m","v","a",")","unsafeFreeze","::","PrimMonad","s","=>","(","Mutable","m",")","(","G","Mutable","v",")","(","PrimState","s",")","a","->","s","(","m","v","a",")","{-# MINIMAL dim, unsafeIndex, unsafeFromVector, thaw, unsafeThaw, freeze, unsafeFreeze #-}","-- | Derived methods","-- | Return the number of rows","rows","::","Matrix","m","v","a","=>","m","v","a","->","Int","rows","=","fst",".","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L39-L91","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Opt.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = pickProjection projection","function_tokens":["p","=","pickProjection","projection"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Opt.hs#L24-L24","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Opt.hs","hash_val":40779,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/String.hs","language":"haskell","identifier":"loop","parameters":"p strs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop p strs = do\n            str <- peekALCString p\n            if str == \"\"\n               then return (reverse strs)\n               else do\n                  len <- lengthArray0 0 p\n                  loop (p `plusPtr` (len + 1)) (str : strs)","function_tokens":["loop","p","strs","=","do","str","<-","peekALCString","p","if","str","==","\"\"","then","return","(","reverse","strs",")","else","do","len","<-","lengthArray0","0","p","loop","(","p","`","plusPtr","`","(","len","+","1",")",")","(","str",":","strs",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/String.hs#L37-L43","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/String.hs","hash_val":13294,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"installBinaries","parameters":"Cabal _ binDir","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"installBinaries Cabal _ binDir =\n  callProcess \"cabal\"\n    [ \"v2-install\"\n    , \"--install-method=copy\"\n    , \"--overwrite-policy=always\"\n    , \"--installdir=\" ++ binDir\n    ]","function_tokens":["installBinaries","Cabal","_","binDir","=","callProcess","\"cabal\"","[","\"v2-install\"",",","\"--install-method=copy\"",",","\"--overwrite-policy=always\"",",","\"--installdir=\"","++","binDir","]"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L45-L51","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkLabelsNamed","parameters":"mk","argument_list":"","return_statement":"","docstring":"Like `mkLabels`, but uses the specified function to produce custom names for the labels.  For instance, @(drop 1 . dropWhile (\/='_'))@ creates a label @val@ from a record @Rec { rec_val :: X }@.","docstring_summary":"Like `mkLabels`, but uses the specified function to produce custom names for the labels.  For instance,","docstring_tokens":["Like","mkLabels","but","uses","the","specified","function","to","produce","custom","names","for","the","labels",".","For","instance"],"function":"mkLabelsNamed mk = liftM concat . mapM (mkLabelsWith mk True False False True)","function_tokens":["mkLabelsNamed","mk","=","liftM","concat",".","mapM","(","mkLabelsWith","mk","True","False","False","True",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L103-L103","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"lift","parameters":"ma","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift ma = AccumC $ \\k _ -> ma >>= k mempty","function_tokens":["lift","ma","=","AccumC","$","\\","k","_","->","ma",">>=","k","mempty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L82-L82","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"traverseEvents","parameters":"df f t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"traverseEvents df f t = Track <$> (df $ dur t) <*> (fmap fromEventList $ traverse f $ render t)","function_tokens":["traverseEvents","df","f","t","=","Track","<$>","(","df","$","dur","t",")","<*>","(","fmap","fromEventList","$","traverse","f","$","render","t",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L228-L228","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Group _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Group _)                = (True, True, False, False)","function_tokens":["go","(","Group","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L371-L371","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Accum\/Church.hs","language":"haskell","identifier":"pure","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pure a = AccumC $ \\k _ -> k mempty a","function_tokens":["pure","a","=","AccumC","$","\\","k","_","->","k","mempty","a"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Accum\/Church.hs#L90-L90","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Accum\/Church.hs","hash_val":7831,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseWord16","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseWord16 = do\n    bs <- lift  get\n    if B.length bs < 2\n        then throwE \"ByteString to short\"\n        else do\n            let (words, rest) = B.splitAt 2 bs\n            lift . put $ rest\n            return . joinWords . B.unpack $ words\n    where\n        joinWords [a, b] = (toWord16 a `shiftL` 8) + toWord16 b\n\n        toWord16 :: Word8 -> Word16\n        toWord16 = fromIntegral\n\n-- | Parses a Node's info","function_tokens":["parseWord16","=","do","bs","<-","lift","get","if","B","length","bs","<","2","then","throwE","\"ByteString to short\"","else","do","let","(","words",",","rest",")","=","B","splitAt","2","bs","lift",".","put","$","rest","return",".","joinWords",".","B","unpack","$","words","where","joinWords","[","a",",","b","]","=","(","toWord16","a","`","shiftL","`","8",")","+","toWord16","b","toWord16","::","Word8","->","Word16","toWord16","=","fromIntegral","-- | Parses a Node's info"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L93-L108","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = NonDetC $ \\ fork leaf nil -> case sig of\n    L (L Empty)  -> nil\n    L (R Choose) -> leaf (True <$ ctx) `fork` leaf (False <$ ctx)\n    R other      -> thread (dst ~<~ hdl) other (pure ctx) >>= run . runNonDet (coerce fork) (coerce leaf) (coerce nil)\n    where\n    dst :: Applicative m => NonDetC Identity (NonDetC m a) -> m (NonDetC Identity a)\n    dst = run . runNonDet (liftA2 (liftA2 (<|>))) (pure . runNonDetA) (pure (pure empty))","function_tokens":["alg","hdl","sig","ctx","=","NonDetC","$","\\","fork","leaf","nil","->","case","sig","of","L","(","L","Empty",")","->","nil","L","(","R","Choose",")","->","leaf","(","True","<$","ctx",")","`","fork","`","leaf","(","False","<$","ctx",")","R","other","->","thread","(","dst","~<~","hdl",")","other","(","pure","ctx",")",">>=","run",".","runNonDet","(","coerce","fork",")","(","coerce","leaf",")","(","coerce","nil",")","where","dst","::","Applicative","m","=>","NonDetC","Identity","(","NonDetC","m","a",")","->","m","(","NonDetC","Identity","a",")","dst","=","run",".","runNonDet","(","liftA2","(","liftA2","(","<|>",")",")",")","(","pure",".","runNonDetA",")","(","pure","(","pure","empty",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L127-L134","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"liftHaskeline","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftHaskeline = Haskeline.withInterrupt >>> lift >>> EvalT","function_tokens":["liftHaskeline","=","Haskeline","withInterrupt",">>>","lift",">>>","EvalT"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L232-L232","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putContext","parameters":"Config{..} lctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putContext Config{..} lctx = suffix (space >> putText \"=>\" >> space) $\n    case ltys of\n        [lty] | GHC.HsParTy _ tp <- GHC.unLoc lty, cCurriedContext ->\n          putType tp\n        [ctx] ->\n          putType ctx\n        ctxs | cCurriedContext ->\n          sep (space >> putText \"=>\" >> space) (fmap putType ctxs)\n        ctxs ->\n          parenthesize $ sep (comma >> space) (fmap putType ctxs)\n  where\n    ltys = GHC.unLoc lctx :: [GHC.LHsType GHC.GhcPs]","function_tokens":["putContext","Config","{","..","}","lctx","=","suffix","(","space",">>","putText","\"=>\"",">>","space",")","$","case","ltys","of","[","lty","]","|","GHC","HsParTy","_","tp","<-","GHC","unLoc","lty",",","cCurriedContext","->","putType","tp","[","ctx","]","->","putType","ctx","ctxs","|","cCurriedContext","->","sep","(","space",">>","putText","\"=>\"",">>","space",")","(","fmap","putType","ctxs",")","ctxs","->","parenthesize","$","sep","(","comma",">>","space",")","(","fmap","putType","ctxs",")","where","ltys","=","GHC","unLoc","lctx","::","[","GHC","LHsType","GHC","GhcPs","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L479-L492","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"phi","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"phi e = TFun (tfmFromEvent e) (Single $ eventContent e)","function_tokens":["phi","e","=","TFun","(","tfmFromEvent","e",")","(","Single","$","eventContent","e",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L347-L347","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"varM","parameters":"f","argument_list":"","return_statement":"","docstring":"Lift a monadic computation to a var. This is <http:\/\/hackage.haskell.org\/package\/arrow-list-0.7\/docs\/Control-Arrow-Kleisli-Class.html#v:arrM arrM> parameterized over the @a `VarT m` b@ arrow.","docstring_summary":"Lift a monadic computation to a var. This is <http:\/\/hackage.haskell.org\/package\/arrow-list-0.7\/docs\/Control-Arrow-Kleisli-Class.html#v:arrM arrM> parameterized over the","docstring_tokens":["Lift","a","monadic","computation","to","a","var",".","This","is","<http",":","\/\/","hackage",".","haskell",".","org","\/","package","\/","arrow","-","list","-","0",".","7","\/","docs","\/","Control","-","Arrow","-","Kleisli","-","Class",".","html#v",":","arrM","arrM",">","parameterized","over","the"],"function":"varM f = VarT $ \\a -> do\n    b <- f a\n    return (b, varM f)\n\n-- | Lift a constant value to a var.","function_tokens":["varM","f","=","VarT","$","\\","a","->","do","b","<-","f","a","return","(","b",",","varM","f",")","-- | Lift a constant value to a var."],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L299-L304","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"liftIO","parameters":"io","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO io = lift (liftIO io)","function_tokens":["liftIO","io","=","lift","(","liftIO","io",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L117-L117","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"putP","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putP    = [| $(failE) ||| id <<< $putT |]","function_tokens":["putP","=","[","|"," $(failE) ||| id <<< $putT ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L439-L439","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookMemberEvent","function_tokens":["reflect","_","=","WebhookMemberEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L448-L448","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable\/Mutable.hs","language":"haskell","identifier":"dim","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dim = MG.dim","function_tokens":["dim","=","MG","dim"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable\/Mutable.hs#L27-L27","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable\/Mutable.hs","hash_val":8779,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"fromRows","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create matrix from rows","docstring_summary":"O(m*n) Create matrix from rows","docstring_tokens":["O","(","m","*","n",")","Create","matrix","from","rows"],"function":"fromRows = MG.fromRows","function_tokens":["fromRows","=","MG","fromRows"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L157-L157","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"forall","parameters":"vs f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forall vs f = case match f of\n    Just (Forall vs' f') -> forall (vs ++ vs') f'\n    Nothing -> inject $ Forall vs f\n\n-- | A smart constructor for existentially quantified formulae","function_tokens":["forall","vs","f","=","case","match","f","of","Just","(","Forall","vs'","f'",")","->","forall","(","vs","++","vs'",")","f'","Nothing","->","inject","$","Forall","vs","f","-- | A smart constructor for existentially quantified formulae"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L653-L658","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Point a b <|> Point c d = Point (a <|> c) (b <|> d)","function_tokens":["Point","a","b","<|>","Point","c","d","=","Point","(","a","<|>","c",")","(","b","<|>","d",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L105-L105","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"IFix a `ieq` IFix b = a `ieq1` b","function_tokens":["IFix","a","`","ieq","`","IFix","b","=","a","`","ieq1","`","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Functor.hs#L35-L35","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Functor.hs","hash_val":19560,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(FreeText a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (FreeText a)     = string a","function_tokens":["pretty","(","FreeText","a",")","=","string","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L131-L131","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"filter","parameters":"predicate t","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nFilter\n------------------------------------------------------------------} \/O(n)\/. Filter all elements that satisfy some predicate.","docstring_summary":"{--------------------------------------------------------------------\nFilter\n------------------------------------------------------------------} \/O(n)\/. Filter all elements that satisfy some predicate.","docstring_tokens":["{","--------------------------------------------------------------------","Filter","------------------------------------------------------------------","}","\/","O","(","n",")","\/",".","Filter","all","elements","that","satisfy","some","predicate","."],"function":"filter predicate t\n  = case t of\n      Bin _ _ p m l r\n        -> bin p m (filter predicate l) (filter predicate r)\n      Tip _ x\n        | predicate x -> t\n        | otherwise   -> Nil\n      Nil -> Nil\n\n-- | \/O(n)\/. partition the set according to some predicate.","function_tokens":["filter","predicate","t","=","case","t","of","Bin","_","_","p","m","l","r","->","bin","p","m","(","filter","predicate","l",")","(","filter","predicate","r",")","Tip","_","x","|","predicate","x","->","t","|","otherwise","->","Nil","Nil","->","Nil","-- | \/O(n)\/. partition the set according to some predicate."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L498-L508","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookGollumEvent","function_tokens":["reflect","_","=","WebhookGollumEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L430-L430","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"qs'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"qs' = zip [1..length qs] qs","function_tokens":["qs'","=","zip","[","1","..","length","qs","]","qs"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L37-L37","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Error.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = 100000","function_tokens":["n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Error.hs#L27-L27","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Error.hs","hash_val":32578,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"cache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cache = intSetCache","function_tokens":["cache","=","intSetCache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L212-L212","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"eventFromTfm","parameters":"(Tfm str del)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eventFromTfm (Tfm str del) = Event del str","function_tokens":["eventFromTfm","(","Tfm","str","del",")","=","Event","del","str"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L362-L362","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Reader.hs","language":"haskell","identifier":"benchmark","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"benchmark = bgroup \"Reader\"\n  [ bgroup \"ask\"\n    [ bench \"(->)\"    $ whnf (`asking` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . asking) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . asking) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . asking) n\n      ]\n    ]\n  , bgroup \"local\"\n    [ bench \"(->)\"    $ whnf (`locally` 'c') n\n    , bgroup \"Identity\"\n      [ bench \"ReaderC\" $ whnf (run . runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnf (run . (`runReaderT` 'c') . locally) n\n      ]\n    , bgroup \"IO\"\n      [ bench \"ReaderC\" $ whnfAppIO (runReader 'c' . locally) n\n      , bench \"ReaderT\" $ whnfAppIO ((`runReaderT` 'c') . locally) n\n      ]\n    ]\n  ]\n  where\n  n = 100000","function_tokens":["benchmark","=","bgroup","\"Reader\"","[","bgroup","\"ask\"","[","bench","\"(->)\"","$","whnf","(","`","asking","`","'c'",")","n",",","bgroup","\"Identity\"","[","bench","\"ReaderC\"","$","whnf","(","run",".","runReader","'c'",".","asking",")","n",",","bench","\"ReaderT\"","$","whnf","(","run",".","(","`","runReaderT","`","'c'",")",".","asking",")","n","]",",","bgroup","\"IO\"","[","bench","\"ReaderC\"","$","whnfAppIO","(","runReader","'c'",".","asking",")","n",",","bench","\"ReaderT\"","$","whnfAppIO","(","(","`","runReaderT","`","'c'",")",".","asking",")","n","]","]",",","bgroup","\"local\"","[","bench","\"(->)\"","$","whnf","(","`","locally","`","'c'",")","n",",","bgroup","\"Identity\"","[","bench","\"ReaderC\"","$","whnf","(","run",".","runReader","'c'",".","locally",")","n",",","bench","\"ReaderT\"","$","whnf","(","run",".","(","`","runReaderT","`","'c'",")",".","locally",")","n","]",",","bgroup","\"IO\"","[","bench","\"ReaderC\"","$","whnfAppIO","(","runReader","'c'",".","locally",")","n",",","bench","\"ReaderT\"","$","whnfAppIO","(","(","`","runReaderT","`","'c'",")",".","locally",")","n","]","]","]","where","n","=","100000"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Reader.hs#L12-L39","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Reader.hs","hash_val":22189,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"start","parameters":"inst rq","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"start inst rq = do\n        startRecvProcess . handle $ inst\n        let rChan = timeoutChan rq\n            dChan = defaultChan rq\n        receivingId <- forkIO . receivingProcess inst rq rChan $ dChan\n        pingId <- forkIO . pingProcess inst $ dChan\n        spreadId <- forkIO . spreadValueProcess $ inst\n        void . forkIO $ backgroundProcess inst dChan [pingId, spreadId, receivingId]\n\n-- | The central process all Replys go trough","function_tokens":["start","inst","rq","=","do","startRecvProcess",".","handle","$","inst","let","rChan","=","timeoutChan","rq","dChan","=","defaultChan","rq","receivingId","<-","forkIO",".","receivingProcess","inst","rq","rChan","$","dChan","pingId","<-","forkIO",".","pingProcess","inst","$","dChan","spreadId","<-","forkIO",".","spreadValueProcess","$","inst","void",".","forkIO","$","backgroundProcess","inst","dChan","[","pingId",",","spreadId",",","receivingId","]","-- | The central process all Replys go trough"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L109-L119","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"addExtraField","parameters":"n b s","argument_list":"","return_statement":"","docstring":"Add an extra field. The specified entry may be missing, in that case this action has no effect.","docstring_summary":"Add an extra field. The specified entry may be missing, in that case this action has no effect.","docstring_tokens":["Add","an","extra","field",".","The","specified","entry","may","be","missing","in","that","case","this","action","has","no","effect","."],"function":"addExtraField n b s = addPending (I.AddExtraField n b s)","function_tokens":["addExtraField","n","b","s","=","addPending","(","I","AddExtraField","n","b","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L580-L580","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r,c) = dim mat","function_tokens":["(","r",",","c",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L105-L105","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"injLabelled","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"injLabelled = R . injLabelled","function_tokens":["injLabelled","=","R",".","injLabelled"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L105-L105","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"natFromInt","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"natFromInt i = fromIntegral i","function_tokens":["natFromInt","i","=","fromIntegral","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L140-L140","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"computePrefixDir","parameters":"NoPrefixSpecified (AppImageExe (ExeFile exeFp))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"computePrefixDir NoPrefixSpecified (AppImageExe (ExeFile exeFp)) =\n  over PrefixDir (exeFp <.>) defaultPrefix","function_tokens":["computePrefixDir","NoPrefixSpecified","(","AppImageExe","(","ExeFile","exeFp",")",")","=","over","PrefixDir","(","exeFp","<.>",")","defaultPrefix"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L107-L108","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"SymbolLine","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go SymbolLine               = \"s\"","function_tokens":["go","SymbolLine","=","\"s\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L354-L354","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","language":"haskell","identifier":"match","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"match = GHC.unLoc lmatch","function_tokens":["match","=","GHC","unLoc","lmatch"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs#L67-L67","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Squash.hs","hash_val":33786,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(r',s') = f r s","function_tokens":["(","r'",",","s'",")","=","f","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L119-L119","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"p2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p2 = Proxy :: Proxy context","function_tokens":["p2","=","Proxy","::","Proxy","context"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L341-L341","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"firstItem","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"firstItem = Text.strip (renderText Plain (_menuItemPrefix m 1))","function_tokens":["firstItem","=","Text","strip","(","renderText","Plain","(","_menuItemPrefix","m","1",")",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L223-L223","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmp","parameters":"(Bin _ _ _ _ _ _) _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subsetCmp (Bin _ _ _ _ _ _) _  = GT","function_tokens":["subsetCmp","(","Bin","_","_","_","_","_","_",")","_","=","GT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L469-L469","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(n, ns') = runCoiter ns","function_tokens":["(","n",",","ns'",")","=","runCoiter","ns"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L765-L765","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/StrUtils.hs","language":"haskell","identifier":"stripNewline","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stripNewline x\n    | \"\\n\" `isSuffixOf` x = init x\n    | otherwise = x","function_tokens":["stripNewline","x","|","\"\\n\"","`","isSuffixOf","`","x","=","init","x","|","otherwise","=","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/StrUtils.hs#L12-L14","hash_key":"Peaker\/git-mediate:src\/StrUtils.hs","hash_val":9940,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"f","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f x = [x, dt]","function_tokens":["f","x","=","[","x",",","dt","]"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L410-L410","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseSerialize","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseSerialize = do\n    bs <- lift get\n    case fromBS bs of\n        Left err -> throwE err\n        Right (id, rest) -> do\n            lift . put $ rest\n            return id\n\n-- | Parses a CommandId","function_tokens":["parseSerialize","=","do","bs","<-","lift","get","case","fromBS","bs","of","Left","err","->","throwE","err","Right","(","id",",","rest",")","->","do","lift",".","put","$","rest","return","id","-- | Parses a CommandId"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L44-L53","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \/\\ b = a .&. b","function_tokens":["a","\/\\","b","=","a",".&.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L206-L206","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Device.hs","language":"haskell","identifier":"allDeviceSpecifiers","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Contains a list of specifiers for all available devices.","docstring_summary":"------------------------------------------------------------------------------ Contains a list of specifiers for all available devices.","docstring_tokens":["------------------------------------------------------------------------------","Contains","a","list","of","specifiers","for","all","available","devices","."],"function":"allDeviceSpecifiers = makeGettableStateVar $ do\n   enumExtPresent <- get (alcIsExtensionPresent Nothing \"ALC_ENUMERATION_EXT\")\n   if enumExtPresent\n      then getStringRaw Nothing DeviceSpecifier >>= peekALCStrings\n      else get defaultDeviceSpecifier >>= (return . maybe [] (\\s -> [s]))","function_tokens":["allDeviceSpecifiers","=","makeGettableStateVar","$","do","enumExtPresent","<-","get","(","alcIsExtensionPresent","Nothing","\"ALC_ENUMERATION_EXT\"",")","if","enumExtPresent","then","getStringRaw","Nothing","DeviceSpecifier",">>=","peekALCStrings","else","get","defaultDeviceSpecifier",">>=","(","return",".","maybe","[","]","(","\\","s","->","[","s","]",")",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Device.hs#L218-L222","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Device.hs","hash_val":14318,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/OptCairo.hs","language":"haskell","identifier":"p","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"p = pickProjection projection","function_tokens":["p","=","pickProjection","projection"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/OptCairo.hs#L34-L34","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/OptCairo.hs","hash_val":36200,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"modify","parameters":"l m","argument_list":"","return_statement":"","docstring":"Modifier for a lens that can fail. When the field to which the lens points is not accessible this function returns 'Nothing'.","docstring_summary":"Modifier for a lens that can fail. When the field to which the lens points is not accessible this function returns 'Nothing'.","docstring_tokens":["Modifier","for","a","lens","that","can","fail",".","When","the","field","to","which","the","lens","points","is","not","accessible","this","function","returns","Nothing","."],"function":"modify l m = runKleisli (Poly.modify l . arr ((,) (arr m)))","function_tokens":["modify","l","m","=","runKleisli","(","Poly","modify","l",".","arr","(","(",",",")","(","arr","m",")",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L68-L68","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"evalState","parameters":"s","argument_list":"","return_statement":"","docstring":"Run a 'State' effect, yielding the result value and discarding the final state.  @ 'evalState' s m = 'fmap' 'snd' ('runState' s m) @  @since 1.0.0.0","docstring_summary":"Run a 'State' effect, yielding the result value and discarding the final state.","docstring_tokens":["Run","a","State","effect","yielding","the","result","value","and","discarding","the","final","state","."],"function":"evalState s = fmap snd . runState s","function_tokens":["evalState","s","=","fmap","snd",".","runState","s"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L59-L59","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"dosTime","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dosTime = fromIntegral (seconds + shiftL minutes 5 + shiftL hours 11)","function_tokens":["dosTime","=","fromIntegral","(","seconds","+","shiftL","minutes","5","+","shiftL","hours","11",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1172-L1172","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"vstrace","parameters":"s","argument_list":"","return_statement":"","docstring":"Trace the sample value of a var with a prefix and pass the sample along as output. This is very useful for debugging graphs of vars.  >>> let v = id >>> vstrace \"test: \" >>> testVarOver v [1,2,3] test: 1 1 test: 2 2 test: 3 3","docstring_summary":"Trace the sample value of a var with a prefix and pass the sample along as output. This is very useful for debugging graphs of vars.  >>> let v = id >>> vstrace \"test: \" >>> testVarOver v [1,2,3] test: 1 1 test: 2 2 test: 3 3","docstring_tokens":["Trace","the","sample","value","of","a","var","with","a","prefix","and","pass","the","sample","along","as","output",".","This","is","very","useful","for","debugging","graphs","of","vars",".",">>>","let","v","=","id",">>>","vstrace","test",":",">>>","testVarOver","v","[","1","2","3","]","test",":","1","1","test",":","2","2","test",":","3","3"],"function":"vstrace s = vftrace ((s ++) . show)","function_tokens":["vstrace","s","=","vftrace","(","(","s","++",")",".","show",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L431-L431","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"toWord16","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toWord16 = fromIntegral","function_tokens":["toWord16","=","fromIntegral"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L105-L105","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"bench\/bench.hs","language":"haskell","identifier":"mkBench","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkBench n = map toBench . actions\n            where\n                toBench (n', a) = bench (n' ++ \" [\" ++ n ++ \"]\") $ nf a benchlen","function_tokens":["mkBench","n","=","map","toBench",".","actions","where","toBench","(","n'",",","a",")","=","bench","(","n'","++","\" [\"","++","n","++","\"]\"",")","$","nf","a","benchlen"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/bench\/bench.hs#L46-L48","hash_key":"bartavelle\/stateWriter:bench\/bench.hs","hash_val":16621,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Major","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Major        = \"\"","function_tokens":["go","Major","=","\"\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L528-L528","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"filterRedundant","parameters":"isRedundant'","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Filter redundant (and duplicate) pragmas out of the groups. As a side effect, we also sort the pragmas in their group...","docstring_summary":"------------------------------------------------------------------------------ Filter redundant (and duplicate) pragmas out of the groups. As a side effect, we also sort the pragmas in their group...","docstring_tokens":["------------------------------------------------------------------------------","Filter","redundant","(","and","duplicate",")","pragmas","out","of","the","groups",".","As","a","side","effect","we","also","sort","the","pragmas","in","their","group","..."],"function":"filterRedundant isRedundant' = snd . foldr filterRedundant' (S.empty, []) . fmap (fmap toList)\n  where\n    filterRedundant' (l, xs) (known, zs)\n        | S.null xs' = (known', zs)\n        | otherwise  = (known', (l, S.toAscList xs') : zs)\n      where\n        fxs    = filter (not . isRedundant') xs\n        xs'    = S.fromList fxs `S.difference` known\n        known' = xs' `S.union` known\n\n--------------------------------------------------------------------------------","function_tokens":["filterRedundant","isRedundant'","=","snd",".","foldr","filterRedundant'","(","S","empty",",","[","]",")",".","fmap","(","fmap","toList",")","where","filterRedundant'","(","l",",","xs",")","(","known",",","zs",")","|","S","null","xs'","=","(","known'",",","zs",")","|","otherwise","=","(","known'",",","(","l",",","S","toAscList","xs'",")",":","zs",")","where","fxs","=","filter","(","not",".","isRedundant'",")","xs","xs'","=","S","fromList","fxs","`","S","difference","`","known","known'","=","xs'","`","S","union","`","known","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L105-L116","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = fst (O.renderFailure h \"\")","function_tokens":["s","=","fst","(","O","renderFailure","h","\"\"",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L86-L86","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Cull\/Church.hs","language":"haskell","identifier":"runCullM","parameters":"leaf","argument_list":"","return_statement":"","docstring":"Run a 'Cull' effect, mapping results into a 'Monoid'.  @since 1.0.0.0","docstring_summary":"Run a 'Cull' effect, mapping results into a 'Monoid'.","docstring_tokens":["Run","a","Cull","effect","mapping","results","into","a","Monoid","."],"function":"runCullM leaf = runCull (liftA2 mappend) (pure . leaf) (pure mempty)","function_tokens":["runCullM","leaf","=","runCull","(","liftA2","mappend",")","(","pure",".","leaf",")","(","pure","mempty",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Cull\/Church.hs#L60-L60","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Cull\/Church.hs","hash_val":5414,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"indexes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"indexes = [0..(length bs `div` 8) -1]","function_tokens":["indexes","=","[","0","..","(","length","bs","`","div","`","8",")","-","1","]"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L68-L68","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Identity (Point x y, vNext) = runVarT v dt","function_tokens":["Identity","(","Point","x","y",",","vNext",")","=","runVarT","v","dt"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L67-L67","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"inv","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"inv i = Iso (bw i) (fw i)","function_tokens":["inv","i","=","Iso","(","bw","i",")","(","fw","i",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L126-L126","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"insertNode","parameters":"(KI _ (KS sTree _) _) node","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"insertNode (KI _ (KS sTree _) _) node = atomically $ do\n    tree <- readTVar sTree\n    writeTVar sTree . T.insert tree $ node\n\n-- | Signal a Node's timeout and retur wether it should be repinged","function_tokens":["insertNode","(","KI","_","(","KS","sTree","_",")","_",")","node","=","atomically","$","do","tree","<-","readTVar","sTree","writeTVar","sTree",".","T","insert","tree","$","node","-- | Signal a Node's timeout and retur wether it should be repinged"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L64-L69","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Discography a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Discography a)          = a","function_tokens":["go","(","Discography","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L408-L408","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"queryShape","parameters":"CayleyConnection{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"queryShape CayleyConnection{..} =\n  doShape manager cayleyConfig\n  where\n    doShape m CayleyConfig{..} q = do\n      r <- apiRequest\n             m (urlBase serverName apiVersion ++ \"\/shape\/\" ++ show queryLang)\n             serverPort (RequestBodyBS $ encodeUtf8 q)\n      return $\n        case r of\n          Just o  ->\n            case A.fromJSON o of\n              A.Success s -> Right s\n              A.Error e   -> Left (\"Not a shape (\\\"\" ++ e ++ \"\\\")\")\n          Nothing -> Left \"API request error\"\n\n-- | Write a 'Quad' with the given subject, predicate, object and optional\n-- label. Throw result or extract amount of query 'results'\n-- from it.\n--\n-- >\u03bb> writeQuad conn \"Humphrey\" \"loves\" \"Lauren\" (Just \"In love\")\n-- >Just (Object (fromList [(\"result\",String \"Successfully wrote 1 quads.\")]))\n--","function_tokens":["queryShape","CayleyConnection","{","..","}","=","doShape","manager","cayleyConfig","where","doShape","m","CayleyConfig","{","..","}","q","=","do","r","<-","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/shape\/\"","++","show","queryLang",")","serverPort","(","RequestBodyBS","$","encodeUtf8","q",")","return","$","case","r","of","Just","o","->","case","A","fromJSON","o","of","A","Success","s","->","Right","s","A","Error","e","->","Left","(","\"Not a shape (\\\"\"","++","e","++","\"\\\")\"",")","Nothing","->","Left","\"API request error\"","-- | Write a 'Quad' with the given subject, predicate, object and optional","-- label. Throw result or extract amount of query 'results'","-- from it.","--","-- >\u03bb> writeQuad conn \"Humphrey\" \"loves\" \"Lauren\" (Just \"In love\")","-- >Just (Object (fromList [(\"result\",String \"Successfully wrote 1 quads.\")]))","--"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L87-L109","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"imap","parameters":"f (Select is es a i)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Select is es a i)   = Select is es (f a) (f i)","function_tokens":["imap","f","(","Select","is","es","a","i",")","=","Select","is","es","(","f","a",")","(","f","i",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L60-L60","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"commit","parameters":"path ArchiveDescription {..} entries xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commit path ArchiveDescription {..} entries xs =\n  withNewFile path $ \\h -> do\n    let (ProducingActions coping sinking, editing) =\n          optimize (toRecreatingActions path entries >< xs)\n        comment = predictComment adComment xs\n    copiedCD <-\n      M.unions\n        <$> forM\n          (M.keys coping)\n          ( \\srcPath ->\n              copyEntries h srcPath (coping ! srcPath) editing\n          )\n    let sinkingKeys = M.keys $ sinking `M.difference` copiedCD\n    sunkCD <-\n      M.fromList\n        <$> forM\n          sinkingKeys\n          ( \\selector ->\n              sinkEntry h selector GenericOrigin (sinking ! selector) editing\n          )\n    writeCD h comment (copiedCD `M.union` sunkCD)\n\n-- | Create a new file with the guarantee that in the case of an exception\n-- the old file will be intact. The file is only updated\\\/replaced if the\n-- second argument finishes without exceptions.","function_tokens":["commit","path","ArchiveDescription","{","..","}","entries","xs","=","withNewFile","path","$","\\","h","->","do","let","(","ProducingActions","coping","sinking",",","editing",")","=","optimize","(","toRecreatingActions","path","entries","><","xs",")","comment","=","predictComment","adComment","xs","copiedCD","<-","M","unions","<$>","forM","(","M","keys","coping",")","(","\\","srcPath","->","copyEntries","h","srcPath","(","coping","!","srcPath",")","editing",")","let","sinkingKeys","=","M","keys","$","sinking","`","M","difference","`","copiedCD","sunkCD","<-","M","fromList","<$>","forM","sinkingKeys","(","\\","selector","->","sinkEntry","h","selector","GenericOrigin","(","sinking","!","selector",")","editing",")","writeCD","h","comment","(","copiedCD","`","M","union","`","sunkCD",")","-- | Create a new file with the guarantee that in the case of an exception","-- the old file will be intact. The file is only updated\\\/replaced if the","-- second argument finishes without exceptions."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L273-L298","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","language":"haskell","identifier":"unsafeWrite","parameters":"(SymMMatrix n v) (i,j)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unsafeWrite (SymMMatrix n v) (i,j) = GM.unsafeWrite v (idx n i j)","function_tokens":["unsafeWrite","(","SymMMatrix","n","v",")","(","i",",","j",")","=","GM","unsafeWrite","v","(","idx","n","i","j",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs#L32-L32","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Symmetric\/Generic\/Mutable.hs","hash_val":33107,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"identity","parameters":"(Pi i _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identity (Pi i _ _ _) = i","function_tokens":["identity","(","Pi","i","_","_","_",")","=","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L45-L45","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"go","parameters":"a v'","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go a v' = VarT $ \\a' -> do (b', v'') <- runVarT v' a\n                                     return (b', go a' v'')\n--------------------------------------------------------------------------------\n-- $running\n-- To sample a var simply run it in the desired monad with\n-- 'runVarT'. This will produce a sample value and a new var.\n--\n-- >>> :{\n-- do let v0 = accumulate (+) 0\n--    (b, v1) <- runVarT v0 1\n--    print b\n--    (c, v2) <- runVarT v1 b\n--    print c\n--    (d,  _) <- runVarT v2 c\n--    print d\n-- >>> :}\n-- 1\n-- 2\n-- 4\n--------------------------------------------------------------------------------\n-- | Iterate a var over a list of input until all input is consumed,\n-- then iterate the var using one single input. Returns the resulting\n-- output value and the new var.\n--\n-- >>> let Identity (outputs, _) = stepMany (accumulate (+) 0) [1,1,1] 1\n-- >>> print outputs\n-- 4","function_tokens":["go","a","v'","=","VarT","$","\\","a'","->","do","(","b'",",","v''",")","<-","runVarT","v'","a","return","(","b'",",","go","a'","v''",")","--------------------------------------------------------------------------------","-- $running","-- To sample a var simply run it in the desired monad with","-- 'runVarT'. This will produce a sample value and a new var.","--","-- >>> :{","-- do let v0 = accumulate (+) 0","--    (b, v1) <- runVarT v0 1","--    print b","--    (c, v2) <- runVarT v1 b","--    print c","--    (d,  _) <- runVarT v2 c","--    print d","-- >>> :}","-- 1","-- 2","-- 4","--------------------------------------------------------------------------------","-- | Iterate a var over a list of input until all input is consumed,","-- then iterate the var using one single input. Returns the resulting","-- output value and the new var.","--","-- >>> let Identity (outputs, _) = stepMany (accumulate (+) 0) [1,1,1] 1","-- >>> print outputs","-- 4"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L358-L385","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"go","parameters":"(BApp f a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (BApp f a) = App i f a","function_tokens":["go","(","BApp","f","a",")","=","App","i","f","a"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L36-L36","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = G.length vec","function_tokens":["n","=","G","length","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L122-L122","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = NoChange","function_tokens":["mempty","=","NoChange"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L141-L141","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"i'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"i' = offset + i * tda","function_tokens":["i'","=","offset","+","i","*","tda"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L51-L51","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"nil","parameters":"","argument_list":"","return_statement":"","docstring":"Monoid shortcuts Synonym for method 'mempty'.","docstring_summary":"Monoid shortcuts Synonym for method 'mempty'.","docstring_tokens":["Monoid","shortcuts","Synonym","for","method","mempty","."],"function":"nil = mempty","function_tokens":["nil","=","mempty"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L66-L66","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"fontStyle","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fontStyle = font_size .~ 15 $ font_weight .~ FontWeightBold $ def","function_tokens":["fontStyle","=","font_size",".~","15","$","font_weight",".~","FontWeightBold","$","def"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L48-L48","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"forkOn","parameters":"","argument_list":"","return_statement":"","docstring":"Same as @Control.Concurrent.Thread.'Thread.forkOn'@ but additionaly adds the thread to the group.","docstring_summary":"Same as","docstring_tokens":["Same","as"],"function":"forkOn = fork . rawForkOn","function_tokens":["forkOn","=","fork",".","rawForkOn"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L154-L154","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"hours","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hours = fromIntegral (shiftR msDosTime 11 .&. 0x1f)","function_tokens":["hours","=","fromIntegral","(","shiftR","msDosTime","11",".&.","0x1f",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1192-L1192","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"sub","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sub        = mconcat $ zipWith (\\(IFix (Var n s)) (IFix (Var n' _)) -> inject (Var n' s) `for` inject (Var n s)) vs vs'","function_tokens":["sub","=","mconcat","$","zipWith","(","\\","(","IFix","(","Var","n","s",")",")","(","IFix","(","Var","n'","_",")",")","->","inject","(","Var","n'","s",")","`","for","`","inject","(","Var","n","s",")",")","vs","vs'"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L725-L725","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"lookupValue","parameters":"key (KI _ (KS _ values) _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookupValue key (KI _ (KS _ values) _) = atomically $ do\n    vals <- readTVar values\n    return . M.lookup key $ vals\n\n-- | Start the background process for a KademliaInstance","function_tokens":["lookupValue","key","(","KI","_","(","KS","_","values",")","_",")","=","atomically","$","do","vals","<-","readTVar","values","return",".","M","lookup","key","$","vals","-- | Start the background process for a KademliaInstance"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L102-L107","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"ins","parameters":"t x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ins t x  = insert x t","function_tokens":["ins","t","x","=","insert","x","t"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L726-L726","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zip","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip = MG.zip","function_tokens":["zip","=","MG","zip"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L310-L310","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"commentOnLine","parameters":"l","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commentOnLine l = listToMaybe $ do\n            comment <- epAnnComments $ GHC.hsmodAnn modul\n            guard $ GHC.srcSpanStartLine (GHC.anchor $ GHC.getLoc comment) == l\n            pure comment","function_tokens":["commentOnLine","l","=","listToMaybe","$","do","comment","<-","epAnnComments","$","GHC","hsmodAnn","modul","guard","$","GHC","srcSpanStartLine","(","GHC","anchor","$","GHC","getLoc","comment",")","==","l","pure","comment"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L92-L97","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"names","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"names = return <$> ['a'..'z']","function_tokens":["names","=","return","<$>","[","'a'","..","'z'","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L579-L579","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"var","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var   = varE (fresh !! i)","function_tokens":["var","=","varE","(","fresh","!!","i",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L518-L518","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseLanguagePragmas","parameters":"config o","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseLanguagePragmas config o = LanguagePragmas.step\n    <$> pure (configColumns config)\n    <*> (o A..:? \"style\" >>= parseEnum styles LanguagePragmas.Vertical)\n    <*> o A..:? \"align\"            A..!= True\n    <*> o A..:? \"remove_redundant\" A..!= True\n    <*> mkLanguage o\n  where\n    styles =\n        [ (\"vertical\",         LanguagePragmas.Vertical)\n        , (\"compact\",          LanguagePragmas.Compact)\n        , (\"compact_line\",     LanguagePragmas.CompactLine)\n        , (\"vertical_compact\", LanguagePragmas.VerticalCompact)\n        ]\n\n\n--------------------------------------------------------------------------------\n-- | Utilities for validating language prefixes","function_tokens":["parseLanguagePragmas","config","o","=","LanguagePragmas","step","<$>","pure","(","configColumns","config",")","<*>","(","o","A",".:?","\"style\"",">>=","parseEnum","styles","LanguagePragmas","Vertical",")","<*>","o","A",".:?","\"align\"","A",".!=","True","<*>","o","A",".:?","\"remove_redundant\"","A",".!=","True","<*>","mkLanguage","o","where","styles","=","[","(","\"vertical\"",",","LanguagePragmas","Vertical",")",",","(","\"compact\"",",","LanguagePragmas","Compact",")",",","(","\"compact_line\"",",","LanguagePragmas","CompactLine",")",",","(","\"vertical_compact\"",",","LanguagePragmas","VerticalCompact",")","]","--------------------------------------------------------------------------------","-- | Utilities for validating language prefixes"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L329-L346","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"go","parameters":"(c:cs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (c:cs)   = c + x * go cs","function_tokens":["go","(","c",":","cs",")","=","c","+","x","*","go","cs"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L95-L95","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"fixable","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fixable []     = False","function_tokens":["fixable","[","]","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L92-L92","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a ==> b = nnf (not a \\\/ b)","function_tokens":["a","==>","b","=","nnf","(","not","a","\\\/","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L230-L230","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"distanceRad","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"distanceRad = on centralAngle toRadians","function_tokens":["distanceRad","=","on","centralAngle","toRadians"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L30-L30","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"captureStartStop","parameters":"funName device","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"captureStartStop funName device = liftIO $ do\n   funPtr <- getCaptureFunc funName\n   invokeCaptureStartStop funPtr (marshalDevice device)","function_tokens":["captureStartStop","funName","device","=","liftIO","$","do","funPtr","<-","getCaptureFunc","funName","invokeCaptureStartStop","funPtr","(","marshalDevice","device",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L78-L82","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs","language":"haskell","identifier":"dbfPath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dbfPath = dropExtension fp ++ \".dbf\"","function_tokens":["dbfPath","=","dropExtension","fp","++","\".dbf\""],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs#L22-L22","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/MergeShpDbf.hs","hash_val":12976,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"makeFormat","parameters":"1  8","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ ToDo: What about IMAADPCMMono16, IMAADPCMStereo16, Vorbis...?","docstring_summary":"------------------------------------------------------------------------------ ToDo: What about IMAADPCMMono16, IMAADPCMStereo16, Vorbis...?","docstring_tokens":["------------------------------------------------------------------------------","ToDo",":","What","about","IMAADPCMMono16","IMAADPCMStereo16","Vorbis","...","?"],"function":"makeFormat 1  8 = Mono8","function_tokens":["makeFormat","1","8","=","Mono8"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L144-L144","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"matchToAlignable","parameters":"(GHC.L matchLoc m@(Hs.Match _ Hs.CaseAlt pats@(_ : _) grhss))","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchToAlignable (GHC.L matchLoc m@(Hs.Match _ Hs.CaseAlt pats@(_ : _) grhss)) = do\n  let patsLocs   = map GHC.getLocA pats\n      pat        = last patsLocs\n      guards     = getGuards m\n      guardsLocs = map GHC.getLocA guards\n      left       = foldl' GHC.combineSrcSpans pat guardsLocs\n  body     <- rhsBody grhss\n  matchPos <- GHC.srcSpanToRealSrcSpan $ GHC.locA matchLoc\n  leftPos  <- GHC.srcSpanToRealSrcSpan left\n  rightPos <- GHC.srcSpanToRealSrcSpan $ GHC.getLocA body\n  Just . Left $ Alignable\n    { aContainer = matchPos\n    , aLeft      = leftPos\n    , aRight     = rightPos\n    , aRightLead = length \"-> \"\n    }","function_tokens":["matchToAlignable","(","GHC","L","matchLoc","m","@","(","Hs","Match","_","Hs","CaseAlt","pats","@","(","_",":","_",")","grhss",")",")","=","do","let","patsLocs","=","map","GHC","getLocA","pats","pat","=","last","patsLocs","guards","=","getGuards","m","guardsLocs","=","map","GHC","getLocA","guards","left","=","foldl'","GHC","combineSrcSpans","pat","guardsLocs","body","<-","rhsBody","grhss","matchPos","<-","GHC","srcSpanToRealSrcSpan","$","GHC","locA","matchLoc","leftPos","<-","GHC","srcSpanToRealSrcSpan","left","rightPos","<-","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","body","Just",".","Left","$","Alignable","{","aContainer","=","matchPos",",","aLeft","=","leftPos",",","aRight","=","rightPos",",","aRightLead","=","length","\"-> \"","}"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L117-L133","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"itraverse","parameters":"f (Forall vs b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Forall vs b) = Forall vs <$> f b","function_tokens":["itraverse","f","(","Forall","vs","b",")","=","Forall","vs","<$>","f","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L553-L553","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_DOPPLER_FACTOR","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_DOPPLER_FACTOR                   = 0xC000","function_tokens":["al_DOPPLER_FACTOR","=","0xC000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L42-L42","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decompressingPipe","parameters":"BZip2","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decompressingPipe BZip2 = BZ.bunzip2","function_tokens":["decompressingPipe","BZip2","=","BZ","bunzip2"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1153-L1153","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","language":"haskell","identifier":"ws","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ws = WorkState\n        { workStateZ = ptr `F.plusPtr`  0\n        , workStateO = ptr `F.plusPtr`  8\n        , workStateE = ptr `F.plusPtr` (8 * 2)\n        , workStateM = ptr `F.plusPtr` (8 * 3)\n        , workStateP = fptr\n        }","function_tokens":["ws","=","WorkState","{","workStateZ","=","ptr","`","F","plusPtr","`","0",",","workStateO","=","ptr","`","F","plusPtr","`","8",",","workStateE","=","ptr","`","F","plusPtr","`","(","8","*","2",")",",","workStateM","=","ptr","`","F","plusPtr","`","(","8","*","3",")",",","workStateP","=","fptr","}"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs#L71-L77","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Internal\/Index\/Simple.hs","hash_val":30325,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"throwError","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"throwError e = do\n    names <- getParserNames\n    ConduitParser . throwError $ foldr NamedParserException e $ reverse names","function_tokens":["throwError","e","=","do","names","<-","getParserNames","ConduitParser",".","throwError","$","foldr","NamedParserException","e","$","reverse","names"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L51-L55","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"bsB","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bsB = toByteStruct idB","function_tokens":["bsB","=","toByteStruct","idB"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L79-L79","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"mapM_","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM_ = MG.mapM_","function_tokens":["mapM_","=","MG","mapM_"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L243-L243","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getEntry","parameters":"s","argument_list":"","return_statement":"","docstring":"Get contents of a specific archive entry as a strict 'ByteString'. It's not recommended to use this on big entries, because it will suck out a lot of memory. For big entries, use conduits: 'sourceEntry'.  Throws: 'EntryDoesNotExist'.","docstring_summary":"Get contents of a specific archive entry as a strict 'ByteString'. It's not recommended to use this on big entries, because it will suck out a lot of memory. For big entries, use conduits: 'sourceEntry'.  Throws: 'EntryDoesNotExist'.","docstring_tokens":["Get","contents","of","a","specific","archive","entry","as","a","strict","ByteString",".","It","s","not","recommended","to","use","this","on","big","entries","because","it","will","suck","out","a","lot","of","memory",".","For","big","entries","use","conduits",":","sourceEntry",".","Throws",":","EntryDoesNotExist","."],"function":"getEntry s = sourceEntry s (CL.foldMap id)","function_tokens":["getEntry","s","=","sourceEntry","s","(","CL","foldMap","id",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L337-L337","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"singleLine","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"singleLine s      = GHC.srcSpanStartLine s == GHC.srcSpanEndLine s","function_tokens":["singleLine","s","=","GHC","srcSpanStartLine","s","==","GHC","srcSpanEndLine","s"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L97-L97","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookRepositoryEvent","function_tokens":["reflect","_","=","WebhookRepositoryEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L436-L436","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"unmarshalLoopingMode","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalLoopingMode x = if x then Looping else OneShot","function_tokens":["unmarshalLoopingMode","x","=","if","x","then","Looping","else","OneShot"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L253-L253","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"es","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge es  = inject $ Add es","function_tokens":["merge","es","=","inject","$","Add","es"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L172-L172","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"show","parameters":"Cabal","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show Cabal = \"cabal\"","function_tokens":["show","Cabal","=","\"cabal\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L21-L21","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_UNDETERMINED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_UNDETERMINED                     = 0x1030","function_tokens":["al_UNDETERMINED","=","0x1030"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L99-L99","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Remark","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Remark                   = (True, True, True, True)","function_tokens":["go","Remark","=","(","True",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L385-L385","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"mapM","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mapM = MG.mapM","function_tokens":["mapM","=","MG","mapM"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L235-L235","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showTreeWith","parameters":"hang wide t","argument_list":"","return_statement":"","docstring":"{- | \/O(n)\/. The expression (@'showTreeWith' hang wide map@) shows\nthe tree that implements the set. If @hang@ is\n'True', a \/hanging\/ tree is shown otherwise a rotated tree is shown. If\n@wide@ is 'True', an extra wide version is shown.\n-}","docstring_summary":"{- | \/O(n)\/. The expression (","docstring_tokens":["{","-","|","\/","O","(","n",")","\/",".","The","expression","("],"function":"showTreeWith hang wide t\n  | hang      = (showsTreeHang wide [] t) \"\"\n  | otherwise = (showsTree wide [] [] t) \"\"","function_tokens":["showTreeWith","hang","wide","t","|","hang","=","(","showsTreeHang","wide","[","]","t",")","\"\"","|","otherwise","=","(","showsTree","wide","[","]","[","]","t",")","\"\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L778-L780","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"testVarOver","parameters":"v xs","argument_list":"","return_statement":"","docstring":"Run a var in IO over some input, printing the output each step. This is the function we've been using throughout this documentation.","docstring_summary":"Run a var in IO over some input, printing the output each step. This is the function we've been using throughout this documentation.","docstring_tokens":["Run","a","var","in","IO","over","some","input","printing","the","output","each","step",".","This","is","the","function","we","ve","been","using","throughout","this","documentation","."],"function":"testVarOver v xs = fst <$> scanVar v xs >>= mapM_ (liftIO . print)","function_tokens":["testVarOver","v","xs","=","fst","<$>","scanVar","v","xs",">>=","mapM_","(","liftIO",".","print",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L454-L454","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Lift.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = LiftC","function_tokens":["lift","=","LiftC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Lift.hs#L37-L37","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Lift.hs","hash_val":12225,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"fail","parameters":"msg","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail msg = RSST $ \\_ _ -> fail msg","function_tokens":["fail","msg","=","RSST","$","\\","_","_","->","fail","msg"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L136-L136","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"harTemp","parameters":"","argument_list":"","return_statement":"","docstring":"A chord of events. Each of them lasts for one second.","docstring_summary":"A chord of events. Each of them lasts for one second.","docstring_tokens":["A","chord","of","events",".","Each","of","them","lasts","for","one","second","."],"function":"harTemp = harMap temp","function_tokens":["harTemp","=","harMap","temp"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L140-L140","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"stripTrailingWhitespace","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stripTrailingWhitespace = reverse . (dropWhile isWhitespace) . reverse","function_tokens":["stripTrailingWhitespace","=","reverse",".","(","dropWhile","isWhitespace",")",".","reverse"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L12-L12","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putMaybeLineComment","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putMaybeLineComment = \\case\n    Nothing  -> pure ()\n    Just cmt -> space >> putComment cmt\n\n-- | Print a 'RdrName'","function_tokens":["putMaybeLineComment","=","\\","case","Nothing","->","pure","(",")","Just","cmt","->","space",">>","putComment","cmt","-- | Print a 'RdrName'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L149-L154","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"zeroN","parameters":"i m","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zeroN i m = (i .&. m) == 0","function_tokens":["zeroN","i","m","=","(","i",".&.","m",")","==","0"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L920-L920","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"fieldDeclToAlignable","parameters":"(GHC.L matchLoc (Hs.ConDeclField _ names ty _))","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"fieldDeclToAlignable (GHC.L matchLoc (Hs.ConDeclField _ names ty _)) = do\n  matchPos <- GHC.srcSpanToRealSrcSpan $ GHC.locA matchLoc\n  leftPos  <- GHC.srcSpanToRealSrcSpan $ GHC.getLoc $ last names\n  tyPos    <- GHC.srcSpanToRealSrcSpan $ GHC.getLocA ty\n  Just $ Alignable\n    { aContainer = matchPos\n    , aLeft      = leftPos\n    , aRight     = tyPos\n    , aRightLead = length \":: \"\n    }\n\n\n--------------------------------------------------------------------------------","function_tokens":["fieldDeclToAlignable","(","GHC","L","matchLoc","(","Hs","ConDeclField","_","names","ty","_",")",")","=","do","matchPos","<-","GHC","srcSpanToRealSrcSpan","$","GHC","locA","matchLoc","leftPos","<-","GHC","srcSpanToRealSrcSpan","$","GHC","getLoc","$","last","names","tyPos","<-","GHC","srcSpanToRealSrcSpan","$","GHC","getLocA","ty","Just","$","Alignable","{","aContainer","=","matchPos",",","aLeft","=","leftPos",",","aRight","=","tyPos",",","aRightLead","=","length","\":: \"","}","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L89-L102","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"truncate","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"truncate e\n            | eventEnd e > d    = e{ eventDur = max 0 $ d - eventStart e }\n            | otherwise         = e","function_tokens":["truncate","e","|","eventEnd","e",">","d","=","e","{","eventDur","=","max","0","$","d","-","eventStart","e","}","|","otherwise","=","e"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L258-L260","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"false'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"false' = string \"false\" *> pure (toDynamicallySorted false)","function_tokens":["false'","=","string","\"false\"","*>","pure","(","toDynamicallySorted","false",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L410-L410","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"comments","parameters":"file","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"comments file = do\n  code <- readFile file\n  return $ commentsInFile file code\n\n-- | Extract comments from a string.  A comment's position contains a\n-- filename; this method uses the empty string in its place.","function_tokens":["comments","file","=","do","code","<-","readFile","file","return","$","commentsInFile","file","code","-- | Extract comments from a string.  A comment's position contains a","-- filename; this method uses the empty string in its place."],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L60-L66","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"centralAngle","parameters":"(long1, lat1) (long2, lat2)","argument_list":"","return_statement":"","docstring":"Compute central angle from points given in radians","docstring_summary":"Compute central angle from points given in radians","docstring_tokens":["Compute","central","angle","from","points","given","in","radians"],"function":"centralAngle (long1, lat1) (long2, lat2) = centralAngle\n    where centralAngle = acos $ (sin lat1) * (sin lat2) + (cos lat1) * (cos lat2) * (cos (long1 - long2))","function_tokens":["centralAngle","(","long1",",","lat1",")","(","long2",",","lat2",")","=","centralAngle","where","centralAngle","=","acos","$","(","sin","lat1",")","*","(","sin","lat2",")","+","(","cos","lat1",")","*","(","cos","lat2",")","*","(","cos","(","long1","-","long2",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L74-L75","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"t'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"t' = realToFrac t - 1","function_tokens":["t'","=","realToFrac","t","-","1"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L108-L108","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_VERSION","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_VERSION                          = 0xB002","function_tokens":["al_VERSION","=","0xB002"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L46-L46","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"ffff","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ffff     = 200","function_tokens":["ffff","=","200"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1207-L1207","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mono","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L365-L365","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"pragmas'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pragmas'      = moduleLanguagePragmas modu","function_tokens":["pragmas'","=","moduleLanguagePragmas","modu"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L160-L160","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"z64ef","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"z64ef = case M.lookup 1 extraField of\n        Nothing -> dfltZip64\n        Just b -> parseZip64ExtraField dfltZip64 b","function_tokens":["z64ef","=","case","M","lookup","1","extraField","of","Nothing","->","dfltZip64","Just","b","->","parseZip64ExtraField","dfltZip64","b"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L716-L719","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Reader.hs","language":"haskell","identifier":"asking","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"asking i = replicateM_ i (ask @Char)","function_tokens":["asking","i","=","replicateM_","i","(","ask","@","Char",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Reader.hs#L40-L40","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Reader.hs","hash_val":22189,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"terminates","parameters":"set","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"terminates set = case relativeError cfg of\n        Just re -> re >= maximum (map (uncurry (\/) . ((confidence cfg*) . standardError &&& fromRational . mean) . analysis . benchmark) $ S.toList set)\n        Nothing -> False","function_tokens":["terminates","set","=","case","relativeError","cfg","of","Just","re","->","re",">=","maximum","(","map","(","uncurry","(","\/",")",".","(","(","confidence","cfg","*",")",".","standardError","&&&","fromRational",".","mean",")",".","analysis",".","benchmark",")","$","S","toList","set",")","Nothing","->","False"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L282-L286","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"exitCodeOf","parameters":"result","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exitCodeOf result\n    | Resolution.fullySuccessful result = ExitSuccess\n    | otherwise = ExitFailure 111","function_tokens":["exitCodeOf","result","|","Resolution","fullySuccessful","result","=","ExitSuccess","|","otherwise","=","ExitFailure","111"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L255-L257","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"(STORE _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandId (STORE _ _)        = 2","function_tokens":["commandId","(","STORE","_","_",")","=","2"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L28-L28","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"cd","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cd = runPut (putCD m)","function_tokens":["cd","=","runPut","(","putCD","m",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L632-L632","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"nz","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nz = U.filter (\\i -> vec `G.unsafeIndex` i \/= zero) . U.enumFromN 0 $ (r*c)","function_tokens":["nz","=","U","filter","(","\\","i","->","vec","`","G","unsafeIndex","`","i","\/=","zero",")",".","U","enumFromN","0","$","(","r","*","c",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L95-L95","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Trace\/Returning.hs","language":"haskell","identifier":"runTrace","parameters":"(TraceC m)","argument_list":"","return_statement":"","docstring":"Run a 'Trace' effect, returning all traces as a list.  @ 'runTrace' ('pure' a) = 'pure' ([], a) @ @ 'runTrace' ('trace' s) = 'pure' ([s], ()) @  @since 1.0.0.0","docstring_summary":"Run a 'Trace' effect, returning all traces as a list.","docstring_tokens":["Run","a","Trace","effect","returning","all","traces","as","a","list","."],"function":"runTrace (TraceC m) = first (($ []) . appEndo) <$> runWriter m","function_tokens":["runTrace","(","TraceC","m",")","=","first","(","(","$","[","]",")",".","appEndo",")","<$>","runWriter","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Trace\/Returning.hs#L42-L42","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Trace\/Returning.hs","hash_val":3401,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = choice [ true',  and' ] <?> \"Conjunction\" where\n        true'  = string \"true\"  *> pure (toDynamicallySorted true)\n\n        and' = do\n            _  <- char '(' *> string \"and\" *> space\n            as <- r `sepBy1` space\n            _  <- char ')'\n            and'' as\n\n        and'' as = case mapM toStaticallySorted as of\n            Just as' -> return . toDynamicallySorted . and $ as'\n            Nothing  -> fail \"and of non-boolean arguments\"","function_tokens":["parser","_","r","=","choice","[","true'",",","and'","]","<?>","\"Conjunction\"","where","true'","=","string","\"true\"","*>","pure","(","toDynamicallySorted","true",")","and'","=","do","_","<-","char","'('","*>","string","\"and\"","*>","space","as","<-","r","`","sepBy1","`","space","_","<-","char","')'","and''","as","and''","as","=","case","mapM","toStaticallySorted","as","of","Just","as'","->","return",".","toDynamicallySorted",".","and","$","as'","Nothing","->","fail","\"and of non-boolean arguments\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L395-L408","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Mono.hs","language":"haskell","identifier":"lens","parameters":"","argument_list":"","return_statement":"","docstring":"Create a lens out of a getter and setter.","docstring_summary":"Create a lens out of a getter and setter.","docstring_tokens":["Create","a","lens","out","of","a","getter","and","setter","."],"function":"lens = Poly.lens","function_tokens":["lens","=","Poly","lens"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Mono.hs#L53-L53","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Mono.hs","hash_val":24943,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookPublicEvent","function_tokens":["reflect","_","=","WebhookPublicEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L457-L457","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Tempo _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Tempo _)                = \"Q\"","function_tokens":["go","(","Tempo","_",")","=","\"Q\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L350-L350","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified' = ifold . imap (isQuantified' . unIFix)","function_tokens":["isQuantified'","=","ifold",".","imap","(","isQuantified'",".","unIFix",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L635-L635","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"hoistServerWithContext","parameters":"_ _ f s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hoistServerWithContext _ _ f s = \\p -> hoistServerWithContext p1 p2 f (s p) where\n    p1 = Proxy :: Proxy sublayout\n    p2 = Proxy :: Proxy context","function_tokens":["hoistServerWithContext","_","_","f","s","=","\\","p","->","hoistServerWithContext","p1","p2","f","(","s","p",")","where","p1","=","Proxy","::","Proxy","sublayout","p2","=","Proxy","::","Proxy","context"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L269-L273","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/IfThenElse.hs","language":"haskell","identifier":"itraverse","parameters":"f (IfThenElse s i t e)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (IfThenElse s i t e) = IfThenElse s <$> f i <*> f t <*> f e","function_tokens":["itraverse","f","(","IfThenElse","s","i","t","e",")","=","IfThenElse","s","<$>","f","i","<*>","f","t","<*>","f","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/IfThenElse.hs#L56-L56","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/IfThenElse.hs","hash_val":30452,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"k","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"k = (u+l) `shiftR` 1","function_tokens":["k","=","(","u","+","l",")","`","shiftR","`","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L165-L165","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_STEREO_SOURCES","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_STEREO_SOURCES                  = 0x1011","function_tokens":["alc_STEREO_SOURCES","=","0x1011"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L136-L136","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"zeroArrow","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zeroArrow = varM $ const mzero","function_tokens":["zeroArrow","=","varM","$","const","mzero"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L158-L158","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"createQuad","parameters":"s p o l","argument_list":"","return_statement":"","docstring":"Given a subject, a predicate, an object and an optional label, create a valid 'Quad'.","docstring_summary":"Given a subject, a predicate, an object and an optional label, create a valid 'Quad'.","docstring_tokens":["Given","a","subject","a","predicate","an","object","and","an","optional","label","create","a","valid","Quad","."],"function":"createQuad s p o l =\n  if T.empty `notElem` [s,p,o]\n    then Just Quad { subject = s, predicate = p, object = o, label = l }\n    else Nothing","function_tokens":["createQuad","s","p","o","l","=","if","T","empty","`","notElem","`","[","s",",","p",",","o","]","then","Just","Quad","{","subject","=","s",",","predicate","=","p",",","object","=","o",",","label","=","l","}","else","Nothing"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L199-L202","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"findHaskellFiles","parameters":"v fs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"findHaskellFiles v fs = mapM (findFilesR v) fs >>= return . concat","function_tokens":["findHaskellFiles","v","fs","=","mapM","(","findFilesR","v",")","fs",">>=","return",".","concat"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L122-L122","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/Error.hs","language":"haskell","identifier":"errorLoop","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"errorLoop i = for_ [1..i] (\\ i -> throwError i `catchError` pure @_ @Int)","function_tokens":["errorLoop","i","=","for_","[","1","..","i","]","(","\\","i","->","throwError","i","`","catchError","`","pure","@","_","@","Int",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/Error.hs#L30-L30","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/Error.hs","hash_val":32578,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"InR a `ieq1` InR b = a `ieq1` b","function_tokens":["InR","a","`","ieq1","`","InR","b","=","a","`","ieq1","`","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L87-L87","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"query","parameters":"CayleyConnection{..}","argument_list":"","return_statement":"","docstring":"Perform a query, in Gremlin graph query language per default (or in MQL).  >\u03bb> query conn \"graph.Vertex('Humphrey Bogart').In('name').All()\" >Right (Array (fromList [Object (fromList [(\"id\",String \"\/en\/humphrey_bogart\")])]))","docstring_summary":"Perform a query, in Gremlin graph query language per default (or in MQL).  >\u03bb> query conn \"graph.Vertex('Humphrey Bogart').In('name').All()\" >Right (Array (fromList [Object (fromList [(\"id\",String \"\/en\/humphrey_bogart\")])]))","docstring_tokens":["Perform","a","query","in","Gremlin","graph","query","language","per","default","(","or","in","MQL",")",".",">","\u03bb",">","query","conn","graph",".","Vertex","(","Humphrey","Bogart",")",".","In","(","name",")",".","All","()",">","Right","(","Array","(","fromList","[","Object","(","fromList","[","(","id","String","\/","en","\/","humphrey_bogart",")","]",")","]","))"],"function":"query CayleyConnection{..} =\n  doQuery manager cayleyConfig\n  where\n    doQuery m CayleyConfig{..} q = do\n      r <- apiRequest\n             m (urlBase serverName apiVersion\n               ++ \"\/query\/\" ++ show queryLang)\n             serverPort (RequestBodyBS $ encodeUtf8 q)\n      return $\n        case r of\n          Just a  ->\n            case a ^? L.key \"result\" of\n              Just v  -> Right v\n              Nothing ->\n                case a ^? L.key \"error\" . L._String of\n                  Just e  -> Left (show e)\n                  Nothing -> Left \"No JSON response from Cayley server\"\n          Nothing -> Left \"Can't get any response from Cayley server\"\n\n-- | Return the description of the given executed query.","function_tokens":["query","CayleyConnection","{","..","}","=","doQuery","manager","cayleyConfig","where","doQuery","m","CayleyConfig","{","..","}","q","=","do","r","<-","apiRequest","m","(","urlBase","serverName","apiVersion","++","\"\/query\/\"","++","show","queryLang",")","serverPort","(","RequestBodyBS","$","encodeUtf8","q",")","return","$","case","r","of","Just","a","->","case","a","^?","L","key","\"result\"","of","Just","v","->","Right","v","Nothing","->","case","a","^?","L","key","\"error\"",".","L","_String","of","Just","e","->","Left","(","show","e",")","Nothing","->","Left","\"No JSON response from Cayley server\"","Nothing","->","Left","\"Can't get any response from Cayley server\"","-- | Return the description of the given executed query."],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L64-L84","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"identifier","parameters":"","argument_list":"","return_statement":"","docstring":"Matches identifier that starts with [a-zA-Z'_@#] and is followed by [a-zA-Z'_@#0-9].","docstring_summary":"Matches identifier that starts with [a-zA-Z'_","docstring_tokens":["Matches","identifier","that","starts","with","[","a","-","zA","-","Z","_"],"function":"identifier = (:) <$> id' <*> A.many' (choice [ id', digit ]) where\n    id' = choice [ letter, char '\\'', char '_', char '@', char '#' ]\n\n-- | Labels parser.","function_tokens":["identifier","=","(",":",")","<$>","id'","<*>","A","many'","(","choice","[","id'",",","digit","]",")","where","id'","=","choice","[","letter",",","char","'\\''",",","char","'_'",",","char","'@'",",","char","'#'","]","-- | Labels parser."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L121-L125","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"nameAnnAdornments","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nameAnnAdornments = foldl'\n    (\\(accl, accr) nameAnn ->\n        let (l, r) = nameAnnAdornment nameAnn in (accl ++ l, r ++ accr))\n    (mempty, mempty)","function_tokens":["nameAnnAdornments","=","foldl'","(","\\","(","accl",",","accr",")","nameAnn","->","let","(","l",",","r",")","=","nameAnnAdornment","nameAnn","in","(","accl","++","l",",","r","++","accr",")",")","(","mempty",",","mempty",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L170-L173","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"sortEvents","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sortEvents = sortBy (comparing eventStart)","function_tokens":["sortEvents","=","sortBy","(","comparing","eventStart",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L275-L275","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"ident","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create an identity matrix","docstring_summary":"O(m*n) Create an identity matrix","docstring_tokens":["O","(","m","*","n",")","Create","an","identity","matrix"],"function":"ident = MG.ident","function_tokens":["ident","=","MG","ident"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L197-L197","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/AppImage.hs","language":"haskell","identifier":"iconDir","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"iconDir = op TmplDir tmplDir <\/> \"share\" <\/> \"icons\" <\/> \"hicolor\" <\/> \"scalable\" <\/> \"apps\"","function_tokens":["iconDir","=","op","TmplDir","tmplDir","<\/>","\"share\"","<\/>","\"icons\"","<\/>","\"hicolor\"","<\/>","\"scalable\"","<\/>","\"apps\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/AppImage.hs#L31-L31","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/AppImage.hs","hash_val":15147,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,gt) = split' x l","function_tokens":["(","lt",",","gt",")","=","split'","x","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L544-L544","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Parts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Parts                    = (False, True, True, True)","function_tokens":["go","Parts","=","(","False",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L382-L382","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"unintern","parameters":"(Bin _ _ p m l r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unintern (Bin _ _ p m l r) = UBin p m l r","function_tokens":["unintern","(","Bin","_","_","p","m","l","r",")","=","UBin","p","m","l","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L226-L226","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"numbered","parameters":"","argument_list":"","return_statement":"","docstring":"Default prefix generator.  Creates numbers aligned for two-digit prefixes.  @since 1.0.0.0","docstring_summary":"Default prefix generator.  Creates numbers aligned for two-digit prefixes.","docstring_tokens":["Default","prefix","generator",".","Creates","numbers","aligned","for","two","-","digit","prefixes","."],"function":"numbered = text . Text.pack . printf \"%2d\"","function_tokens":["numbered","=","text",".","Text","pack",".","printf","\"%2d\""],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L99-L99","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkLabels","parameters":"","argument_list":"","return_statement":"","docstring":"Derive labels including type signatures for all the record selectors for a collection of datatypes. The types will be polymorphic and can be used in an arbitrary context.","docstring_summary":"Derive labels including type signatures for all the record selectors for a collection of datatypes. The types will be polymorphic and can be used in an arbitrary context.","docstring_tokens":["Derive","labels","including","type","signatures","for","all","the","record","selectors","for","a","collection","of","datatypes",".","The","types","will","be","polymorphic","and","can","be","used","in","an","arbitrary","context","."],"function":"mkLabels = liftM concat . mapM (mkLabelsWith defaultNaming True False False True)","function_tokens":["mkLabels","=","liftM","concat",".","mapM","(","mkLabelsWith","defaultNaming","True","False","False","True",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L87-L87","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"benchIO","parameters":"label io","argument_list":"","return_statement":"","docstring":"Construct a benchmark of a name and an impure function.  > benchIO \"ioref\" (newIORef () >>= readIORef)","docstring_summary":"Construct a benchmark of a name and an impure function.  > benchIO \"ioref\" (newIORef () >>= readIORef)","docstring_tokens":["Construct","a","benchmark","of","a","name","and","an","impure","function",".",">","benchIO","ioref","(","newIORef","()",">>","=","readIORef",")"],"function":"benchIO label io = Benchmark label (Analysis 0 0 0 0) (measure (`replicateM_` io))","function_tokens":["benchIO","label","io","=","Benchmark","label","(","Analysis","0","0","0","0",")","(","measure","(","`","replicateM_","`","io",")",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L120-L120","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"genLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"genLine = Gen.string (Range.linear 0 20) Gen.unicode","function_tokens":["genLine","=","Gen","string","(","Range","linear","0","20",")","Gen","unicode"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L41-L41","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Reader.hs","language":"haskell","identifier":"local","parameters":"f m","argument_list":"","return_statement":"","docstring":"Run a computation with an environment value locally modified by the passed function.  @ runReader a ('local' f m) = runReader (f a) m @  @since 0.1.0.0","docstring_summary":"Run a computation with an environment value locally modified by the passed function.","docstring_tokens":["Run","a","computation","with","an","environment","value","locally","modified","by","the","passed","function","."],"function":"local f m = send (Local f m)","function_tokens":["local","f","m","=","send","(","Local","f","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Reader.hs#L61-L61","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Reader.hs","hash_val":1897,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"imap","parameters":"f (a `LessThan` b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (a `LessThan` b) = f a `LessThan` f b","function_tokens":["imap","f","(","a","`","LessThan","`","b",")","=","f","a","`","LessThan","`","f","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L73-L73","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"s","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"s = take (length fs)","function_tokens":["s","=","take","(","length","fs",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L552-L552","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"getMatchStrict","parameters":"(GHC.Match _ ctx _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getMatchStrict (GHC.Match _ ctx _ _) = case ctx of\n      GHC.FunRhs _ _ GHC.SrcStrict -> [()]\n      _                            -> []","function_tokens":["getMatchStrict","(","GHC","Match","_","ctx","_","_",")","=","case","ctx","of","GHC","FunRhs","_","_","GHC","SrcStrict","->","[","(",")","]","_","->","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L200-L202","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Empty\/Maybe.hs","language":"haskell","identifier":"runEmpty","parameters":"(EmptyC m)","argument_list":"","return_statement":"","docstring":"Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.  @ 'runEmpty' 'empty' = 'pure' 'Nothing' @ @ 'runEmpty' ('pure' a) = 'pure' ('Just' a) @  @since 1.0.0.0","docstring_summary":"Run an 'Empty' effect, returning 'Nothing' for empty computations, or 'Just' the result otherwise.","docstring_tokens":["Run","an","Empty","effect","returning","Nothing","for","empty","computations","or","Just","the","result","otherwise","."],"function":"runEmpty (EmptyC m) = runMaybeT m","function_tokens":["runEmpty","(","EmptyC","m",")","=","runMaybeT","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Empty\/Maybe.hs#L45-L45","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Empty\/Maybe.hs","hash_val":35180,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"decls","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decls           = map GHC.unLoc (Hs.hsmodDecls (GHC.unLoc modu))","function_tokens":["decls","=","map","GHC","unLoc","(","Hs","hsmodDecls","(","GHC","unLoc","modu",")",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L68-L68","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"prag","parameters":"comment","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"prag comment = case GHC.ac_tok (GHC.unLoc comment) of\n        GHC.EpaBlockComment str\n            | lang : p1 : ps <- tokenize str, map toLower lang == \"language\" ->\n                pure (GHC.anchor (GHC.getLoc comment), p1 :| ps)\n        _ -> Nothing","function_tokens":["prag","comment","=","case","GHC","ac_tok","(","GHC","unLoc","comment",")","of","GHC","EpaBlockComment","str","|","lang",":","p1",":","ps","<-","tokenize","str",",","map","toLower","lang","==","\"language\"","->","pure","(","GHC","anchor","(","GHC","getLoc","comment",")",",","p1",":|","ps",")","_","->","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L140-L146","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"go","parameters":"words","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go words = do\n      case O.execParserPure shellPrefs shellInfo words of\n        O.Success a ->\n          dispatch a\n        O.Failure help -> do\n          let str = fst (O.renderFailure help \"\")\n          sayLn (text $ toText str)\n        O.CompletionInvoked _ ->\n          pure ()\n\n-- | Print a list of shell commands.\n--\n-- @since 1.1.0.0","function_tokens":["go","words","=","do","case","O","execParserPure","shellPrefs","shellInfo","words","of","O","Success","a","->","dispatch","a","O","Failure","help","->","do","let","str","=","fst","(","O","renderFailure","help","\"\"",")","sayLn","(","text","$","toText","str",")","O","CompletionInvoked","_","->","pure","(",")","-- | Print a list of shell commands.","--","-- @since 1.1.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L67-L80","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"doIndent","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"doIndent = spaces (indent conf)","function_tokens":["doIndent","=","spaces","(","indent","conf",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L219-L219","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"exists'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exists' = do\n            _   <- char '(' *> string \"exists\" *> space *> char '('\n            vs  <- var' `sepBy1` space\n            _   <- char ')' *> space\n            phi <- local (union (fromList $ map context vs)) r\n            _   <- char ')'\n            exists'' vs phi","function_tokens":["exists'","=","do","_","<-","char","'('","*>","string","\"exists\"","*>","space","*>","char","'('","vs","<-","var'","`","sepBy1","`","space","_","<-","char","')'","*>","space","phi","<-","local","(","union","(","fromList","$","map","context","vs",")",")","r","_","<-","char","')'","exists''","vs","phi"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L593-L601","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"instantiate","parameters":"v (InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"instantiate v (InL fa) = instantiate v fa","function_tokens":["instantiate","v","(","InL","fa",")","=","instantiate","v","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L917-L917","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC mf <*> StateC mx = StateC $ \\ s -> do\n    ~(s',  f) <- mf s\n    ~(s'', x) <- mx s'\n    pure (s'', f x)","function_tokens":["StateC","mf","<*>","StateC","mx","=","StateC","$","\\","s","->","do","~","(","s'",",","f",")","<-","mf","s","~","(","s''",",","x",")","<-","mx","s'","pure","(","s''",",","f","x",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L84-L88","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"commented","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commented = commentGroups\n                (GHC.srcSpanToRealSrcSpan . GHC.getLocA)\n                (GHC.unLoc largs)\n                (epAnnComments . GHC.ann $ GHC.getLoc largs)","function_tokens":["commented","=","commentGroups","(","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")","(","GHC","unLoc","largs",")","(","epAnnComments",".","GHC","ann","$","GHC","getLoc","largs",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L382-L385","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"longListAligns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"longListAligns =\n        [ (\"inline\",             Imports.Inline)\n        , (\"new_line\",           Imports.InlineWithBreak)\n        , (\"new_line_multiline\", Imports.InlineToMultiline)\n        , (\"multiline\",          Imports.Multiline)\n        ]","function_tokens":["longListAligns","=","[","(","\"inline\"",",","Imports","Inline",")",",","(","\"new_line\"",",","Imports","InlineWithBreak",")",",","(","\"new_line_multiline\"",",","Imports","InlineToMultiline",")",",","(","\"multiline\"",",","Imports","Multiline",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L310-L315","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"swapAndLift","parameters":"p","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"swapAndLift p = (,) (snd p) <$> fst p","function_tokens":["swapAndLift","p","=","(",",",")","(","snd","p",")","<$>","fst","p"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L253-L253","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"go","parameters":"_  _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _  _ = fclError \"Non-AppT with type variables in mkSubst. Please report this as a bug for fclabels.\"","function_tokens":["go","_","_","=","fclError","\"Non-AppT with type variables in mkSubst. Please report this as a bug for fclabels.\""],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L372-L372","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"mkRenderablePlots","parameters":"title plots","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkRenderablePlots title plots = toRenderable $\n    layout_title .~ title $ layout_plots .~ plots $ def","function_tokens":["mkRenderablePlots","title","plots","=","toRenderable","$","layout_title",".~","title","$","layout_plots",".~","plots","$","def"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L23-L24","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookIssueCommentEvent","function_tokens":["reflect","_","=","WebhookIssueCommentEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L442-L442","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decompressingPipe","parameters":"Zstd","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decompressingPipe Zstd = Zstandard.decompress","function_tokens":["decompressingPipe","Zstd","=","Zstandard","decompress"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1159-L1159","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseSplit","parameters":"c","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseSplit c = do\n    bs <- lift get\n    if B.null bs\n        then throwE \"ByteString empty\"\n        else do\n            let (result, rest) = C.span (\/=c) bs\n            lift . put $ rest\n            return result\n\n-- | Skips one character","function_tokens":["parseSplit","c","=","do","bs","<-","lift","get","if","B","null","bs","then","throwE","\"ByteString empty\"","else","do","let","(","result",",","rest",")","=","C","span","(","\/=","c",")","bs","lift",".","put","$","rest","return","result","-- | Skips one character"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L64-L74","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"trimRight","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"trimRight = reverse . trimLeft . reverse","function_tokens":["trimRight","=","reverse",".","trimLeft",".","reverse"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L90-L90","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"pingProcess","parameters":"(KI h (KS sTree _) _) chan","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pingProcess (KI h (KS sTree _) _) chan = forever $ do\n    threadDelay fiveMinutes\n\n    tree <- atomically . readTVar $ sTree\n    forM_ (T.toList tree) $ \\node -> do\n        -- Send PING and expect a PONG\n        send h (peer node) PING\n        expect h (RR [R_PONG] (nodeId node)) $ chan\n\n    where fiveMinutes = 300000000\n\n-- | Store all values stored in the node in the 7 closest known nodes every hour","function_tokens":["pingProcess","(","KI","h","(","KS","sTree","_",")","_",")","chan","=","forever","$","do","threadDelay","fiveMinutes","tree","<-","atomically",".","readTVar","$","sTree","forM_","(","T","toList","tree",")","$","\\","node","->","do","-- Send PING and expect a PONG","send","h","(","peer","node",")","PING","expect","h","(","RR","[","R_PONG","]","(","nodeId","node",")",")","$","chan","where","fiveMinutes","=","300000000","-- | Store all values stored in the node in the 7 closest known nodes every hour"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L214-L226","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"bin","parameters":"p m l r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bin p m l r = intern (UBin p m l r)","function_tokens":["bin","p","m","l","r","=","intern","(","UBin","p","m","l","r",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L186-L186","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Completion.hs","language":"haskell","identifier":"word","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"word = Text.takeWhileEnd (isSpace >>> not) left","function_tokens":["word","=","Text","takeWhileEnd","(","isSpace",">>>","not",")","left"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Completion.hs#L95-L95","hash_key":"pjones\/byline:src\/Byline\/Completion.hs","hash_val":38250,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"liftBaseWith","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftBaseWith f = ZipArchive . StateT $ \\s ->\n    (,s) <$> f (flip runStateT s . unZipArchive)","function_tokens":["liftBaseWith","f","=","ZipArchive",".","StateT","$","\\","s","->","(",",","s",")","<$>","f","(","flip","runStateT","s",".","unZipArchive",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L210-L211","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ifold","parameters":"(Forall _ b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ifold (Forall _ b) = b","function_tokens":["ifold","(","Forall","_","b",")","=","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L547-L547","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"forkOnWithUnmask","parameters":"","argument_list":"","return_statement":"","docstring":"Like @Control.Concurrent.Thread.'Thread.forkOnWithUnmask'@ but additionaly adds the thread to the group.","docstring_summary":"Like","docstring_tokens":["Like"],"function":"forkOnWithUnmask = forkWithUnmask . Control.Concurrent.forkOnWithUnmask","function_tokens":["forkOnWithUnmask","=","forkWithUnmask",".","Control","Concurrent","forkOnWithUnmask"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L171-L171","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Reader.hs","language":"haskell","identifier":"asks","parameters":"","argument_list":"","return_statement":"","docstring":"Project a function out of the current environment value.  @ 'asks' f = 'fmap' f 'ask' @  @since 0.1.0.0","docstring_summary":"Project a function out of the current environment value.","docstring_tokens":["Project","a","function","out","of","the","current","environment","value","."],"function":"asks = (`fmap` ask)","function_tokens":["asks","=","(","`","fmap","`","ask",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Reader.hs#L50-L50","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Reader.hs","hash_val":1897,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"args","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"args = commandArgs command","function_tokens":["args","=","commandArgs","command"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L57-L57","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"f","parameters":"Mixed _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f Mixed _ = Mixed","function_tokens":["f","Mixed","_","=","Mixed"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L107-L107","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"itraverse","parameters":"f (Or os)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"itraverse f (Or os) = Or <$> traverse f os","function_tokens":["itraverse","f","(","Or","os",")","=","Or","<$>","traverse","f","os"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L378-L378","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"getT","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getT    = [| arr $(getter failing total field) |]","function_tokens":["getT","=","[","|"," arr $(getter failing total field) ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L436-L436","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"buffer","parameters":"","argument_list":"","return_statement":"","docstring":"'buffer' contains the current buffer object. Setting 'buffer' to 'Just' a buffer object makes it the head entry in the source\\'s queue. Setting 'buffer'for a source in the 'Stopped' or 'Initial' state empties the entire queue, then appends the one buffer specified (or none at all if 'Nothing' was specified).  For a source in the 'Playing' or 'Paused' state, setting 'buffer' will result in the 'ALInvalidOperation' error state being set. 'buffer' can be applied only to sources in the 'Initial' and 'Stopped' states. Specifying an invalid buffer name (either because the buffer name doesn\\'t exist or because that buffer can\\'t be attached to the specified source) will result in an 'ALInvalidValue' error while specifying an invalid source name results in an 'ALInvalidName' error. Setting 'buffer' to 'Nothing' is a legal way to release the current buffer queue on a source in the 'Initial' or 'Stopped' state, whether the source has just one entry (current buffer) or more. Setting 'buffer' to 'Nothing' still causes an 'ALInvalidOperation' for any source in the 'Playing' or 'Paused' state, consequently it cannot be used to mute or stop a source. The initial value is 'Nothing'.","docstring_summary":"'buffer' contains the current buffer object. Setting 'buffer' to 'Just' a buffer object makes it the head entry in the source\\'s queue. Setting 'buffer'for a source in the 'Stopped' or 'Initial' state empties the entire queue, then appends the one buffer specified (or none at all if 'Nothing' was specified).  For a source in the 'Playing' or 'Paused' state, setting 'buffer' will result in the 'ALInvalidOperation' error state being set. 'buffer' can be applied only to sources in the 'Initial' and 'Stopped' states. Specifying an invalid buffer name (either because the buffer name doesn\\'t exist or because that buffer can\\'t be attached to the specified source) will result in an 'ALInvalidValue' error while specifying an invalid source name results in an 'ALInvalidName' error. Setting 'buffer' to 'Nothing' is a legal way to release the current buffer queue on a source in the 'Initial' or 'Stopped' state, whether the source has just one entry (current buffer) or more. Setting 'buffer' to 'Nothing' still causes an 'ALInvalidOperation' for any source in the 'Playing' or 'Paused' state, consequently it cannot be used to mute or stop a source. The initial value is 'Nothing'.","docstring_tokens":["buffer","contains","the","current","buffer","object",".","Setting","buffer","to","Just","a","buffer","object","makes","it","the","head","entry","in","the","source","\\","s","queue",".","Setting","buffer","for","a","source","in","the","Stopped","or","Initial","state","empties","the","entire","queue","then","appends","the","one","buffer","specified","(","or","none","at","all","if","Nothing","was","specified",")",".","For","a","source","in","the","Playing","or","Paused","state","setting","buffer","will","result","in","the","ALInvalidOperation","error","state","being","set",".","buffer","can","be","applied","only","to","sources","in","the","Initial","and","Stopped","states",".","Specifying","an","invalid","buffer","name","(","either","because","the","buffer","name","doesn","\\","t","exist","or","because","that","buffer","can","\\","t","be","attached","to","the","specified","source",")","will","result","in","an","ALInvalidValue","error","while","specifying","an","invalid","source","name","results","in","an","ALInvalidName","error",".","Setting","buffer","to","Nothing","is","a","legal","way","to","release","the","current","buffer","queue","on","a","source","in","the","Initial","or","Stopped","state","whether","the","source","has","just","one","entry","(","current","buffer",")","or","more",".","Setting","buffer","to","Nothing","still","causes","an","ALInvalidOperation","for","any","source","in","the","Playing","or","Paused","state","consequently","it","cannot","be","used","to","mute","or","stop","a","source",".","The","initial","value","is","Nothing","."],"function":"buffer = makeSourceStateVar dictMaybeBuffer GetBuffer","function_tokens":["buffer","=","makeSourceStateVar","dictMaybeBuffer","GetBuffer"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L287-L287","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"getCurrentLine","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getCurrentLine = gets currentLine","function_tokens":["getCurrentLine","=","gets","currentLine"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L319-L319","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"changes","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"changes = Editor.changeLines\n            (Editor.Block startLine endLine)\n            (const printedModuleHeader)","function_tokens":["changes","=","Editor","changeLines","(","Editor","Block","startLine","endLine",")","(","const","printedModuleHeader",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L113-L115","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = do\n  t <- getCurrentTime\n  ($ t) . ($ backAndForth) $ fix $ \\loop v lastT -> do\n    thisT <- getCurrentTime\n    -- Here we'll run in the Identity monad using a time delta provided by\n    -- getCurrentTime and diffUTCTime.\n    let dt = realToFrac $ diffUTCTime thisT lastT\n        Identity (Point x y, vNext) = runVarT v dt\n        xStr = replicate (round x) ' ' ++ \"x\" ++ replicate (50 - round x) ' '\n        yStr = replicate (round y) ' ' ++ \"y\" ++ replicate (50 - round y) ' '\n        str  = zipWith f xStr yStr\n        f 'x' 'y' = '|'\n        f 'y' 'x' = '|'\n        f a ' '   = a\n        f ' ' b   = b\n        f _ _     = ' '\n    putStrLn str\n    threadDelay $ floor $ 1000000 \/ (20 :: Double)\n    loop vNext thisT","function_tokens":["main","=","do","t","<-","getCurrentTime","(","$","t",")",".","(","$","backAndForth",")","$","fix","$","\\","loop","v","lastT","->","do","thisT","<-","getCurrentTime","-- Here we'll run in the Identity monad using a time delta provided by","-- getCurrentTime and diffUTCTime.","let","dt","=","realToFrac","$","diffUTCTime","thisT","lastT","Identity","(","Point","x","y",",","vNext",")","=","runVarT","v","dt","xStr","=","replicate","(","round","x",")","' '","++","\"x\"","++","replicate","(","50","-","round","x",")","' '","yStr","=","replicate","(","round","y",")","' '","++","\"y\"","++","replicate","(","50","-","round","y",")","' '","str","=","zipWith","f","xStr","yStr","f","'x'","'y'","=","'|'","f","'y'","'x'","=","'|'","f","a","' '","=","a","f","' '","b","=","b","f","_","_","=","' '","putStrLn","str","threadDelay","$","floor","$","1000000","\/","(","20","::","Double",")","loop","vNext","thisT"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L60-L78","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"go","parameters":"ty","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go ty =\n    case ty of\n      ForallT ts _ _ -> ts\n      AppT a b       -> go a ++ go b\n      SigT t _       -> go t\n#if MIN_VERSION_template_haskell(2,17,0)\n      VarT n         -> [PlainTV n SpecifiedSpec]\n#else\n      VarT n         -> [PlainTV n]\n#endif\n      _              -> []","function_tokens":["go","ty","=","case","ty","of","ForallT","ts","_","_","->","ts","AppT","a","b","->","go","a","++","go","b","SigT","t","_","->","go","t","#if MIN_VERSION_template_haskell(2,17,0)","VarT","n","->","[","PlainTV","n","SpecifiedSpec","]","#else\n      VarT n         -> [PlainTV n]\n","#endif","_","->","[","]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L630-L642","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"space","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"space = putText \" \"","function_tokens":["space","=","putText","\" \""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L279-L279","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"f","parameters":"s e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f s e = s |> CopyEntry path e e","function_tokens":["f","s","e","=","s","|>","CopyEntry","path","e","e"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L340-L340","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"f","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f e | ascii = B.char7 '*' <> B.intDec 10 <> mWhen (e\/=2) (B.char7 '^' <> B.intDec (e-1))\n        | otherwise = B.charUtf8 '\u00b7' <> B.intDec 10 <> mWhen (e\/=2) (showE (e-1))","function_tokens":["f","e","|","ascii","=","B","char7","'*'","<>","B","intDec","10","<>","mWhen","(","e","\/=","2",")","(","B","char7","'^'","<>","B","intDec","(","e","-","1",")",")","|","otherwise","=","B","charUtf8","'\u00b7' ","> ",".","ntDec ","0 ","> ","When ","e","\/","=2",")"," ","s","howE ","e","-","1",")",")",""],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L361-L362","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Trace\/Ignoring.hs","language":"haskell","identifier":"lift","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lift = TraceC","function_tokens":["lift","=","TraceC"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Trace\/Ignoring.hs#L48-L48","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Trace\/Ignoring.hs","hash_val":10926,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"commentsWithLines","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commentsWithLines = do\n        comment <- allComments\n        let s = GHC.anchor $ GHC.getLoc comment\n        pure (realSrcSpanToLineBlock s, comment)","function_tokens":["commentsWithLines","=","do","comment","<-","allComments","let","s","=","GHC","anchor","$","GHC","getLoc","comment","pure","(","realSrcSpanToLineBlock","s",",","comment",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L62-L67","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"linear","parameters":"c t b","argument_list":"","return_statement":"","docstring":"Ease linear.","docstring_summary":"Ease linear.","docstring_tokens":["Ease","linear","."],"function":"linear c t b = c * realToFrac t + b","function_tokens":["linear","c","t","b","=","c","*","realToFrac","t","+","b"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L156-L156","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"oneOf","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"oneOf f = f (analysis b1) || f (analysis b2)","function_tokens":["oneOf","f","=","f","(","analysis","b1",")","||","f","(","analysis","b2",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L327-L327","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putDataDecl","parameters":"cfg@Config {..} decl","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putDataDecl cfg@Config {..} decl = do\n    let defn = dataDefn decl\n        constructorComments = commentGroups\n            (GHC.srcSpanToRealSrcSpan . GHC.getLocA)\n            (GHC.dd_cons defn)\n            (dataComments decl)\n\n        onelineEnum =\n            isEnum decl && not cBreakEnums &&\n            all (not . commentGroupHasComments) constructorComments\n\n    putText $ newOrData decl\n    space\n    putName decl\n\n    when (isGADT decl) (space >> putText \"where\")\n\n    when (hasConstructors decl) do\n        case (cEquals, cFirstField) of\n            (_, Indent x) | isEnum decl && cBreakEnums -> newline >> spaces x\n            (_, _)\n                | not (isNewtype decl)\n                , singleConstructor decl && not cBreakSingleConstructors ->\n                    space\n            (Indent x, _)\n                | onelineEnum -> space\n                | otherwise -> newline >> spaces x\n            (SameLine, _) -> space\n\n        lineLengthAfterEq <- fmap (+2) getCurrentLineLength\n\n        if  | onelineEnum ->\n                putText \"=\" >> space >> putUnbrokenEnum cfg decl\n            | isNewtype decl -> do\n                putText \"=\" >> space\n                forM_ (GHC.dd_cons defn) $ putNewtypeConstructor cfg\n            | not . null $ GHC.dd_cons defn -> do\n                forM_ (flagEnds constructorComments) $ \\(CommentGroup {..}, firstGroup, lastGroup) -> do\n                    forM_ cgPrior $ \\lc -> do\n                        putComment $ GHC.unLoc lc\n                        consIndent lineLengthAfterEq\n\n                    forM_ (flagEnds cgItems) $ \\((lcon, mbInlineComment), firstItem, lastItem) -> do\n                        unless (isGADT decl) $ do\n                            putText $ if firstGroup && firstItem then \"=\" else \"|\"\n                            space\n                        putConstructor cfg lineLengthAfterEq lcon\n                        putMaybeLineComment $ GHC.unLoc <$> mbInlineComment\n                        unless (lastGroup && lastItem) $\n                            consIndent lineLengthAfterEq\n\n                    forM_ cgFollowing $ \\lc -> do\n                        consIndent lineLengthAfterEq\n                        putComment $ GHC.unLoc lc\n\n            | otherwise ->\n                pure ()\n\n    let derivingComments = deepAnnComments (GHC.dd_derivs defn)\n\n    when (hasDeriving decl) do\n        if onelineEnum && null derivingComments then\n            space\n        else do\n            forM_ derivingComments $ \\lc -> do\n                newline\n                spaces cDeriving\n                putComment $ GHC.unLoc lc\n            newline\n            spaces cDeriving\n\n        sep (newline >> spaces cDeriving) $ map\n            (putDeriving cfg)\n            (GHC.dd_derivs defn)\n  where\n    consIndent eqIndent = newline >> case (cEquals, cFirstField) of\n        (SameLine, SameLine) -> spaces (eqIndent - 2)\n        (SameLine, Indent y) -> spaces (eqIndent + y - 4)\n        (Indent x, Indent _) -> spaces x\n        (Indent x, SameLine) -> spaces x","function_tokens":["putDataDecl","cfg","@","Config","{","..","}","decl","=","do","let","defn","=","dataDefn","decl","constructorComments","=","commentGroups","(","GHC","srcSpanToRealSrcSpan",".","GHC","getLocA",")","(","GHC","dd_cons","defn",")","(","dataComments","decl",")","onelineEnum","=","isEnum","decl","&&","not","cBreakEnums","&&","all","(","not",".","commentGroupHasComments",")","constructorComments","putText","$","newOrData","decl","space","putName","decl","when","(","isGADT","decl",")","(","space",">>","putText","\"where\"",")","when","(","hasConstructors","decl",")","do","case","(","cEquals",",","cFirstField",")","of","(","_",",","Indent","x",")","|","isEnum","decl","&&","cBreakEnums","->","newline",">>","spaces","x","(","_",",","_",")","|","not","(","isNewtype","decl",")",",","singleConstructor","decl","&&","not","cBreakSingleConstructors","->","space","(","Indent","x",",","_",")","|","onelineEnum","->","space","|","otherwise","->","newline",">>","spaces","x","(","SameLine",",","_",")","->","space","lineLengthAfterEq","<-","fmap","(","+","2",")","getCurrentLineLength","if","|","onelineEnum","->","putText","\"=\"",">>","space",">>","putUnbrokenEnum","cfg","decl","|","isNewtype","decl","->","do","putText","\"=\"",">>","space","forM_","(","GHC","dd_cons","defn",")","$","putNewtypeConstructor","cfg","|","not",".","null","$","GHC","dd_cons","defn","->","do","forM_","(","flagEnds","constructorComments",")","$","\\","(","CommentGroup","{","..","}",",","firstGroup",",","lastGroup",")","->","do","forM_","cgPrior","$","\\","lc","->","do","putComment","$","GHC","unLoc","lc","consIndent","lineLengthAfterEq","forM_","(","flagEnds","cgItems",")","$","\\","(","(","lcon",",","mbInlineComment",")",",","firstItem",",","lastItem",")","->","do","unless","(","isGADT","decl",")","$","do","putText","$","if","firstGroup","&&","firstItem","then","\"=\"","else","\"|\"","space","putConstructor","cfg","lineLengthAfterEq","lcon","putMaybeLineComment","$","GHC","unLoc","<$>","mbInlineComment","unless","(","lastGroup","&&","lastItem",")","$","consIndent","lineLengthAfterEq","forM_","cgFollowing","$","\\","lc","->","do","consIndent","lineLengthAfterEq","putComment","$","GHC","unLoc","lc","|","otherwise","->","pure","(",")","let","derivingComments","=","deepAnnComments","(","GHC","dd_derivs","defn",")","when","(","hasDeriving","decl",")","do","if","onelineEnum","&&","null","derivingComments","then","space","else","do","forM_","derivingComments","$","\\","lc","->","do","newline","spaces","cDeriving","putComment","$","GHC","unLoc","lc","newline","spaces","cDeriving","sep","(","newline",">>","spaces","cDeriving",")","$","map","(","putDeriving","cfg",")","(","GHC","dd_derivs","defn",")","where","consIndent","eqIndent","=","newline",">>","case","(","cEquals",",","cFirstField",")","of","(","SameLine",",","SameLine",")","->","spaces","(","eqIndent","-","2",")","(","SameLine",",","Indent","y",")","->","spaces","(","eqIndent","+","y","-","4",")","(","Indent","x",",","Indent","_",")","->","spaces","x","(","Indent","x",",","SameLine",")","->","spaces","x"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L138-L219","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"done","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"done = var . const","function_tokens":["done","=","var",".","const"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L305-L305","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"newlines","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newlines =\n        [ (\"native\", IO.nativeNewline)\n        , (\"lf\",     IO.LF)\n        , (\"crlf\",   IO.CRLF)\n        ]","function_tokens":["newlines","=","[","(","\"native\"",",","IO","nativeNewline",")",",","(","\"lf\"",",","IO","LF",")",",","(","\"crlf\"",",","IO","CRLF",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L152-L156","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"tip","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tip n = intern (UTip n)","function_tokens":["tip","n","=","intern","(","UTip","n",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L178-L178","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"matrix","parameters":"ncol xs","argument_list":"","return_statement":"","docstring":"O(m*n) Matrix construction","docstring_summary":"O(m*n) Matrix construction","docstring_tokens":["O","(","m","*","n",")","Matrix","construction"],"function":"matrix ncol xs | n `mod` ncol \/= 0 = error \"incorrect length\"\n               | otherwise = unsafeFromVector (nrow,ncol) vec\n  where\n    vec = G.fromList xs\n    nrow = n `div` ncol\n    n = G.length vec","function_tokens":["matrix","ncol","xs","|","n","`","mod","`","ncol","\/=","0","=","error","\"incorrect length\"","|","otherwise","=","unsafeFromVector","(","nrow",",","ncol",")","vec","where","vec","=","G","fromList","xs","nrow","=","n","`","div","`","ncol","n","=","G","length","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L134-L140","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"setArchiveComment","parameters":"text","argument_list":"","return_statement":"","docstring":"Set the comment of the entire archive.","docstring_summary":"Set the comment of the entire archive.","docstring_tokens":["Set","the","comment","of","the","entire","archive","."],"function":"setArchiveComment text = addPending (I.SetArchiveComment text)","function_tokens":["setArchiveComment","text","=","addPending","(","I","SetArchiveComment","text",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L616-L616","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Strict.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = WriterC $ case sig of\n    L writer -> StateC $ \\ w -> case writer of\n      Tell w'    -> do\n        let !w'' = mappend w w'\n        pure (w'', ctx)\n      Listen   m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w w'\n        pure (w'', (,) w' <$> a)\n      Censor f m -> do\n        (w', a) <- runWriter (hdl (m <$ ctx))\n        let !w'' = mappend w (f w')\n        pure (w'', a)\n    R other  -> alg (runWriterC . hdl) (R other) ctx","function_tokens":["alg","hdl","sig","ctx","=","WriterC","$","case","sig","of","L","writer","->","StateC","$","\\","w","->","case","writer","of","Tell","w'","->","do","let","w''","=","mappend","w","w'","pure","(","w''",",","ctx",")","Listen","m","->","do","(","w'",",","a",")","<-","runWriter","(","hdl","(","m","<$","ctx",")",")","let","w''","=","mappend","w","w'","pure","(","w''",",","(",",",")","w'","<$>","a",")","Censor","f","m","->","do","(","w'",",","a",")","<-","runWriter","(","hdl","(","m","<$","ctx",")",")","let","w''","=","mappend","w","(","f","w'",")","pure","(","w''",",","a",")","R","other","->","alg","(","runWriterC",".","hdl",")","(","R","other",")","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Strict.hs#L64-L78","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Strict.hs","hash_val":32183,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Transcription a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Transcription a)        = a","function_tokens":["go","(","Transcription","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L430-L430","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"queueBuffers","parameters":"","argument_list":"","return_statement":"","docstring":"The application can queue up one or multiple buffer names using 'queueBuffers'. The buffers will be queued in the sequence in which they appear in the list.  This command is legal on a source in any playback state (to allow for streaming, queuing has to be possible on a 'Playing' source).  All buffers in a queue must have the same format and attributes. An attempt to mix formats or other buffer attributes will result in a failure and an 'ALInvalidValue' error will be thrown. If the queue operation fails, the source queue will remain unchanged (even if some of the buffers could have been queued).","docstring_summary":"The application can queue up one or multiple buffer names using 'queueBuffers'. The buffers will be queued in the sequence in which they appear in the list.  This command is legal on a source in any playback state (to allow for streaming, queuing has to be possible on a 'Playing' source).  All buffers in a queue must have the same format and attributes. An attempt to mix formats or other buffer attributes will result in a failure and an 'ALInvalidValue' error will be thrown. If the queue operation fails, the source queue will remain unchanged (even if some of the buffers could have been queued).","docstring_tokens":["The","application","can","queue","up","one","or","multiple","buffer","names","using","queueBuffers",".","The","buffers","will","be","queued","in","the","sequence","in","which","they","appear","in","the","list",".","This","command","is","legal","on","a","source","in","any","playback","state","(","to","allow","for","streaming","queuing","has","to","be","possible","on","a","Playing","source",")",".","All","buffers","in","a","queue","must","have","the","same","format","and","attributes",".","An","attempt","to","mix","formats","or","other","buffer","attributes","will","result","in","a","failure","and","an","ALInvalidValue","error","will","be","thrown",".","If","the","queue","operation","fails","the","source","queue","will","remain","unchanged","(","even","if","some","of","the","buffers","could","have","been","queued",")","."],"function":"queueBuffers = withArraySizei . alSourceQueueBuffers","function_tokens":["queueBuffers","=","withArraySizei",".","alSourceQueueBuffers"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L664-L664","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Bin i _ _ _ _ _ `compare` Tip j _ = compare i j","function_tokens":["Bin","i","_","_","_","_","_","`","compare","`","Tip","j","_","=","compare","i","j"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L854-L854","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"izipWith5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith5 = MG.izipWith5","function_tokens":["izipWith5","=","MG","izipWith5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L298-L298","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"rest","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"rest = flip del nil","function_tokens":["rest","=","flip","del","nil"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L154-L154","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseEnum","parameters":"strs _   (Just k)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseEnum strs _   (Just k) = case lookup k strs of\n    Just v  -> return v\n    Nothing -> fail $ \"Unknown option: \" ++ k ++ \", should be one of: \" ++\n        intercalate \", \" (map fst strs)\n\n--------------------------------------------------------------------------------","function_tokens":["parseEnum","strs","_","(","Just","k",")","=","case","lookup","k","strs","of","Just","v","->","return","v","Nothing","->","fail","$","\"Unknown option: \"","++","k","++","\", should be one of: \"","++","intercalate","\", \"","(","map","fst","strs",")","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L192-L198","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseKBucket","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseKBucket = liftM2 (:) parseNode parseKBucket\n                   `catchE` \\_ -> return []","function_tokens":["parseKBucket","=","liftM2","(",":",")","parseNode","parseKBucket","`","catchE","`","\\","_","->","return","[","]"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L119-L120","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"distance","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"distance = (*6371) .* (on centralAngle toRadians)","function_tokens":["distance","=","(","*","6371",")",".*","(","on","centralAngle","toRadians",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L70-L70","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten''","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten'' e = case match e of\n        Just (And as) -> as\n        _ -> [e]\n\n-- | A smart constructor for binary disjunction","function_tokens":["flatten''","e","=","case","match","e","of","Just","(","And","as",")","->","as","_","->","[","e","]","-- | A smart constructor for binary disjunction"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L460-L465","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs","language":"haskell","identifier":"bmi_2","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bmi_2 = U.unsafePerformIO F.enabled_bmi_2 \/= 0","function_tokens":["bmi_2","=","U","unsafePerformIO","F","enabled_bmi_2","\/=","0"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs#L15-L15","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Capabilities.hs","hash_val":30181,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"and","parameters":"[]","argument_list":"","return_statement":"","docstring":"A smart constructor for variadic conjunction","docstring_summary":"A smart constructor for variadic conjunction","docstring_tokens":["A","smart","constructor","for","variadic","conjunction"],"function":"and []  = true","function_tokens":["and","[","]","=","true"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L508-L508","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"nw","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"nw = ow `mappend` w","function_tokens":["nw","=","ow","`","mappend","`","w"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L191-L191","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"g","parameters":"d (c, v')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"g d (c, v') = ((c, d), first v')","function_tokens":["g","d","(","c",",","v'",")","=","(","(","c",",","d",")",",","first","v'",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L155-L155","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for @<=@","docstring_summary":"A smart constructor for","docstring_tokens":["A","smart","constructor","for"],"function":"a .<=. b = a .<. b .+. cnst 1","function_tokens":["a",".<=.","b","=","a",".<.","b",".+.","cnst","1"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L229-L229","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"cnsts'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cnsts' a = case prj a of\n        Just (Const c) -> F.Const [cnst c]\n        _              -> ifold a","function_tokens":["cnsts'","a","=","case","prj","a","of","Just","(","Const","c",")","->","F","Const","[","cnst","c","]","_","->","ifold","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L158-L162","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"zero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zero = []","function_tokens":["zero","=","[","]"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L64-L64","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"resBpPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"resBpPtr      = F.castPtr (F.unsafeForeignPtrToPtr resBpFptr  )","function_tokens":["resBpPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","resBpFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L79-L79","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"flatten","parameters":"f","argument_list":"","return_statement":"","docstring":"Replaces non-variable and non-constant arguments to uninterpreted functions (such as `select` and `store`) with a fresh bound (universally or existentially) variable that is bound to the original term.","docstring_summary":"Replaces non-variable and non-constant arguments to uninterpreted functions (such as `select` and `store`) with a fresh bound (universally or existentially) variable that is bound to the original term.","docstring_tokens":["Replaces","non","-","variable","and","non","-","constant","arguments","to","uninterpreted","functions","(","such","as","select","and","store",")","with","a","fresh","bound","(","universally","or","existentially",")","variable","that","is","bound","to","the","original","term","."],"function":"flatten f = let (a, (_, qs)) = runState (imapM flatten'' f) (freenames f, []) in foldr snd a qs where\n    flatten'' f' = do\n        (ns, q) <- get\n        put (ns, [])\n        r <- flatten' (unIFix f')\n        (ns', q') <- get\n        put (ns', q ++ q')\n        return r","function_tokens":["flatten","f","=","let","(","a",",","(","_",",","qs",")",")","=","runState","(","imapM","flatten''","f",")","(","freenames","f",",","[","]",")","in","foldr","snd","a","qs","where","flatten''","f'","=","do","(","ns",",","q",")","<-","get","put","(","ns",",","[","]",")","r","<-","flatten'","(","unIFix","f'",")","(","ns'",",","q'",")","<-","get","put","(","ns'",",","q","++","q'",")","return","r"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L874-L883","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Exe\/Parser.hs","language":"haskell","identifier":"mapMaker","parameters":"","argument_list":"","return_statement":"","docstring":"Parses the `Command` datatype into a map","docstring_summary":"Parses the `Command` datatype into a map","docstring_tokens":["Parses","the","Command","datatype","into","a","map"],"function":"mapMaker = MapMaker\n    <$> strOption\n        (long \"output\"\n        <> short 'o'\n        <> metavar \"OUTPUT\"\n        <> help \"Where to write the image\/map\" )\n    <*> switch\n        (long \"generate-all\"\n        <> short 'a'\n        <> help \"Whether to generate a separate file for each object in the shapefile\" )\n    <*> ( optional $ strOption\n        (long \"projection\"\n        <> short 'p'\n        <> help \"Which projection to use, e.g. mercator etc.\") )","function_tokens":["mapMaker","=","MapMaker","<$>","strOption","(","long","\"output\"","<>","short","'o'","<>","metavar","\"OUTPUT\"","<>","help","\"Where to write the image\/map\"",")","<*>","switch","(","long","\"generate-all\"","<>","short","'a'","<>","help","\"Whether to generate a separate file for each object in the shapefile\"",")","<*>","(","optional","$","strOption","(","long","\"projection\"","<>","short","'p'","<>","help","\"Which projection to use, e.g. mercator etc.\"",")",")"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Exe\/Parser.hs#L68-L81","hash_key":"vmchale\/hgis:src\/GIS\/Exe\/Parser.hs","hash_val":43704,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"throwError","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"throwError = lift . throwError","function_tokens":["throwError","=","lift",".","throwError"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L207-L207","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"isInfix","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isInfix = (== GHC.Infix) . dataFixity","function_tokens":["isInfix","=","(","==","GHC","Infix",")",".","dataFixity"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L535-L535","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"getInteger","parameters":"maybeDevice query","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getInteger maybeDevice query = fmap head $ getIntegerv maybeDevice query 1","function_tokens":["getInteger","maybeDevice","query","=","fmap","head","$","getIntegerv","maybeDevice","query","1"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L91-L91","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"f","parameters":"a ' '","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f a ' '   = a","function_tokens":["f","a","' '","=","a"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L73-L73","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"perimeters","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"perimeters = map (totalPerimeter . getPolygon . fromJust . shpRecContents) . shpRecs $ file","function_tokens":["perimeters","=","map","(","totalPerimeter",".","getPolygon",".","fromJust",".","shpRecContents",")",".","shpRecs","$","file"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L71-L71","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"dfltZip64","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dfltZip64 =\n        Zip64ExtraField\n          { z64efUncompressedSize = uncompressed,\n            z64efCompressedSize = compressed,\n            z64efOffset = offset\n          }","function_tokens":["dfltZip64","=","Zip64ExtraField","{","z64efUncompressedSize","=","uncompressed",",","z64efCompressedSize","=","compressed",",","z64efOffset","=","offset","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L710-L715","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/Capture.hs","language":"haskell","identifier":"open","parameters":"deviceSpec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"open deviceSpec =\n          invokeCaptureOpenDevice funPtr deviceSpec (round frequency)\n                                  (fromIntegral (marshalFormat format)) size","function_tokens":["open","deviceSpec","=","invokeCaptureOpenDevice","funPtr","deviceSpec","(","round","frequency",")","(","fromIntegral","(","marshalFormat","format",")",")","size"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/Capture.hs#L61-L63","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/Capture.hs","hash_val":24324,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser <?> name = do\n    pushParserName $ pack name\n    a <- parser\n    popParserName\n    return a","function_tokens":["parser","<?>","name","=","do","pushParserName","$","pack","name","a","<-","parser","popParserName","return","a"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L80-L86","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"emb","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"emb = InR . emb","function_tokens":["emb","=","InR",".","emb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L65-L65","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseSquash","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseSquash _ _ = return Squash.step","function_tokens":["parseSquash","_","_","=","return","Squash","step"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L274-L274","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Lens f . Lens g = Lens (compose f g)","function_tokens":["Lens","f",".","Lens","g","=","Lens","(","compose","f","g",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L90-L90","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"stepToByteString","parameters":"state (Step step size)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"stepToByteString state (Step step size) = F.unsafeLocalState $ do\n  let bsSize = size * 8\n  bpFptr <- BSI.mallocByteString bsSize\n  let bpVm = DVSM.unsafeFromForeignPtr (F.castForeignPtr bpFptr) 0 size\n  w64Size <- stToIO $ step state bpVm\n  return (BSI.PS bpFptr 0 (w64Size * 8))","function_tokens":["stepToByteString","state","(","Step","step","size",")","=","F","unsafeLocalState","$","do","let","bsSize","=","size","*","8","bpFptr","<-","BSI","mallocByteString","bsSize","let","bpVm","=","DVSM","unsafeFromForeignPtr","(","F","castForeignPtr","bpFptr",")","0","size","w64Size","<-","stToIO","$","step","state","bpVm","return","(","BSI","PS","bpFptr","0","(","w64Size","*","8",")",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L140-L147","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"set","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"set i = intern (BSet i)","function_tokens":["set","i","=","intern","(","BSet","i",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L87-L87","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"sep","parameters":"_ []","argument_list":"","return_statement":"","docstring":"Add separator between each element of the given printers","docstring_summary":"Add separator between each element of the given printers","docstring_tokens":["Add","separator","between","each","element","of","the","given","printers"],"function":"sep _ []             = pure ()","function_tokens":["sep","_","[","]","=","pure","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L299-L299","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"fieldVars","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fieldVars = typeVariables field","function_tokens":["fieldVars","=","typeVariables","field"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L598-L598","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"step","parameters":"maxCols","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"step maxCols = makeStep \"Module header\" . printModuleHeader maxCols","function_tokens":["step","maxCols","=","makeStep","\"Module header\"",".","printModuleHeader","maxCols"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L66-L66","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"fail","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail s = lift (Fail.fail s)","function_tokens":["fail","s","=","lift","(","Fail","fail","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L103-L103","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"eventEnd","parameters":"e","argument_list":"","return_statement":"","docstring":"End point of event (start time plus duration).","docstring_summary":"End point of event (start time plus duration).","docstring_tokens":["End","point","of","event","(","start","time","plus","duration",")","."],"function":"eventEnd e = eventStart e + eventDur e","function_tokens":["eventEnd","e","=","eventStart","e","+","eventDur","e"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L208-L208","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"alg","parameters":"_ sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg _ sig ctx = case sig of\n    L Empty  -> []\n    R Choose -> [ True <$ ctx, False <$ ctx ]","function_tokens":["alg","_","sig","ctx","=","case","sig","of","L","Empty","->","[","]","R","Choose","->","[","True","<$","ctx",",","False","<$","ctx","]"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L174-L177","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"unpack","parameters":"Id","argument_list":"","return_statement":"","docstring":"----------------------------------------------------------------------------- Convert a polymorphic lens back to point.","docstring_summary":"----------------------------------------------------------------------------- Convert a polymorphic lens back to point.","docstring_tokens":["-----------------------------------------------------------------------------","Convert","a","polymorphic","lens","back","to","point","."],"function":"unpack Id       = identity","function_tokens":["unpack","Id","=","identity"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L119-L119","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"emptyListAligns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"emptyListAligns =\n        [ (\"inherit\", Imports.Inherit)\n        , (\"right_after\", Imports.RightAfter)\n        ]","function_tokens":["emptyListAligns","=","[","(","\"inherit\"",",","Imports","Inherit",")",",","(","\"right_after\"",",","Imports","RightAfter",")","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L317-L320","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"defaultFromChoice","parameters":"config prefixes input","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultFromChoice config prefixes input =\n  case uniquePrefix <|> lookup cleanInput prefixes of\n    Nothing -> Other input\n    Just match -> Match match\n  where\n    cleanInput :: Text\n    cleanInput = Text.strip input\n    uniquePrefix :: Maybe a\n    uniquePrefix =\n      let matches = matchOnPrefix config cleanInput\n       in if length matches == 1\n            then listToMaybe matches\n            else Nothing\n\n-- | Default completion function.  Matches all of the menu items.\n--\n-- @since 1.0.0.0","function_tokens":["defaultFromChoice","config","prefixes","input","=","case","uniquePrefix","<|>","lookup","cleanInput","prefixes","of","Nothing","->","Other","input","Just","match","->","Match","match","where","cleanInput","::","Text","cleanInput","=","Text","strip","input","uniquePrefix","::","Maybe","a","uniquePrefix","=","let","matches","=","matchOnPrefix","config","cleanInput","in","if","length","matches","==","1","then","listToMaybe","matches","else","Nothing","-- | Default completion function.  Matches all of the menu items.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L119-L136","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"def","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"def f = f Imports.defaultOptions","function_tokens":["def","f","=","f","Imports","defaultOptions"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L291-L291","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal\/Text.hs","language":"haskell","identifier":"describe","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe = DT","function_tokens":["describe","=","DT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal\/Text.hs#L35-L35","hash_key":"ekmett\/intern:Data\/Interned\/Internal\/Text.hs","hash_val":22486,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Area a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Area a)                 = a","function_tokens":["go","(","Area","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L405-L405","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"handler","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"handler = const (return ())","function_tokens":["handler","=","const","(","return","(",")",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L716-L716","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Empty.hs","language":"haskell","identifier":"guard","parameters":"False","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"guard False = empty","function_tokens":["guard","False","=","empty"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Empty.hs#L47-L47","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Empty.hs","hash_val":17478,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"dual","parameters":"(Exists vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dual (Exists vs a) = forall vs (dual . unIFix $ a)","function_tokens":["dual","(","Exists","vs","a",")","=","forall","vs","(","dual",".","unIFix","$","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L680-L680","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"packDirRecur'","parameters":"t f patch path","argument_list":"","return_statement":"","docstring":"The same as 'packDirRecur' but allows us to perform modifying actions on the created entities as we go.  @since 1.5.0","docstring_summary":"The same as 'packDirRecur' but allows us to perform modifying actions on the created entities as we go.","docstring_tokens":["The","same","as","packDirRecur","but","allows","us","to","perform","modifying","actions","on","the","created","entities","as","we","go","."],"function":"packDirRecur' t f patch path = do\n  files <- liftIO (listDirRecur path)\n  forM_ files $ \\x -> do\n    s <- f x\n    loadEntry t s (path <\/> x)\n    patch s\n\n-- | Rename an entry in the archive. If the entry does not exist, nothing\n-- will happen.","function_tokens":["packDirRecur'","t","f","patch","path","=","do","files","<-","liftIO","(","listDirRecur","path",")","forM_","files","$","\\","x","->","do","s","<-","f","x","loadEntry","t","s","(","path","<\/>","x",")","patch","s","-- | Rename an entry in the archive. If the entry does not exist, nothing","-- will happen."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L512-L521","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"derivingComments","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"derivingComments = deepAnnComments (GHC.dd_derivs defn)","function_tokens":["derivingComments","=","deepAnnComments","(","GHC","dd_derivs","defn",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L196-L196","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toVersion","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toVersion x = makeVersion [major, minor]\n  where\n    (major, minor) = quotRem (fromIntegral $ x .&. 0x00ff) 10\n\n-- | Covert 'Version' to its numeric representation as per the .ZIP\n-- specification.","function_tokens":["toVersion","x","=","makeVersion","[","major",",","minor","]","where","(","major",",","minor",")","=","quotRem","(","fromIntegral","$","x",".&.","0x00ff",")","10","-- | Covert 'Version' to its numeric representation as per the .ZIP","-- specification."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1092-L1098","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Key a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Key a)                  = show $ pretty a","function_tokens":["go","(","Key","a",")","=","show","$","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L413-L413","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(ReferenceNumber _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (ReferenceNumber _)      = (False, True{-first-}, True, False)","function_tokens":["go","(","ReferenceNumber","_",")","=","(","False",",","True","{-first-}",",","True",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L394-L394","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","language":"haskell","identifier":"ishow","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (InL fa) = ishow fa","function_tokens":["ishow","(","InL","fa",")","=","ishow","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Utils\/Indexed\/Sum.hs#L99-L99","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Utils\/Indexed\/Sum.hs","hash_val":570,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"onEvents","parameters":"phi t@(Track d es)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"onEvents phi t@(Track d es) = Track d $ fromEventList $ phi $ render t","function_tokens":["onEvents","phi","t","@","(","Track","d","es",")","=","Track","d","$","fromEventList","$","phi","$","render","t"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L235-L235","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(SetExternalFileAttributes _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (SetExternalFileAttributes _ s) = Just s","function_tokens":["targetEntry","(","SetExternalFileAttributes","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1063-L1063","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"cacheWidth","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"cacheWidth _ = defaultCacheWidth","function_tokens":["cacheWidth","_","=","defaultCacheWidth"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L72-L72","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"isEqualTo","parameters":"b1 b2","argument_list":"","return_statement":"","docstring":"Determine whether two benchmarks have got the same performance. It runs each benchmark until their confidence intervals don't overlap - in which case False is returned - or are no bigger than 1% of the mean - in which case True is returned.  This function is meant to be used in test suites as infix function.  > benchShell \"echo\" \"echo\" `isEqualTo` benchShell \"sleep 0\" \"sleep 0\"","docstring_summary":"Determine whether two benchmarks have got the same performance. It runs each benchmark until their confidence intervals don't overlap - in which case False is returned - or are no bigger than 1% of the mean - in which case True is returned.  This function is meant to be used in test suites as infix function.  > benchShell \"echo\" \"echo\" `isEqualTo` benchShell \"sleep 0\" \"sleep 0\"","docstring_tokens":["Determine","whether","two","benchmarks","have","got","the","same","performance",".","It","runs","each","benchmark","until","their","confidence","intervals","don","t","overlap","-","in","which","case","False","is","returned","-","or","are","no","bigger","than","1%","of","the","mean","-","in","which","case","True","is","returned",".","This","function","is","meant","to","be","used","in","test","suites","as","infix","function",".",">","benchShell","echo","echo","isEqualTo","benchShell","sleep","0","sleep","0"],"function":"isEqualTo b1 b2 = (EQ==) <$> compareBench defaultConfig 0.01 b1 b2","function_tokens":["isEqualTo","b1","b2","=","(","EQ","==",")","<$>","compareBench","defaultConfig","0.01","b1","b2"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L167-L167","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"fromInteger","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromInteger = pure . fromInteger","function_tokens":["fromInteger","=","pure",".","fromInteger"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L236-L236","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"input","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"input = removeCpp $ dropBom string","function_tokens":["input","=","removeCpp","$","dropBom","string"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L84-L84","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pt = mkName \"f\"","function_tokens":["pt","=","mkName","\"f\""],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L523-L523","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"f","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f = foldT empty single append tfun","function_tokens":["f","=","foldT","empty","single","append","tfun"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L295-L295","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"app\/Main.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = exec","function_tokens":["main","=","exec"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/app\/Main.hs#L6-L6","hash_key":"vmchale\/hgis:app\/Main.hs","hash_val":20792,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"putCond","parameters":"p action fallback","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putCond p action fallback = do\n  prevState <- get\n  res <- action\n  currState <- get\n  if p currState then pure res\n  else put prevState >> fallback\n\n-- | Print an 'Outputable'","function_tokens":["putCond","p","action","fallback","=","do","prevState","<-","get","res","<-","action","currState","<-","get","if","p","currState","then","pure","res","else","put","prevState",">>","fallback","-- | Print an 'Outputable'"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L111-L119","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"bsPtr","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bsPtr = F.castPtr (F.unsafeForeignPtrToPtr bsFptr)","function_tokens":["bsPtr","=","F","castPtr","(","F","unsafeForeignPtrToPtr","bsFptr",")"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L58-L58","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"freeze","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freeze = undefined","function_tokens":["freeze","=","undefined"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L120-L120","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"runSteps","parameters":"exts mfp steps ls","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"runSteps exts mfp steps ls =\n foldM (runStep exts mfp) ls steps","function_tokens":["runSteps","exts","mfp","steps","ls","=","foldM","(","runStep","exts","mfp",")","ls","steps"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L105-L106","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Sequence as)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Sequence as) = sepBy \" \" $ fmap pretty as","function_tokens":["go","(","Sequence","as",")","=","sepBy","\" \"","$","fmap","pretty","as"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L187-L187","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"commit","parameters":"","argument_list":"","return_statement":"","docstring":"Archive contents are not modified instantly, but instead changes are collected as \u201cpending actions\u201d that should be committed, in order to efficiently modify the archive in one pass. The actions are committed automatically when the program leaves the 'ZipArchive' monad (i.e. as part of 'createArchive' or 'withArchive'), or can be forced explicitly with the help of this function. Once committed, changes take place in the file system and cannot be undone.","docstring_summary":"Archive contents are not modified instantly, but instead changes are collected as \u201cpending actions\u201d that should be committed, in order to efficiently modify the archive in one pass. The actions are committed automatically when the program leaves the 'ZipArchive' monad (i.e. as part of 'createArchive' or 'withArchive'), or can be forced explicitly with the help of this function. Once committed, changes take place in the file system and cannot be undone.","docstring_tokens":["Archive","contents","are","not","modified","instantly","but","instead","changes","are","collected","as","\u201cpending","actions\u201d","that","should","be","committed","in","order","to","efficiently","modify","the","archive","in","one","pass",".","The","actions","are","committed","automatically","when","the","program","leaves","the","ZipArchive","monad","(","i",".","e",".","as","part","of","createArchive","or","withArchive",")","or","can","be","forced","explicitly","with","the","help","of","this","function",".","Once","committed","changes","take","place","in","the","file","system","and","cannot","be","undone","."],"function":"commit = do\n  file <- getFilePath\n  odesc <- getArchiveDescription\n  oentries <- getEntries\n  actions <- getPending\n  exists <- liftIO (doesFileExist file)\n  unless (S.null actions && exists) $ do\n    liftIO (I.commit file odesc oentries actions)\n    -- NOTE The most robust way to update the internal description of the\n    -- archive is to scan it again\u2014manual manipulations with descriptions of\n    -- entries are too error-prone. We also want to erase all pending\n    -- actions because 'I.commit' executes them all by definition.\n    (ndesc, nentries) <- liftIO (I.scanArchive file)\n    ZipArchive . modify $ \\st ->\n      st\n        { zsEntries = nentries,\n          zsArchive = ndesc,\n          zsActions = S.empty\n        }\n\n----------------------------------------------------------------------------\n-- Helpers\n\n-- | Get the path of the actual archive file from inside of 'ZipArchive'\n-- monad.","function_tokens":["commit","=","do","file","<-","getFilePath","odesc","<-","getArchiveDescription","oentries","<-","getEntries","actions","<-","getPending","exists","<-","liftIO","(","doesFileExist","file",")","unless","(","S","null","actions","&&","exists",")","$","do","liftIO","(","I","commit","file","odesc","oentries","actions",")","-- NOTE The most robust way to update the internal description of the","-- archive is to scan it again\u2014manual manipulations with descriptions of","-- entries are too error-prone. We also want to erase all pending","-- actions because 'I.commit' executes them all by definition.","(","ndesc",",","nentries",")","<-","liftIO","(","I","scanArchive","file",")","ZipArchive",".","modify","$","\\","st","->","st","{","zsEntries","=","nentries",",","zsArchive","=","ndesc",",","zsActions","=","S","empty","}","----------------------------------------------------------------------------","-- Helpers","-- | Get the path of the actual archive file from inside of 'ZipArchive'","-- monad."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L646-L671","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' a = bind (Proxy :: Proxy g) (inject a)","function_tokens":["bind'","a","=","bind","(","Proxy","::","Proxy","g",")","(","inject","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L808-L808","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"loop","parameters":"!l !u","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"loop !l !u\n        | l > u = Nothing\n        | x == x' = Just k\n        | x < x' = loop l (k-1)\n        | otherwise = loop (k+1) u\n      where\n        k = (u+l) `shiftR` 1\n        x' = vec `U.unsafeIndex` k","function_tokens":["loop","l","u","|","l",">","u","=","Nothing","|","x","==","x'","=","Just","k","|","x","<","x'","=","loop","l","(","k","-","1",")","|","otherwise","=","loop","(","k","+","1",")","u","where","k","=","(","u","+","l",")","`","shiftR","`","1","x'","=","vec","`","U","unsafeIndex","`","k"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L159-L167","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"HeinrichApfelmus\/vault","sha":"19f905d8f3794511a846e5f4667b801688dec38c","path":"src\/Data\/Vault\/ST\/backends\/IORef.hs","language":"haskell","identifier":"delete","parameters":"(Key k _) (Vault m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delete (Key k _) (Vault m)  = Vault $ Map.delete k m","function_tokens":["delete","(","Key","k","_",")","(","Vault","m",")","=","Vault","$","Map","delete","k","m"],"url":"https:\/\/github.com\/HeinrichApfelmus\/vault\/blob\/19f905d8f3794511a846e5f4667b801688dec38c\/src\/Data\/Vault\/ST\/backends\/IORef.hs#L40-L40","hash_key":"HeinrichApfelmus\/vault:src\/Data\/Vault\/ST\/backends\/IORef.hs","hash_val":26284,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"bg","parameters":"c (Stylized m t)","argument_list":"","return_statement":"","docstring":"Set the background color.  @since 1.0.0.0","docstring_summary":"Set the background color.","docstring_tokens":["Set","the","background","color","."],"function":"bg c (Stylized m t) = Stylized (m {modColorBG = OnlyOne (Just c)}) t","function_tokens":["bg","c","(","Stylized","m","t",")","=","Stylized","(","m","{","modColorBG","=","OnlyOne","(","Just","c",")","}",")","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L103-L103","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"modify'","parameters":"l m f","argument_list":"","return_statement":"","docstring":"Like 'modify' but return behaves like the identity function when the field could not be set.","docstring_summary":"Like 'modify' but return behaves like the identity function when the field could not be set.","docstring_tokens":["Like","modify","but","return","behaves","like","the","identity","function","when","the","field","could","not","be","set","."],"function":"modify' l m f = f `fromMaybe` modify l m f","function_tokens":["modify'","l","m","f","=","f","`","fromMaybe","`","modify","l","m","f"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L88-L88","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"closestId","parameters":"","argument_list":"","return_statement":"","docstring":"Find out closest known node","docstring_summary":"Find out closest known node","docstring_tokens":["Find","out","closest","known","node"],"function":"closestId = nodeId . head . sortByDistanceTo bucket $ originId","function_tokens":["closestId","=","nodeId",".","head",".","sortByDistanceTo","bucket","$","originId"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L156-L156","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"takeNext","parameters":"((ib, i) : items) []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeNext ((ib, i) : items) [] =\n    Just","function_tokens":["takeNext","(","(","ib",",","i",")",":","items",")","[","]","=","Just"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L102-L103","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"varNames","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"varNames  = nameFromBinder <$> vars","function_tokens":["varNames","=","nameFromBinder","<$>","vars"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L599-L599","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"runChooseS","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'Choose' effect, mapping results into a 'S.Semigroup'.  @since 1.0.0.0","docstring_summary":"Run a 'Choose' effect, mapping results into a 'S.Semigroup'.","docstring_tokens":["Run","a","Choose","effect","mapping","results","into","a","S",".","Semigroup","."],"function":"runChooseS = runChoose (liftA2 (S.<>))","function_tokens":["runChooseS","=","runChoose","(","liftA2","(","S","<>",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L54-L54","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"hashWithSalt","parameters":"s x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hashWithSalt s x = hashWithSalt s $ identity x","function_tokens":["hashWithSalt","s","x","=","hashWithSalt","s","$","identity","x"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L869-L869","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"defaultPrefix","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultPrefix = PrefixDir $ \"AppDir\" <\/> \"usr\"","function_tokens":["defaultPrefix","=","PrefixDir","$","\"AppDir\"","<\/>","\"usr\""],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L103-L103","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"getStatusPorcelain","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getStatusPorcelain =\n    do  (statusCode, statusPorcelain, statusStderr) <-\n            readProcessWithExitCode \"git\" [\"status\", \"--porcelain\"] \"\"\n        when (statusCode \/= ExitSuccess) $ do\n            -- Print git's error message. Usually -\n            -- \"fatal: Not a git repository (or any of the parent directories): .git\"\n            hPutStr stderr statusStderr\n            exitWith statusCode\n        pure statusPorcelain","function_tokens":["getStatusPorcelain","=","do","(","statusCode",",","statusPorcelain",",","statusStderr",")","<-","readProcessWithExitCode","\"git\"","[","\"status\"",",","\"--porcelain\"","]","\"\"","when","(","statusCode","\/=","ExitSuccess",")","$","do","-- Print git's error message. Usually -","-- \"fatal: Not a git repository (or any of the parent directories): .git\"","hPutStr","stderr","statusStderr","exitWith","statusCode","pure","statusPorcelain"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L198-L208","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"mokus0\/erf-native","sha":"e371ba6821b2d9f18d19d010b863e5eb00ef681a","path":"src\/GSL\/SpecFunc\/Erf.hs","language":"haskell","identifier":"ax","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ax = abs x","function_tokens":["ax","=","abs","x"],"url":"https:\/\/github.com\/mokus0\/erf-native\/blob\/e371ba6821b2d9f18d19d010b863e5eb00ef681a\/src\/GSL\/SpecFunc\/Erf.hs#L55-L55","hash_key":"mokus0\/erf-native:src\/GSL\/SpecFunc\/Erf.hs","hash_val":1104,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"modifyTVar","parameters":"tv f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"modifyTVar tv f = readTVar tv >>= writeTVar tv .! f","function_tokens":["modifyTVar","tv","f","=","readTVar","tv",">>=","writeTVar","tv",".!","f"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L207-L207","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pushQuantifier","parameters":"(InR gb)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushQuantifier (InR gb) = pushQuantifier gb","function_tokens":["pushQuantifier","(","InR","gb",")","=","pushQuantifier","gb"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L742-L742","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/Build.hs","language":"haskell","identifier":"determineBuildTool","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"determineBuildTool = do\n  dirContents <- getDirectoryContents \".\"\n  pure $ if \"stack.yaml\" `elem` dirContents\n    then Stack\n    else Cabal","function_tokens":["determineBuildTool","=","do","dirContents","<-","getDirectoryContents","\".\"","pure","$","if","\"stack.yaml\"","`","elem","`","dirContents","then","Stack","else","Cabal"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/Build.hs#L26-L33","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/Build.hs","hash_val":14562,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Interpret.hs","language":"haskell","identifier":"reify","parameters":"a k","argument_list":"","return_statement":"","docstring":"For more information on this technique, see the @reflection@ library. We use the formulation described in https:\/\/github.com\/ekmett\/reflection\/issues\/31 for better inlining.  Essentially we can view @k@ as internally a function of type @Reifies s a -> Tagged s r@, whch we can again view as just @a -> Tagged s r@ through @unsafeCoerce@. After this coercion, we just apply the function to @a@.","docstring_summary":"For more information on this technique, see the","docstring_tokens":["For","more","information","on","this","technique","see","the"],"function":"reify a k = unsafeCoerce (Magic k) a","function_tokens":["reify","a","k","=","unsafeCoerce","(","Magic","k",")","a"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Interpret.hs#L59-L59","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Interpret.hs","hash_val":29980,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Exit.hs","language":"haskell","identifier":"die","parameters":"a","argument_list":"","return_statement":"","docstring":"Exit the current process after printing a pretty error message.  This function is similar to 'Exit.die' except that the name of the current process along with a 'Stylized' error message is printed to the standard error handle before exiting with a failure code.  @since 1.0.0.0","docstring_summary":"Exit the current process after printing a pretty error message.  This function is similar to 'Exit.die' except that the name of the current process along with a 'Stylized' error message is printed to the standard error handle before exiting with a failure code.","docstring_tokens":["Exit","the","current","process","after","printing","a","pretty","error","message",".","This","function","is","similar","to","Exit",".","die","except","that","the","name","of","the","current","process","along","with","a","Stylized","error","message","is","printed","to","the","standard","error","handle","before","exiting","with","a","failure","code","."],"function":"die a = do\n  warn a\n  liftIO (IO.hFlush stderr >> Exit.exitFailure)\n\n-- | Print a message to standard error.\n--\n-- Unlike 'die', this function will __not__ exit the current process.\n--\n-- @since 1.0.0.0","function_tokens":["die","a","=","do","warn","a","liftIO","(","IO","hFlush","stderr",">>","Exit","exitFailure",")","-- | Print a message to standard error.","--","-- Unlike 'die', this function will __not__ exit the current process.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Exit.hs#L43-L52","hash_key":"pjones\/byline:src\/Byline\/Exit.hs","hash_val":6289,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \\\/ b = a .|. b","function_tokens":["a","\\\/","b","=","a",".|.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L199-L199","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseListPadding","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseListPadding = \\case\n        A.String \"module_name\" -> pure Imports.LPModuleName\n        A.Number n | n >= 1    -> pure $ Imports.LPConstant (truncate n)\n        v                      -> A.typeMismatch \"'module_name' or >=1 number\" v\n\n--------------------------------------------------------------------------------","function_tokens":["parseListPadding","=","\\","case","A","String","\"module_name\"","->","pure","Imports","LPModuleName","A","Number","n","|","n",">=","1","->","pure","$","Imports","LPConstant","(","truncate","n",")","v","->","A","typeMismatch","\"'module_name' or >=1 number\"","v","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L322-L328","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"nnf","parameters":"","argument_list":"","return_statement":"","docstring":"Propagates negation toward boolean atoms (across conjunction, disjunction, quantifiers).","docstring_summary":"Propagates negation toward boolean atoms (across conjunction, disjunction, quantifiers).","docstring_tokens":["Propagates","negation","toward","boolean","atoms","(","across","conjunction","disjunction","quantifiers",")","."],"function":"nnf = nnf' where\n\n    nnf' :: IFix f s -> IFix f s\n    nnf' (IFix f) = case index f %~ SBooleanSort of\n        Proved Refl -> fromJust $ ( match (IFix f) >>= not' ) <|> Just (IFix (imap nnf' f))\n        Disproved _ -> IFix (imap nnf' f)\n\n    not' :: NegationF (IFix f) 'BooleanSort -> Maybe (IFix f 'BooleanSort)\n    not' (Not a) = return . dual . unIFix $ a","function_tokens":["nnf","=","nnf'","where","nnf'","::","IFix","f","s","->","IFix","f","s","nnf'","(","IFix","f",")","=","case","index","f","%~","SBooleanSort","of","Proved","Refl","->","fromJust","$","(","match","(","IFix","f",")",">>=","not'",")","<|>","Just","(","IFix","(","imap","nnf'","f",")",")","Disproved","_","->","IFix","(","imap","nnf'","f",")","not'","::","NegationF","(","IFix","f",")","'","BooleanSort","->","Maybe","(","IFix","f","'","BooleanSort",")","not'","(","Not","a",")","=","return",".","dual",".","unIFix","$","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L694-L704","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!idxByteLen = (bsLen + 7) `div` 8","function_tokens":["idxByteLen","=","(","bsLen","+","7",")","`","div","`","8"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs#L75-L75","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Standard.hs","hash_val":20973,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"padRight","parameters":"len str","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"padRight len str = str ++ replicate (len - length str) ' '","function_tokens":["padRight","len","str","=","str","++","replicate","(","len","-","length","str",")","' '"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L61-L61","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Group a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Group a)                = a","function_tokens":["go","(","Group","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L410-L410","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"newline","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newline = do\n  l <- gets currentLine\n  modify \\s -> s { currentLine = \"\", linePos = 0, lines = lines s <> [l] }\n\n-- | Print a space","function_tokens":["newline","=","do","l","<-","gets","currentLine","modify","\\","s","->","s","{","currentLine","=","\"\"",",","linePos","=","0",",","lines","=","lines","s","<>","[","l","]","}","-- | Print a space"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L273-L278","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(Tune a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (Tune a)         = pretty a","function_tokens":["pretty","(","Tune","a",")","=","pretty","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L130-L130","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"align","parameters":"_ []","argument_list":"","return_statement":"","docstring":"^ Changes performing the alignment","docstring_summary":"^ Changes performing the alignment","docstring_tokens":["^","Changes","performing","the","alignment"],"function":"align _ [] = mempty","function_tokens":["align","_","[","]","=","mempty"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L61-L61","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"alc_REFRESH","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alc_REFRESH                         = 0x1008","function_tokens":["alc_REFRESH","=","0x1008"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L133-L133","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Utils.hs","language":"haskell","identifier":"stripExt","parameters":"","argument_list":"","return_statement":"","docstring":"Strip extension from a filepath","docstring_summary":"Strip extension from a filepath","docstring_tokens":["Strip","extension","from","a","filepath"],"function":"stripExt = reverse . drop 1 . dropWhile (\/='.') . reverse","function_tokens":["stripExt","=","reverse",".","drop","1",".","dropWhile","(","\/=","'.'",")",".","reverse"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Utils.hs#L8-L8","hash_key":"vmchale\/hgis:src\/GIS\/Utils.hs","hash_val":20401,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"ownId","parameters":"","argument_list":"","return_statement":"","docstring":"Retrieve your own id","docstring_summary":"Retrieve your own id","docstring_tokens":["Retrieve","your","own","id"],"function":"ownId =\n            fmap T.extractId . atomically . readTVar .  sTree . state $ inst","function_tokens":["ownId","=","fmap","T","extractId",".","atomically",".","readTVar",".","sTree",".","state","$","inst"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L139-L140","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"mempty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mempty = StylizedList []","function_tokens":["mempty","=","StylizedList","[","]"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L61-L61","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"NonDetC a >>= f = NonDetC $ \\ fork leaf nil ->\n    a fork (runNonDet fork leaf nil . f) nil","function_tokens":["NonDetC","a",">>=","f","=","NonDetC","$","\\","fork","leaf","nil","->","a","fork","(","runNonDet","fork","leaf","nil",".","f",")","nil"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L98-L99","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseInt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseInt = do\n    bs <- lift get\n    case C.readInt bs of\n        Nothing -> throwE \"Failed to parse an Int\"\n        Just (n, rest) -> do\n            lift . put $ rest\n            return n\n\n-- | Parses two Word8s from a ByteString into one Word16","function_tokens":["parseInt","=","do","bs","<-","lift","get","case","C","readInt","bs","of","Nothing","->","throwE","\"Failed to parse an Int\"","Just","(","n",",","rest",")","->","do","lift",".","put","$","rest","return","n","-- | Parses two Word8s from a ByteString into one Word16"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L83-L92","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"isProperSubsetOf","parameters":"t1 t2","argument_list":"","return_statement":"","docstring":"{--------------------------------------------------------------------\nSubset\n------------------------------------------------------------------} \/O(n+m)\/. Is this a proper subset? (ie. a subset but not equal).","docstring_summary":"{--------------------------------------------------------------------\nSubset\n------------------------------------------------------------------} \/O(n+m)\/. Is this a proper subset? (ie. a subset but not equal).","docstring_tokens":["{","--------------------------------------------------------------------","Subset","------------------------------------------------------------------","}","\/","O","(","n","+","m",")","\/",".","Is","this","a","proper","subset?","(","ie",".","a","subset","but","not","equal",")","."],"function":"isProperSubsetOf t1 t2\n  = case subsetCmp t1 t2 of\n      LT -> True\n      _  -> False","function_tokens":["isProperSubsetOf","t1","t2","=","case","subsetCmp","t1","t2","of","LT","->","True","_","->","False"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L446-L451","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Writer\/Strict.hs","language":"haskell","identifier":"execWriter","parameters":"","argument_list":"","return_statement":"","docstring":"Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.  @ 'execWriter' m = 'fmap' 'fst' ('runWriter' m) @","docstring_summary":"Run a 'Writer' effect with a 'Monoid'al log, producing the final log and discarding the result value.","docstring_tokens":["Run","a","Writer","effect","with","a","Monoid","al","log","producing","the","final","log","and","discarding","the","result","value","."],"function":"execWriter = fmap fst . runWriter","function_tokens":["execWriter","=","fmap","fst",".","runWriter"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Writer\/Strict.hs#L53-L53","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Writer\/Strict.hs","hash_val":32183,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"toStylizedText","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toStylizedText = id","function_tokens":["toStylizedText","=","id"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L73-L73","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"sortByDistanceTo","parameters":"bucket id","argument_list":"","return_statement":"","docstring":"Sort a bucket by the closeness of its nodes to a give Id","docstring_summary":"Sort a bucket by the closeness of its nodes to a give Id","docstring_tokens":["Sort","a","bucket","by","the","closeness","of","its","nodes","to","a","give","Id"],"function":"sortByDistanceTo bucket id = unpack . sort . pack $ bucket\n    where pack bk = zip bk $ map f bk\n          f = distance id . nodeId\n          sort = sortBy (compare `on` snd)\n          unpack = map fst\n\n-- | A structure serializable into and parsable from a ByteString","function_tokens":["sortByDistanceTo","bucket","id","=","unpack",".","sort",".","pack","$","bucket","where","pack","bk","=","zip","bk","$","map","f","bk","f","=","distance","id",".","nodeId","sort","=","sortBy","(","compare","`","on","`","snd",")","unpack","=","map","fst","-- | A structure serializable into and parsable from a ByteString"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L43-L50","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"trimLeft","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ {-\ninfoPoints :: [S.Located pass] -> [((Int, Int), (Int, Int))]\ninfoPoints = fmap (helper . S.getLoc)\nwhere\nhelper :: S.SrcSpan -> ((Int, Int), (Int, Int))\nhelper (S.RealSrcSpan s) = do\nlet\nstart = S.realSrcSpanStart s\nend = S.realSrcSpanEnd s\n((S.srcLocLine start, S.srcLocCol start), (S.srcLocLine end, S.srcLocCol end))\nhelper _                   = ((-1,-1), (-1,-1))\n-} ------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------ {-\ninfoPoints :: [S.Located pass] -> [((Int, Int), (Int, Int))]\ninfoPoints = fmap (helper . S.getLoc)\nwhere\nhelper :: S.SrcSpan -> ((Int, Int), (Int, Int))\nhelper (S.RealSrcSpan s) = do\nlet\nstart = S.realSrcSpanStart s\nend = S.realSrcSpanEnd s\n((S.srcLocLine start, S.srcLocCol start), (S.srcLocLine end, S.srcLocCol end))\nhelper _                   = ((-1,-1), (-1,-1))\n-} ------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------","{","-","infoPoints","::","[","S",".","Located","pass","]","-",">","[","((","Int","Int",")","(","Int","Int","))","]","infoPoints","=","fmap","(","helper",".","S",".","getLoc",")","where","helper","::","S",".","SrcSpan","-",">","((","Int","Int",")","(","Int","Int","))","helper","(","S",".","RealSrcSpan","s",")","=","do","let","start","=","S",".","realSrcSpanStart","s","end","=","S",".","realSrcSpanEnd","s","((","S",".","srcLocLine","start","S",".","srcLocCol","start",")","(","S",".","srcLocLine","end","S",".","srcLocCol","end","))","helper","_","=","((","-","1","-","1",")","(","-","1","-","1","))","-","}","------------------------------------------------------------------------------"],"function":"trimLeft  = dropWhile isSpace","function_tokens":["trimLeft","=","dropWhile","isSpace"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L85-L85","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getSymbol","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getSymbol = Symbol <$> getString","function_tokens":["getSymbol","=","Symbol","<$>","getString"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L216-L216","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \\\/ b = a .|. b","function_tokens":["a","\\\/","b","=","a",".|.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L207-L207","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"results","parameters":"m","argument_list":"","return_statement":"","docstring":"Get amount of results from a write\/delete 'Quad'(s) operation, or an explicite error message.  >\u03bb> writeNQuadFile conn \"testdata.nq\" >>= results >Right 11","docstring_summary":"Get amount of results from a write\/delete 'Quad'(s) operation, or an explicite error message.  >\u03bb> writeNQuadFile conn \"testdata.nq\" >>= results >Right 11","docstring_tokens":["Get","amount","of","results","from","a","write","\/","delete","Quad","(","s",")","operation","or","an","explicite","error","message",".",">","\u03bb",">","writeNQuadFile","conn","testdata",".","nq",">>","=","results",">","Right","11"],"function":"results m = return $\n  case m of\n    Just v ->\n      case v ^? L.key \"result\" . L._String of\n        Just r  ->\n          case APT.parse getAmount r of\n            APT.Done \"\" i -> Right i\n            _             -> Left \"Can't get amount of results\"\n        Nothing ->\n          case v ^? L.key \"error\" . L._String of\n            Just e  -> Left (show e)\n            Nothing -> Left \"No JSON response from Cayley server\"\n    Nothing -> Left \"Can't get any response from Cayley server\"\n  where\n  getAmount = do\n      _ <- APT.string \"Successfully \"\n      _ <- APT.string \"deleted \" <|> APT.string \"wrote \"\n      a <- APT.decimal\n      _ <- APT.string \" quads.\"\n      return a","function_tokens":["results","m","=","return","$","case","m","of","Just","v","->","case","v","^?","L","key","\"result\"",".","L","_String","of","Just","r","->","case","APT","parse","getAmount","r","of","APT","Done","\"\"","i","->","Right","i","_","->","Left","\"Can't get amount of results\"","Nothing","->","case","v","^?","L","key","\"error\"",".","L","_String","of","Just","e","->","Left","(","show","e",")","Nothing","->","Left","\"No JSON response from Cayley server\"","Nothing","->","Left","\"Can't get any response from Cayley server\"","where","getAmount","=","do","_","<-","APT","string","\"Successfully \"","_","<-","APT","string","\"deleted \"","<|>","APT","string","\"wrote \"","a","<-","APT","decimal","_","<-","APT","string","\" quads.\"","return","a"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L212-L231","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = case sig of\n    L Read      -> (<$ ctx) <$> liftIO getLine\n    L (Write s) -> ctx <$ liftIO (putStrLn s)\n    R other     -> TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)","function_tokens":["alg","hdl","sig","ctx","=","case","sig","of","L","Read","->","(","<$","ctx",")","<$>","liftIO","getLine","L","(","Write","s",")","->","ctx","<$","liftIO","(","putStrLn","s",")","R","other","->","TeletypeIOC","(","alg","(","runTeletypeIO",".","hdl",")","other","ctx",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L59-L65","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/DeploymentInfo.hs","language":"haskell","identifier":"constructDeploymentInfo","parameters":"buildTool opts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"constructDeploymentInfo buildTool opts = do\n  mbCabalFile <- runMaybeT\n    $   MaybeT locateCabalFile\n    <|> MaybeT (makeCabal buildTool >> locateCabalFile)\n  maybe (throwM NoCabalFiles)\n    (fmap (constructDeploymentInfo' opts . package . packageDescription)\n      . readGenericPackageDescription normal) mbCabalFile","function_tokens":["constructDeploymentInfo","buildTool","opts","=","do","mbCabalFile","<-","runMaybeT","$","MaybeT","locateCabalFile","<|>","MaybeT","(","makeCabal","buildTool",">>","locateCabalFile",")","maybe","(","throwM","NoCabalFiles",")","(","fmap","(","constructDeploymentInfo'","opts",".","package",".","packageDescription",")",".","readGenericPackageDescription","normal",")","mbCabalFile"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/DeploymentInfo.hs#L81-L90","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/DeploymentInfo.hs","hash_val":6968,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish.hs","language":"haskell","identifier":"listDirectoryFiles","parameters":"go topdir","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"listDirectoryFiles go topdir = do\n      ps <- listDirectory topdir >>=\n        mapM (\\x -> do\n                 let dir = topdir <\/> x\n                 doesDirectoryExist dir >>= \\case\n                   True  -> go dir\n                   False -> return [dir])\n      return $ concat ps","function_tokens":["listDirectoryFiles","go","topdir","=","do","ps","<-","listDirectory","topdir",">>=","mapM","(","\\","x","->","do","let","dir","=","topdir","<\/>","x","doesDirectoryExist","dir",">>=","\\","case","True","->","go","dir","False","->","return","[","dir","]",")","return","$","concat","ps"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish.hs#L143-L150","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish.hs","hash_val":28175,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pushQuantifier","parameters":"(Exists vs a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushQuantifier (Exists vs a) = pushQuantifier' exists vs a","function_tokens":["pushQuantifier","(","Exists","vs","a",")","=","pushQuantifier'","exists","vs","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L738-L738","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"withHead","parameters":"_ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"withHead _ []       = []","function_tokens":["withHead","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L175-L175","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"identity","parameters":"","argument_list":"","return_statement":"","docstring":"Identity Point. Cannot change the type.","docstring_summary":"Identity Point. Cannot change the type.","docstring_tokens":["Identity","Point",".","Cannot","change","the","type","."],"function":"identity = Point id app","function_tokens":["identity","=","Point","id","app"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L77-L77","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseIndent","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseIndent = \\case\n    A.String \"same_line\" -> return Data.SameLine\n    A.String t | \"indent \" `T.isPrefixOf` t ->\n        case readMaybe (T.unpack $ T.drop 7 t) of\n             Just n -> return $ Data.Indent n\n             Nothing -> fail $ \"Indent: not a number\" <> T.unpack (T.drop 7 t)\n    A.String t -> fail $ \"can't parse indent setting: \" <> T.unpack t\n    _ -> fail \"Expected string for indent value\"\n\n--------------------------------------------------------------------------------","function_tokens":["parseIndent","=","\\","case","A","String","\"same_line\"","->","return","Data","SameLine","A","String","t","|","\"indent \"","`","T","isPrefixOf","`","t","->","case","readMaybe","(","T","unpack","$","T","drop","7","t",")","of","Just","n","->","return","$","Data","Indent","n","Nothing","->","fail","$","\"Indent: not a number\"","<>","T","unpack","(","T","drop","7","t",")","A","String","t","->","fail","$","\"can't parse indent setting: \"","<>","T","unpack","t","_","->","fail","\"Expected string for indent value\"","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L263-L273","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"highestBitMask","parameters":"x0","argument_list":"","return_statement":"","docstring":"{----------------------------------------------------------------------\nFinding the highest bit (mask) in a word [x] can be done efficiently in\nthree ways:\n* convert to a floating point value and the mantissa tells us the\n[log2(x)] that corresponds with the highest bit position. The mantissa\nis retrieved either via the standard C function [frexp] or by some bit\ntwiddling on IEEE compatible numbers (float). Note that one needs to\nuse at least [double] precision for an accurate mantissa of 32 bit\nnumbers.\n* use bit twiddling, a logarithmic sequence of bitwise or's and shifts (bit).\n* use processor specific assembler instruction (asm).\n\nThe most portable way would be [bit], but is it efficient enough?\nI have measured the cycle counts of the different methods on an AMD\nAthlon-XP 1800 (~ Pentium III 1.8Ghz) using the RDTSC instruction:\n\nhighestBitMask: method  cycles\n------------\nfrexp   200\nfloat    33\nbit      11\nasm      12\n\nhighestBit:     method  cycles\n------------\nfrexp   195\nfloat    33\nbit      11\nasm      11\n\nWow, the bit twiddling is on today's RISC like machines even faster\nthan a single CISC instruction (BSR)!\n--------------------------------------------------------------------} {----------------------------------------------------------------------\n[highestBitMask] returns a word where only the highest bit is set.\nIt is found by first setting all bits in lower positions than the\nhighest bit and than taking an exclusive or with the original value.\nAlthough the function may look expensive, GHC compiles this into\nexcellent C code that subsequently compiled into highly efficient\nmachine code. The algorithm is derived from Jorg Arndt's FXT library.\n--------------------------------------------------------------------}","docstring_summary":"{----------------------------------------------------------------------\nFinding the highest bit (mask) in a word [x] can be done efficiently in\nthree ways:\n* convert to a floating point value and the mantissa tells us the\n[log2(x)] that corresponds with the highest bit position. The mantissa\nis retrieved either via the standard C function [frexp] or by some bit\ntwiddling on IEEE compatible numbers (float). Note that one needs to\nuse at least [double] precision for an accurate mantissa of 32 bit\nnumbers.\n* use bit twiddling, a logarithmic sequence of bitwise or's and shifts (bit).\n* use processor specific assembler instruction (asm).","docstring_tokens":["{","----------------------------------------------------------------------","Finding","the","highest","bit","(","mask",")","in","a","word","[","x","]","can","be","done","efficiently","in","three","ways",":","*","convert","to","a","floating","point","value","and","the","mantissa","tells","us","the","[","log2","(","x",")","]","that","corresponds","with","the","highest","bit","position",".","The","mantissa","is","retrieved","either","via","the","standard","C","function","[","frexp","]","or","by","some","bit","twiddling","on","IEEE","compatible","numbers","(","float",")",".","Note","that","one","needs","to","use","at","least","[","double","]","precision","for","an","accurate","mantissa","of","32","bit","numbers",".","*","use","bit","twiddling","a","logarithmic","sequence","of","bitwise","or","s","and","shifts","(","bit",")",".","*","use","processor","specific","assembler","instruction","(","asm",")","."],"function":"highestBitMask x0\n  = case (x0 .|. shiftRL x0 1) of\n     x1 -> case (x1 .|. shiftRL x1 2) of\n      x2 -> case (x2 .|. shiftRL x2 4) of\n       x3 -> case (x3 .|. shiftRL x3 8) of\n        x4 -> case (x4 .|. shiftRL x4 16) of\n         x5 -> case (x5 .|. shiftRL x5 32) of   -- for 64 bit platforms\n          x6 -> (x6 `xor` (shiftRL x6 1))\n\n\n{--------------------------------------------------------------------\n  Utilities\n--------------------------------------------------------------------}","function_tokens":["highestBitMask","x0","=","case","(","x0",".|.","shiftRL","x0","1",")","of","x1","->","case","(","x1",".|.","shiftRL","x1","2",")","of","x2","->","case","(","x2",".|.","shiftRL","x2","4",")","of","x3","->","case","(","x3",".|.","shiftRL","x3","8",")","of","x4","->","case","(","x4",".|.","shiftRL","x4","16",")","of","x5","->","case","(","x5",".|.","shiftRL","x5","32",")","of","-- for 64 bit platforms","x6","->","(","x6","`","xor","`","(","shiftRL","x6","1",")",")","{--------------------------------------------------------------------\n  Utilities\n--------------------------------------------------------------------}"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L980-L993","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(major, minor) =\n      case versionBranch v of\n        v0 : v1 : _ -> (v0, v1)\n        v0 : _ -> (v0, 0)\n        [] -> (0, 0)\n\n-- | Get the compression method form its numeric representation.","function_tokens":["(","major",",","minor",")","=","case","versionBranch","v","of","v0",":","v1",":","_","->","(","v0",",","v1",")","v0",":","_","->","(","v0",",","0",")","[","]","->","(","0",",","0",")","-- | Get the compression method form its numeric representation."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1101-L1108","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"eof","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"eof = do\n    result <- peek\n    maybe (return ()) (const $ throwError ExpectedEndOfInput) result","function_tokens":["eof","=","do","result","<-","peek","maybe","(","return","(",")",")","(","const","$","throwError","ExpectedEndOfInput",")","result"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L88-L92","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"withTween_","parameters":"ease from to dur f","argument_list":"","return_statement":"","docstring":"A version of 'withTween' that discards its result.","docstring_summary":"A version of 'withTween' that discards its result.","docstring_tokens":["A","version","of","withTween","that","discards","its","result","."],"function":"withTween_ ease from to dur f = Control.Monad.void (withTween ease from to dur f)","function_tokens":["withTween_","ease","from","to","dur","f","=","Control","Monad","void","(","withTween","ease","from","to","dur","f",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L340-L340","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"ef","parameters":"k v Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ef k v Nothing = Just (M.singleton k v)","function_tokens":["ef","k","v","Nothing","=","Just","(","M","singleton","k","v",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L443-L443","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Area _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Area _)                 = (True, True, False, False)","function_tokens":["go","(","Area","_",")","=","(","True",",","True",",","False",",","False",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L366-L366","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"columns","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"columns = configColumns config","function_tokens":["columns","=","configColumns","config"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L208-L208","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(lt,gt) = split' x l","function_tokens":["(","lt",",","gt",")","=","split'","x","l"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L530-L530","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"splitMember'","parameters":"x t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"splitMember' x t\n  = case t of\n      Bin _ _ p m l r\n         | match x p m ->  if zero x m then let (lt,found,gt) = splitMember x l in (lt,found,union gt r)\n                                       else let (lt,found,gt) = splitMember x r in (union l lt,found,gt)\n         | otherwise   -> if x < p then (Nil, False, t)\n                                   else (t, False, Nil)\n      Tip _ y\n        | x>y       -> (t,False,Nil)\n        | x<y       -> (Nil,False,t)\n        | otherwise -> (Nil,True,Nil)\n      Nil -> (Nil,False,Nil)\n\n\n\n{----------------------------------------------------------------------\n  Min\/Max\n----------------------------------------------------------------------}\n\n-- | \/O(min(n,W))\/. Retrieves the maximal key of the set, and the set\n-- stripped of that element, or 'Nothing' if passed an empty set.","function_tokens":["splitMember'","x","t","=","case","t","of","Bin","_","_","p","m","l","r","|","match","x","p","m","->","if","zero","x","m","then","let","(","lt",",","found",",","gt",")","=","splitMember","x","l","in","(","lt",",","found",",","union","gt","r",")","else","let","(","lt",",","found",",","gt",")","=","splitMember","x","r","in","(","union","l","lt",",","found",",","gt",")","|","otherwise","->","if","x","<","p","then","(","Nil",",","False",",","t",")","else","(","t",",","False",",","Nil",")","Tip","_","y","|","x",">","y","->","(","t",",","False",",","Nil",")","|","x","<","y","->","(","Nil",",","False",",","t",")","|","otherwise","->","(","Nil",",","True",",","Nil",")","Nil","->","(","Nil",",","False",",","Nil",")","{----------------------------------------------------------------------\n  Min\/Max\n----------------------------------------------------------------------}","-- | \/O(min(n,W))\/. Retrieves the maximal key of the set, and the set","-- stripped of that element, or 'Nothing' if passed an empty set."],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L571-L592","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"computeTypes","parameters":"forcedMono fieldtype datatype dtVars_ subst","argument_list":"","return_statement":"","docstring":"-----------------------------------------------------------------------------","docstring_summary":"-----------------------------------------------------------------------------","docstring_tokens":["-----------------------------------------------------------------------------"],"function":"computeTypes forcedMono fieldtype datatype dtVars_ subst =\n\n  do let fieldVars = typeVariables fieldtype\n         tyO       = return fieldtype\n         dtTypes   = substitute subst . typeFromBinder <$> dtVars_\n         dtBinders = concatMap binderFromType dtTypes\n         varNames  = nameFromBinder <$> dtBinders\n         usedVars  = filter (`elem` fieldVars) varNames\n         tyI       = return $ foldr (flip AppT) (ConT datatype) (reverse dtTypes)\n         pretties  = mapTyVarBndr pretty <$> dtBinders\n         mono      = forcedMono || isMonomorphic fieldtype dtBinders\n\n     if mono\n       then return $ Typing\n               mono\n               (prettyType <$> tyI)\n               (prettyType <$> tyO)\n               (nub pretties)\n       else\n         do let names = return <$> ['a'..'z']\n                used  = show . pretty <$> varNames\n                free  = filter (not . (`elem` used)) names\n            subs <- forM (zip usedVars free) (\\(a, b) -> (,) a <$> newName b)\n            let rename = mapTypeVariables (\\a -> a `fromMaybe` lookup a subs)\n\n            return $ Typing\n              mono\n              (prettyType <$> [t| $tyI -> $(rename <$> tyI) |])\n              (prettyType <$> [t| $tyO -> $(rename <$> tyO) |])\n              (nub (pretties ++ map (mapTyVarBndr pretty)\n#if MIN_VERSION_template_haskell(2,17,0)\n                (flip PlainTV SpecifiedSpec . snd <$> subs)))\n#else\n                (PlainTV . snd <$> subs)))\n#endif","function_tokens":["computeTypes","forcedMono","fieldtype","datatype","dtVars_","subst","=","do","let","fieldVars","=","typeVariables","fieldtype","tyO","=","return","fieldtype","dtTypes","=","substitute","subst",".","typeFromBinder","<$>","dtVars_","dtBinders","=","concatMap","binderFromType","dtTypes","varNames","=","nameFromBinder","<$>","dtBinders","usedVars","=","filter","(","`","elem","`","fieldVars",")","varNames","tyI","=","return","$","foldr","(","flip","AppT",")","(","ConT","datatype",")","(","reverse","dtTypes",")","pretties","=","mapTyVarBndr","pretty","<$>","dtBinders","mono","=","forcedMono","||","isMonomorphic","fieldtype","dtBinders","if","mono","then","return","$","Typing","mono","(","prettyType","<$>","tyI",")","(","prettyType","<$>","tyO",")","(","nub","pretties",")","else","do","let","names","=","return","<$>","[","'a'","..","'z'","]","used","=","show",".","pretty","<$>","varNames","free","=","filter","(","not",".","(","`","elem","`","used",")",")","names","subs","<-","forM","(","zip","usedVars","free",")","(","\\","(","a",",","b",")","->","(",",",")","a","<$>","newName","b",")","let","rename","=","mapTypeVariables","(","\\","a","->","a","`","fromMaybe","`","lookup","a","subs",")","return","$","Typing","mono","(","prettyType","<$>","[","t","|"," $tyI -> $(rename <$> tyI) ","|]",")","(","prettyType","<$>","[","t","|"," $tyO -> $(rename <$> tyO) ","|]",")","(","nub","(","pretties","++","map","(","mapTyVarBndr","pretty",")","#if MIN_VERSION_template_haskell(2,17,0)","(","flip","PlainTV","SpecifiedSpec",".","snd","<$>","subs",")",")",")","#else\n                (PlainTV . snd <$> subs)))\n","#endif"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L560-L596","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Graphics\/Plot.hs","language":"haskell","identifier":"mkMapR","parameters":"(Map { _projection = p , _title = tit , _labelEntities = le , _labelledDistricts = points })","argument_list":"","return_statement":"","docstring":"Given a map, return a `Renderable ()` for use with the \"\"\"Graphics.Rendering.Char\"\"\" module.","docstring_summary":"Given a map, return a `Renderable ()` for use with the \"\"\"Graphics.Rendering.Char\"\"\" module.","docstring_tokens":["Given","a","map","return","a","Renderable","()","for","use","with","the","Graphics",".","Rendering",".","Char","module","."],"function":"mkMapR (Map { _projection = p , _title = tit , _labelEntities = le , _labelledDistricts = points }) = case le of\n    True -> mkRenderableLabelled tit points\n    False -> mkRenderableLabelled tit $ fmap (over _2 (const \"\")) points","function_tokens":["mkMapR","(","Map","{","_projection","=","p",",","_title","=","tit",",","_labelEntities","=","le",",","_labelledDistricts","=","points","}",")","=","case","le","of","True","->","mkRenderableLabelled","tit","points","False","->","mkRenderableLabelled","tit","$","fmap","(","over","_2","(","const","\"\"",")",")","points"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Graphics\/Plot.hs#L18-L22","hash_key":"vmchale\/hgis:src\/GIS\/Graphics\/Plot.hs","hash_val":20644,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"sort","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sort = sortBy (compare `on` snd)","function_tokens":["sort","=","sortBy","(","compare","`","on","`","snd",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L46-L46","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"describe","parameters":"UNil","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"describe UNil = DNil","function_tokens":["describe","UNil","=","DNil"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L204-L204","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"pad","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pad\n      | align = padRight longest\n      | otherwise = id","function_tokens":["pad","|","align","=","padRight","longest","|","otherwise","=","id"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L47-L49","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookTeamAddEvent","function_tokens":["reflect","_","=","WebhookTeamAddEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L475-L475","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"subsetCmpEq","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"subsetCmpEq = case (subsetCmp l1 l2, subsetCmp r1 r2) of\n                    (GT,_ ) -> GT\n                    (_ ,GT) -> GT\n                    (EQ,EQ) -> EQ\n                    _       -> LT","function_tokens":["subsetCmpEq","=","case","(","subsetCmp","l1","l2",",","subsetCmp","r1","r2",")","of","(","GT",",","_",")","->","GT","(","_",",","GT",")","->","GT","(","EQ",",","EQ",")","->","EQ","_","->","LT"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L463-L469","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments.hs","language":"haskell","identifier":"commentsFromString","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commentsFromString = commentsInFile \"\"","function_tokens":["commentsFromString","=","commentsInFile","\"\""],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments.hs#L67-L67","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments.hs","hash_val":25846,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"DeleteArchiveComment","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry DeleteArchiveComment = Nothing","function_tokens":["targetEntry","DeleteArchiveComment","=","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1065-L1065","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"again","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"again = hSeek h AbsoluteSeek (pos - 1) >> loop limit","function_tokens":["again","=","hSeek","h","AbsoluteSeek","(","pos","-","1",")",">>","loop","limit"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L975-L975","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Phrygian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Phrygian     = \"phrygian\"","function_tokens":["go","Phrygian","=","\"phrygian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L532-L532","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(Not n)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (Not n)  = coerce $ \"(not \" ++ coerce n ++ \")\"","function_tokens":["ishow","(","Not","n",")","=","coerce","$","\"(not \"","++","coerce","n","++","\")\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L392-L392","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"exists","parameters":"[] f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exists [] f = f","function_tokens":["exists","[","]","f","=","f"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L659-L659","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_MAX_GAIN","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_MAX_GAIN                         = 0x100E","function_tokens":["al_MAX_GAIN","=","0x100E"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L84-L84","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"f","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"f = distance id . nodeId","function_tokens":["f","=","distance","id",".","nodeId"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L45-L45","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Buffer.hs","language":"haskell","identifier":"makeFormat","parameters":"channels bits","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"makeFormat channels bits =\n   error (\"makeFormat: illegal values \" ++ show (channels, bits))","function_tokens":["makeFormat","channels","bits","=","error","(","\"makeFormat: illegal values \"","++","show","(","channels",",","bits",")",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Buffer.hs#L148-L149","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Buffer.hs","hash_val":44847,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"readShpData","parameters":"","argument_list":"","return_statement":"","docstring":"Parse a shapefile ByteString","docstring_summary":"Parse a shapefile ByteString","docstring_tokens":["Parse","a","shapefile","ByteString"],"function":"readShpData = runGet $ do\n  shpH  <- getShpHeader\n  shpRs <- whileM (not <$> isEmpty) getShpRec\n  return ShpData { shpHeader     = shpH,\n              dbfFieldDescs = Nothing, -- fill using readDbfData\n              shpRecs       = shpRs }\n\n-- | Header of the shapefile","function_tokens":["readShpData","=","runGet","$","do","shpH","<-","getShpHeader","shpRs","<-","whileM","(","not","<$>","isEmpty",")","getShpRec","return","ShpData","{","shpHeader","=","shpH",",","dbfFieldDescs","=","Nothing",",","-- fill using readDbfData","shpRecs","=","shpRs","}","-- | Header of the shapefile"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L28-L36","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"PONG","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandId PONG               = 1","function_tokens":["commandId","PONG","=","1"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L27-L27","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"configFileName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"configFileName = \".stylish-haskell.yaml\"","function_tokens":["configFileName","=","\".stylish-haskell.yaml\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L89-L89","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","language":"haskell","identifier":"getIntLE","parameters":"","argument_list":"","return_statement":"","docstring":"32-bit little-endian Int","docstring_summary":"32-bit little-endian Int","docstring_tokens":["32","-","bit","little","-","endian","Int"],"function":"getIntLE = fromIntegral <$> getWord32le","function_tokens":["getIntLE","=","fromIntegral","<$>","getWord32le"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs#L28-L28","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/Internal.hs","hash_val":35699,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Config.hs","language":"haskell","identifier":"parseConfig","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseConfig _            = mzero","function_tokens":["parseConfig","_","=","mzero"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Config.hs#L161-L161","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Config.hs","hash_val":33062,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showsTreeHang","parameters":"wide bars t","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showsTreeHang wide bars t\n  = case t of\n      Bin _ _ p m l r\n          -> showsBars bars . showString (showBin p m) . showString \"\\n\" .\n             showWide wide bars .\n             showsTreeHang wide (withBar bars) l .\n             showWide wide bars .\n             showsTreeHang wide (withEmpty bars) r\n      Tip _ x\n          -> showsBars bars . showString \" \" . shows x . showString \"\\n\"\n      Nil -> showsBars bars . showString \"|\\n\"","function_tokens":["showsTreeHang","wide","bars","t","=","case","t","of","Bin","_","_","p","m","l","r","->","showsBars","bars",".","showString","(","showBin","p","m",")",".","showString","\"\\n\"",".","showWide","wide","bars",".","showsTreeHang","wide","(","withBar","bars",")","l",".","showWide","wide","bars",".","showsTreeHang","wide","(","withEmpty","bars",")","r","Tip","_","x","->","showsBars","bars",".","showString","\" \"",".","shows","x",".","showString","\"\\n\"","Nil","->","showsBars","bars",".","showString","\"|\\n\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L796-L808","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = do\n      answer <- askLn prompt def\n      confirm answer >>= \\case\n        Left msg -> sayLn msg >> go\n        Right res -> pure res\n\n-- $use\n--\n--  Byline provides a monad transformer that allows you to compose\n-- interactive terminal actions.  When producing output,\n-- these actions accept stylized text that can include\n-- foreground and background colors, underlined text, and\n-- bold text.\n--\n-- Stylized text can be constructed with string literals\n-- (using the @OverloadedStrings@ extension) or using the\n-- 'text' function.  Attributes such as color can be changed\n-- using modifier functions and the 'Semigroup' @(<>)@ operator.\n--\n-- Actions that read user input can work with completion\n-- functions which are activated when the user presses the\n-- tab key.  Most input actions also support default values\n-- that will be returned when the user presses the enter key\n-- without providing any input.\n--\n-- Example:\n--\n-- @\n-- {-\\# LANGUAGE OverloadedStrings \\#-}\n--\n-- example :: MonadByline m => m Text\n-- example = do\n--   sayLn (\"Hey, I like \" <> (\"Haskell\" <> fg magenta) <> \"!\")\n--\n--   let question =\n--         \"What's \"\n--           <> (\"your\" <> bold)\n--           <> \" favorite \"\n--           <> (\"language\" <> fg green <> underline)\n--           <> \"? \"\n--\n--   askLn question (Just \"Haskell\")\n-- @\n--\n-- More complete examples can be found in the @examples@\n-- directory of the distribution tarball or in the\n-- repository.","function_tokens":["go","=","do","answer","<-","askLn","prompt","def","confirm","answer",">>=","\\","case","Left","msg","->","sayLn","msg",">>","go","Right","res","->","pure","res","-- $use","--","--  Byline provides a monad transformer that allows you to compose","-- interactive terminal actions.  When producing output,","-- these actions accept stylized text that can include","-- foreground and background colors, underlined text, and","-- bold text.","--","-- Stylized text can be constructed with string literals","-- (using the @OverloadedStrings@ extension) or using the","-- 'text' function.  Attributes such as color can be changed","-- using modifier functions and the 'Semigroup' @(<>)@ operator.","--","-- Actions that read user input can work with completion","-- functions which are activated when the user presses the","-- tab key.  Most input actions also support default values","-- that will be returned when the user presses the enter key","-- without providing any input.","--","-- Example:","--","-- @","-- {-\\# LANGUAGE OverloadedStrings \\#-}","--","-- example :: MonadByline m => m Text","-- example = do","--   sayLn (\"Hey, I like \" <> (\"Haskell\" <> fg magenta) <> \"!\")","--","--   let question =","--         \"What's \"","--           <> (\"your\" <> bold)","--           <> \" favorite \"","--           <> (\"language\" <> fg green <> underline)","--           <> \"? \"","--","--   askLn question (Just \"Haskell\")","-- @","--","-- More complete examples can be found in the @examples@","-- directory of the distribution tarball or in the","-- repository."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L156-L202","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"spreadValueProcess","parameters":"(KI h (KS sTree sValues) _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"spreadValueProcess (KI h (KS sTree sValues) _) = forever $ do\n    threadDelay hour\n\n    values <- atomically . readTVar $ sValues\n    tree <- atomically . readTVar $ sTree\n\n    mapMWithKey (sendRequests tree) $ values\n\n    where hour = 60 * 60 * 1000000\n          sendRequests tree key val = do\n            let closest = T.findClosest tree key 7\n            forM_ closest $ \\node -> send h (peer node) (STORE key val)\n\n          mapMWithKey :: (k -> v -> IO a) -> M.Map k v -> IO [a]\n          mapMWithKey f m = sequence . map snd . M.toList . M.mapWithKey f $ m\n\n-- | Delete a value after a certain amount of time has passed","function_tokens":["spreadValueProcess","(","KI","h","(","KS","sTree","sValues",")","_",")","=","forever","$","do","threadDelay","hour","values","<-","atomically",".","readTVar","$","sValues","tree","<-","atomically",".","readTVar","$","sTree","mapMWithKey","(","sendRequests","tree",")","$","values","where","hour","=","60","*","60","*","1000000","sendRequests","tree","key","val","=","do","let","closest","=","T","findClosest","tree","key","7","forM_","closest","$","\\","node","->","send","h","(","peer","node",")","(","STORE","key","val",")","mapMWithKey","::","(","k","->","v","->","IO","a",")","->","M","Map","k","v","->","IO","[","a","]","mapMWithKey","f","m","=","sequence",".","map","snd",".","M","toList",".","M","mapWithKey","f","$","m","-- | Delete a value after a certain amount of time has passed"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L228-L245","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"go","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go = \\case\n      RenderText t -> t\n      RenderSGR s ->\n        -- NOTE: The \\STX character below is not a real terminal\n        -- escape character.  Instead it is intercepted by Haskeline.\n        -- See: https:\/\/github.com\/judah\/haskeline\/wiki\/ControlSequencesInPrompt\n        toText (ANSI.setSGRCode s) <> \"\\STX\"\n\n-- | Internal function to turn stylized text into render instructions.\n--\n-- @since 1.0.0.0","function_tokens":["go","=","\\","case","RenderText","t","->","t","RenderSGR","s","->","-- NOTE: The \\STX character below is not a real terminal","-- escape character.  Instead it is intercepted by Haskeline.","-- See: https:\/\/github.com\/judah\/haskeline\/wiki\/ControlSequencesInPrompt","toText","(","ANSI","setSGRCode","s",")","<>","\"\\STX\"","-- | Internal function to turn stylized text into render instructions.","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L167-L178","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Types.hs","language":"haskell","identifier":"","parameters":"On On","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(<>) On On = On","function_tokens":["(","<>",")","On","On","=","On"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Types.hs#L50-L50","hash_key":"pjones\/byline:src\/Byline\/Internal\/Types.hs","hash_val":11549,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"sgrBuilder","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"sgrBuilder = (`csi'` 'm') . sgrToCode","function_tokens":["sgrBuilder","=","(","`","csi'","`","'m'",")",".","sgrToCode"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L388-L388","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"or","parameters":"[o]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"or [o] = o","function_tokens":["or","[","o","]","=","o"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L515-L515","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline.hs","language":"haskell","identifier":"say","parameters":"","argument_list":"","return_statement":"","docstring":"Output the given stylized text.  See also: 'sayLn'.  @since 1.0.0.0","docstring_summary":"Output the given stylized text.  See also: 'sayLn'.","docstring_tokens":["Output","the","given","stylized","text",".","See","also",":","sayLn","."],"function":"say =\n  toStylizedText\n    >>> Prim.say\n    >>> liftByline","function_tokens":["say","=","toStylizedText",">>>","Prim","say",">>>","liftByline"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline.hs#L73-L76","hash_key":"pjones\/byline:src\/Byline.hs","hash_val":30877,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Base.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Lens pointing to the tail of a list's cons cell. (Partial and monomorphic)","docstring_summary":"Lens pointing to the tail of a list's cons cell. (Partial and monomorphic)","docstring_tokens":["Lens","pointing","to","the","tail","of","a","list","s","cons","cell",".","(","Partial","and","monomorphic",")"],"function":"(head, tail) = $(getLabel ''[])","function_tokens":["(","head",",","tail",")","=","(","getLabel","''","[","]",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Base.hs#L60-L60","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Base.hs","hash_val":32756,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"choice","parameters":"","argument_list":"","return_statement":"","docstring":"Matches first of many choices.","docstring_summary":"Matches first of many choices.","docstring_tokens":["Matches","first","of","many","choices","."],"function":"choice = A.choice","function_tokens":["choice","=","A","choice"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L85-L85","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"r1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"r1 = rp `U.unsafeIndex` (i+1) - 1","function_tokens":["r1","=","rp","`","U","unsafeIndex","`","(","i","+","1",")","-","1"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L115-L115","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"takeNext","parameters":"[] []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeNext [] [] = Nothing","function_tokens":["takeNext","[","]","[","]","=","Nothing"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L99-L99","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"set","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"set = S.insert new s'","function_tokens":["set","=","S","insert","new","s'"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L262-L262","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"forall''","parameters":"vs phi","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"forall'' vs phi = case (mapM toStaticallySorted vs :: Maybe [Var v]) of\n            Just vs' -> case toStaticallySorted phi of\n                Just phi' -> return . toDynamicallySorted . forall vs' $ phi'\n                Nothing   -> fail \"quantifying non-boolean expression\"\n            Nothing  -> fail \"ill-sorted quantifier\"","function_tokens":["forall''","vs","phi","=","case","(","mapM","toStaticallySorted","vs","::","Maybe","[","Var","v","]",")","of","Just","vs'","->","case","toStaticallySorted","phi","of","Just","phi'","->","return",".","toDynamicallySorted",".","forall","vs'","$","phi'","Nothing","->","fail","\"quantifying non-boolean expression\"","Nothing","->","fail","\"ill-sorted quantifier\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L578-L584","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"exitProcess","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exitProcess = exitWith . exitCodeOf","function_tokens":["exitProcess","=","exitWith",".","exitCodeOf"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L260-L260","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"null","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"null _ = False","function_tokens":["null","_","=","False"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L66-L66","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"go","parameters":"_           []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go _           []       = []","function_tokens":["go","_","[","]","=","[","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L43-L43","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind","parameters":"_ a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind _ a = case index (unIFix a) %~ (sing :: Sing v) of\n        Proved Refl -> Just . (\\s -> (True, s)) $ do\n            (ns, q) <- get\n\n            let x :: forall f. VarF :<: f => IFix f v\n                x = var n\n\n                (n, ns') = runCoiter ns\n\n            put (ns', (freevars a, exists [x] . (x .=. a .&.)) : q)\n            return x\n        Disproved _ -> Nothing","function_tokens":["bind","_","a","=","case","index","(","unIFix","a",")","%~","(","sing","::","Sing","v",")","of","Proved","Refl","->","Just",".","(","\\","s","->","(","True",",","s",")",")","$","do","(","ns",",","q",")","<-","get","let","x","::","forall","f",".","VarF",":<:","f","=>","IFix","f","v","x","=","var","n","(","n",",","ns'",")","=","runCoiter","ns","put","(","ns'",",","(","freevars","a",",","exists","[","x","]",".","(","x",".=.","a",".&.",")",")",":","q",")","return","x","Disproved","_","->","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L772-L785","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d <\/> p = d FilePath.<\/> p","function_tokens":["d","<\/>","p","=","d","FilePath","<\/>","p"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L139-L139","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Implementation.hs","language":"haskell","identifier":"sendS","parameters":"node","argument_list":"","return_statement":"","docstring":"Send a FIND_NODE command, looking up your own id","docstring_summary":"Send a FIND_NODE command, looking up your own id","docstring_tokens":["Send","a","FIND_NODE","command","looking","up","your","own","id"],"function":"sendS node = liftIO ownId >>= flip sendSignal node . FIND_NODE","function_tokens":["sendS","node","=","liftIO","ownId",">>=","flip","sendSignal","node",".","FIND_NODE"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Implementation.hs#L154-L154","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Implementation.hs","hash_val":13779,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Choose\/Church.hs","language":"haskell","identifier":"liftIO","parameters":"io","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"liftIO io = lift (liftIO io)","function_tokens":["liftIO","io","=","lift","(","liftIO","io",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Choose\/Church.hs#L92-L92","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Choose\/Church.hs","hash_val":20622,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantifierFree","parameters":"","argument_list":"","return_statement":"","docstring":"Tests whether an expression is free of any quantifier.","docstring_summary":"Tests whether an expression is free of any quantifier.","docstring_tokens":["Tests","whether","an","expression","is","free","of","any","quantifier","."],"function":"isQuantifierFree = P.not . isQuantified","function_tokens":["isQuantifierFree","=","P","not",".","isQuantified"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L644-L644","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"durTfm","parameters":"(Tfm str del)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"durTfm (Tfm str del) = str + del","function_tokens":["durTfm","(","Tfm","str","del",")","=","str","+","del"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L357-L357","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"identify","parameters":"i (UBin p m l r)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identify i (UBin p m l r) = Bin i (size l + size r) p m l r","function_tokens":["identify","i","(","UBin","p","m","l","r",")","=","Bin","i","(","size","l","+","size","r",")","p","m","l","r"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L211-L211","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"flagEnds","parameters":"","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Utility for traversing through a list and knowing when you're at the first and last element.","docstring_summary":"------------------------------------------------------------------------------ Utility for traversing through a list and knowing when you're at the first and last element.","docstring_tokens":["------------------------------------------------------------------------------","Utility","for","traversing","through","a","list","and","knowing","when","you","re","at","the","first","and","last","element","."],"function":"flagEnds = \\case\n    [] -> []\n    [x] -> [(x, True, True)]\n    x : y : zs -> (x, True, False) : go (y : zs)\n  where\n    go (x : y : zs) = (x, False, False) : go (y : zs)\n    go [x]          = [(x, False, True)]\n    go []           = []\n\n\n--------------------------------------------------------------------------------","function_tokens":["flagEnds","=","\\","case","[","]","->","[","]","[","x","]","->","[","(","x",",","True",",","True",")","]","x",":","y",":","zs","->","(","x",",","True",",","False",")",":","go","(","y",":","zs",")","where","go","(","x",":","y",":","zs",")","=","(","x",",","False",",","False",")",":","go","(","y",":","zs",")","go","[","x","]","=","[","(","x",",","False",",","True",")","]","go","[","]","=","[","]","--------------------------------------------------------------------------------"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L204-L215","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"ishow","parameters":"(And [])","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ishow (And []) = coerce (\"true\" :: String)","function_tokens":["ishow","(","And","[","]",")","=","coerce","(","\"true\"","::","String",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L384-L384","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"createWord","parameters":"i","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"createWord i = let pos = i * 8\n                         in foldr changeBit zeroBits [pos..pos+7]","function_tokens":["createWord","i","=","let","pos","=","i","*","8","in","foldr","changeBit","zeroBits","[","pos","..","pos","+","7","]"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L69-L70","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"runPrinter_","parameters":"cfg printer","argument_list":"","return_statement":"","docstring":"Run printer to get printed lines only","docstring_summary":"Run printer to get printed lines only","docstring_tokens":["Run","printer","to","get","printed","lines","only"],"function":"runPrinter_ cfg printer = snd (runPrinter cfg printer)","function_tokens":["runPrinter_","cfg","printer","=","snd","(","runPrinter","cfg","printer",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L101-L101","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"indent","parameters":"len","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"indent len = (indentPrefix len ++)","function_tokens":["indent","len","=","(","indentPrefix","len","++",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L51-L51","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"var","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"var f = VarT $ \\a -> pure (f a, var f)","function_tokens":["var","f","=","VarT","$","\\","a","->","pure","(","f","a",",","var","f",")"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L293-L293","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Ionian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Ionian       = \"ionian\"","function_tokens":["go","Ionian","=","\"ionian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L530-L530","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"node","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"node = source sig","function_tokens":["node","=","source","sig"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L191-L191","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a <*> b = Point (arr app . (get a &&& get b)) $\n    proc (t, p) -> do (f, v) <- get a &&& get b -< p\n                      q <- modify a             -< (t . arr ($ v), p)\n                      modify b                  -< (t . arr f, q)","function_tokens":["a","<*>","b","=","Point","(","arr","app",".","(","get","a","&&&","get","b",")",")","$","proc","(","t",",","p",")","->","do","(","f",",","v",")","<-","get","a","&&&","get","b","-<","p","q","<-","modify","a","-<","(","t",".","arr","(","$","v",")",",","p",")","modify","b","-<","(","t",".","arr","f",",","q",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L96-L100","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty _ = \"{VoiceProperties}\"","function_tokens":["pretty","_","=","\"{VoiceProperties}\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L558-L558","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"right","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"right f = arr id +++ f","function_tokens":["right","f","=","arr","id","+++","f"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L166-L166","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"PING","argument_list":"","return_statement":"","docstring":"Retrieve the assigned protocolId","docstring_summary":"Retrieve the assigned protocolId","docstring_tokens":["Retrieve","the","assigned","protocolId"],"function":"commandId PING               = 0","function_tokens":["commandId","PING","=","0"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L26-L26","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"current'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"current' = case next of\n                    NextItem i -> current {cgItems = cgItems current <> [(i, Nothing)]}\n                    NextComment c\n                        | null (cgItems current) -> current {cgPrior = cgPrior current <> [c]}\n                        | otherwise -> current {cgFollowing = cgFollowing current <> [c]}\n                    NextItemWithComment i c ->\n                        current {cgItems = cgItems current <> [(i, Just c)]} in","function_tokens":["current'","=","case","next","of","NextItem","i","->","current","{","cgItems","=","cgItems","current","<>","[","(","i",",","Nothing",")","]","}","NextComment","c","|","null","(","cgItems","current",")","->","current","{","cgPrior","=","cgPrior","current","<>","[","c","]","}","|","otherwise","->","current","{","cgFollowing","=","cgFollowing","current","<>","[","c","]","}","NextItemWithComment","i","c","->","current","{","cgItems","=","cgItems","current","<>","[","(","i",",","Just","c",")","]","}","in"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L83-L90","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decodeText","parameters":"True","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decodeText True = either (const Nothing) Just . T.decodeUtf8'","function_tokens":["decodeText","True","=","either","(","const","Nothing",")","Just",".","T","decodeUtf8'"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1080-L1080","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol\/Parsing.hs","language":"haskell","identifier":"parseCommand","parameters":"4","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseCommand 4 = liftM2 RETURN_NODES  parseSerialize parseKBucket","function_tokens":["parseCommand","4","=","liftM2","RETURN_NODES","parseSerialize","parseKBucket"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol\/Parsing.hs#L128-L128","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol\/Parsing.hs","hash_val":13392,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(_, s', w) = runRSS m r s","function_tokens":["(","_",",","s'",",","w",")","=","runRSS","m","r","s"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L71-L71","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"dumpAndOpenEditor","parameters":"colorEnable opts path conflicts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dumpAndOpenEditor colorEnable opts path conflicts =\n    do  when (shouldDumpDiffs opts || shouldDumpDiff2 opts) $\n            traverse_ (dumpDiffs colorEnable opts path (length conflicts)) (zip [1..] conflicts)\n        openEditor opts path","function_tokens":["dumpAndOpenEditor","colorEnable","opts","path","conflicts","=","do","when","(","shouldDumpDiffs","opts","||","shouldDumpDiff2","opts",")","$","traverse_","(","dumpDiffs","colorEnable","opts","path","(","length","conflicts",")",")","(","zip","[","1","..","]","conflicts",")","openEditor","opts","path"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L67-L72","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"src\/Main.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"_ <> DidFormat = DidFormat","function_tokens":["_","<>","DidFormat","=","DidFormat"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/src\/Main.hs#L136-L136","hash_key":"haskell\/stylish-haskell:src\/Main.hs","hash_val":29291,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Labelled.hs","language":"haskell","identifier":"sendLabelled","parameters":"op","argument_list":"","return_statement":"","docstring":"Construct a request for a labelled effect to be interpreted by some handler later on.  @since 1.0.2.0","docstring_summary":"Construct a request for a labelled effect to be interpreted by some handler later on.","docstring_tokens":["Construct","a","request","for","a","labelled","effect","to","be","interpreted","by","some","handler","later","on","."],"function":"sendLabelled op = runIdentity <$> alg (fmap Identity . runIdentity) (injLabelled @label (Labelled op)) (Identity ())","function_tokens":["sendLabelled","op","=","runIdentity","<$>","alg","(","fmap","Identity",".","runIdentity",")","(","injLabelled","@","label","(","Labelled","op",")",")","(","Identity","(",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Labelled.hs#L120-L120","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Labelled.hs","hash_val":16121,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"Nondeterministically choose between two computations.  @ (m '<|>' n) '>>=' k = (m '>>=' k) '<|>' (n '>>=' k) @ @ (m '<|>' n) '<|>' o = m '<|>' (n '<|>' o) @ @ 'empty' '<|>' m = m @ @ m '<|>' 'empty' = m @  @since 1.0.0.0","docstring_summary":"Nondeterministically choose between two computations.","docstring_tokens":["Nondeterministically","choose","between","two","computations","."],"function":"a <|> b = send Choose >>= bool b a","function_tokens":["a","<|>","b","=","send","Choose",">>=","bool","b","a"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L64-L64","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"imap","parameters":"f (Equals s a b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap f (Equals s a b) = Equals s (f a) (f b)","function_tokens":["imap","f","(","Equals","s","a","b",")","=","Equals","s","(","f","a",")","(","f","b",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L47-L47","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getDocument","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getDocument = do\n  len <- subtract 4 <$> getInt32\n  b <- getLazyByteString (fromIntegral len)\n  return (runGet getFields b)\n where\n  getFields = lookAhead getWord8 >>= \\done -> if done == 0\n   then return []\n   else (:) <$> getField <*> getFields","function_tokens":["getDocument","=","do","len","<-","subtract","4","<$>","getInt32","b","<-","getLazyByteString","(","fromIntegral","len",")","return","(","runGet","getFields","b",")","where","getFields","=","lookAhead","getWord8",">>=","\\","done","->","if","done","==","0","then","return","[","]","else","(",":",")","<$>","getField","<*>","getFields"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L164-L173","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"asLen","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"asLen = BS.length as","function_tokens":["asLen","=","BS","length","as"],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L102-L102","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"or","parameters":"[]","argument_list":"","return_statement":"","docstring":"A smart constructor for variadic disjunction","docstring_summary":"A smart constructor for variadic disjunction","docstring_tokens":["A","smart","constructor","for","variadic","disjunction"],"function":"or []  = false","function_tokens":["or","[","]","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L514-L514","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"getFields","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getFields = lookAhead getWord8 >>= \\done -> if done == 0\n   then return []\n   else (:) <$> getField <*> getFields","function_tokens":["getFields","=","lookAhead","getWord8",">>=","\\","done","->","if","done","==","0","then","return","[","]","else","(",":",")","<$>","getField","<*>","getFields"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L169-L171","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mkLabelsWith","parameters":"mk sigs concrete failing inl name","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mkLabelsWith mk sigs concrete failing inl name =\n  do dec <- reifyDec name\n     mkLabelsWithForDec mk sigs concrete failing inl dec\n\n-- | Default way of generating a label name from the Haskell record selector\n-- name. If the original selector starts with an underscore, remove it and make\n-- the next character lowercase. Otherwise, add 'l', and make the next\n-- character uppercase.","function_tokens":["mkLabelsWith","mk","sigs","concrete","failing","inl","name","=","do","dec","<-","reifyDec","name","mkLabelsWithForDec","mk","sigs","concrete","failing","inl","dec","-- | Default way of generating a label name from the Haskell record selector","-- name. If the original selector starts with an underscore, remove it and make","-- the next character lowercase. Otherwise, add 'l', and make the next","-- character uppercase."],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L167-L176","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"fromVector","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromVector = MG.fromVector","function_tokens":["fromVector","=","MG","fromVector"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L141-L141","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"zero","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zero = 0","function_tokens":["zero","=","0"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L58-L58","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Module.hs","language":"haskell","identifier":"go","parameters":"acc _ []","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go acc _ [] = ne acc","function_tokens":["go","acc","_","[","]","=","ne","acc"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Module.hs#L92-L92","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Module.hs","hash_val":11188,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"lessThan'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lessThan' = do\n            _ <- char '(' *> char '<' *> space\n            a <- r\n            _ <- space\n            b <- r\n            _ <- char ')'\n            lessThan'' a b","function_tokens":["lessThan'","=","do","_","<-","char","'('","*>","char","'<'","*>","space","a","<-","r","_","<-","space","b","<-","r","_","<-","char","')'","lessThan''","a","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L126-L134","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Source a)","argument_list":"","return_statement":"","docstring":"TODO","docstring_summary":"TODO","docstring_tokens":["TODO"],"function":"go (Source a)               = a","function_tokens":["go","(","Source","a",")","=","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L423-L423","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"action","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"action = unZipArchive (m <* commit)","function_tokens":["action","=","unZipArchive","(","m","<*","commit",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L296-L296","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"left","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"left       = foldl' GHC.combineSrcSpans pat guardsLocs","function_tokens":["left","=","foldl'","GHC","combineSrcSpans","pat","guardsLocs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L122-L122","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"tell","parameters":"w","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tell w = RSST $ \\_ (s, ow) ->\n        let nw = ow `mappend` w\n        in  nw `seq` return ((), (s,  nw))","function_tokens":["tell","w","=","RSST","$","\\","_","(","s",",","ow",")","->","let","nw","=","ow","`","mappend","`","w","in","nw","`","seq","`","return","(","(",")",",","(","s",",","nw",")",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L190-L192","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","language":"haskell","identifier":"name","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"name = GHC.unLoc <$> GHC.hsmodName modul","function_tokens":["name","=","GHC","unLoc","<$>","GHC","hsmodName","modul"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs#L71-L71","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/ModuleHeader.hs","hash_val":31022,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label.hs","language":"haskell","identifier":"get","parameters":"","argument_list":"","return_statement":"","docstring":"Get the getter function from a lens.","docstring_summary":"Get the getter function from a lens.","docstring_tokens":["Get","the","getter","function","from","a","lens","."],"function":"get = Mono.get","function_tokens":["get","=","Mono","get"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label.hs#L200-L200","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label.hs","hash_val":23450,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"self","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"self = node { nodeId = ownId }","function_tokens":["self","=","node","{","nodeId","=","ownId","}"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L153-L153","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"melTemp","parameters":"","argument_list":"","return_statement":"","docstring":"Analog of 'replicate' function for tracks. Replicated tracks are played sequentially. A melody of events. Each of them lasts for one second.","docstring_summary":"Analog of 'replicate' function for tracks. Replicated tracks are played sequentially. A melody of events. Each of them lasts for one second.","docstring_tokens":["Analog","of","replicate","function","for","tracks",".","Replicated","tracks","are","played","sequentially",".","A","melody","of","events",".","Each","of","them","lasts","for","one","second","."],"function":"melTemp = melMap temp","function_tokens":["melTemp","=","melMap","temp"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L136-L136","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = WebhookDeploymentEvent","function_tokens":["reflect","_","=","WebhookDeploymentEvent"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L421-L421","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Core.hs","language":"haskell","identifier":"contramap","parameters":"f (FlipVarT vmab)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"contramap f (FlipVarT vmab) = FlipVarT $ VarT $ \\c -> do\n    (b, vmab1) <- runVarT vmab $ f c\n    return (b, unFlipVarT $ contramap f $ FlipVarT vmab1)\n\n#if __GLASGOW_HASKELL__ >= 804\n-- | Vars can be semigroups\n--\n-- >>> let v = var (const \"Hello \") <> var (const \"World!\")\n-- >>> testVarOver v [()]\n-- \"Hello World!\"","function_tokens":["contramap","f","(","FlipVarT","vmab",")","=","FlipVarT","$","VarT","$","\\","c","->","do","(","b",",","vmab1",")","<-","runVarT","vmab","$","f","c","return","(","b",",","unFlipVarT","$","contramap","f","$","FlipVarT","vmab1",")","#if __GLASGOW_HASKELL__ >= 804","-- | Vars can be semigroups","--","-- >>> let v = var (const \"Hello \") <> var (const \"World!\")","-- >>> testVarOver v [()]","-- \"Hello World!\""],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Core.hs#L200-L210","hash_key":"schell\/varying:src\/Control\/Varying\/Core.hs","hash_val":44307,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for reversed implication (an abbreviation for @a .|. not b@)","docstring_summary":"A smart constructor for reversed implication (an abbreviation for","docstring_tokens":["A","smart","constructor","for","reversed","implication","(","an","abbreviation","for"],"function":"a .<-. b = b .->. a","function_tokens":["a",".<-.","b","=","b",".->.","a"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L481-L481","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"matchBottom","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"matchBottom = match (revBottom sideBase) (revBottom sideA) (revBottom sideB)","function_tokens":["matchBottom","=","match","(","revBottom","sideBase",")","(","revBottom","sideA",")","(","revBottom","sideB",")"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L47-L47","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"a \/\\ b = a .&. b","function_tokens":["a","\/\\","b","=","a",".&.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L202-L202","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"decompress","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"decompress =\n      if d\n        then decompressingPipe edCompression\n        else C.awaitForever C.yield","function_tokens":["decompress","=","if","d","then","decompressingPipe","edCompression","else","C","awaitForever","C","yield"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L254-L257","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = MG.empty","function_tokens":["empty","=","MG","empty"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L164-L164","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"zipVersion","parameters":"","argument_list":"","return_statement":"","docstring":"-------------------------------------------------------------------------- Constants \u201cVersion created by\u201d to specify when writing archive data.","docstring_summary":"-------------------------------------------------------------------------- Constants \u201cVersion created by\u201d to specify when writing archive data.","docstring_tokens":["--------------------------------------------------------------------------","Constants","\u201cVersion","created","by\u201d","to","specify","when","writing","archive","data","."],"function":"zipVersion = Version [6, 3] []","function_tokens":["zipVersion","=","Version","[","6",",","3","]","[","]"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L178-L178","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zip3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip3 = MG.zip3","function_tokens":["zip3","=","MG","zip3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L315-L315","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"fromVector","parameters":"(r,c) vec","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fromVector (r,c) vec | r*c \/= n = error errMsg\n                     | otherwise = unsafeFromVector (r,c) vec\n  where\n    errMsg = printf \"fromVector: incorrect length (%d * %d != %d)\" r c n\n    n = G.length vec","function_tokens":["fromVector","(","r",",","c",")","vec","|","r","*","c","\/=","n","=","error","errMsg","|","otherwise","=","unsafeFromVector","(","r",",","c",")","vec","where","errMsg","=","printf","\"fromVector: incorrect length (%d * %d != %d)\"","r","c","n","n","=","G","length","vec"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L118-L123","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"putZip64ECD","parameters":"totalCount cdSize cdOffset","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putZip64ECD totalCount cdSize cdOffset = do\n  putWord32le 0x06064b50 -- zip64 end of central dir signature\n  putWord64le 44 -- size of zip64 end of central dir record\n  putWord16le (fromVersion zipVersion) -- version made by\n  putWord16le (fromVersion $ getZipVersion True Nothing)\n  -- \u2191 version needed to extract\n  putWord32le 0 -- number of this disk\n  putWord32le 0 -- number of the disk with the start of the central directory\n  putWord64le (fromIntegral totalCount) -- total number of entries (this disk)\n  putWord64le (fromIntegral totalCount) -- total number of entries\n  putWord64le (fromIntegral cdSize) -- size of the central directory\n  putWord64le (fromIntegral cdOffset) -- offset of central directory\n\n-- | Create 'ByteString' representing Zip64 end of the central directory\n-- locator.","function_tokens":["putZip64ECD","totalCount","cdSize","cdOffset","=","do","putWord32le","0x06064b50","-- zip64 end of central dir signature","putWord64le","44","-- size of zip64 end of central dir record","putWord16le","(","fromVersion","zipVersion",")","-- version made by","putWord16le","(","fromVersion","$","getZipVersion","True","Nothing",")","-- \u2191 version needed to extract","putWord32le","0","-- number of this disk","putWord32le","0","-- number of the disk with the start of the central directory","putWord64le","(","fromIntegral","totalCount",")","-- total number of entries (this disk)","putWord64le","(","fromIntegral","totalCount",")","-- total number of entries","putWord64le","(","fromIntegral","cdSize",")","-- size of the central directory","putWord64le","(","fromIntegral","cdOffset",")","-- offset of central directory","-- | Create 'ByteString' representing Zip64 end of the central directory","-- locator."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L868-L883","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"getEntrySource","parameters":"s","argument_list":"","return_statement":"","docstring":"Get an entry source.  Throws: 'EntryDoesNotExist'.  @since 0.1.3","docstring_summary":"Get an entry source.  Throws: 'EntryDoesNotExist'.","docstring_tokens":["Get","an","entry","source",".","Throws",":","EntryDoesNotExist","."],"function":"getEntrySource s = do\n  path <- getFilePath\n  mdesc <- M.lookup s <$> getEntries\n  case mdesc of\n    Nothing -> throwM (EntryDoesNotExist path s)\n    Just desc -> return (I.sourceEntry path desc True)\n\n-- | Stream contents of an archive entry to the given 'Sink'.\n--\n-- Throws: 'EntryDoesNotExist'.","function_tokens":["getEntrySource","s","=","do","path","<-","getFilePath","mdesc","<-","M","lookup","s","<$>","getEntries","case","mdesc","of","Nothing","->","throwM","(","EntryDoesNotExist","path","s",")","Just","desc","->","return","(","I","sourceEntry","path","desc","True",")","-- | Stream contents of an archive entry to the given 'Sink'.","--","-- Throws: 'EntryDoesNotExist'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L349-L359","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Lazy.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)","function_tokens":["StateC","l","<|>","StateC","r","=","StateC","(","\\","s","->","l","s","<|>","r","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Lazy.hs#L103-L103","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Lazy.hs","hash_val":38987,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"instantiate","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"instantiate _ _ = Nothing","function_tokens":["instantiate","_","_","=","Nothing"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L914-L914","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"merge","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge []  = cnst 1","function_tokens":["merge","[","]","=","cnst","1"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L187-L187","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"get","parameters":"","argument_list":"","return_statement":"","docstring":"Get the getter arrow from a lens.","docstring_summary":"Get the getter arrow from a lens.","docstring_tokens":["Get","the","getter","arrow","from","a","lens","."],"function":"get = Point.get . unpack","function_tokens":["get","=","Point","get",".","unpack"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L65-L65","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"dropT","parameters":"t0 a","argument_list":"","return_statement":"","docstring":"@('dropT' t m)@ is equivalent to @('slice' t (dur a) a)@.","docstring_summary":"","docstring_tokens":[],"function":"dropT t0 a = slice t0 (dur a) a","function_tokens":["dropT","t0","a","=","slice","t0","(","dur","a",")","a"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L174-L174","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Shell.hs","language":"haskell","identifier":"bareChar","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bareChar = do\n      char <-\n        Atto.satisfy\n          ( \\c ->\n              not (isSpace c)\n                && c \/= '\\''\n                && c \/= '\"'\n                && isPrint c\n          )\n      if char == '\\\\'\n        then Atto.anyChar Atto.<?> \"escaped character\"\n        else pure char\n\n-- | State needed to scan input looking for a closing quote.","function_tokens":["bareChar","=","do","char","<-","Atto","satisfy","(","\\","c","->","not","(","isSpace","c",")","&&","c","\/=","'\\''","&&","c","\/=","'\"'","&&","isPrint","c",")","if","char","==","'\\\\'","then","Atto","anyChar","Atto","<?>","\"escaped character\"","else","pure","char","-- | State needed to scan input looking for a closing quote."],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Shell.hs#L188-L202","hash_key":"pjones\/byline:src\/Byline\/Shell.hs","hash_val":26601,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Lift.hs","language":"haskell","identifier":"runM","parameters":"(LiftC m)","argument_list":"","return_statement":"","docstring":"Extract a 'Lift'ed 'Monad'ic action from an effectful computation.  @since 1.0.0.0","docstring_summary":"Extract a 'Lift'ed 'Monad'ic action from an effectful computation.","docstring_tokens":["Extract","a","Lift","ed","Monad","ic","action","from","an","effectful","computation","."],"function":"runM (LiftC m) = m","function_tokens":["runM","(","LiftC","m",")","=","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Lift.hs#L29-L29","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Lift.hs","hash_val":12225,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/PPDiff.hs","language":"haskell","identifier":"ppDiff","parameters":"c (Second x)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ppDiff c (Second x) = wrap c Green $ '+':x","function_tokens":["ppDiff","c","(","Second","x",")","=","wrap","c","Green","$","'+'",":","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/PPDiff.hs#L17-L17","hash_key":"Peaker\/git-mediate:src\/PPDiff.hs","hash_val":5685,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"termCache","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"termCache = mkCache","function_tokens":["termCache","=","mkCache"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L55-L55","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"src\/Control\/Varying\/Tween.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = end - start","function_tokens":["c","=","end","-","start"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/src\/Control\/Varying\/Tween.hs#L296-L296","hash_key":"schell\/varying:src\/Control\/Varying\/Tween.hs","hash_val":124,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"areaPolygon","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"areaPolygon = (*factor) . areaPolyRectangular . fmap (bonne . toRadians)\n    where factor = 1717856\/4.219690791828533e-2\n\n-- | Given a list of polygons, return the total area.","function_tokens":["areaPolygon","=","(","*","factor",")",".","areaPolyRectangular",".","fmap","(","bonne",".","toRadians",")","where","factor","=","1717856","\/","4.219690791828533e-2","-- | Given a list of polygons, return the total area."],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L52-L56","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"isQuantified'","parameters":"(InL fa)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isQuantified' (InL fa) = isQuantified' fa","function_tokens":["isQuantified'","(","InL","fa",")","=","isQuantified'","fa"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L629-L629","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Verbose.hs","language":"haskell","identifier":"makeVerbose","parameters":"verbose","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------"],"function":"makeVerbose verbose\n    | verbose   = hPutStrLn stderr\n    | otherwise = const $ return ()","function_tokens":["makeVerbose","verbose","|","verbose","=","hPutStrLn","stderr","|","otherwise","=","const","$","return","(",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Verbose.hs#L18-L20","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Verbose.hs","hash_val":31231,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"A smart constructor for @>=@","docstring_summary":"A smart constructor for","docstring_tokens":["A","smart","constructor","for"],"function":"a .>=. b = a .+. cnst 1 .>. b","function_tokens":["a",".>=.","b","=","a",".+.","cnst","1",".>.","b"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L232-L232","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"saveEntry","parameters":"s path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"saveEntry s path = do\n  sourceEntry s (CB.sinkFile path)\n  med <- getEntryDesc s\n  forM_ med (liftIO . setModificationTime path . edModTime)\n\n-- | Calculate CRC32 check sum and compare it with the value read from the\n-- archive. The function returns 'True' when the check sums are the\n-- same\u2014that is, the data is not corrupted.\n--\n-- Throws: 'EntryDoesNotExist'.","function_tokens":["saveEntry","s","path","=","do","sourceEntry","s","(","CB","sinkFile","path",")","med","<-","getEntryDesc","s","forM_","med","(","liftIO",".","setModificationTime","path",".","edModTime",")","-- | Calculate CRC32 check sum and compare it with the value read from the","-- archive. The function returns 'True' when the check sums are the","-- same\u2014that is, the data is not corrupted.","--","-- Throws: 'EntryDoesNotExist'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L379-L389","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"mongodb-haskell\/bson","sha":"5654fbfbeee875cebaaee20bef9f078560bb6df0","path":"Data\/Bson\/Binary.hs","language":"haskell","identifier":"putDocument","parameters":"es","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putDocument es = let b = runPut (mapM_ putField es) in do\n  putInt32 $ (toEnum . fromEnum) (LC.length b + 5)  -- include length and null terminator\n  putLazyByteString b\n  putWord8 0","function_tokens":["putDocument","es","=","let","b","=","runPut","(","mapM_","putField","es",")","in","do","putInt32","$","(","toEnum",".","fromEnum",")","(","LC","length","b","+","5",")","-- include length and null terminator","putLazyByteString","b","putWord8","0"],"url":"https:\/\/github.com\/mongodb-haskell\/bson\/blob\/5654fbfbeee875cebaaee20bef9f078560bb6df0\/Data\/Bson\/Binary.hs#L158-L163","hash_key":"mongodb-haskell\/bson:Data\/Bson\/Binary.hs","hash_val":1791,"partition":"train"}
{"repo":"bartavelle\/stateWriter","sha":"2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34","path":"Control\/Monad\/Trans\/RSS\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"m >>= k  = RSST $ \\r s -> do\n        (a, (s', w))  <- runRSST' m r s\n        runRSST' (k a) r (s',w)","function_tokens":["m",">>=","k","=","RSST","$","\\","r","s","->","do","(","a",",","(","s'",",","w",")",")","<-","runRSST'","m","r","s","runRSST'","(","k","a",")","r","(","s'",",","w",")"],"url":"https:\/\/github.com\/bartavelle\/stateWriter\/blob\/2f7bfc9171ea6b7e1d3f564f08b6f5a74f049b34\/Control\/Monad\/Trans\/RSS\/Strict.hs#L130-L133","hash_key":"bartavelle\/stateWriter:Control\/Monad\/Trans\/RSS\/Strict.hs","hash_val":45006,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Teletype.hs","language":"haskell","identifier":"alg","parameters":"hdl sig ctx","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"alg hdl sig ctx = TeletypeRetC $ case sig of\n    L Read      -> do\n      i <- get\n      case i of\n        []  -> pure (\"\" <$ ctx)\n        h:t -> h <$ ctx <$ put t\n    L (Write s) -> ctx <$ tell [s]\n    R other     -> alg (runTeletypeRetC . hdl) (R (R other)) ctx","function_tokens":["alg","hdl","sig","ctx","=","TeletypeRetC","$","case","sig","of","L","Read","->","do","i","<-","get","case","i","of","[","]","->","pure","(","\"\"","<$","ctx",")","h",":","t","->","h","<$","ctx","<$","put","t","L","(","Write","s",")","->","ctx","<$","tell","[","s","]","R","other","->","alg","(","runTeletypeRetC",".","hdl",")","(","R","(","R","other",")",")","ctx"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Teletype.hs#L72-L79","hash_key":"fused-effects\/fused-effects:examples\/Teletype.hs","hash_val":38315,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"reflect","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reflect _ = reflect x : reflect xs where\n    x = Proxy :: Proxy x\n    xs = Proxy :: Proxy xs","function_tokens":["reflect","_","=","reflect","x",":","reflect","xs","where","x","=","Proxy","::","Proxy","x","xs","=","Proxy","::","Proxy","xs"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L398-L402","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"fail","parameters":"s","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fail s = StateC (const (Fail.fail s))","function_tokens":["fail","s","=","StateC","(","const","(","Fail","fail","s",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L105-L105","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"valLen","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"valLen e = expo - e + 2","function_tokens":["valLen","e","=","expo","-","e","+","2"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L356-L356","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"bkup","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bkup = fileName <.> \"bk\"","function_tokens":["bkup","=","fileName","<.>","\"bk\""],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L80-L80","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(a, (_, qs)) = runState (imapM flatten'' f) (freenames f, [])","function_tokens":["(","a",",","(","_",",","qs",")",")","=","runState","(","imapM","flatten''","f",")","(","freenames","f",",","[","]",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L874-L874","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"accesses'","parameters":"e","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"accesses' e = do\n    case match e of\n      Just (Select is es a i)   -> tell [ DynamicallySorted is\n                                        $ DynamicValueArrayAccess\n                                        $ DynamicallySorted es\n                                        $ ArrayAccess\n                                        $ (a, i) ]\n      Just (Store  is es a i _) -> tell [ DynamicallySorted is\n                                        $ DynamicValueArrayAccess\n                                        $ DynamicallySorted es\n                                        $ ArrayAccess\n                                        $ (a, i) ]\n      _                         -> return ()\n    return e","function_tokens":["accesses'","e","=","do","case","match","e","of","Just","(","Select","is","es","a","i",")","->","tell","[","DynamicallySorted","is","$","DynamicValueArrayAccess","$","DynamicallySorted","es","$","ArrayAccess","$","(","a",",","i",")","]","Just","(","Store","is","es","a","i","_",")","->","tell","[","DynamicallySorted","is","$","DynamicValueArrayAccess","$","DynamicallySorted","es","$","ArrayAccess","$","(","a",",","i",")","]","_","->","return","(",")","return","e"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L140-L153","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(values, ci, rp) = runST $ do\n        v <- GM.new n\n        col <- GM.new n\n        row <- GM.new (r+1)\n\n        ((i,_),_) <- foldM (f v col row) ((-1,-1),0) al\n\n        let stride = r - i\n        forM_ [0..stride-1] $ \\s -> GM.write row (r-s) n\n        v' <- G.unsafeFreeze v\n        col' <- G.unsafeFreeze col\n        row' <- G.unsafeFreeze row\n        return (v', col', row')","function_tokens":["(","values",",","ci",",","rp",")","=","runST","$","do","v","<-","GM","new","n","col","<-","GM","new","n","row","<-","GM","new","(","r","+","1",")","(","(","i",",","_",")",",","_",")","<-","foldM","(","f","v","col","row",")","(","(","-","1",",","-","1",")",",","0",")","al","let","stride","=","r","-","i","forM_","[","0","..","stride","-","1","]","$","\\","s","->","GM","write","row","(","r","-","s",")","n","v'","<-","G","unsafeFreeze","v","col'","<-","G","unsafeFreeze","col","row'","<-","G","unsafeFreeze","row","return","(","v'",",","col'",",","row'",")"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L130-L144","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zip5","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zip5 = MG.zip5","function_tokens":["zip5","=","MG","zip5"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L326-L326","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"go","parameters":"n","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go n = uncurry (>>) $ ((`replicateM_` f 10000) *** f) (n `divMod` 10000)","function_tokens":["go","n","=","uncurry","(",">>",")","$","(","(","`","replicateM_","`","f","10000",")","***","f",")","(","n","`","divMod","`","10000",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L127-L127","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Types.hs","language":"haskell","identifier":"pos","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pos = i * 8","function_tokens":["pos","=","i","*","8"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Types.hs#L69-L69","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Types.hs","hash_val":9495,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"prefix","parameters":"pa pb","argument_list":"","return_statement":"","docstring":"Prefix a printer with another one","docstring_summary":"Prefix a printer with another one","docstring_tokens":["Prefix","a","printer","with","another","one"],"function":"prefix pa pb = pa >> pb","function_tokens":["prefix","pa","pb","=","pa",">>","pb"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L304-L304","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"id","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"id = Iso id id","function_tokens":["id","=","Iso","id","id"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L118-L118","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Cut.hs","language":"haskell","identifier":"cut","parameters":"","argument_list":"","return_statement":"","docstring":"Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.  @ 'cut' '>>' 'empty' = 'cutfail' @  @since 0.1.2.0","docstring_summary":"Commit to the current branch, preventing backtracking within the nearest enclosing 'call' (if any) on failure.","docstring_tokens":["Commit","to","the","current","branch","preventing","backtracking","within","the","nearest","enclosing","call","(","if","any",")","on","failure","."],"function":"cut = pure () <|> cutfail","function_tokens":["cut","=","pure","(",")","<|>","cutfail"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Cut.hs#L72-L72","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Cut.hs","hash_val":25056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"benchmark\/Bench\/NonDet\/NQueens.hs","language":"haskell","identifier":"addOne","parameters":"n curr","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"addOne n curr = do\n  let i = length curr + 1\n  let choose = asum . fmap pure\n  j <- choose [1..n]\n  guard ((i, j) `isSafeIn` curr)\n  pure (curr ++ [j])","function_tokens":["addOne","n","curr","=","do","let","i","=","length","curr","+","1","let","choose","=","asum",".","fmap","pure","j","<-","choose","[","1","..","n","]","guard","(","(","i",",","j",")","`","isSafeIn","`","curr",")","pure","(","curr","++","[","j","]",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/benchmark\/Bench\/NonDet\/NQueens.hs#L41-L48","hash_key":"fused-effects\/fused-effects:benchmark\/Bench\/NonDet\/NQueens.hs","hash_val":44005,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"indexSort","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"indexSort = fmap getDVAA . toStaticallySorted","function_tokens":["indexSort","=","fmap","getDVAA",".","toStaticallySorted"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L134-L134","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"diagRect","parameters":"","argument_list":"","return_statement":"","docstring":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_summary":"O(m*n) Create a rectangular matrix with default values and given diagonal","docstring_tokens":["O","(","m","*","n",")","Create","a","rectangular","matrix","with","default","values","and","given","diagonal"],"function":"diagRect = MG.diagRect","function_tokens":["diagRect","=","MG","diagRect"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L211-L211","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Eval.hs","language":"haskell","identifier":"hOut","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"hOut = fromMaybe stdout bylineOutput","function_tokens":["hOut","=","fromMaybe","stdout","bylineOutput"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Eval.hs#L153-L153","hash_key":"pjones\/byline:src\/Byline\/Internal\/Eval.hs","hash_val":41020,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"areaConvex","parameters":"(base1:base2:pts)","argument_list":"","return_statement":"","docstring":"Compute the area of a convex polygon on the surface of a sphere.","docstring_summary":"Compute the area of a convex polygon on the surface of a sphere.","docstring_tokens":["Compute","the","area","of","a","convex","polygon","on","the","surface","of","a","sphere","."],"function":"areaConvex (base1:base2:pts) = (view _1) $ foldr stepArea (0,base2) pts\n    where stepArea point (sum, base) = (sum + (areaTriangle base1 base point), point)\n\n-- | Uses areal projection; then finds area of the polygon. \n-- Result is in km^2","function_tokens":["areaConvex","(","base1",":","base2",":","pts",")","=","(","view","_1",")","$","foldr","stepArea","(","0",",","base2",")","pts","where","stepArea","point","(","sum",",","base",")","=","(","sum","+","(","areaTriangle","base1","base","point",")",",","point",")","-- | Uses areal projection; then finds area of the polygon. ","-- Result is in km^2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L46-L51","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Choose.hs","language":"haskell","identifier":"traverse","parameters":"f (Choosing m)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"traverse f (Choosing m) = fmap Choosing (traverse f m)","function_tokens":["traverse","f","(","Choosing","m",")","=","fmap","Choosing","(","traverse","f","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Choose.hs#L149-L149","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Choose.hs","hash_val":5860,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/hsinstall.hs","language":"haskell","identifier":"binFp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"binFp = op BinDir . binDir $ di","function_tokens":["binFp","=","op","BinDir",".","binDir","$","di"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/hsinstall.hs#L56-L56","hash_key":"dino-\/hsinstall:src\/app\/hsinstall.hs","hash_val":1203,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Menu.hs","language":"haskell","identifier":"matchOnPrefix","parameters":"config input","argument_list":"","return_statement":"","docstring":"Helper function to produce a list of menu items matching the given user input.  @since 1.0.0.0","docstring_summary":"Helper function to produce a list of menu items matching the given user input.","docstring_tokens":["Helper","function","to","produce","a","list","of","menu","items","matching","the","given","user","input","."],"function":"matchOnPrefix config input =\n  filter prefixCheck (toList $ _menuItems config)\n  where\n    asText i = renderText Plain (toStylizedText i)\n    prefixCheck i = input `Text.isPrefixOf` asText i\n\n-- | Default 'FromChoice' function.  Checks to see if the user has input\n-- a unique prefix for a menu item (matches the item text) or selected\n-- one of the generated item prefixes (such as those generated by the\n-- internal @numbered@ function).\n--\n-- @since 1.0.0.0","function_tokens":["matchOnPrefix","config","input","=","filter","prefixCheck","(","toList","$","_menuItems","config",")","where","asText","i","=","renderText","Plain","(","toStylizedText","i",")","prefixCheck","i","=","input","`","Text","isPrefixOf","`","asText","i","-- | Default 'FromChoice' function.  Checks to see if the user has input","-- a unique prefix for a menu item (matches the item text) or selected","-- one of the generated item prefixes (such as those generated by the","-- internal @numbered@ function).","--","-- @since 1.0.0.0"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Menu.hs#L106-L118","hash_key":"pjones\/byline:src\/Byline\/Menu.hs","hash_val":27171,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"(ProducingActions coping sinking, editing) =\n          optimize (toRecreatingActions path entries >< xs)","function_tokens":["(","ProducingActions","coping","sinking",",","editing",")","=","optimize","(","toRecreatingActions","path","entries","><","xs",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L275-L276","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Sparse\/Generic.hs","language":"haskell","identifier":"n","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"n = U.length nz","function_tokens":["n","=","U","length","nz"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Sparse\/Generic.hs#L103-L103","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Sparse\/Generic.hs","hash_val":41428,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"wrap'","parameters":"ss (str:strs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"wrap' ss (str:strs)\n        | overflows ss str =\n            ss : wrapRest maxWidth ind (str:strs)\n        | otherwise = wrap' (ss ++ \" \" ++ str) strs","function_tokens":["wrap'","ss","(","str",":","strs",")","|","overflows","ss","str","=","ss",":","wrapRest","maxWidth","ind","(","str",":","strs",")","|","otherwise","=","wrap'","(","ss","++","\" \"","++","str",")","strs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L102-L105","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","language":"haskell","identifier":"longest","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"longest  = maximum $ map length prags","function_tokens":["longest","=","maximum","$","map","length","prags"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs#L65-L65","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/LanguagePragmas.hs","hash_val":28564,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/hsinstall.hs","language":"haskell","identifier":"tmplFp","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"tmplFp = op TmplDir tmplDir","function_tokens":["tmplFp","=","op","TmplDir","tmplDir"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/hsinstall.hs#L70-L70","hash_key":"dino-\/hsinstall:src\/app\/hsinstall.hs","hash_val":1203,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"go","parameters":"(RenderText t)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (RenderText t) = Text.hPutStr h t","function_tokens":["go","(","RenderText","t",")","=","Text","hPutStr","h","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L155-L155","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"freename","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"freename a = head $ dropWhile (\\s -> any (>= s) ns) pool where\n    fs = vars a\n    ns = sort $ map (\\(DynamicallySorted _ (IFix (Var n _))) -> takeWhile (`elem` ['a'..'z']) n) fs\n\n    pool = [ [x] | x <- ['a'..'z'] ] ++ [ x ++ [y] | x <- pool, y <- ['a'..'z'] ]","function_tokens":["freename","a","=","head","$","dropWhile","(","\\","s","->","any","(",">=","s",")","ns",")","pool","where","fs","=","vars","a","ns","=","sort","$","map","(","\\","(","DynamicallySorted","_","(","IFix","(","Var","n","_",")",")",")","->","takeWhile","(","`","elem","`","[","'a'","..","'z'","]",")","n",")","fs","pool","=","[","[","x","]","|","x","<-","[","'a'","..","'z'","]","]","++","[","x","++","[","y","]","|","x","<-","pool",",","y","<-","[","'a'","..","'z'","]","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L705-L711","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Protocol.hs","language":"haskell","identifier":"commandId","parameters":"(FIND_NODE _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"commandId (FIND_NODE _)      = 3","function_tokens":["commandId","(","FIND_NODE","_",")","=","3"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Protocol.hs#L29-L29","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Protocol.hs","hash_val":11791,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"checkCDSig","parameters":"pos","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"checkCDSig pos = do\n      hSeek h AbsoluteSeek (pos + 16)\n      sigPos <- fromIntegral <$> getNum getWord32le 4\n      if sigPos == 0xffffffff -- Zip64 is probably used\n        then return (Just pos)\n        else do\n          hSeek h AbsoluteSeek sigPos\n          cdSig <- getNum getWord32le 4\n          return $\n            if cdSig == 0x02014b50\n              ||\n              -- \u2191 normal case: central directory file header signature\n              cdSig == 0x06064b50\n              ||\n              -- \u2191 happens when zip 64 archive is empty\n              cdSig == 0x06054b50\n              then -- \u2191 happens when vanilla archive is empty\n                Just pos\n              else Nothing","function_tokens":["checkCDSig","pos","=","do","hSeek","h","AbsoluteSeek","(","pos","+","16",")","sigPos","<-","fromIntegral","<$>","getNum","getWord32le","4","if","sigPos","==","0xffffffff","-- Zip64 is probably used","then","return","(","Just","pos",")","else","do","hSeek","h","AbsoluteSeek","sigPos","cdSig","<-","getNum","getWord32le","4","return","$","if","cdSig","==","0x02014b50","||","-- \u2191 normal case: central directory file header signature","cdSig","==","0x06064b50","||","-- \u2191 happens when zip 64 archive is empty","cdSig","==","0x06054b50","then","-- \u2191 happens when vanilla archive is empty","Just","pos","else","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L996-L1015","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","language":"haskell","identifier":"putName","parameters":"decl@MkDataDecl{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"putName decl@MkDataDecl{..} =\n  if isInfix decl then do\n    forM_ firstTvar (\\t -> putOutputable t >> space)\n    putRdrName dataDeclName\n    space\n    forM_ secondTvar putOutputable\n    maybePutKindSig\n  else do\n    putRdrName dataDeclName\n    forM_ (GHC.hsq_explicit dataTypeVars) (\\t -> space >> putOutputable t)\n    maybePutKindSig\n\n  where\n    firstTvar :: Maybe (GHC.LHsTyVarBndr () GHC.GhcPs)\n    firstTvar = listToMaybe $ GHC.hsq_explicit dataTypeVars\n\n    secondTvar :: Maybe (GHC.LHsTyVarBndr () GHC.GhcPs)\n    secondTvar = listToMaybe . drop 1 $ GHC.hsq_explicit dataTypeVars\n\n    maybePutKindSig :: Printer ()\n    maybePutKindSig = forM_ maybeKindSig (\\k -> space >> putText \"::\" >> space >> putOutputable k)\n\n    maybeKindSig :: Maybe (GHC.LHsKind GHC.GhcPs)\n    maybeKindSig = GHC.dd_kindSig dataDefn","function_tokens":["putName","decl","@","MkDataDecl","{","..","}","=","if","isInfix","decl","then","do","forM_","firstTvar","(","\\","t","->","putOutputable","t",">>","space",")","putRdrName","dataDeclName","space","forM_","secondTvar","putOutputable","maybePutKindSig","else","do","putRdrName","dataDeclName","forM_","(","GHC","hsq_explicit","dataTypeVars",")","(","\\","t","->","space",">>","putOutputable","t",")","maybePutKindSig","where","firstTvar","::","Maybe","(","GHC","LHsTyVarBndr","(",")","GHC","GhcPs",")","firstTvar","=","listToMaybe","$","GHC","hsq_explicit","dataTypeVars","secondTvar","::","Maybe","(","GHC","LHsTyVarBndr","(",")","GHC","GhcPs",")","secondTvar","=","listToMaybe",".","drop","1","$","GHC","hsq_explicit","dataTypeVars","maybePutKindSig","::","Printer","(",")","maybePutKindSig","=","forM_","maybeKindSig","(","\\","k","->","space",">>","putText","\"::\"",">>","space",">>","putOutputable","k",")","maybeKindSig","::","Maybe","(","GHC","LHsKind","GHC","GhcPs",")","maybeKindSig","=","GHC","dd_kindSig","dataDefn"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/Data.hs#L301-L326","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/Data.hs","hash_val":38559,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/BufferInternal.hs","language":"haskell","identifier":"poke","parameters":"ptr   (Buffer b)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"poke ptr   (Buffer b) = poke1 (castPtr ptr) b","function_tokens":["poke","ptr","(","Buffer","b",")","=","poke1","(","castPtr","ptr",")","b"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/BufferInternal.hs#L59-L59","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/BufferInternal.hs","hash_val":15620,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"mver","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mver = makeVersion $ case m of\n      Nothing -> [2, 0]\n      Just Store -> [2, 0]\n      Just Deflate -> [2, 0]\n      Just BZip2 -> [4, 6]\n      Just Zstd -> [6, 3]\n\n-- | Return a decompressing 'Conduit' corresponding to the given compression\n-- method.","function_tokens":["mver","=","makeVersion","$","case","m","of","Nothing","->","[","2",",","0","]","Just","Store","->","[","2",",","0","]","Just","Deflate","->","[","2",",","0","]","Just","BZip2","->","[","4",",","6","]","Just","Zstd","->","[","6",",","3","]","-- | Return a decompressing 'Conduit' corresponding to the given compression","-- method."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1136-L1145","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"mfix","parameters":"f","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mfix f = NonDetC $ \\ fork leaf nil ->\n    mfix (runNonDetA . f . head)\n    >>= runNonDet fork leaf nil . foldr\n      (\\ a _ -> pure a <|> mfix (liftAll . fmap tail . runNonDetA . f))\n      empty where\n    liftAll m = NonDetC $ \\ fork leaf nil -> m >>= foldr (fork . leaf) nil","function_tokens":["mfix","f","=","NonDetC","$","\\","fork","leaf","nil","->","mfix","(","runNonDetA",".","f",".","head",")",">>=","runNonDet","fork","leaf","nil",".","foldr","(","\\","a","_","->","pure","a","<|>","mfix","(","liftAll",".","fmap","tail",".","runNonDetA",".","f",")",")","empty","where","liftAll","m","=","NonDetC","$","\\","fork","leaf","nil","->","m",">>=","foldr","(","fork",".","leaf",")","nil"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L108-L114","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"loopingMode","parameters":"","argument_list":"","return_statement":"","docstring":"If 'loopingMode' contains 'Looping', it indicates that the source will not be in the 'Stopped' state once it reaches the end of last buffer in the buffer queue. Instead, the source will immediately promote to 'Initial' and 'Playing'.  The initial value is 'OneShot'. 'loopingMode' can be changed on a source in any execution state. In particular, it can be changed on a 'Playing' source.","docstring_summary":"If 'loopingMode' contains 'Looping', it indicates that the source will not be in the 'Stopped' state once it reaches the end of last buffer in the buffer queue. Instead, the source will immediately promote to 'Initial' and 'Playing'.  The initial value is 'OneShot'. 'loopingMode' can be changed on a source in any execution state. In particular, it can be changed on a 'Playing' source.","docstring_tokens":["If","loopingMode","contains","Looping","it","indicates","that","the","source","will","not","be","in","the","Stopped","state","once","it","reaches","the","end","of","last","buffer","in","the","buffer","queue",".","Instead","the","source","will","immediately","promote","to","Initial","and","Playing",".","The","initial","value","is","OneShot",".","loopingMode","can","be","changed","on","a","source","in","any","execution","state",".","In","particular","it","can","be","changed","on","a","Playing","source","."],"function":"loopingMode = makeSourceStateVar dictLoopingMode GetLooping","function_tokens":["loopingMode","=","makeSourceStateVar","dictLoopingMode","GetLooping"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L263-L263","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Stylized.hs","language":"haskell","identifier":"swapFgBg","parameters":"(Stylized m t)","argument_list":"","return_statement":"","docstring":"Produce swapped foreground\/background text.  @since 1.0.0.0","docstring_summary":"Produce swapped foreground\/background text.","docstring_tokens":["Produce","swapped","foreground","\/","background","text","."],"function":"swapFgBg (Stylized m t) = Stylized (m {modSwapFgBg = On}) t","function_tokens":["swapFgBg","(","Stylized","m","t",")","=","Stylized","(","m","{","modSwapFgBg","=","On","}",")","t"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Stylized.hs#L124-L124","hash_key":"pjones\/byline:src\/Byline\/Internal\/Stylized.hs","hash_val":39469,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"case1","parameters":"i con","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"case1 i con =\n    case con of\n      NormalC  c  fs   -> [one fs c]\n      RecC     c  fs   -> [one fs c]\n      InfixC   _  c  _ -> [(infixP (pats !! 0) c (pats !! 1), var)]\n      ForallC  _  _  c -> case1 i c\n#if MIN_VERSION_template_haskell(2,11,0)\n      GadtC    cs fs _ -> map (one fs) cs\n      RecGadtC cs fs _ -> map (one fs) cs\n#endif\n    where fresh = mkName <$> delete \"f\" freshNames\n          pats1 = varP <$> fresh\n          pats  = replicate i wildP ++ [pats1 !! i] ++ repeat wildP\n          var   = varE (fresh !! i)\n          one fs c = let s = take (length fs) in (conP c (s pats), var)","function_tokens":["case1","i","con","=","case","con","of","NormalC","c","fs","->","[","one","fs","c","]","RecC","c","fs","->","[","one","fs","c","]","InfixC","_","c","_","->","[","(","infixP","(","pats","!!","0",")","c","(","pats","!!","1",")",",","var",")","]","ForallC","_","_","c","->","case1","i","c","#if MIN_VERSION_template_haskell(2,11,0)","GadtC","cs","fs","_","->","map","(","one","fs",")","cs","RecGadtC","cs","fs","_","->","map","(","one","fs",")","cs","#endif","where","fresh","=","mkName","<$>","delete","\"f\"","freshNames","pats1","=","varP","<$>","fresh","pats","=","replicate","i","wildP","++","[","pats1","!!","i","]","++","repeat","wildP","var","=","varE","(","fresh","!!","i",")","one","fs","c","=","let","s","=","take","(","length","fs",")","in","(","conP","c","(","s","pats",")",",","var",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L505-L521","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"districtPerimeter","parameters":"districts","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"districtPerimeter districts = concat . intercalate (pure \"\\n\") $ map (pure . show . distP) districts\n    where distP (District _ label perimeter _ _) = (label, perimeter)\n\n-- | Label with relative compactness","function_tokens":["districtPerimeter","districts","=","concat",".","intercalate","(","pure","\"\\n\"",")","$","map","(","pure",".","show",".","distP",")","districts","where","distP","(","District","_","label","perimeter","_","_",")","=","(","label",",","perimeter",")","-- | Label with relative compactness"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L31-L35","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Class.hs","language":"haskell","identifier":"takeRow","parameters":"mat i","argument_list":"","return_statement":"","docstring":"Extract a row.","docstring_summary":"Extract a row.","docstring_tokens":["Extract","a","row","."],"function":"takeRow mat i | i < 0 || i >= r =\n                error $ printf \"index out of bounds: (%d,%d)\" i r\n              | otherwise = unsafeTakeRow mat i\n  where\n    (r,_) = dim mat","function_tokens":["takeRow","mat","i","|","i","<","0","||","i",">=","r","=","error","$","printf","\"index out of bounds: (%d,%d)\"","i","r","|","otherwise","=","unsafeTakeRow","mat","i","where","(","r",",","_",")","=","dim","mat"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Class.hs#L163-L168","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Class.hs","hash_val":44443,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"returnNodes","parameters":"peer id (KI h (KS sTree _) _)","argument_list":"","return_statement":"","docstring":"Return a KBucket with the closest Nodes to a supplied Id","docstring_summary":"Return a KBucket with the closest Nodes to a supplied Id","docstring_tokens":["Return","a","KBucket","with","the","closest","Nodes","to","a","supplied","Id"],"function":"returnNodes peer id (KI h (KS sTree _) _) = do\n    tree <- atomically . readTVar $ sTree\n    let nodes = T.findClosest tree id 7\n    liftIO $ send h peer (RETURN_NODES id nodes)","function_tokens":["returnNodes","peer","id","(","KI","h","(","KS","sTree","_",")","_",")","=","do","tree","<-","atomically",".","readTVar","$","sTree","let","nodes","=","T","findClosest","tree","id","7","liftIO","$","send","h","peer","(","RETURN_NODES","id","nodes",")"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L284-L287","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"exists''","parameters":"[] _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"exists'' [] _   = fail \"quantifying zero variables\"","function_tokens":["exists''","[","]","_","=","fail","\"quantifying zero variables\""],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L601-L601","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"c","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"c = distanceRad x2 x3","function_tokens":["c","=","distanceRad","x2","x3"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L29-L29","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Point.hs","language":"haskell","identifier":"fmap","parameters":"f x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fmap f x = pure f <*> x","function_tokens":["fmap","f","x","=","pure","f","<*>","x"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Point.hs#L91-L91","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Point.hs","hash_val":17605,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toMsDosTime","parameters":"UTCTime {..}","argument_list":"","return_statement":"","docstring":"Convert 'UTCTime' to the MS-DOS time format.","docstring_summary":"Convert 'UTCTime' to the MS-DOS time format.","docstring_tokens":["Convert","UTCTime","to","the","MS","-","DOS","time","format","."],"function":"toMsDosTime UTCTime {..} = MsDosTime dosDate dosTime\n  where\n    dosTime = fromIntegral (seconds + shiftL minutes 5 + shiftL hours 11)\n    dosDate = fromIntegral (day + shiftL month 5 + shiftL year 9)\n    seconds =\n      let (MkFixed x) = todSec tod\n       in fromIntegral (x `quot` 2000000000000)\n    minutes = todMin tod\n    hours = todHour tod\n    tod = timeToTimeOfDay utctDayTime\n    year = fromIntegral year' - 1980\n    (year', month, day) = toGregorian utctDay\n\n-- | Convert MS-DOS date-time to 'UTCTime'.","function_tokens":["toMsDosTime","UTCTime","{","..","}","=","MsDosTime","dosDate","dosTime","where","dosTime","=","fromIntegral","(","seconds","+","shiftL","minutes","5","+","shiftL","hours","11",")","dosDate","=","fromIntegral","(","day","+","shiftL","month","5","+","shiftL","year","9",")","seconds","=","let","(","MkFixed","x",")","=","todSec","tod","in","fromIntegral","(","x","`","quot","`","2000000000000",")","minutes","=","todMin","tod","hours","=","todHour","tod","tod","=","timeToTimeOfDay","utctDayTime","year","=","fromIntegral","year'","-","1980","(","year'",",","month",",","day",")","=","toGregorian","utctDay","-- | Convert MS-DOS date-time to 'UTCTime'."],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1170-L1184","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Doppler.hs","language":"haskell","identifier":"dopplerFactor","parameters":"","argument_list":"","return_statement":"","docstring":"'dopplerFactor' is a simple scaling of source and listener velocities to exaggerate or deemphasize the Doppler (pitch) shift resulting from the calculation. Setting 'dopplerFactor' to a negative value will result in an 'ALInvalidValue' error, the command is then ignored. The default value is 1. The implementation is free to optimize the case of 'dopplerFactor' containing zero, as this effectively disables the effect.","docstring_summary":"'dopplerFactor' is a simple scaling of source and listener velocities to exaggerate or deemphasize the Doppler (pitch) shift resulting from the calculation. Setting 'dopplerFactor' to a negative value will result in an 'ALInvalidValue' error, the command is then ignored. The default value is 1. The implementation is free to optimize the case of 'dopplerFactor' containing zero, as this effectively disables the effect.","docstring_tokens":["dopplerFactor","is","a","simple","scaling","of","source","and","listener","velocities","to","exaggerate","or","deemphasize","the","Doppler","(","pitch",")","shift","resulting","from","the","calculation",".","Setting","dopplerFactor","to","a","negative","value","will","result","in","an","ALInvalidValue","error","the","command","is","then","ignored",".","The","default","value","is","1",".","The","implementation","is","free","to","optimize","the","case","of","dopplerFactor","containing","zero","as","this","effectively","disables","the","effect","."],"function":"dopplerFactor = makeDopplerVar GetDopplerFactor \"alDopplerFactor\"","function_tokens":["dopplerFactor","=","makeDopplerVar","GetDopplerFactor","\"alDopplerFactor\""],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Doppler.hs#L49-L49","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Doppler.hs","hash_val":10218,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"bin_","parameters":"p m l r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bin_ p m l r = intern (UBin p m l r)","function_tokens":["bin_","p","m","l","r","=","intern","(","UBin","p","m","l","r",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L189-L189","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"delayTfm","parameters":"k (Tfm str del)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"delayTfm   k (Tfm str del) = Tfm str      (k+del)","function_tokens":["delayTfm","k","(","Tfm","str","del",")","=","Tfm","str","(","k","+","del",")"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L359-L359","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"defaultNaming","parameters":"field","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"defaultNaming field =\n  case field of\n    '_' : c : rest -> toLower c : rest\n    f : rest       -> 'l' : toUpper f : rest\n    n              -> fclError (\"Cannot derive label for record selector with name: \" ++ n)\n\n-- | Derive labels for all the record types in the supplied declaration. The\n-- record fields don't need an underscore prefix. Multiple data types \/\n-- newtypes are allowed at once.\n--\n-- The advantage of this approach is that you don't need to explicitly hide the\n-- original record accessors from being exported and they won't show up in the\n-- derived `Show` instance.\n--\n-- Example:\n--\n-- > fclabels [d|\n-- >   data Record = Record\n-- >     { int  :: Int\n-- >     , bool :: Bool\n-- >     } deriving Show\n-- >   |]\n--\n-- > ghci> modify int (+2) (Record 1 False)\n-- > Record 3 False","function_tokens":["defaultNaming","field","=","case","field","of","'_'",":","c",":","rest","->","toLower","c",":","rest","f",":","rest","->","'l'",":","toUpper","f",":","rest","n","->","fclError","(","\"Cannot derive label for record selector with name: \"","++","n",")","-- | Derive labels for all the record types in the supplied declaration. The","-- record fields don't need an underscore prefix. Multiple data types \/","-- newtypes are allowed at once.","--","-- The advantage of this approach is that you don't need to explicitly hide the","-- original record accessors from being exported and they won't show up in the","-- derived `Show` instance.","--","-- Example:","--","-- > fclabels [d|","-- >   data Record = Record","-- >     { int  :: Int","-- >     , bool :: Bool","-- >     } deriving Show","-- >   |]","--","-- > ghci> modify int (+2) (Record 1 False)","-- > Record 3 False"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L177-L203","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"unzip3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unzip3 = MG.unzip3","function_tokens":["unzip3","=","MG","unzip3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L349-L349","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toCompressionMethod","parameters":"0","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toCompressionMethod 0 = Just Store","function_tokens":["toCompressionMethod","0","=","Just","Store"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1109-L1109","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Trace\/Ignoring.hs","language":"haskell","identifier":"runTrace","parameters":"(TraceC m)","argument_list":"","return_statement":"","docstring":"Run a 'Trace' effect, ignoring all traces.  @ 'runTrace' ('trace' s) = 'pure' () @ @ 'runTrace' ('pure' a) = 'pure' a @  @since 1.0.0.0","docstring_summary":"Run a 'Trace' effect, ignoring all traces.","docstring_tokens":["Run","a","Trace","effect","ignoring","all","traces","."],"function":"runTrace (TraceC m) = m","function_tokens":["runTrace","(","TraceC","m",")","=","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Trace\/Ignoring.hs#L40-L40","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Trace\/Ignoring.hs","hash_val":10926,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","language":"haskell","identifier":"getString","parameters":"device query","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getString device query = getStringRaw device query >>= peekALCString","function_tokens":["getString","device","query","=","getStringRaw","device","query",">>=","peekALCString"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/ALC\/QueryUtils.hs#L59-L59","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/ALC\/QueryUtils.hs","hash_val":9016,"partition":"train"}
{"repo":"ghulette\/language-c-comments","sha":"64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865","path":"src\/Language\/C\/Comments\/LineParser.hs","language":"haskell","identifier":"joinBrokenLines","parameters":"[line]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"joinBrokenLines [line] = [stripBreak line]","function_tokens":["joinBrokenLines","[","line","]","=","[","stripBreak","line","]"],"url":"https:\/\/github.com\/ghulette\/language-c-comments\/blob\/64e5a7e06be8cdc74d0a194e5a3fbeb5555ff865\/src\/Language\/C\/Comments\/LineParser.hs#L29-L29","hash_key":"ghulette\/language-c-comments:src\/Language\/C\/Comments\/LineParser.hs","hash_val":5767,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Config.hs","language":"haskell","identifier":"unmarshalDevice","parameters":"device","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"unmarshalDevice device =\n   if device == marshalDevice nullDevice then Nothing else Just (Device device)","function_tokens":["unmarshalDevice","device","=","if","device","==","marshalDevice","nullDevice","then","Nothing","else","Just","(","Device","device",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Config.hs#L135-L136","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Config.hs","hash_val":18131,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"examples\/Utils.hs","language":"haskell","identifier":"testGroup","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"testGroup = Branch","function_tokens":["testGroup","=","Branch"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/examples\/Utils.hs#L17-L17","hash_key":"fused-effects\/fused-effects:examples\/Utils.hs","hash_val":7652,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"examples\/demo.hs","language":"haskell","identifier":"main","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"main = runBylineT example >>= print","function_tokens":["main","=","runBylineT","example",">>=","print"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/examples\/demo.hs#L38-L38","hash_key":"pjones\/byline:examples\/demo.hs","hash_val":17487,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Comments.hs","language":"haskell","identifier":"show","parameters":"CommentGroup {..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show CommentGroup {..} = \"(CommentGroup (\" ++\n        show cgBlock ++ \") (\" ++\n        showOutputable cgPrior ++ \") (\" ++\n        showOutputable cgItems ++ \") (\" ++\n        showOutputable cgFollowing ++ \"))\"","function_tokens":["show","CommentGroup","{","..","}","=","\"(CommentGroup (\"","++","show","cgBlock","++","\") (\"","++","showOutputable","cgPrior","++","\") (\"","++","showOutputable","cgItems","++","\") (\"","++","showOutputable","cgFollowing","++","\"))\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Comments.hs#L38-L42","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Comments.hs","hash_val":38928,"partition":"train"}
{"repo":"k0ral\/conduit-parse","sha":"1db9983b18f7e7d5bc2aaf1af88224995fab40c7","path":"Data\/Conduit\/Parser\/Internal.hs","language":"haskell","identifier":"popParserName","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"popParserName = ConduitParser $ lift $ modify $ first tailSafe","function_tokens":["popParserName","=","ConduitParser","$","lift","$","modify","$","first","tailSafe"],"url":"https:\/\/github.com\/k0ral\/conduit-parse\/blob\/1db9983b18f7e7d5bc2aaf1af88224995fab40c7\/Data\/Conduit\/Parser\/Internal.hs#L119-L119","hash_key":"k0ral\/conduit-parse:Data\/Conduit\/Parser\/Internal.hs","hash_val":8740,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/AL\/Source.hs","language":"haskell","identifier":"coneAngles","parameters":"source","argument_list":"","return_statement":"","docstring":"'coneAngles' contains the inner and outer angles of the sound cone, in degrees. The default of 360 for the inner cone angle means that it covers the entire world, which is equivalent to an omni-directional source. The default of 360 for the outer cone angle means that it covers the entire world. If the inner angle is also 360, then the zone for angle-dependent attenuation is zero.","docstring_summary":"'coneAngles' contains the inner and outer angles of the sound cone, in degrees. The default of 360 for the inner cone angle means that it covers the entire world, which is equivalent to an omni-directional source. The default of 360 for the outer cone angle means that it covers the entire world. If the inner angle is also 360, then the zone for angle-dependent attenuation is zero.","docstring_tokens":["coneAngles","contains","the","inner","and","outer","angles","of","the","sound","cone","in","degrees",".","The","default","of","360","for","the","inner","cone","angle","means","that","it","covers","the","entire","world","which","is","equivalent","to","an","omni","-","directional","source",".","The","default","of","360","for","the","outer","cone","angle","means","that","it","covers","the","entire","world",".","If","the","inner","angle","is","also","360","then","the","zone","for","angle","-","dependent","attenuation","is","zero","."],"function":"coneAngles source =\n   pairStateVars\n      (makeSourceStateVar dictALfloat GetConeInnerAngle source)\n      (makeSourceStateVar dictALfloat GetConeOuterAngle source)","function_tokens":["coneAngles","source","=","pairStateVars","(","makeSourceStateVar","dictALfloat","GetConeInnerAngle","source",")","(","makeSourceStateVar","dictALfloat","GetConeOuterAngle","source",")"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/AL\/Source.hs#L420-L423","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/AL\/Source.hs","hash_val":29439,"partition":"train"}
{"repo":"froozen\/kademlia","sha":"60f05d0455b92960a1a51abd2932cd12d9e422db","path":"src\/Network\/Kademlia\/Instance.hs","language":"haskell","identifier":"lookupNode","parameters":"(KI _ (KS sTree _) _) id","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"lookupNode (KI _ (KS sTree _) _) id = atomically $ do\n    tree <- readTVar sTree\n    return . T.lookup tree $ id\n\n-- | Return all the Nodes an Instance has encountered so far","function_tokens":["lookupNode","(","KI","_","(","KS","sTree","_",")","_",")","id","=","atomically","$","do","tree","<-","readTVar","sTree","return",".","T","lookup","tree","$","id","-- | Return all the Nodes an Instance has encountered so far"],"url":"https:\/\/github.com\/froozen\/kademlia\/blob\/60f05d0455b92960a1a51abd2932cd12d9e422db\/src\/Network\/Kademlia\/Instance.hs#L78-L83","hash_key":"froozen\/kademlia:src\/Network\/Kademlia\/Instance.hs","hash_val":12859,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"toCompressionMethod","parameters":"_","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"toCompressionMethod _ = Nothing","function_tokens":["toCompressionMethod","_","=","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1113-L1113","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_EXPONENT_DISTANCE_CLAMPED","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_EXPONENT_DISTANCE_CLAMPED        = 0xD006","function_tokens":["al_EXPONENT_DISTANCE_CLAMPED","=","0xD006"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L60-L60","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"mappendTList","parameters":"a       b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mappendTList a       b       = Append a b","function_tokens":["mappendTList","a","b","=","Append","a","b"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L317-L317","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"showBin","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showBin _ _\n  = \"*\"","function_tokens":["showBin","_","_","=","\"*\""],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L809-L810","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"runPrinter","parameters":"cfg (Printer printer)","argument_list":"","return_statement":"","docstring":"Run printer to get printed lines out of module as well as return value of monad","docstring_summary":"Run printer to get printed lines out of module as well as return value of monad","docstring_tokens":["Run","printer","to","get","printed","lines","out","of","module","as","well","as","return","value","of","monad"],"function":"runPrinter cfg (Printer printer) =\n  let\n    (a, PrinterState parsedLines _ startedLine) = runReaderT printer cfg `runState` PrinterState [] 0 \"\"\n  in\n    (a, parsedLines <> if startedLine == [] then [] else [startedLine])","function_tokens":["runPrinter","cfg","(","Printer","printer",")","=","let","(","a",",","PrinterState","parsedLines","_","startedLine",")","=","runReaderT","printer","cfg","`","runState","`","PrinterState","[","]","0","\"\"","in","(","a",",","parsedLines","<>","if","startedLine","==","[","]","then","[","]","else","[","startedLine","]",")"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L93-L97","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","language":"haskell","identifier":"getDbfRecord","parameters":"field","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getDbfRecord field = let n = fieldLen field in\n  case fieldType field of\n    'C' -> DbfString <$> getString     n\n    'N' -> DbfNum    <$> getString     n\n    _   -> DbfBS     <$> getByteString n","function_tokens":["getDbfRecord","field","=","let","n","=","fieldLen","field","in","case","fieldType","field","of","'C'","->","DbfString","<$>","getString","n","'N'","->","DbfNum","<$>","getString","n","_","->","DbfBS","<$>","getByteString","n"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs#L58-L62","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadDbf.hs","hash_val":38792,"partition":"train"}
{"repo":"tsani\/servant-github-webhook","sha":"89574d30a3bce1411a03d7f8e21606125f4859cb","path":"src\/Servant\/GitHub\/Webhook.hs","language":"haskell","identifier":"ct","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"ct = withRequest $ \\req -> do\n        let hdrs = requestHeaders req\n        let contentTypeH =\n              fromMaybe \"application\/octet-stream\" $ lookup hContentType hdrs\n\n        msg <- liftIO (toStrict <$> strictRequestBody req)\n\n        let mrqbody =\n              handleCTypeH (Proxy :: Proxy list) (cs contentTypeH) $\n              fromStrict msg\n\n        case mrqbody of\n          Nothing -> delayedFailFatal err415\n          Just (Left e) -> delayedFailFatal err400 { errBody = cs e }\n          Just (Right v) -> pure (msg, lookupSig hdrs, v)","function_tokens":["ct","=","withRequest","$","\\","req","->","do","let","hdrs","=","requestHeaders","req","let","contentTypeH","=","fromMaybe","\"application\/octet-stream\"","$","lookup","hContentType","hdrs","msg","<-","liftIO","(","toStrict","<$>","strictRequestBody","req",")","let","mrqbody","=","handleCTypeH","(","Proxy","::","Proxy","list",")","(","cs","contentTypeH",")","$","fromStrict","msg","case","mrqbody","of","Nothing","->","delayedFailFatal","err415","Just","(","Left","e",")","->","delayedFailFatal","err400","{","errBody","=","cs","e","}","Just","(","Right","v",")","->","pure","(","msg",",","lookupSig","hdrs",",","v",")"],"url":"https:\/\/github.com\/tsani\/servant-github-webhook\/blob\/89574d30a3bce1411a03d7f8e21606125f4859cb\/src\/Servant\/GitHub\/Webhook.hs#L291-L307","hash_key":"tsani\/servant-github-webhook:src\/Servant\/GitHub\/Webhook.hs","hash_val":25396,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"deleteEntry","parameters":"s","argument_list":"","return_statement":"","docstring":"Delete an entry from the archive, if it does not exist, nothing will happen.","docstring_summary":"Delete an entry from the archive, if it does not exist, nothing will happen.","docstring_tokens":["Delete","an","entry","from","the","archive","if","it","does","not","exist","nothing","will","happen","."],"function":"deleteEntry s = addPending (I.DeleteEntry s)","function_tokens":["deleteEntry","s","=","addPending","(","I","DeleteEntry","s",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L532-L532","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"spell-music\/temporal-media","sha":"b0508a6444714ac64d970d505e27f66daefc8ff1","path":"src\/Temporal\/Media.hs","language":"haskell","identifier":"d","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"d = dur x","function_tokens":["d","=","dur","x"],"url":"https:\/\/github.com\/spell-music\/temporal-media\/blob\/b0508a6444714ac64d970d505e27f66daefc8ff1\/src\/Temporal\/Media.hs#L261-L261","hash_key":"spell-music\/temporal-media:src\/Temporal\/Media.hs","hash_val":11498,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Voice _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Voice _)                = (False, True, True, True)","function_tokens":["go","(","Voice","_",")","=","(","False",",","True",",","True",",","True",")"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L392-L392","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"benchShell","parameters":"label cmd","argument_list":"","return_statement":"","docstring":"Construct a benchmark of a name and a shell command.  > benchShell \"sleep is slow\" \"sleep 0\"","docstring_summary":"Construct a benchmark of a name and a shell command.  > benchShell \"sleep is slow\" \"sleep 0\"","docstring_tokens":["Construct","a","benchmark","of","a","name","and","a","shell","command",".",">","benchShell","sleep","is","slow","sleep","0"],"function":"benchShell label cmd = Benchmark label (Analysis 0 0 0 0) $ measure go\n  where go n = uncurry (>>) $ ((`replicateM_` f 10000) *** f) (n `divMod` 10000)\n        f x = withCreateProcess (shell (intercalate \";\" $ replicate x cmd)) {std_out = CreatePipe, std_err = CreatePipe} $ \\_ _ _ p ->\n          waitForProcess p >> threadDelay 0 -- this is needed to let UserInterrupt be handled\n\n-- | Configurable main function for running a list of benchmarks.\n--\n-- > defaultMainWith defaultConfig {hideBar = True} [bench \"id ()\" id ()]","function_tokens":["benchShell","label","cmd","=","Benchmark","label","(","Analysis","0","0","0","0",")","$","measure","go","where","go","n","=","uncurry","(",">>",")","$","(","(","`","replicateM_","`","f","10000",")","***","f",")","(","n","`","divMod","`","10000",")","f","x","=","withCreateProcess","(","shell","(","intercalate","\";\"","$","replicate","x","cmd",")",")","{","std_out","=","CreatePipe",",","std_err","=","CreatePipe","}","$","\\","_","_","_","p","->","waitForProcess","p",">>","threadDelay","0","-- this is needed to let UserInterrupt be handled","-- | Configurable main function for running a list of benchmarks.","--","-- > defaultMainWith defaultConfig {hideBar = True} [bench \"id ()\" id ()]"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L126-L134","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"schell\/varying","sha":"7de5580d7a590f2e11804fd69047b86926fee270","path":"app\/Main.hs","language":"haskell","identifier":"y","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"y = tweenStream tweeny 0","function_tokens":["y","=","tweenStream","tweeny","0"],"url":"https:\/\/github.com\/schell\/varying\/blob\/7de5580d7a590f2e11804fd69047b86926fee270\/app\/Main.hs#L54-L54","hash_key":"schell\/varying:app\/Main.hs","hash_val":28665,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Parse.hs","language":"haskell","identifier":"go","parameters":"isMultiline (x : xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go isMultiline (x : xs) =\n        let isCpp         = isMultiline || listToMaybe x == Just '#'\n            nextMultiline = isCpp && not (null x) && last x == '\\\\'\n        in (if isCpp then \"\" else x) : go nextMultiline xs","function_tokens":["go","isMultiline","(","x",":","xs",")","=","let","isCpp","=","isMultiline","||","listToMaybe","x","==","Just","'#'","nextMultiline","=","isCpp","&&","not","(","null","x",")","&&","last","x","==","'\\\\'","in","(","if","isCpp","then","\"\"","else","x",")",":","go","nextMultiline","xs"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Parse.hs#L44-L47","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Parse.hs","hash_val":23890,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Algebra.hs","language":"haskell","identifier":"send","parameters":"sig","argument_list":"","return_statement":"","docstring":"Construct a request for an effect to be interpreted by some handler later on.  @since 0.1.0.0","docstring_summary":"Construct a request for an effect to be interpreted by some handler later on.","docstring_tokens":["Construct","a","request","for","an","effect","to","be","interpreted","by","some","handler","later","on","."],"function":"send sig = runIdentity <$> alg (fmap Identity . runIdentity) (inj sig) (Identity ())","function_tokens":["send","sig","=","runIdentity","<$>","alg","(","fmap","Identity",".","runIdentity",")","(","inj","sig",")","(","Identity","(",")",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Algebra.hs#L139-L139","hash_key":"fused-effects\/fused-effects:src\/Control\/Algebra.hs","hash_val":10662,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"pushCompFunc","parameters":"","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"pushCompFunc = Free.liftF . (`PushCompFunc` ())","function_tokens":["pushCompFunc","=","Free","liftF",".","(","`","PushCompFunc","`","(",")",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L80-L80","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"pretty","parameters":"(TypesetText a)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pretty (TypesetText a)  = string a","function_tokens":["pretty","(","TypesetText","a",")","=","string","a"],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L132-L132","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"seconds","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"seconds = fromIntegral $ 2 * (msDosTime .&. 0x1f)","function_tokens":["seconds","=","fromIntegral","$","2","*","(","msDosTime",".&.","0x1f",")"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1190-L1190","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"UserDefined","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go UserDefined              = \"U\"","function_tokens":["go","UserDefined","=","\"U\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L356-L356","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","language":"haskell","identifier":"getRecBBox","parameters":"","argument_list":"","return_statement":"","docstring":"Record bounding boxes contain no information on M\/Z","docstring_summary":"Record bounding boxes contain no information on M\/Z","docstring_tokens":["Record","bounding","boxes","contain","no","information","on","M","\/","Z"],"function":"getRecBBox = do\n  [xMin, yMin, xMax, yMax] <- replicateM 4 getFloat64le\n  return RecBBox { recXMin = xMin,\n              recXMax = xMax,\n              recYMin = yMin,\n              recYMax = yMax }","function_tokens":["getRecBBox","=","do","[","xMin",",","yMin",",","xMax",",","yMax","]","<-","replicateM","4","getFloat64le","return","RecBBox","{","recXMin","=","xMin",",","recXMax","=","xMax",",","recYMin","=","yMin",",","recYMax","=","yMax","}"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs#L241-L246","hash_key":"vmchale\/hgis:src\/depends\/readshp\/Geometry\/Shapefile\/ReadShp.hs","hash_val":30394,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_EXPONENT_DISTANCE","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_EXPONENT_DISTANCE                = 0xD005","function_tokens":["al_EXPONENT_DISTANCE","=","0xD005"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L59-L59","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_INITIAL","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_INITIAL                          = 0x1011","function_tokens":["al_INITIAL","=","0x1011"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L104-L104","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"mono","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"mono  = any (\\x -> any (elem x) fsTys) (typeVariables ty)","function_tokens":["mono","=","any","(","\\","x","->","any","(","elem","x",")","fsTys",")","(","typeVariables","ty",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L361-L361","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"parser","parameters":"_ _","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ _ = choice [ var', var'' ] <?> \"Var\" where\n        var' = do\n            _ <- char '('\n            n <- identifier\n            _ <- space *> char ':' *> space\n            s <- lift . lift $ parseSort\n            _ <- char ')'\n\n            assertSort n s\n\n            var''' n s\n\n        var'' = do\n            n <- many1 letter\n\n            s <- assumeSort n\n\n            var''' n s\n\n        var''' :: VariableName -> DynamicSort -> Parser (DynamicallySortedFix f)\n        var''' n (DynamicSort (s :: Sing s)) = return $ dynvar n s\n\n-- | A smart constructor for variables of any sort in any language\n-- Takes the variable name and infers the target language and sort from context.\n--\n-- @\n-- var \"a\" :: Lia 'IntegralSort\n-- @","function_tokens":["parser","_","_","=","choice","[","var'",",","var''","]","<?>","\"Var\"","where","var'","=","do","_","<-","char","'('","n","<-","identifier","_","<-","space","*>","char","':'","*>","space","s","<-","lift",".","lift","$","parseSort","_","<-","char","')'","assertSort","n","s","var'''","n","s","var''","=","do","n","<-","many1","letter","s","<-","assumeSort","n","var'''","n","s","var'''","::","VariableName","->","DynamicSort","->","Parser","(","DynamicallySortedFix","f",")","var'''","n","(","DynamicSort","(","s","::","Sing","s",")",")","=","return","$","dynvar","n","s","-- | A smart constructor for variables of any sort in any language","-- Takes the variable name and infers the target language and sort from context.","--","-- @","-- var \"a\" :: Lia 'IntegralSort","-- @"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L266-L294","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"dino-\/hsinstall","sha":"9d405af78d6239c6b94decdab51230b47cf889d7","path":"src\/app\/HSInstall\/System\/Directory.hs","language":"haskell","identifier":"absPath","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"absPath = path <\/> relPath","function_tokens":["absPath","=","path","<\/>","relPath"],"url":"https:\/\/github.com\/dino-\/hsinstall\/blob\/9d405af78d6239c6b94decdab51230b47cf889d7\/src\/app\/HSInstall\/System\/Directory.hs#L42-L42","hash_key":"dino-\/hsinstall:src\/app\/HSInstall\/System\/Directory.hs","hash_val":21133,"partition":"train"}
{"repo":"haskell-works\/hw-json-simd","sha":"caa0aa4395f880a2279370ebd34b5a8ade68bbd6","path":"src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","language":"haskell","identifier":"makeSimpleJsonIbBps","parameters":"lbs","argument_list":"","return_statement":"","docstring":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_summary":"{- HLINT ignore \"Reduce duplication\"  -} {- HLINT ignore \"Redundant do\"        -}","docstring_tokens":["{","-","HLINT","ignore","Reduce","duplication","-","}","{","-","HLINT","ignore","Redundant","do","-","}"],"function":"makeSimpleJsonIbBps lbs = if enabledMakeSimpleJsonIbBps\n  then Right (makeSimpleJsonIbBpsUnsafe lbs)\n  else Left \"makeSimpleJsonIbBps function is disabled\"","function_tokens":["makeSimpleJsonIbBps","lbs","=","if","enabledMakeSimpleJsonIbBps","then","Right","(","makeSimpleJsonIbBpsUnsafe","lbs",")","else","Left","\"makeSimpleJsonIbBps function is disabled\""],"url":"https:\/\/github.com\/haskell-works\/hw-json-simd\/blob\/caa0aa4395f880a2279370ebd34b5a8ade68bbd6\/src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs#L32-L34","hash_key":"haskell-works\/hw-json-simd:src\/HaskellWorks\/Data\/Json\/Simd\/Index\/Simple.hs","hash_val":5841,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"newSquaredWeights","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"newSquaredWeights = squaredWeights + weight*weight","function_tokens":["newSquaredWeights","=","squaredWeights","+","weight","*","weight"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L380-L380","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Poly.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Id     . u      = u","function_tokens":["Id",".","u","=","u"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Poly.hs#L91-L91","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Poly.hs","hash_val":29671,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Parser.hs","language":"haskell","identifier":"id'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"id' = choice [ letter, char '\\'', char '_', char '@', char '#' ]","function_tokens":["id'","=","choice","[","letter",",","char","'\\''",",","char","'_'",",","char","'@'",",","char","'#'","]"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Parser.hs#L122-L122","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Parser.hs","hash_val":4294,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pt","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pt = mkName \"f\"","function_tokens":["pt","=","mkName","\"f\""],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L496-L496","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"identity","parameters":"(Bin i _ _ _ _ _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"identity (Bin i _ _ _ _ _) = i","function_tokens":["identity","(","Bin","i","_","_","_","_","_",")","=","i"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L195-L195","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/Internal.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"!wid = cacheWidth dt","function_tokens":["wid","=","cacheWidth","dt"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/Internal.hs#L86-L86","hash_key":"ekmett\/intern:Data\/Interned\/Internal.hs","hash_val":14290,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/State\/Strict.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"StateC l <|> StateC r = StateC (\\ s -> l s <|> r s)","function_tokens":["StateC","l","<|>","StateC","r","=","StateC","(","\\","s","->","l","s","<|>","r","s",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/State\/Strict.hs#L95-L95","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/State\/Strict.hs","hash_val":38449,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"merge","parameters":"[]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"merge []  = false","function_tokens":["merge","[","]","=","false"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L467-L467","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"getP","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getP    = [| $(failE) ||| id <<< $getT |]","function_tokens":["getP","=","[","|"," $(failE) ||| id <<< $getT ","|]"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L438-L438","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"bind'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"bind' a = bind (Proxy :: Proxy g) (inject a)","function_tokens":["bind'","a","=","bind","(","Proxy","::","Proxy","g",")","(","inject","a",")"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L823-L823","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Type.hs","language":"haskell","identifier":"show","parameters":"ZstdUnsupported","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"show ZstdUnsupported =\n    \"Encountered a zipfile entry with Zstd compression, but \" ++\n    \"the zip library has been built with zstd disabled.\"","function_tokens":["show","ZstdUnsupported","=","\"Encountered a zipfile entry with Zstd compression, but \"","++","\"the zip library has been built with zstd disabled.\""],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Type.hs#L245-L247","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Type.hs","hash_val":9543,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Origin _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Origin _)               = \"O\"","function_tokens":["go","(","Origin","_",")","=","\"O\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L348-L348","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"desc1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"desc1 = case o of\n        GenericOrigin ->\n          desc0\n            { edCRC32 = ddCRC32,\n              edCompressedSize = ddCompressedSize,\n              edUncompressedSize = ddUncompressedSize\n            }\n        Borrowed ed ->\n          desc0\n            { edCRC32 =\n                bool (edCRC32 ed) ddCRC32 recompression,\n              edCompressedSize =\n                bool (edCompressedSize ed) ddCompressedSize recompression,\n              edUncompressedSize =\n                bool (edUncompressedSize ed) ddUncompressedSize recompression\n            }","function_tokens":["desc1","=","case","o","of","GenericOrigin","->","desc0","{","edCRC32","=","ddCRC32",",","edCompressedSize","=","ddCompressedSize",",","edUncompressedSize","=","ddUncompressedSize","}","Borrowed","ed","->","desc0","{","edCRC32","=","bool","(","edCRC32","ed",")","ddCRC32","recompression",",","edCompressedSize","=","bool","(","edCompressedSize","ed",")","ddCompressedSize","recompression",",","edUncompressedSize","=","bool","(","edUncompressedSize","ed",")","ddUncompressedSize","recompression","}"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L540-L556","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"(Group _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go (Group _)                = \"G\"","function_tokens":["go","(","Group","_",")","=","\"G\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L340-L340","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"knupfer\/chronos","sha":"f11a295d7aaf9c88ebc0884506817551ba44957b","path":"src\/Chronos\/Bench.hs","language":"haskell","identifier":"renderAnalysis","parameters":"cfg a@Analysis{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"renderAnalysis cfg a@Analysis{..}\n  = mUnless (samples == 0) $ B.char7 't' <> B.char7 '='\n  <> prettyScientific (simple cfg) (fromRational mean) (Just $ confidence cfg * standardError a)\n  <> B.char7 's'\n  <> mUnless (hideDetails cfg)\n  ( B.char7 ' '\n    <> mUnless (samples <= 1)\n    ( (if simple cfg then fromString \"SD\" else B.charUtf8 '\u03c3')\n      <> B.char7 '='\n      <> prettyScientific (simple cfg) (100 * standardDeviation a \/ fromRational mean) Nothing\n      <> B.char7 '%' <> B.char7 ' '\n    )\n    <> B.char7 'n' <> B.char7 '='\n    <> prettyNatural samples\n  )","function_tokens":["renderAnalysis","cfg","a","@","Analysis","{","..","}","=","mUnless","(","samples","==","0",")","$","B","char7","'t'","<>","B","char7","'='","<>","prettyScientific","(","simple","cfg",")","(","fromRational","mean",")","(","Just","$","confidence","cfg","*","standardError","a",")","<>","B","char7","'s'","<>","mUnless","(","hideDetails","cfg",")","(","B","char7","' '","<>","mUnless","(","samples","<=","1",")","(","(","if","simple","cfg","then","fromString","\"SD\"","else","B","charUtf8","'\u03c3')","","<>","B","char7","'='","<>","prettyScientific","(","simple","cfg",")","(","100","*","standardDeviation","a","\/","fromRational","mean",")","Nothing","<>","B","char7","'%'","<>","B","char7","' '",")","<>","B","char7","'n'","<>","B","char7","'='","<>","prettyNatural","samples",")"],"url":"https:\/\/github.com\/knupfer\/chronos\/blob\/f11a295d7aaf9c88ebc0884506817551ba44957b\/src\/Chronos\/Bench.hs#L300-L314","hash_key":"knupfer\/chronos:src\/Chronos\/Bench.hs","hash_val":43267,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Effect\/Writer.hs","language":"haskell","identifier":"censor","parameters":"f m","argument_list":"","return_statement":"","docstring":"Run a computation, modifying its output with the passed function.  @ runWriter ('censor' f m) = 'fmap' ('Data.Bifunctor.first' f) (runWriter m) @  @since 0.2.0.0","docstring_summary":"Run a computation, modifying its output with the passed function.","docstring_tokens":["Run","a","computation","modifying","its","output","with","the","passed","function","."],"function":"censor f m = send (Censor f m)","function_tokens":["censor","f","m","=","send","(","Censor","f","m",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Effect\/Writer.hs#L79-L79","hash_key":"fused-effects\/fused-effects:src\/Control\/Effect\/Writer.hs","hash_val":30433,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"showField","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"showField = go\n    where\n        go (Area a)                 = a\n        go (Book a)                 = a\n        go (Composer a)             = a\n        go (Discography a)          = a\n        go (FileUrl a)              = a\n        go (Group a)                = a\n        go (History a)              = a\n        go (Instruction a)          = show $ pretty a\n        go (Key a)                  = show $ pretty a\n        go (UnitNoteLength a)       = show $ pretty a\n        go (Meter a)                = show $ pretty a\n        go Macro                    = \"\"\n        go (Notes a)                = a\n        go (Origin a)               = a\n        go Parts                    = \"\" -- TODO\n        go (Tempo a)                = show $ pretty a\n        go (Rhythm a)               = a\n        go Remark                   = \"\" -- TODO\n        go (Source a)               = a\n        go SymbolLine               = \"\" -- TODO\n        go (Title a)                = a\n        go UserDefined              = \"\" -- TODO\n        go (Voice a)                = show $ pretty a\n        go (Words a)                = a\n        go (ReferenceNumber a)      = show a\n        go (Transcription a)        = a\n        \n\n--------------------------------------------------------------------------------\n\n-- Base types\n\n-- | Pitch (4.1, 4.2).","function_tokens":["showField","=","go","where","go","(","Area","a",")","=","a","go","(","Book","a",")","=","a","go","(","Composer","a",")","=","a","go","(","Discography","a",")","=","a","go","(","FileUrl","a",")","=","a","go","(","Group","a",")","=","a","go","(","History","a",")","=","a","go","(","Instruction","a",")","=","show","$","pretty","a","go","(","Key","a",")","=","show","$","pretty","a","go","(","UnitNoteLength","a",")","=","show","$","pretty","a","go","(","Meter","a",")","=","show","$","pretty","a","go","Macro","=","\"\"","go","(","Notes","a",")","=","a","go","(","Origin","a",")","=","a","go","Parts","=","\"\"","-- TODO","go","(","Tempo","a",")","=","show","$","pretty","a","go","(","Rhythm","a",")","=","a","go","Remark","=","\"\"","-- TODO","go","(","Source","a",")","=","a","go","SymbolLine","=","\"\"","-- TODO","go","(","Title","a",")","=","a","go","UserDefined","=","\"\"","-- TODO","go","(","Voice","a",")","=","show","$","pretty","a","go","(","Words","a",")","=","a","go","(","ReferenceNumber","a",")","=","show","a","go","(","Transcription","a",")","=","a","--------------------------------------------------------------------------------","-- Base types","-- | Pitch (4.1, 4.2)."],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L403-L438","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"examples\/Term.hs","language":"haskell","identifier":"app","parameters":"a b","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"app a b = intern (BApp a b)","function_tokens":["app","a","b","=","intern","(","BApp","a","b",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/examples\/Term.hs#L78-L78","hash_key":"ekmett\/intern:examples\/Term.hs","hash_val":32323,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","language":"haskell","identifier":"dataDecls","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dataDecls       = [ d | d@(Hs.DataDecl _ _ _ _ _)  <- tyClDecls ]","function_tokens":["dataDecls","=","[","d","|","d","@","(","Hs","DataDecl","_","_","_","_","_",")","<-","tyClDecls","]"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs#L70-L70","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Step\/SimpleAlign.hs","hash_val":41184,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"isValid","parameters":"Quad{..}","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"isValid Quad{..} = T.empty `notElem` [subject, predicate, object]","function_tokens":["isValid","Quad","{","..","}","=","T","empty","`","notElem","`","[","subject",",","predicate",",","object","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L190-L190","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"music-suite\/abcnotation","sha":"b0a9ef74f52387285a94e3f90a8459367ad1e2ae","path":"src\/Data\/Music\/Abc.hs","language":"haskell","identifier":"go","parameters":"Aeolian","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"go Aeolian      = \"aeolian\"","function_tokens":["go","Aeolian","=","\"aeolian\""],"url":"https:\/\/github.com\/music-suite\/abcnotation\/blob\/b0a9ef74f52387285a94e3f90a8459367ad1e2ae\/src\/Data\/Music\/Abc.hs#L535-L535","hash_key":"music-suite\/abcnotation:src\/Data\/Music\/Abc.hs","hash_val":25224,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"pushQuantifier","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pushQuantifier = return . inject","function_tokens":["pushQuantifier","=","return",".","inject"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L745-L745","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"foldlStrict","parameters":"f z xs","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"foldlStrict f z xs\n  = case xs of\n      []     -> z\n      (x:xx) -> let z' = f z x in seq z' (foldlStrict f z' xx)","function_tokens":["foldlStrict","f","z","xs","=","case","xs","of","[","]","->","z","(","x",":","xx",")","->","let","z'","=","f","z","x","in","seq","z'","(","foldlStrict","f","z'","xx",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L994-L997","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Hylo.hs","language":"haskell","identifier":"getPolygon","parameters":"(RecPolygonM { recPolMPoints = pt })","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getPolygon (RecPolygonM { recPolMPoints = pt }) = pt","function_tokens":["getPolygon","(","RecPolygonM","{","recPolMPoints","=","pt","}",")","=","pt"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Hylo.hs#L79-L79","hash_key":"vmchale\/hgis:src\/GIS\/Hylo.hs","hash_val":38990,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/Interpret.hs","language":"haskell","identifier":"runInterpretState","parameters":"handler state m","argument_list":"","return_statement":"","docstring":"Interpret an effect using a higher-order function with some state variable.  @since 1.0.0.0","docstring_summary":"Interpret an effect using a higher-order function with some state variable.","docstring_tokens":["Interpret","an","effect","using","a","higher","-","order","function","with","some","state","variable","."],"function":"runInterpretState handler state m\n  = runState state\n  $ runInterpret (\\ hdl sig ctx -> StateC (flip (handler hdl sig) ctx)) m","function_tokens":["runInterpretState","handler","state","m","=","runState","state","$","runInterpret","(","\\","hdl","sig","ctx","->","StateC","(","flip","(","handler","hdl","sig",")","ctx",")",")","m"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/Interpret.hs#L84-L86","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/Interpret.hs","hash_val":29980,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"er","parameters":"_ Nothing","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"er _ Nothing = Nothing","function_tokens":["er","_","Nothing","=","Nothing"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L447-L447","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"combineEq","parameters":"x' (x:xs)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"combineEq x' (x:xs)\n      | x==x'     = combineEq x' xs\n      | otherwise = x' : combineEq x xs","function_tokens":["combineEq","x'","(","x",":","xs",")","|","x","==","x'","=","combineEq","x'","xs","|","otherwise","=","x'",":","combineEq","x","xs"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L735-L737","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"vmchale\/hgis","sha":"5bd38f150a8d237dc78501859352bf1cf734f92b","path":"src\/GIS\/Math\/Spherical.hs","language":"haskell","identifier":"compactness1","parameters":"p","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"compactness1 p = (areaPolygon p)\/(perimeterPolygon p)^2","function_tokens":["compactness1","p","=","(","areaPolygon","p",")","\/","(","perimeterPolygon","p",")","^","2"],"url":"https:\/\/github.com\/vmchale\/hgis\/blob\/5bd38f150a8d237dc78501859352bf1cf734f92b\/src\/GIS\/Math\/Spherical.hs#L42-L42","hash_key":"vmchale\/hgis:src\/GIS\/Math\/Spherical.hs","hash_val":41944,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Resolution.hs","language":"haskell","identifier":"removeCr","parameters":"x","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"removeCr x = x","function_tokens":["removeCr","x","=","x"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Resolution.hs#L128-L128","hash_key":"Peaker\/git-mediate:src\/Resolution.hs","hash_val":5989,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Storable.hs","language":"haskell","identifier":"flatten","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"flatten = MG.flatten","function_tokens":["flatten","=","MG","flatten"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Storable.hs#L167-L167","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Storable.hs","hash_val":2010,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"needUnicode","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"needUnicode = testBit bitFlag 11","function_tokens":["needUnicode","=","testBit","bitFlag","11"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L688-L688","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Client.hs","language":"haskell","identifier":"writeQuad","parameters":"c s p o l","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"writeQuad c s p o l =\n  writeQuads c [Quad { subject = s, predicate = p, object = o, label = l }]","function_tokens":["writeQuad","c","s","p","o","l","=","writeQuads","c","[","Quad","{","subject","=","s",",","predicate","=","p",",","object","=","o",",","label","=","l","}","]"],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Client.hs#L115-L116","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Client.hs","hash_val":18520,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"takeDiag","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"takeDiag = MG.takeDiag","function_tokens":["takeDiag","=","MG","takeDiag"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L135-L135","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"izipWith3","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"izipWith3 = MG.izipWith3","function_tokens":["izipWith3","=","MG","izipWith3"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L288-L288","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"haskell-openal\/OpenAL","sha":"5131984f172dffc43ca8b482f215d120523fb137","path":"src\/Sound\/OpenAL\/Constants.hs","language":"haskell","identifier":"al_NO_ERROR","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"al_NO_ERROR                         = 0x0000","function_tokens":["al_NO_ERROR","=","0x0000"],"url":"https:\/\/github.com\/haskell-openal\/OpenAL\/blob\/5131984f172dffc43ca8b482f215d120523fb137\/src\/Sound\/OpenAL\/Constants.hs#L31-L31","hash_key":"haskell-openal\/OpenAL:src\/Sound\/OpenAL\/Constants.hs","hash_val":40880,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip\/Internal.hs","language":"haskell","identifier":"targetEntry","parameters":"(SinkEntry _ _ s)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"targetEntry (SinkEntry _ _ s) = Just s","function_tokens":["targetEntry","(","SinkEntry","_","_","s",")","=","Just","s"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip\/Internal.hs#L1053-L1053","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip\/Internal.hs","hash_val":26056,"partition":"train"}
{"repo":"basvandijk\/threads","sha":"9df9493a2efd63a8290e2460c1c294b6fd02ee4e","path":"Control\/Concurrent\/Thread\/Group.hs","language":"haskell","identifier":"fork","parameters":"doFork (ThreadGroup numThreadsTV) a","argument_list":"","return_statement":"","docstring":"------------------------------------------------------------------------------ Utils ------------------------------------------------------------------------------","docstring_summary":"------------------------------------------------------------------------------ Utils ------------------------------------------------------------------------------","docstring_tokens":["------------------------------------------------------------------------------","Utils","------------------------------------------------------------------------------"],"function":"fork doFork (ThreadGroup numThreadsTV) a = do\n  res <- newEmptyMVar\n  tid <- mask $ \\restore -> do\n    atomically $ modifyTVar numThreadsTV (+ 1)\n    doFork $ do\n      try (restore a) >>= putMVar res\n      atomically $ modifyTVar numThreadsTV (subtract 1)\n  return (tid, readMVar res)","function_tokens":["fork","doFork","(","ThreadGroup","numThreadsTV",")","a","=","do","res","<-","newEmptyMVar","tid","<-","mask","$","\\","restore","->","do","atomically","$","modifyTVar","numThreadsTV","(","+","1",")","doFork","$","do","try","(","restore","a",")",">>=","putMVar","res","atomically","$","modifyTVar","numThreadsTV","(","subtract","1",")","return","(","tid",",","readMVar","res",")"],"url":"https:\/\/github.com\/basvandijk\/threads\/blob\/9df9493a2efd63a8290e2460c1c294b6fd02ee4e\/Control\/Concurrent\/Thread\/Group.hs#L182-L191","hash_key":"basvandijk\/threads:Control\/Concurrent\/Thread\/Group.hs","hash_val":29860,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Printer.hs","language":"haskell","identifier":"dot","parameters":"","argument_list":"","return_statement":"","docstring":"Print a dot","docstring_summary":"Print a dot","docstring_tokens":["Print","a","dot"],"function":"dot = putText \".\"","function_tokens":["dot","=","putText","\".\""],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Printer.hs#L287-L287","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Printer.hs","hash_val":40182,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"pats1","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"pats1     = varP <$> fresh","function_tokens":["pats1","=","varP","<$>","fresh"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L546-L546","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"reduce","parameters":"z zs m px tx stk@(Push py ty stk')","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"reduce z zs m px tx stk@(Push py ty stk') =\n        let mxy = branchMask px py\n            pxy = mask px mxy\n        in  if shorter m mxy\n                 then reduce z zs m pxy (bin_ pxy mxy ty tx) stk'\n                 else work z zs (Push px tx stk)","function_tokens":["reduce","z","zs","m","px","tx","stk","@","(","Push","py","ty","stk'",")","=","let","mxy","=","branchMask","px","py","pxy","=","mask","px","mxy","in","if","shorter","m","mxy","then","reduce","z","zs","m","pxy","(","bin_","pxy","mxy","ty","tx",")","stk'","else","work","z","zs","(","Push","px","tx","stk",")"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L749-L754","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"mrkkrp\/zip","sha":"770801e246a6914e1b583e03d204046fc56f22d8","path":"Codec\/Archive\/Zip.hs","language":"haskell","identifier":"dirs","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dirs = E.map (FP.takeDirectory . (dir <\/>) . unEntrySelector) selectors","function_tokens":["dirs","=","E","map","(","FP","takeDirectory",".","(","dir","<\/>",")",".","unEntrySelector",")","selectors"],"url":"https:\/\/github.com\/mrkkrp\/zip\/blob\/770801e246a6914e1b583e03d204046fc56f22d8\/Codec\/Archive\/Zip.hs#L409-L409","hash_key":"mrkkrp\/zip:Codec\/Archive\/Zip.hs","hash_val":26740,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"fixable","parameters":"[_]","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"fixable [_]    = False","function_tokens":["fixable","[","_","]","=","False"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L93-L93","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Derive.hs","language":"haskell","identifier":"dtBinders","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"dtBinders = concatMap binderFromType dtTypes","function_tokens":["dtBinders","=","concatMap","binderFromType","dtTypes"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Derive.hs#L565-L565","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Derive.hs","hash_val":816,"partition":"train"}
{"repo":"Peaker\/git-mediate","sha":"ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a","path":"src\/Main.hs","language":"haskell","identifier":"deleteModifyConflictHandle","parameters":"path","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"deleteModifyConflictHandle path =\n    do  marked <-\n            any (markerPrefix '<' `isPrefixOf`) . lines <$> readFile path\n        unless marked $\n            do  putStrLn $ show path ++ \" has a delete\/modify conflict. Adding conflict markers\"\n                deleteModifyConflictAddMarkers path","function_tokens":["deleteModifyConflictHandle","path","=","do","marked","<-","any","(","markerPrefix","'<'","`","isPrefixOf","`",")",".","lines","<$>","readFile","path","unless","marked","$","do","putStrLn","$","show","path","++","\" has a delete\/modify conflict. Adding conflict markers\"","deleteModifyConflictAddMarkers","path"],"url":"https:\/\/github.com\/Peaker\/git-mediate\/blob\/ef9b197fca3f4a0e9dce65fa7107b6df5aa12c2a\/src\/Main.hs#L183-L190","hash_key":"Peaker\/git-mediate:src\/Main.hs","hash_val":27547,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Mono.hs","language":"haskell","identifier":"get","parameters":"","argument_list":"","return_statement":"","docstring":"Get the getter arrow from a lens.","docstring_summary":"Get the getter arrow from a lens.","docstring_tokens":["Get","the","getter","arrow","from","a","lens","."],"function":"get = Poly.get","function_tokens":["get","=","Poly","get"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Mono.hs#L58-L58","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Mono.hs","hash_val":24943,"partition":"train"}
{"repo":"ekmett\/intern","sha":"6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1","path":"Data\/Interned\/IntSet.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Nil             == Nil             = True","function_tokens":["Nil","==","Nil","=","True"],"url":"https:\/\/github.com\/ekmett\/intern\/blob\/6ec6afc2b7c3c165bc29fae5a0d2f59a17afe9a1\/Data\/Interned\/IntSet.hs#L836-L836","hash_key":"ekmett\/intern:Data\/Interned\/IntSet.hs","hash_val":8889,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Equality.hs","language":"haskell","identifier":"parser","parameters":"_ r","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parser _ r = do\n        _ <- char '(' *> char '=' *> space\n        a <- r\n        _ <- space\n        b <- r\n        _ <- char ')'\n        equals a b <?> \"Equality\" where\n\n        equals :: DynamicallySortedFix f -> DynamicallySortedFix f -> Parser (DynamicallySortedFix f)\n        equals (DynamicallySorted s1 a)\n               (DynamicallySorted s2 b) = case s1 %~ s2 of\n            Proved Refl -> return . toDynamicallySorted . inject $ Equals s1 a b\n            Disproved _ -> fail \"multi-sorted equality\"\n\n-- | A smart constructor for an equality predicate","function_tokens":["parser","_","r","=","do","_","<-","char","'('","*>","char","'='","*>","space","a","<-","r","_","<-","space","b","<-","r","_","<-","char","')'","equals","a","b","<?>","\"Equality\"","where","equals","::","DynamicallySortedFix","f","->","DynamicallySortedFix","f","->","Parser","(","DynamicallySortedFix","f",")","equals","(","DynamicallySorted","s1","a",")","(","DynamicallySorted","s2","b",")","=","case","s1","%~","s2","of","Proved","Refl","->","return",".","toDynamicallySorted",".","inject","$","Equals","s1","a","b","Disproved","_","->","fail","\"multi-sorted equality\"","-- | A smart constructor for an equality predicate"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Equality.hs#L60-L75","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Equality.hs","hash_val":15069,"partition":"train"}
{"repo":"pjones\/byline","sha":"e975c1d6787acb7019d86cf9e29746796e4a5134","path":"src\/Byline\/Internal\/Prim.hs","language":"haskell","identifier":"askPassword","parameters":"prompt mask","argument_list":"","return_statement":"","docstring":"Smart constructor.  @since 1.0.0.0","docstring_summary":"Smart constructor.","docstring_tokens":["Smart","constructor","."],"function":"askPassword prompt mask = Free.liftF (AskPassword prompt mask id)","function_tokens":["askPassword","prompt","mask","=","Free","liftF","(","AskPassword","prompt","mask","id",")"],"url":"https:\/\/github.com\/pjones\/byline\/blob\/e975c1d6787acb7019d86cf9e29746796e4a5134\/src\/Byline\/Internal\/Prim.hs#L74-L74","hash_key":"pjones\/byline:src\/Byline\/Internal\/Prim.hs","hash_val":21814,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"Select isa _ aa ia `ieq1` Select isb _ ab ib = case isa %~ isb of\n        Proved Refl -> aa `ieq` ab && ia `ieq` ib\n        Disproved _ -> False","function_tokens":["Select","isa","_","aa","ia","`","ieq1","`","Select","isb","_","ab","ib","=","case","isa","%~","isb","of","Proved","Refl","->","aa","`","ieq","`","ab","&&","ia","`","ieq","`","ib","Disproved","_","->","False"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L53-L56","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Generic\/Mutable.hs","language":"haskell","identifier":"idx","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"idx = offset + i * tda + j","function_tokens":["idx","=","offset","+","i","*","tda","+","j"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Generic\/Mutable.hs#L39-L39","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Generic\/Mutable.hs","hash_val":31178,"partition":"train"}
{"repo":"MichelBoucey\/cayley-client","sha":"4266ea325b51c275ea1202058876b13dea9706e6","path":"Database\/Cayley\/Types.hs","language":"haskell","identifier":"parseLink","parameters":"(A.Object v)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"parseLink (A.Object v) = Link <$>\n                       v A..: \"source\" <*>\n                       v A..: \"target\" <*>\n                       v A..: \"link_node\"","function_tokens":["parseLink","(","A","Object","v",")","=","Link","<$>","v","A",".:","\"source\"","<*>","v","A",".:","\"target\"","<*>","v","A",".:","\"link_node\""],"url":"https:\/\/github.com\/MichelBoucey\/cayley-client\/blob\/4266ea325b51c275ea1202058876b13dea9706e6\/Database\/Cayley\/Types.hs#L116-L119","hash_key":"MichelBoucey\/cayley-client:Database\/Cayley\/Types.hs","hash_val":40235,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Array.hs","language":"haskell","identifier":"select'","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"select' = do\n            _ <- char '(' *> string \"select\" *> space\n            a <- r\n            _ <- space\n            i <- r\n            _ <- char ')'\n            select'' a i","function_tokens":["select'","=","do","_","<-","char","'('","*>","string","\"select\"","*>","space","a","<-","r","_","<-","space","i","<-","r","_","<-","char","')'","select''","a","i"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Array.hs#L80-L87","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Array.hs","hash_val":25302,"partition":"train"}
{"repo":"fused-effects\/fused-effects","sha":"36bec2d6c0e97f7e01df97acd15012e1735c28bf","path":"src\/Control\/Carrier\/NonDet\/Church.hs","language":"haskell","identifier":"empty","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"empty = NonDetC (\\ _ _ nil -> nil)","function_tokens":["empty","=","NonDetC","(","\\","_","_","nil","->","nil",")"],"url":"https:\/\/github.com\/fused-effects\/fused-effects\/blob\/36bec2d6c0e97f7e01df97acd15012e1735c28bf\/src\/Control\/Carrier\/NonDet\/Church.hs#L90-L90","hash_key":"fused-effects\/fused-effects:src\/Control\/Carrier\/NonDet\/Church.hs","hash_val":25688,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"set","parameters":"l v","argument_list":"","return_statement":"","docstring":"Setter for a lens that can fail. When the field to which the lens points is not accessible this function returns 'Nothing'.","docstring_summary":"Setter for a lens that can fail. When the field to which the lens points is not accessible this function returns 'Nothing'.","docstring_tokens":["Setter","for","a","lens","that","can","fail",".","When","the","field","to","which","the","lens","points","is","not","accessible","this","function","returns","Nothing","."],"function":"set l v = runKleisli (Poly.set l . arr ((,) v))","function_tokens":["set","l","v","=","runKleisli","(","Poly","set","l",".","arr","(","(",",",")","v",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L74-L74","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression\/Arithmetic.hs","language":"haskell","identifier":"imap","parameters":"_ (Const c)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"imap _ (Const c)        = Const c","function_tokens":["imap","_","(","Const","c",")","=","Const","c"],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression\/Arithmetic.hs#L69-L69","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression\/Arithmetic.hs","hash_val":43442,"partition":"train"}
{"repo":"kaizhang\/matrices","sha":"4d85abd72aecce03284c597497fbe6154d8919bd","path":"src\/Data\/Matrix\/Unboxed.hs","language":"haskell","identifier":"zipWith6","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"zipWith6 = MG.zipWith6","function_tokens":["zipWith6","=","MG","zipWith6"],"url":"https:\/\/github.com\/kaizhang\/matrices\/blob\/4d85abd72aecce03284c597497fbe6154d8919bd\/src\/Data\/Matrix\/Unboxed.hs#L279-L279","hash_key":"kaizhang\/matrices:src\/Data\/Matrix\/Unboxed.hs","hash_val":16303,"partition":"train"}
{"repo":"sebastiaanvisser\/fclabels","sha":"b2c6d1d6677f301cd8e24dfa835494a55f034b8c","path":"src\/Data\/Label\/Partial.hs","language":"haskell","identifier":"lens","parameters":"g s","argument_list":"","return_statement":"","docstring":"Create a lens that can fail from a getter and a modifier that can themselves potentially fail.","docstring_summary":"Create a lens that can fail from a getter and a modifier that can themselves potentially fail.","docstring_tokens":["Create","a","lens","that","can","fail","from","a","getter","and","a","modifier","that","can","themselves","potentially","fail","."],"function":"lens g s = Poly.lens (Kleisli g) (Kleisli (\\(m, f) -> s (runKleisli m) f))","function_tokens":["lens","g","s","=","Poly","lens","(","Kleisli","g",")","(","Kleisli","(","\\","(","m",",","f",")","->","s","(","runKleisli","m",")","f",")",")"],"url":"https:\/\/github.com\/sebastiaanvisser\/fclabels\/blob\/b2c6d1d6677f301cd8e24dfa835494a55f034b8c\/src\/Data\/Label\/Partial.hs#L56-L56","hash_key":"sebastiaanvisser\/fclabels:src\/Data\/Label\/Partial.hs","hash_val":18661,"partition":"train"}
{"repo":"jakubdaniel\/expressions","sha":"b4f64fc2756f4f7a197501b8bc948a16e5b29669","path":"src\/Data\/Expression.hs","language":"haskell","identifier":"vars'","parameters":"a","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"vars' a = case prj a of\n        Just (Var n s) -> F.Const [dynvar n s]\n        Nothing -> ifold a\n\n-- | Substitution that given an expression produces replacement if the expression is to be replaced or nothing otherwise.","function_tokens":["vars'","a","=","case","prj","a","of","Just","(","Var","n","s",")","->","F","Const","[","dynvar","n","s","]","Nothing","->","ifold","a","-- | Substitution that given an expression produces replacement if the expression is to be replaced or nothing otherwise."],"url":"https:\/\/github.com\/jakubdaniel\/expressions\/blob\/b4f64fc2756f4f7a197501b8bc948a16e5b29669\/src\/Data\/Expression.hs#L304-L309","hash_key":"jakubdaniel\/expressions:src\/Data\/Expression.hs","hash_val":39680,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Align.hs","language":"haskell","identifier":"containers","parameters":"","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"containers        = map aContainer fields","function_tokens":["containers","=","map","aContainer","fields"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Align.hs#L96-L96","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Align.hs","hash_val":43042,"partition":"train"}
{"repo":"haskell\/stylish-haskell","sha":"39f5c3a4a0950654e6fa402e39fef32e0dc9a647","path":"lib\/Language\/Haskell\/Stylish\/Util.hs","language":"haskell","identifier":"getLocGRHS","parameters":"(Hs.GRHSs _ guardeds _)","argument_list":"","return_statement":"","docstring":"","docstring_summary":"","docstring_tokens":[],"function":"getLocGRHS (Hs.GRHSs _ guardeds _) = guardeds","function_tokens":["getLocGRHS","(","Hs","GRHSs","_","guardeds","_",")","=","guardeds"],"url":"https:\/\/github.com\/haskell\/stylish-haskell\/blob\/39f5c3a4a0950654e6fa402e39fef32e0dc9a647\/lib\/Language\/Haskell\/Stylish\/Util.hs#L252-L252","hash_key":"haskell\/stylish-haskell:lib\/Language\/Haskell\/Stylish\/Util.hs","hash_val":13551,"partition":"train"}
